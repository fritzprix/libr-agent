# Refactoring Plan: MessageBubbleRouter Multi-Part Message Support

## 작업의 목적

MessageBubbleRouter에서 `message.content`의 multi-part 구조(텍스트 + 도구 호출 등)를 제대로 처리하여, 도구 호출과 텍스트가 함께 포함된 메시지가 모두 표시되도록 개선한다.

## 현재의 상태 / 문제점

### 현재 처리 방식

- `MessageBubbleRouter`는 `message.tool_calls`가 존재하면 `ToolCallBubble`로 라우팅하고 `message.content`는 무시
- `message.role === 'tool'`이면 `ToolOutputBubble`로 라우팅
- 그 외는 `ContentBubble`로 라우팅하여 `message.content` 처리

### 주요 문제점

1. **정보 손실**: `tool_calls`와 텍스트가 함께 있는 multi-part 메시지에서 텍스트가 누락됨
2. **타입 제한**: `MCPContent` 타입에 `tool_call` 타입이 정의되지 않아 MCPContent[]에서 도구 호출 표현 불가
3. **확장성 부족**: `MessageRenderer`에서 `tool_call` 타입을 처리하지 못하여 "unknown"으로 표시됨
4. **일관성 부족**: multi-part 메시지의 모든 파트를 타입별로 분기 처리하지 않음

## 추가 분석 과제

- MCPContent[]에서 tool_call 타입 외에 다른 누락된 타입이 있는지 확인
- MessageRenderer의 타입별 렌더링 로직이 모든 MCPContent 타입을 커버하는지 검증
- 실제 사용 사례에서 multi-part 메시지가 어떻게 생성되는지 분석

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

- `tool_calls`와 `content`가 모두 있는 메시지에서 두 정보 모두 표시
- MCPContent[]의 모든 타입이 적절히 렌더링됨
- 새로운 MCPContent 타입 추가 시 확장 가능한 구조

### 해결 판정 기준

1. ✅ `tool_calls` + 텍스트 메시지가 모두 표시되는지 확인
2. ✅ MCPContent[]에 `tool_call` 타입이 추가되고 MessageRenderer에서 처리되는지 확인
3. ✅ TypeScript 컴파일 에러 없이 모든 타입이 안전하게 처리되는지 확인
4. ✅ 기존 단일 타입 메시지(텍스트만, tool_calls만)의 동작이 유지되는지 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. MCPContent 타입 확장 (`src/lib/mcp-types.ts`)

```typescript
// 추가할 인터페이스
export interface MCPToolCallContent {
  type: 'tool_call';
  id: string;
  function: {
    name: string;
    arguments: string;
  };
  annotations?: Record<string, unknown>;
}

// MCPContent union 타입에 추가
export type MCPContent =
  | MCPTextContent
  | MCPImageContent
  | MCPAudioContent
  | MCPResourceLinkContent
  | MCPResourceContent
  | MCPToolCallContent; // ← 추가
```

### 2. MessageRenderer 개선 (`src/components/MessageRenderer.tsx`)

```typescript
case 'tool_call': {
  const toolCallItem = item as MCPToolCallContent;
  return (
    <ToolCallBubble
      key={index}
      tool_calls={[{
        id: toolCallItem.id,
        type: 'function',
        function: toolCallItem.function
      }]}
    />
  );
}
```

### 3. MessageBubbleRouter 개선 (`src/features/chat/MessageBubbleRouter.tsx`)

```typescript
const MessageBubbleRouter: React.FC<MessageBubbleRouterProps> = ({
  message,
}) => {
  // 1. 기존 tool_calls 우선 처리
  if (
    message.tool_calls &&
    Array.isArray(message.tool_calls) &&
    message.tool_calls.length > 0
  ) {
    return <ToolCallBubble tool_calls={message.tool_calls} />;
  }

  // 2. MCPContent[]에서 tool_call 확인
  if (Array.isArray(message.content)) {
    const hasToolCalls = message.content.some(
      (item: MCPContent) => item.type === 'tool_call'
    );

    if (hasToolCalls) {
      const toolCalls = message.content
        .filter((item: MCPContent) => item.type === 'tool_call')
        .map((item: MCPContent) => {
          const toolCallItem = item as MCPToolCallContent;
          return {
            id: toolCallItem.id,
            type: 'function' as const,
            function: toolCallItem.function,
          };
        });

      return <ToolCallBubble tool_calls={toolCalls} />;
    }
  }

  // 3. tool role 메시지 처리
  if (message.role === 'tool') {
    return <ToolOutputBubble message={message} />;
  }

  // 4. 기본 콘텐츠 처리
  return <ContentBubble message={message} />;
};
```

## 타입 안전성 개선 방향

### 1. 타입 가드 함수 도입

```typescript
// src/lib/mcp-types.ts에 추가
export function isToolCallContent(item: MCPContent): item is MCPToolCallContent {
  return item.type === 'tool_call';
}

export function isTextContent(item: MCPContent): item is MCPTextContent {
  return item.type === 'text';
}

export function isImageContent(item: MCPContent): item is MCPImageContent {
  return item.type === 'image';
}

// 기타 타입별 가드 함수들...
```

### 2. 엄격한 타입 분기 및 에러 처리

```typescript
// MessageBubbleRouter 개선
const MessageBubbleRouter: React.FC<MessageBubbleRouterProps> = ({
  message,
}) => {
  // 1. content 타입 검증
  if (typeof message.content !== 'string' && !Array.isArray(message.content)) {
    logger.error('Invalid message content type', { content: message.content });
    return <ContentBubble message={{ ...message, content: 'Error: Invalid content type' }} />;
  }

  // 2. MCPContent[] 타입 검증
  if (Array.isArray(message.content)) {
    const invalidItems = message.content.filter(item => !('type' in item));
    if (invalidItems.length > 0) {
      logger.error('Invalid MCPContent items missing type field', { invalidItems });
    }
  }

  // 3. 기존 tool_calls 우선 처리 (타입 검증 강화)
  if (
    message.tool_calls &&
    Array.isArray(message.tool_calls) &&
    message.tool_calls.length > 0 &&
    message.tool_calls.every((tc): tc is ToolCall =>
      tc && typeof tc === 'object' && 'function' in tc && tc.function && typeof tc.function.name === 'string'
    )
  ) {
    return <ToolCallBubble tool_calls={message.tool_calls} />;
  }

  // 4. MCPContent[]에서 tool_call 확인 (타입 가드 활용)
  if (Array.isArray(message.content)) {
    const toolCallItems = message.content.filter(isToolCallContent);

    if (toolCallItems.length > 0) {
      const toolCalls: ToolCall[] = toolCallItems.map(item => ({
        id: item.id,
        type: 'function' as const,
        function: item.function,
      }));

      return <ToolCallBubble tool_calls={toolCalls} />;
    }
  }

  // 5. tool role 메시지 처리
  if (message.role === 'tool') {
    return <ToolOutputBubble message={message} />;
  }

  // 6. 기본 콘텐츠 처리
  return <ContentBubble message={message} />;
};
```

### 3. 불변 타입 패턴 적용

```typescript
// src/models/chat.ts 개선
export interface Message {
  readonly id: string;
  readonly sessionId: string;
  readonly role: 'user' | 'assistant' | 'system' | 'tool';
  readonly content: string | readonly MCPContent[];
  readonly tool_calls?: readonly ToolCall[];
  readonly tool_call_id?: string;
  readonly isStreaming?: boolean;
  readonly thinking?: string;
  readonly assistantId?: string;
  readonly attachments?: readonly AttachmentReference[];
  readonly tool_use?: { readonly id: string; readonly name: string; readonly input: Record<string, unknown> };
  readonly createdAt?: Date;
  readonly updatedAt?: Date;
}
```

### 4. 타입별 렌더링 컴포넌트 분리

```typescript
// src/components/MessageRenderer.tsx 개선
export const MessageRenderer: React.FC<MessageRendererProps> = ({
  content,
  className = '',
}) => {
  const { openExternalUrl } = useRustBackend();

  if (typeof content === 'string') {
    return <div className={`message-text ${className}`}>{content}</div>;
  }

  return (
    <div className={`message-content ${className}`}>
      {content.map((item, index) => {
        try {
          return renderContentItem(item, index, openExternalUrl);
        } catch (error) {
          logger.error('Failed to render content item', { item, error });
          return (
            <div key={index} className="content-error text-red-500">
              Error rendering content: {item.type}
            </div>
          );
        }
      })}
    </div>
  );
};

function renderContentItem(
  item: MCPContent,
  index: number,
  openExternalUrl: (url: string) => Promise<void>
): React.ReactNode {
  switch (item.type) {
    case 'text':
      return <TextContentRenderer key={index} content={item} />;
    case 'tool_call':
      return <ToolCallContentRenderer key={index} content={item} />;
    case 'image':
      return <ImageContentRenderer key={index} content={item} />;
    // ... 다른 타입들
    default:
      return (
        <div key={index} className="content-unknown text-gray-500">
          Unknown content type: {(item as { type: string }).type}
        </div>
      );
  }
}
```

### 5. 타입 테스트 추가

```typescript
// src/features/chat/__tests__/MessageBubbleRouter.test.ts
describe('MessageBubbleRouter', () => {
  it('should handle tool_calls + text multi-part message', () => {
    const message: Message = {
      id: '1',
      sessionId: 'session1',
      role: 'assistant',
      content: [
        { type: 'text', text: 'Processing your request...' },
        {
          type: 'tool_call',
          id: 'call1',
          function: { name: 'search', arguments: '{}' }
        }
      ],
      tool_calls: [{
        id: 'call1',
        type: 'function',
        function: { name: 'search', arguments: '{}' }
      }]
    };

    // 렌더링 테스트
    const { container } = render(<MessageBubbleRouter message={message} />);

    // tool_calls가 우선 처리되는지 확인
    expect(container.querySelector('.tool-call')).toBeInTheDocument();
  });

  it('should handle MCPContent[] with tool_call only', () => {
    const message: Message = {
      id: '2',
      sessionId: 'session2',
      role: 'assistant',
      content: [{
        type: 'tool_call',
        id: 'call2',
        function: { name: 'calculate', arguments: '{}' }
      }]
    };

    const { container } = render(<MessageBubbleRouter message={message} />);
    expect(container.querySelector('.tool-call')).toBeInTheDocument();
  });
});
```

---

**작성일시**: 2025-08-31 17:00
**작성자**: GitHub Copilot
**브랜치**: ref/chat
