# Drag and Drop 분리 리팩터링 계획

## 작업의 목적

현재 `useFileAttachment` 훅에 혼재된 파일 처리 로직과 전역 DnD 이벤트 처리를 분리하여, SynapticFlow의 compound component 패턴에 맞는 재사용 가능한 DnD 시스템을 구축한다. 이를 통해 여러 drop zone이 위치 기반으로 독립적으로 동작할 수 있는 확장 가능한 구조를 제공한다.

## 현재의 상태 / 문제점

### 현재 DnD 시스템의 충돌 문제

1. **여러 DnD 라이브러리 혼재**:
   - `useFileAttachment.ts`: Tauri webview 전역 DnD (OS 파일 드롭)
   - `WorkspaceFilesPanel.tsx`: `@dnd-kit/core` (내부 파일 이동 + 외부 파일 업로드)
   - 각각 독립적으로 동작하여 상호 간섭 및 일관성 부족

2. **위치 기반 라우팅 불가**: 드래그 위치에 따라 적절한 컴포넌트로 이벤트 전달 불가
3. **관심사 혼재**: 파일 처리 로직과 DnD 이벤트 처리가 각 컴포넌트에 혼재
4. **확장성 제한**: 새로운 drop zone 추가 시 기존 시스템과의 호환성 문제

### 현재 코드 구조 분석

```typescript
// useFileAttachment.ts - Tauri 전역 DnD
export function useFileAttachment() {
  const [dragState, setDragState] = useState<'none' | 'valid' | 'invalid'>('none');
  useEffect(() => {
    webview.onDragDropEvent((event) => {
      // 전역 단일 핸들러로 위치 기반 라우팅 불가
    });
  }, []);
}

// WorkspaceFilesPanel.tsx - @dnd-kit/core 사용
export function WorkspaceFilesPanel() {
  return (
    <DndContext onDragStart={...} onDragOver={...} onDragEnd={...}>
      {/* 내부 파일 이동 + DOM 파일 드롭 처리 */}
    </DndContext>
  );
}
```

### 현재 사용처 및 충돌 지점

- **ChatInput**: Tauri DnD로 OS 파일 첨부
- **WorkspaceFilesPanel**: @dnd-kit으로 파일 이동 + DOM 드롭으로 파일 업로드
- **문제**: 같은 영역에서 서로 다른 DnD 시스템이 경합

## 추가 분석 과제

1. **DnD 소스별 데이터 통합**: Tauri paths, DOM files, @dnd-kit custom 데이터를 일관된 DropData로 변환
2. **성능 최적화**: 실시간 포인터 추적 및 다중 rect 계산의 성능 영향
3. **기존 기능 보존**: `WorkspaceFilesPanel`의 파일 이동, 자동 확장 등 고급 기능 유지
4. **확장성 검증**: 새로운 드래그 소스(텍스트, 이미지 등) 추가 시 구조 검증

## 변경 이후의 상태 / 해결 판정 기준

### 목표 구조

```typescript
src/
├── context/
│   └── DragDropSurfaceContext.tsx     # 통합 DnD 라우팅, 모든 소스 처리
├── hooks/
│   └── useDropZone.ts                 # 단일 범용 drop zone 훅
└── features/
    ├── chat/hooks/useFileAttachment.ts    # 순수 파일 처리만
    └── chat/components/
        ├── ChatInput.tsx                  # useDropZone 사용
        └── WorkspaceFilesPanel.tsx        # useDropZone + @dnd-kit 공존
```

### 해결 판정 기준

1. **인터페이스 단순화**: 모든 subscriber가 동일한 `useDropZone` 인터페이스 사용
2. **데이터 추상화**: 소스와 무관하게 일관된 `DropData` 형태로 제공
3. **기존 기능 보존**: @dnd-kit 내부 드래그는 그대로, 외부 드롭만 통합 처리
4. **확장성**: 새로운 드래그 소스/타입을 기존 subscriber 수정 없이 추가 가능
5. **성능**: 위치 추적이 기존 DnD 라이브러리들과 충돌하지 않음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 새로운 DragDropSurfaceContext 생성

### 1. 간소화된 DragDropSurfaceContext 생성

```typescript
// src/context/DragDropSurfaceContext.tsx
interface DropData {
  type: 'paths' | 'files' | 'text' | 'custom';
  paths?: string[]; // Tauri 경로
  files?: File[]; // DOM File 객체
  text?: string; // 텍스트 드래그
  custom?: any; // @dnd-kit 등 커스텀 데이터
}

interface DropZoneRegistration {
  id: string;
  getRect: () => DOMRect | null;
  priority?: number; // 겹침 시 우선순위 (기본값: 0)
  onDrop?: (data: DropData) => void;
  validate?: (data: DropData) => boolean;
}

export function DragDropSurfaceProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // 모든 DnD 소스(Tauri, DOM, @dnd-kit)를 통합하여
  // subscriber에게 일관된 DropData 형태로 전달
  // 위치 기반 라우팅으로 적절한 zone에 이벤트 전달
}
```

### 2. useFileAttachment 리팩터링

```typescript
// src/features/chat/hooks/useFileAttachment.ts - 수정 후
export function useFileAttachment() {
  // DnD 관련 코드 제거
  // const [dragState, setDragState] = useState<'none' | 'valid' | 'invalid'>('none'); // 삭제
  // useEffect(() => { webview.onDragDropEvent... }); // 삭제

  // 순수 파일 처리 로직만 유지
  const processFileDrop = useCallback(async (filePaths: string[]) => { ... });
  const processFiles = useCallback(async (files: File[]) => { ... });
  const handleFileAttachment = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => { ... });

  return {
    // dragState, // 삭제
    processFileDrop,    // 추가
    processFiles,       // 추가
    handleFileAttachment,
    // ... 기타 파일 관련 기능들
  };
}
```

### 3. useDropZone 훅 생성

### 3. 간소화된 useDropZone 훅

```typescript
// src/hooks/useDropZone.ts
export function useDropZone<T extends HTMLElement>({
  id,
  priority = 0,
  onDrop,
  validate,
}: {
  id: string;
  priority?: number;
  onDrop?: (data: DropData) => void;
  validate?: (data: DropData) => boolean;
}) {
  const ref = useRef<T | null>(null);
  const { registerZone, unregisterZone, activeZoneId } = useDragDropSurface();

  useEffect(() => {
    const getRect = () => ref.current?.getBoundingClientRect() ?? null;
    registerZone({ id, getRect, priority, onDrop, validate });
    return () => unregisterZone(id);
  }, [id, priority, onDrop, validate, registerZone, unregisterZone]);

  return {
    ref,
    isActive: activeZoneId === id,
    // 추가 상태 정보
    isDragging: /* 전역 드래그 상태 */,
    dragData: /* 현재 드래그되는 데이터 정보 */
  };
}
```

### 4. 모든 컴포넌트가 동일한 인터페이스 사용

```typescript
// ChatInput - 파일 첨부용
const { ref, isActive, isDragging } = useDropZone({
  id: 'chat-input',
  priority: 1,
  onDrop: (data) => {
    if (data.type === 'paths') processFileDrop(data.paths!);
    if (data.type === 'files') processFiles(data.files!);
  },
  validate: (data) => {
    if (data.type === 'paths') return validatePaths(data.paths!);
    if (data.type === 'files') return validateFiles(data.files!);
    return false;
  },
});

// WorkspaceFilesPanel - 기존 @dnd-kit + 외부 파일 업로드
const { ref, isActive } = useDropZone({
  id: 'workspace-panel',
  priority: 2, // 더 높은 우선순위
  onDrop: (data) => {
    // @dnd-kit 내부 드래그는 여전히 자체 처리
    // 외부 파일 드롭만 여기서 처리
    if (data.type === 'files') handleFilesDrop(data.files!, rootPath);
  },
});

// 새로운 컴포넌트들도 동일한 방식
const { ref, isActive } = useDropZone({
  id: 'image-uploader',
  onDrop: (data) => {
    if (data.type === 'files') uploadImages(data.files!);
    if (data.type === 'text') insertText(data.text!);
  },
});
```

### 5. ChatInput 수정

```typescript
// src/features/chat/components/ChatInput.tsx - 수정 부분
import { useFileAttachmentDropZone } from '../hooks/useFileAttachmentDropZone';
import { useDragDropSurface } from '@/context/DragDropSurfaceContext';

export function ChatInput({ children }: ChatInputProps) {
  const { ref: dropZoneRef, isActive } =
    useFileAttachmentDropZone<HTMLDivElement>({
      id: 'chat-input-dropzone',
    });
  const { isDragging, dragState } = useDragDropSurface();

  // dragState는 useDragDropSurface에서 가져옴
  // useFileAttachment에서는 dragState 제거
}
```

## 재사용 가능한 연관 코드

### 파일 경로 및 주요 기능

- **ResourceAttachmentContext** (`src/context/ResourceAttachmentContext.tsx`): 파일 상태 관리
  - `addPendingFiles`, `commitPendingFiles`, `removeFile` 등 파일 lifecycle 관리
  - SWR 기반 서버 동기화
- **useRustBackend** (`src/hooks/use-rust-backend.ts`): Tauri 파일 읽기
  - `readDroppedFile` 메서드로 OS 경로에서 파일 데이터 읽기
- **SessionContext** (`src/context/SessionContext.tsx`): 세션별 파일 저장소 관리

### 재사용 가능한 인터페이스

```typescript
// 기존 AttachmentReference 인터페이스 활용
interface AttachmentReference {
  storeId: string;
  contentId: string;
  filename: string;
  mimeType: string;
  size: number;
  // ...
}

// 기존 파일 처리 함수들 재사용
type FileProcessor = (filePaths: string[]) => Promise<void>;
type FileValidator = (paths: string[]) => boolean;
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트

1. **DragDropSurfaceContext 테스트**
   - 포인터 위치 기반 zone 선택 로직
   - 중첩된 zone에서의 우선순위 (가장 작은 area 선택)
   - Tauri 이벤트와 DOM 이벤트 통합 처리

2. **useDropZone 테스트**
   - zone 등록/해제 lifecycle
   - rect 계산 및 업데이트 (resize, scroll 시)
   - 여러 zone 동시 등록 시나리오

3. **useFileAttachment 테스트**
   - DnD 로직 제거 후 순수 파일 처리 기능
   - `processFileDrop`, `processFiles` 함수 독립 테스트

### 통합 테스트

1. **다중 DnD 시스템 호환성**
   - Tauri + @dnd-kit + DOM 드롭이 같은 영역에서 충돌 없이 작동
   - 우선순위 기반 이벤트 라우팅 정상 동작
   - WorkspaceFilesPanel의 기존 파일 이동 기능 유지

2. **위치 기반 라우팅 정확성**
   - 드래그 위치에 따라 적절한 컴포넌트로 이벤트 전달
   - 중첩된 drop zone에서 우선순위 기반 선택
   - 다양한 화면 크기에서 좌표 계산 정확성

### 테스트 파일 구조

```typescript
src/test/
├── context/
│   └── DragDropSurfaceContext.test.tsx
├── hooks/
│   ├── useDropZone.test.ts
│   ├── useDndKitDropZone.test.ts
│   └── useFileAttachmentDropZone.test.ts
└── features/chat/
    ├── hooks/useFileAttachment.test.ts
    └── components/
        ├── ChatInput.test.tsx
        └── WorkspaceFilesPanel.test.tsx
```

### Mock 전략

- Tauri `getCurrentWebview()` 및 `onDragDropEvent` mock
- DOM `getBoundingClientRect()` mock으로 다양한 zone 위치 시뮬레이션
- File 객체 및 DataTransfer 객체 mock
