# Refactoring Plan: 브라우저 도구 분리 및 최적화

**작성일**: 2025-09-12

## 작업의 목적

SynapticFlow의 웹페이지 자동화 효율성을 크게 향상시키기 위해 현재 과도한 책임을 가진 `extractContent` 도구를 단일 책임 원칙에 따라 분리하고 최적화한다.

**핵심 목표:**

- **콘텐츠 읽기 전용화**: `extractContent`를 마크다운 텍스트 추출 전용으로 단순화
- **상호작용 요소 분석 전용화**: AI Agent 액션을 위한 `extractInteractable` 도구 신규 생성
- **워크플로우 효율화**: 2단계 추론 과정을 1단계로 단축하여 LLM 토큰 사용량 및 응답 시간 최적화

**비즈니스 임팩트:**

- AI Agent의 웹 자동화 정확도 향상
- 대용량 웹페이지 처리 시 응답 속도 개선
- LLM API 비용 절감 효과Plan: 브라우저 도구 분리 및 최적화

## 현재의 상태 / 문제점

### 1. 성능 및 효율성 문제

**현재 extractContent 도구의 복잡성:**

```typescript
// 파일 위치: src/features/tools/browser-tools/ExtractContentTool.ts (lines 17-26)
interface ValidatedArgs {
  sessionId: string;
  selector: string;
  format: 'markdown' | 'json' | 'dom-map'; // 3가지 서로 다른 출력 형식
  saveRawHtml: boolean;
  includeLinks: boolean; // json format에만 사용
  maxDepth: number; // dom-map에만 사용
}
```

**문제점:**

- `json` 및 `dom-map` 형식의 출력이 raw HTML보다 2-3배 크고 복잡함
- 불필요한 메타데이터와 중첩 구조로 인한 토큰 과다 사용
- 하나의 도구에서 서로 다른 목적의 기능 혼재로 인한 복잡성

### 2. 워크플로우 비효율성 문제

**현재 AI Agent 웹 상호작용 프로세스:**

1. `extractContent` 실행 (dom-map 형식)
2. LLM이 대량의 DOM 데이터를 분석하여 상호작용 요소 식별
3. LLM이 CSS selector 추측 시도
4. `clickElement` 또는 `inputText` 실행
5. selector 오류 시 재시도 반복

**결과적 문제:**

- 다단계 추론으로 인한 응답 지연 (평균 3-5초)
- selector 오류율 높음 (약 30-40%)
- 불필요한 LLM API 호출 증가

### 3. 정보 정확성 문제

**선택자 부재로 인한 실패 사례:**

```typescript
// 현재 extractContent dom-map 출력 예시
{
  "tag": "button",
  "text": "로그인",
  "class": "btn btn-primary",
  // selector 정보 부재 - LLM이 추측해야 함
}

// 이로 인해 발생하는 문제
clickElement({ sessionId: "test", selector: ".btn.btn-primary" }); // 실패 가능성 높음
```

**근본 원인:**

- 정확한 CSS selector 생성 로직 부재
- 요소의 고유성 보장 메커니즘 없음
- 동적 UI 변경에 대한 내성 부족

## 추가 분석 과제

### 1. 최적 선택자 생성 전략 수립

**분석 목표:**

- 브라우저별, 웹사이트별 CSS selector 안정성 검증
- SPA 환경에서 동적 DOM 변경에 대한 선택자 내성 분석
- 성능과 정확성의 균형점 도출

**분석 방법:**

- 대표적인 웹사이트들(React, Vue, Angular 기반)에서 선택자 생성 테스트
- 페이지 새로고침 후 동일 선택자의 유효성 검증
- 선택자 생성 알고리즘별 성능 벤치마크

### 2. 상호작용 요소 탐지 범위 최적화

**현재 불명확한 부분:**

- 커스텀 컴포넌트의 상호작용 가능성 판단 기준
- ARIA 속성과 실제 기능 간의 일치성 검증 방법
- 숨겨진 요소 중 프로그래밍적으로 접근 가능한 요소 구분

**추가 조사 필요:**

```typescript
// 애매한 케이스들 - 추가 분석 필요
'[data-action="submit"]',           // 커스텀 액션 속성
'[aria-expanded]',                  // 확장 가능한 요소
'.dropdown-toggle:not([disabled])', // 복합 선택자의 필요성
```

### 3. 기존 html-parser 로직 재활용 방안

**분석 대상:**

- `parseElementToDOMMap` 함수의 DOM 순회 로직 재사용 가능성
- `DOMMapNode` 인터페이스와 새로운 `InteractableElement` 간의 호환성
- 기존 유틸리티 함수들의 extractInteractable에서의 활용도

**현재 html-parser.ts의 재사용 가능한 구조:**

```typescript
// 파일 위치: src/lib/html-parser.ts (lines 801-810)
function parseElementToDOMMap(
  element: Element,
  depth: number,
  options: Required<DOMMapOptions>,
  document: Document,
): DOMMapNode | null;
```

## 변경 이후의 상태 / 해결 판정 기준

### 1. extractContent 도구 (단순화된 버전)

**목표 상태:**

- **단일 책임**: 마크다운 형식 텍스트 추출만 담당
- **단순화된 인터페이스**: format, includeLinks, maxDepth 옵션 제거
- **향상된 성능**: 복잡한 분기 로직 제거로 처리 속도 개선

**새로운 인터페이스:**

```typescript
interface SimplifiedValidatedArgs {
  sessionId: string;
  selector: string; // 기본값: 'body'
  saveRawHtml: boolean; // 기본값: false
}
```

### 2. extractInteractable 도구 (신규 생성)

**핵심 기능:**

- 상호작용 가능한 요소들의 정확한 CSS selector 제공
- 각 요소의 현재 상태 정보 포함 (enabled, visible, value 등)
- 최소한의 필수 정보만 포함하여 데이터 크기 최적화

**출력 데이터 구조:**

```typescript
interface InteractableResult {
  elements: Array<{
    selector: string; // 핵심: 고유하고 안정적인 CSS selector
    type: 'button' | 'input' | 'select' | 'link' | 'textarea';
    text?: string; // 사용자에게 보이는 텍스트
    enabled: boolean; // 현재 활성화 상태
    visible: boolean; // 현재 가시성 상태
    // input 요소 전용
    inputType?: string; // input type 속성
    value?: string; // 현재 입력값
    placeholder?: string; // placeholder 텍스트
  }>;
  metadata: {
    total_count: number;
    extraction_timestamp: string;
    scope_selector: string;
    performance: {
      execution_time_ms: number;
      data_size_bytes: number;
    };
  };
}
```

### 3. 측정 가능한 성공 기준

**성능 목표:**

- [ ] **처리 시간**: extractContent 실행 시간 50% 이상 단축
- [ ] **데이터 크기**: extractInteractable 결과가 기존 dom-map 대비 70% 이상 감소
- [ ] **토큰 절약**: 동일 페이지 처리 시 LLM 토큰 사용량 50% 이상 감소
- [ ] **정확도**: selector 기반 요소 접근 성공률 90% 이상

**기능 목표:**

- [ ] **호환성**: 기존 markdown 추출 기능 100% 유지
- [ ] **워크플로우**: extractInteractable → clickElement/inputText 1단계 성공 시나리오 달성
- [ ] **안정성**: 페이지 새로고침 후에도 85% 이상의 selector 유효성 유지

**검증 시나리오:**

```typescript
// 시나리오 1: 로그인 폼 자동화
const interactables = await extractInteractable({ sessionId: 'test' });
const loginBtn = interactables.elements.find((el) =>
  el.text?.includes('로그인'),
);
await clickElement({ sessionId: 'test', selector: loginBtn.selector });

// 시나리오 2: 검색 폼 입력
const searchInput = interactables.elements.find(
  (el) => el.type === 'input' && el.inputType === 'search',
);
await inputText({
  sessionId: 'test',
  selector: searchInput.selector,
  text: '검색어',
});
```

## 수정이 필요한 코드 및 수정부분

### 1. ExtractContentTool.ts 단순화 (기존 파일 수정)

**파일 위치**: `src/features/tools/browser-tools/ExtractContentTool.ts`

**제거할 코드 블록들:**

```typescript
// Lines 17-26: ValidatedArgs 인터페이스 단순화
interface ValidatedArgs {
  sessionId: string;
  selector: string;
  // 제거 대상
  // format: 'markdown' | 'json' | 'dom-map';
  // includeLinks: boolean;
  // maxDepth: number;
  saveRawHtml: boolean;
}

// Lines 151-166: convertToJson 함수 제거
function convertToJson(
  rawHtml: string,
  options: { maxDepth: number; includeLinks: boolean },
): ConversionResult {
  // 전체 함수 제거
}

// Lines 168-182: convertToDomMap 함수 제거
function convertToDomMap(rawHtml: string, maxDepth: number): ConversionResult {
  // 전체 함수 제거
}

// Lines 184-194: executeConversion 함수 단순화
function executeConversion(
  // format 매개변수 제거, markdown 전용으로 변경
  rawHtml: string,
): ConversionResult {
  return convertToMarkdown(rawHtml);
}
```

**수정할 validation 로직:**

```typescript
// Lines 37-104: validateExtractContentArgs 함수 단순화
function validateExtractContentArgs(
  args: Record<string, unknown>,
): ValidatedArgs | null {
  // format, includeLinks, maxDepth 관련 검증 로직 제거
  // sessionId, selector, saveRawHtml만 검증

  if (typeof args.sessionId !== 'string') {
    return null;
  }

  const selector = args.selector ?? 'body';
  if (typeof selector !== 'string') {
    return null;
  }

  const saveRawHtml = args.saveRawHtml ?? false;
  if (typeof saveRawHtml !== 'boolean') {
    return null;
  }

  return { sessionId: args.sessionId, selector, saveRawHtml };
}
```

**inputSchema 수정:**

```typescript
// Lines 286-310: inputSchema 단순화
inputSchema: {
  type: 'object',
  properties: {
    sessionId: BROWSER_TOOL_SCHEMAS.sessionId,
    selector: {
      type: 'string',
      description: 'CSS selector to target specific elements. Defaults to "body"',
    },
    saveRawHtml: {
      type: 'boolean',
      description: 'Save raw HTML to file for debugging. Default: false',
    },
    // format, includeLinks, maxDepth 속성 제거
  },
  required: ['sessionId'],
}
```

### 2. ExtractInteractableTool.ts 신규 생성

**파일 위치**: `src/features/tools/browser-tools/ExtractInteractableTool.ts`

**새로 생성할 인터페이스:**

```typescript
import { getLogger } from '@/lib/logger';
import { BROWSER_TOOL_SCHEMAS } from './helpers';
import { StrictBrowserMCPTool } from './types';
import {
  createMCPStructuredResponse,
  createMCPErrorResponse,
} from '@/lib/mcp-response-utils';
import { createId } from '@paralleldrive/cuid2';

const logger = getLogger('ExtractInteractableTool');

interface InteractableElement {
  selector: string;
  type: 'button' | 'input' | 'select' | 'link' | 'textarea';
  text?: string;
  enabled: boolean;
  visible: boolean;
  inputType?: string;
  value?: string;
  placeholder?: string;
}

interface InteractableResult {
  elements: InteractableElement[];
  metadata: {
    extraction_timestamp: string;
    total_count: number;
    scope_selector: string;
    performance: {
      execution_time_ms: number;
      data_size_bytes: number;
    };
  };
}

interface ValidatedArgs {
  sessionId: string;
  selector: string;
  includeHidden: boolean;
}
```

**핵심 브라우저 스크립트:**

```typescript
// 브라우저에서 실행될 상호작용 요소 추출 스크립트
const EXTRACT_INTERACTABLE_SCRIPT = `
(function() {
  function generateUniqueSelector(element) {
    // 1순위: id 속성 (고유성 검증)
    if (element.id && document.querySelectorAll('#' + element.id).length === 1) {
      return '#' + element.id;
    }
    
    // 2순위: data-testid 속성
    const testId = element.getAttribute('data-testid');
    if (testId) {
      return '[data-testid="' + testId + '"]';
    }
    
    // 3순위: name 속성 (폼 요소)
    if (element.name && element.type) {
      const selector = element.tagName.toLowerCase() + 
                     '[name="' + element.name + '"]' +
                     '[type="' + element.type + '"]';
      if (document.querySelectorAll(selector).length === 1) {
        return selector;
      }
    }
    
    // 4순위: nth-child 기반 구조적 경로
    return generateStructuralPath(element);
  }
  
  function generateStructuralPath(element) {
    const path = [];
    let current = element;
    
    while (current && current.tagName) {
      const tagName = current.tagName.toLowerCase();
      const parent = current.parentElement;
      
      if (parent) {
        const siblings = Array.from(parent.children).filter(
          el => el.tagName === current.tagName
        );
        if (siblings.length > 1) {
          const index = siblings.indexOf(current) + 1;
          path.unshift(tagName + ':nth-child(' + index + ')');
        } else {
          path.unshift(tagName);
        }
      } else {
        path.unshift(tagName);
      }
      
      current = parent;
      if (path.length > 6) break; // 경로 길이 제한
    }
    
    return path.join(' > ');
  }
  
  function isVisible(element) {
    const rect = element.getBoundingClientRect();
    const style = getComputedStyle(element);
    
    return rect.width > 0 && 
           rect.height > 0 && 
           style.visibility !== 'hidden' && 
           style.display !== 'none' &&
           style.opacity !== '0';
  }
  
  function getElementText(element) {
    return (element.textContent || 
            element.value || 
            element.title || 
            element.alt || 
            element.getAttribute('aria-label') || '').trim();
  }
  
  function getElementType(element) {
    const tag = element.tagName.toLowerCase();
    if (tag === 'a') return 'link';
    if (tag === 'button') return 'button';
    if (tag === 'input') return 'input';
    if (tag === 'select') return 'select';
    if (tag === 'textarea') return 'textarea';
    if (element.getAttribute('role') === 'button') return 'button';
    return 'button'; // 기본값
  }
  
  // 메인 추출 로직
  const scopeElement = arguments[0] ? 
    document.querySelector(arguments[0]) : document.body;
  const includeHidden = arguments[1] || false;
  
  if (!scopeElement) {
    return { elements: [], error: 'Scope element not found' };
  }
  
  const interactableSelectors = [
    'button:not([disabled])',
    'input:not([disabled]):not([type="hidden"])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'a[href]:not([href="#"])',
    '[role="button"]:not([aria-disabled="true"])',
    '[onclick]',
    '[data-action]'
  ];
  
  const elements = [];
  const startTime = performance.now();
  
  scopeElement.querySelectorAll(interactableSelectors.join(',')).forEach(el => {
    const visible = isVisible(el);
    
    if (!includeHidden && !visible) {
      return;
    }
    
    const elementData = {
      selector: generateUniqueSelector(el),
      type: getElementType(el),
      text: getElementText(el),
      enabled: !el.disabled && !el.hasAttribute('disabled') && 
               el.getAttribute('aria-disabled') !== 'true',
      visible: visible
    };
    
    // input 요소 전용 속성
    if (el.tagName.toLowerCase() === 'input') {
      elementData.inputType = el.type;
      elementData.value = el.value;
      elementData.placeholder = el.placeholder;
    }
    
    elements.push(elementData);
  });
  
  const executionTime = performance.now() - startTime;
  
  return {
    elements: elements,
    metadata: {
      extraction_timestamp: new Date().toISOString(),
      total_count: elements.length,
      scope_selector: arguments[0] || 'body',
      performance: {
        execution_time_ms: Math.round(executionTime * 100) / 100,
        data_size_bytes: JSON.stringify(elements).length
      }
    }
  };
})();
`;
```

**도구 구현 클래스:**

```typescript
export const extractInteractableTool: StrictBrowserMCPTool = {
  name: 'extractInteractable',
  description:
    'Extract interactive elements with precise CSS selectors for automation',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: BROWSER_TOOL_SCHEMAS.sessionId,
      selector: {
        type: 'string',
        description: 'Scope selector to limit search area. Defaults to "body"',
      },
      includeHidden: {
        type: 'boolean',
        description:
          'Include hidden but potentially interactable elements. Default: false',
      },
    },
    required: ['sessionId'],
  },
  execute: async (args: Record<string, unknown>, executeScript) => {
    const validatedArgs = validateExtractInteractableArgs(args);
    if (!validatedArgs) {
      return createMCPErrorResponse(
        -32602,
        'Invalid arguments provided',
        { toolName: 'extractInteractable', args },
        createId(),
      );
    }

    if (!executeScript) {
      return createMCPErrorResponse(
        -32603,
        'executeScript function is required',
        { toolName: 'extractInteractable', args },
        createId(),
      );
    }

    try {
      const result = await executeScript(
        validatedArgs.sessionId,
        `${EXTRACT_INTERACTABLE_SCRIPT}("${validatedArgs.selector}", ${validatedArgs.includeHidden})`,
      );

      if (!result || typeof result !== 'object') {
        throw new Error('Invalid response from browser script');
      }

      const textContent = `Found ${result.metadata.total_count} interactive elements in ${result.metadata.performance.execution_time_ms}ms`;

      return createMCPStructuredResponse(textContent, result, createId());
    } catch (error) {
      logger.error('Error in extractInteractable:', {
        error,
        sessionId: validatedArgs.sessionId,
      });

      return createMCPErrorResponse(
        -32603,
        `Failed to extract interactive elements: ${error instanceof Error ? error.message : String(error)}`,
        { toolName: 'extractInteractable', args },
        createId(),
      );
    }
  },
};

function validateExtractInteractableArgs(
  args: Record<string, unknown>,
): ValidatedArgs | null {
  if (typeof args.sessionId !== 'string') {
    return null;
  }

  const selector = args.selector ?? 'body';
  if (typeof selector !== 'string') {
    return null;
  }

  const includeHidden = args.includeHidden ?? false;
  if (typeof includeHidden !== 'boolean') {
    return null;
  }

  return {
    sessionId: args.sessionId,
    selector,
    includeHidden,
  };
}
```

## 재사용 가능한 연관 코드

### 1. 기존 ExtractContentTool.ts에서 재사용할 코드

**파일 위치**: `src/features/tools/browser-tools/ExtractContentTool.ts`

**재사용 가능한 함수들:**

```typescript
// Lines 209-224: HTML 추출 로직 (extractInteractable에서도 필요)
async function extractHtmlFromPage(
  executeScript: (sessionId: string, script: string) => Promise<unknown>,
  sessionId: string,
  selector: string,
): Promise<string> {
  const rawHtml = await executeScript(
    sessionId,
    `document.querySelector(${JSON.stringify(selector)}).outerHTML`,
  );

  if (!rawHtml || typeof rawHtml !== 'string') {
    throw new Error('Failed to extract HTML from the page');
  }

  return rawHtml;
}

// Lines 226-241: 메타데이터 생성 패턴
function createMetadata(
  result: ConversionResult,
  rawHtml: string,
  selector: string,
  format: string,
): Record<string, unknown> {
  return {
    ...result,
    metadata: {
      extraction_timestamp: new Date().toISOString(),
      content_length:
        typeof result.content === 'string' ? result.content.length : 0,
      raw_html_size: rawHtml.length,
      selector,
      format,
    },
  };
}

// Lines 243-264: 응답 텍스트 생성 패턴
function generateResponseText(result: ConversionResult): string {
  // 응답 포맷팅 로직 재사용 가능
}
```

**재사용할 validation 패턴:**

```typescript
// sessionId 검증 로직 (두 도구 공통)
if (typeof args.sessionId !== 'string') {
  logger.warn('Invalid sessionId type', {
    sessionId: args.sessionId,
    type: typeof args.sessionId,
  });
  return null;
}

// selector 검증 로직 (두 도구 공통)
const selector = args.selector ?? 'body';
if (typeof selector !== 'string') {
  logger.warn('Invalid selector type', { selector, type: typeof selector });
  return null;
}
```

### 2. MCP 응답 유틸리티 (공통)

**파일 위치**: `src/lib/mcp-response-utils.ts`

**공통 사용 함수들:**

```typescript
// 성공 응답 생성
createMCPStructuredResponse(
  textContent: string,
  data: Record<string, unknown>,
  requestId: string,
)

// 에러 응답 생성
createMCPErrorResponse(
  code: number,
  message: string,
  data: Record<string, unknown>,
  requestId: string,
)
```

### 3. 브라우저 도구 공통 유틸리티

**파일 위치**: `src/features/tools/browser-tools/helpers.ts`

**재사용할 스키마 및 상수:**

```typescript
// 공통 스키마 정의
export const BROWSER_TOOL_SCHEMAS = {
  sessionId: {
    type: 'string',
    description: 'Browser session identifier',
  },
  selector: {
    type: 'string',
    description: 'CSS selector for targeting elements',
  },
} as const;

// 공통 에러 처리 패턴
export function formatBrowserResultAsMCP(result: string) {
  // 브라우저 결과를 MCP 형식으로 변환
}
```

### 4. 타입 정의 및 인터페이스

**파일 위치**: `src/features/tools/browser-tools/types.ts`

**재사용할 인터페이스:**

```typescript
// 브라우저 도구 공통 인터페이스
export interface StrictBrowserMCPTool {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  execute: (
    args: Record<string, unknown>,
    executeScript?: (sessionId: string, script: string) => Promise<unknown>,
  ) => Promise<unknown>;
}
```

### 5. html-parser.ts DOM 분석 로직 (참조용)

**파일 위치**: `src/lib/html-parser.ts`

**참조 가능한 구조:**

```typescript
// Lines 801-810: DOM 요소 파싱 구조
function parseElementToDOMMap(
  element: Element,
  depth: number,
  options: Required<DOMMapOptions>,
  document: Document,
): DOMMapNode | null;

// Lines 42-54: DOMMapNode 인터페이스 (참조용)
export interface DOMMapNode {
  tag: string;
  selector: string;
  id?: string;
  class?: string;
  text?: string;
  type?: string; // input type
  href?: string; // link href
  placeholder?: string;
  value?: string;
  name?: string;
  role?: string;
  ariaLabel?: string;
  children: DOMMapNode[];
}
```

**DOM 순회 및 요소 분석 패턴 참조:**

```typescript
// 기존 DOM 순회 로직의 개념적 재사용
// - 요소별 속성 추출 방법
// - 중첩 구조 처리 방식
// - 에러 처리 패턴
```

### 6. 로깅 시스템

**파일 위치**: `src/lib/logger.ts`

**일관된 로깅 패턴:**

```typescript
import { getLogger } from '@/lib/logger';

const logger = getLogger('ExtractInteractableTool');

// 디버그 로깅
logger.debug('Executing extractInteractable', { sessionId, selector });

// 에러 로깅
logger.error('Error in extractInteractable:', {
  error,
  sessionId,
  selector,
});

// 경고 로깅
logger.warn('Invalid arguments provided', { args });
```

### 7. 기존 브라우저 도구 등록 패턴

**파일 위치**: `src/features/tools/browser-tools/index.ts`

**새 도구 등록 방법:**

```typescript
// 기존 등록 패턴 참조
export { extractContentTool } from './ExtractContentTool';
// 새로 추가 예정
export { extractInteractableTool } from './ExtractInteractableTool';
```

## 구현 순서 및 검증 계획

### Phase 1: extractContent 단순화

1. format 관련 코드 제거
2. validation 로직 단순화
3. 기존 markdown 기능 정상 동작 확인

### Phase 2: extractInteractable 개발

1. 기본 구조 및 인터페이스 구현
2. 브라우저 측 선택자 생성 로직 개발
3. 단위 테스트 및 성능 측정

### Phase 3: 통합 검증

1. **워크플로우 테스트**: extractInteractable → clickElement 연동 확인
2. **성능 비교**: 기존 대비 토큰 사용량 및 응답 시간 측정
3. **데이터 크기 검증**: 결과물 크기 비교 분석

### 성공 검증 시나리오

```typescript
// 검증 워크플로우 예시
1. extractInteractable({ sessionId: 'test' })
2. 결과에서 "Login" 버튼의 selector 획득
3. clickElement({ sessionId: 'test', selector: 획득된_선택자 })
4. 로그인 폼으로 정상 이동 확인
```
