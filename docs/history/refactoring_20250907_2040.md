# Refactoring Plan: MCPContent-level Service Context Preservation

## 작업의 목적

Tool execution pipeline에서 service context 정보를 MCPContent 레벨로 보존하여 UI components가 prefix 관리 없이 도구를 정확하게 재호출할 수 있도록 개선합니다. 현재 MessageRenderer에서 수동으로 관리하는 MCP tools의 `builtin.`, `server__tool` 등의 prefix 처리를 자동화하고, UI action에서 정확한 service context로 도구를 재호출할 수 있게 합니다.

**중요**: `tauri:` prefix는 실제 MCP tool이 아닌 Tauri Command 호출을 위한 내부 규약이므로 이 refactoring의 대상에서 제외합니다.

## 현재의 상태 / 문제점

### 1. Service Context 손실

Tool response에서 어떤 service가 해당 결과를 제공했는지 정보가 사라짐:

```typescript
// use-tool-processor.ts에서 MCPResponse.result.content만 Message에 저장
content: mcpResponse.result?.content || [];
// serviceInfo, serverName 등의 context 정보 손실
```

- External MCP: `filesystem__read_file` → 응답에서 `filesystem` 서버 정보 손실
- Built-in: `builtin.planning__create_todo` → 응답에서 `planning` 서비스 정보 손실

### 2. UI Action 시 Context 부족

MessageRenderer에서 UI action으로 도구를 재호출할 때:

```typescript
// MessageRenderer.tsx handleUIAction
const { toolName, params } = result.payload;
// toolName은 base name (예: "read_file")
// 하지만 실제 호출해야 하는 full name은 "filesystem__read_file"
```

- UI에서 전달되는 toolName은 base name
- 정확한 full name 구성을 위한 service context 없음
- 현재는 복잡한 패턴 매칭으로 해결 시도

### 3. 다중 도구 결과 처리 한계

하나의 Message에 여러 도구 결과가 포함될 때 각각의 service context 구분 불가:

```typescript
// Message.content: MCPContent[]에서 각 content의 출처 불명
// 병렬 실행이나 streaming 시 여러 서버 결과 혼재 시 문제
```

## 추가 분석 과제

1. **MCPContent 확장 시 성능 영향**: 모든 content에 serviceInfo 추가 시 메모리 오버헤드 측정 필요
2. **Streaming 시나리오 검증**: 실시간 도구 결과 누적 시 service context 보존 방식 확인
3. **Type Compatibility 검증**: ExtendedMCPContent가 기존 MCPContent 처리 로직과 완전 호환되는지 확인
4. **UI Resource 타입 처리**: resource 타입 MCPContent에서 serviceInfo 활용 방안 분석

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

- [ ] MessageRenderer에서 MCP tools의 prefix 수동 처리 완전 제거 (tauri: 명령어는 제외)
- [ ] UI action이 base name으로 도구 호출 시 자동으로 정확한 full name 구성
- [ ] 각 MCPContent에 service context 정보 보존 및 추출 가능
- [ ] 하나의 Message에 여러 서버 결과 포함 시 개별 service context 구분 가능
- [ ] 기존 tool execution flow에 breaking change 없음
- [ ] 모든 MCP backend type (External MCP, Built-in Rust/Web)에서 service info 제공
- [ ] Type safety 유지 및 ExtendedMCPContent ↔ MCPContent 자동 호환
- [ ] Tauri Command (`tauri:` prefix) 처리는 기존 로직 완전 유지

### 데이터 흐름 개선

```text
Before: LLM → Tool Call → use-unified-mcp → Backend → MCPResponse → Message.content (context 손실)
After:  LLM → Tool Call → use-unified-mcp → Backend → MCPResponse → ExtendedMCPContent → Message.content (context 보존)
Note:   tauri: commands는 별도 처리 경로로 기존 로직 유지
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. MCPContent 확장 타입 정의

```typescript
// src/lib/mcp-types.ts에 추가
export interface ServiceInfo {
  serverName: string;
  toolName: string;
  backendType: 'ExternalMCP' | 'BuiltInWeb' | 'BuiltInRust';
}

export interface ExtendedMCPContent extends MCPContent {
  serviceInfo?: ServiceInfo;
}

export function isExtendedMCPContent(
  content: MCPContent,
): content is ExtendedMCPContent {
  return content && typeof content === 'object' && 'serviceInfo' in content;
}

export function extractServiceInfoFromContent(
  content: MCPContent[],
): ServiceInfo | null {
  for (const item of content) {
    if (isExtendedMCPContent(item) && item.serviceInfo) {
      return item.serviceInfo;
    }
  }
  return null;
}
```

### 2. Service Context 주입 로직

```typescript
// src/hooks/use-unified-mcp.ts executeToolCall() 수정
try {
  let response: MCPResponse;

  if (toolType === 'BuiltInRust') {
    response = await executeRustBuiltinRef.current(actualToolCall);
  } else {
    response = await executeExternalRef.current(actualToolCall);
  }

  // Service info 추출
  const serviceInfo = extractServiceInfo(resolvedToolName, toolType);

  // MCPResponse의 content를 ExtendedMCPContent로 확장
  if (response.result?.content) {
    response.result.content = response.result.content.map(
      (content) =>
        ({
          ...content,
          serviceInfo,
        }) as ExtendedMCPContent,
    );
  }

  return response;
} catch (error) {
  // 기존 error handling 유지
}

// Service info 추출 utility 함수
const extractServiceInfo = (
  resolvedToolName: string,
  toolType: BackendType,
): ServiceInfo => {
  if (toolType === 'ExternalMCP') {
    const [serverName, ...toolNameParts] = resolvedToolName.split('__');
    return {
      serverName,
      toolName: toolNameParts.join('__'),
      backendType: toolType,
    };
  } else {
    const withoutPrefix = resolvedToolName.replace('builtin.', '');
    const [serverName, ...toolNameParts] = withoutPrefix.split('__');
    return {
      serverName,
      toolName: toolNameParts.join('__'),
      backendType: toolType,
    };
  }
};
```

### 3. MessageRenderer Service Context 활용

```typescript
// src/components/MessageRenderer.tsx handleUIAction 수정
const handleUIAction = useCallback(
  async (result: UIActionResult) => {
    // ... 기존 sessionId, assistantId 로직 유지

    switch (result.type) {
      case 'tool': {
        const { toolName, params = {} } = result.payload;

        // tauri: prefix 처리는 기존 로직 완전히 유지
        if (toolName.startsWith('tauri:')) {
          // ... 기존 Tauri 명령어 처리 로직 그대로 유지
          return;
        }

        // MCP 도구 호출 개선: content에서 service info 추출
        const serviceInfo = extractServiceInfoFromContent(content);

        let finalToolName = toolName;
        if (serviceInfo) {
          const isBaseName =
            !toolName.includes('__') && !toolName.startsWith('builtin.');

          if (isBaseName) {
            finalToolName =
              serviceInfo.backendType === 'ExternalMCP'
                ? `${serviceInfo.serverName}__${toolName}`
                : `builtin.${serviceInfo.serverName}__${toolName}`;

            logger.info('Tool name resolved using service context', {
              originalName: toolName,
              resolvedName: finalToolName,
              serviceInfo,
            });
          }
        } else {
          logger.warn(
            'No service context available, using original tool name',
            {
              toolName,
            },
          );
        }

        // 통합된 MCP 도구 호출
        await executeToolCall({
          id: createId(),
          type: 'function',
          function: {
            name: finalToolName,
            arguments: JSON.stringify(params),
          },
        });
        break;
      }
      // ... 기존 intent case 유지
    }
  },
  [content, executeToolCall, submit, getCurrentSession, getCurrent],
);
```

## 재사용 가능한 연관 코드

### Tool Execution Pipeline

- **`src/hooks/use-unified-mcp.ts`**: 중앙 도구 실행 오케스트레이션
  - `executeToolCall()`: 핵심 도구 실행 함수, service info 주입 지점
  - `resolveToolName()`: 도구 이름 해석 로직, service info 추출에 활용
  - Backend type 구분 로직: External MCP vs Built-in 구분

- **`src/hooks/use-tool-processor.ts`**: 도구 실행 결과를 Message로 변환
  - `toolResultMessage` 생성 로직: 이미 ExtendedMCPContent가 포함된 content 처리
  - 수정 불필요 (upstream에서 이미 확장된 content 제공)

### Type Definitions

- **`src/lib/mcp-types.ts`**: 핵심 MCP 프로토콜 타입들
  - `MCPContent`: 기본 content 타입, 확장 대상
  - `MCPResponse`: tool 실행 응답, result.content 포함
  - `normalizeToolResult()`: 도구 결과 정규화, ExtendedMCPContent 호환 확인 필요

- **`src/models/chat.ts`**: Chat 및 Message 데이터 구조
  - `Message.content: MCPContent[]`: ExtendedMCPContent와 호환 (수정 불필요)

### UI Components

- **`src/components/MessageRenderer.tsx`**: 도구 결과 렌더링 및 UI action 처리
  - `handleUIAction()`: service context 활용 대상
  - `content` prop: ExtendedMCPContent[] 처리
  - Tauri command 처리 로직: 완전 보존

- **`@mcp-ui/client`**: UI resource 렌더링 라이브러리
  - `UIResourceRenderer`: resource 타입 MCPContent 처리
  - `onUIAction` callback: base name 전달, service context 필요

### Built-in Tools

- **`src/features/tools/index.tsx`**: Built-in tool provider
  - Web backend tools: serviceInfo.backendType = 'BuiltInWeb'
  - 수정 불필요 (upstream service info 주입으로 처리)

- **`src/features/tools/RustMCPToolProvider.tsx`**: Rust built-in tools
  - Rust backend tools: serviceInfo.backendType = 'BuiltInRust'
  - 수정 불필요 (upstream service info 주입으로 처리)

### Key Interfaces

```typescript
// 재사용할 핵심 인터페이스들
- MCPContent: 기본 content 타입, 확장 기반
- MCPResponse: 표준 MCP 응답 형식, content 포함
- ToolCall: 도구 호출 인터페이스
- BackendType: 'ExternalMCP' | 'BuiltInWeb' | 'BuiltInRust'
- Message: 채팅 메시지 구조, content 필드 활용
```

### External Dependencies

- **`src/context/MCPServerContext.tsx`**: External MCP 서버 통신
  - 수정 불필요 (MCPResponse는 표준 형식 유지)
  - serviceInfo는 use-unified-mcp에서 추가 처리

- **`@mcp-ui/server`**: UI resource 타입 정의
  - UIResource 인터페이스: MCPContent의 resource 타입
  - serviceInfo 확장 시 호환성 확인 필요
