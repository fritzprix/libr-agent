# WebMCP 프록시 인스턴스 통합을 위한 Context Provider 분리 리팩토링

## 작업의 목적

WebMCPToolProvider와 useWebMCPServer에서 각각 별도의 MCPWorker 인스턴스를 생성하여 발생하는 상태 불일치 문제를 해결하고, 단일 WebMCP 프록시 인스턴스를 React Context를 통해 공유하는 구조로 개선한다.

## 현재의 상태 / 문제점

### 1. 이중 워커 인스턴스 문제

- `WebMCPToolProvider.tsx`: 자체적으로 `new MCPWorker()` 생성 → Worker A
- `use-web-mcp-server.ts`: `WebMCPProxyManager`에서 `new MCPWorker()` 생성 → Worker B
- 각 워커는 독립적인 JS 실행 컨텍스트를 가지므로 planning-server의 상태가 서로 다름

### 2. 상태 동기화 불가

- ChatPlanningPanel에서 useWebMCPServer로 조회하는 상태 ≠ WebMCPToolProvider를 통해 업데이트된 상태
- 도구 호출 결과가 UI에 반영되지 않는 문제 발생

### 3. 구조적 문제

- WebMCPToolProvider는 이름은 Provider이지만 실제로는 Context를 제공하지 않음
- 코드 중복: 동일한 프록시 초기화 로직이 두 곳에 존재
- 책임 분산: 프록시 관리와 서비스 등록이 한 곳에 혼재

## 추가 분석 과제

1. **Context Provider 위치 결정**: App 레벨에서 제공할지, 특정 기능 영역에서 제공할지 분석
2. **기존 BuiltInService 등록 로직 호환성**: 현재 도구 등록 시스템과의 호환성 확인
3. **서버 프록시 캐싱 전략**: 서버별 프록시 인스턴스 생성 및 캐싱 최적화 방안
4. **에러 처리 및 복구**: Context Provider 레벨에서의 에러 처리 및 프록시 재초기화 전략

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **단일 프록시 인스턴스**: 애플리케이션 전체에서 하나의 MCPWorker 인스턴스만 사용
2. **상태 일관성**: planning-server의 상태가 모든 컴포넌트에서 동일하게 조회됨
3. **명확한 책임 분리**:
   - Context Provider: 프록시 관리 및 제공
   - Service Registry: BuiltInService 등록
   - Hook: 서버 프록시 접근
4. **기존 기능 유지**: 현재 동작하는 모든 MCP 기능이 그대로 작동

### 검증 방법

- ChatPlanningPanel에서 도구 호출 후 즉시 상태 조회 시 변경사항 반영 확인
- 여러 컴포넌트에서 동시에 planning 서버 상태 조회 시 일관성 확인
- 기존 MCP 도구들의 정상 동작 확인

## 수정이 필요한 코드 및 수정부분

### 1. 새로운 Context Provider 생성

**파일**: `src/context/WebMCPContext.tsx` (신규)

```typescript
// 핵심 Context 정의
interface WebMCPContextValue {
  proxy: WebMCPProxy | null;
  isLoading: boolean;
  initialized: boolean;
  getServerProxy: <T extends WebMCPServerProxy>(
    serverName: string,
  ) => Promise<T>;
}

const WebMCPContext = createContext<WebMCPContextValue | null>(null);

export function WebMCPProvider({ children }: { children: React.ReactNode }) {
  // WebMCPToolProvider의 프록시 초기화 로직 이동
  // 서버 프록시 생성 및 캐싱 로직 추가
}

export function useWebMCP() {
  // Context 접근 훅
}
```

### 2. WebMCPToolProvider 리팩토링

**파일**: `src/features/tools/WebMCPServiceRegistry.tsx` (리네임)

```typescript
// 기존 코드에서 수정 필요한 부분
- const proxyRef = useRef<WebMCPProxy | null>(null);
- const [{ loading: isLoading }, initializeProxy] = useAsyncFn(async () => {
+ const { proxy, isLoading, initialized } = useWebMCP();

// BuiltInService 등록 로직만 유지
export function WebMCPServiceRegistry({ servers }: { servers: string[] }) {
  const { proxy, getServerProxy } = useWebMCP();
  // 기존 services 생성 로직 유지하되 Context의 프록시 사용
}
```

### 3. useWebMCPServer Hook 단순화

**파일**: `src/hooks/use-web-mcp-server.ts`

```typescript
// 제거할 코드
- class WebMCPProxyManager { ... }
- const workerInstance = new MCPWorker();

// 추가할 코드
+ import { useWebMCP } from '@/context/WebMCPContext';

export function useWebMCPServer<T extends WebMCPServerProxy>(serverName: string) {
- const proxyManagerRef = useRef(WebMCPProxyManager.getInstance());
+ const { getServerProxy, isLoading } = useWebMCP();

  // 서버 프록시 로드 로직을 Context의 getServerProxy 사용으로 변경
}
```

### 4. App.tsx 수정

**파일**: `src/app/App.tsx`

```typescript
// Provider 계층 구조 변경
<WebMCPProvider>
  <WebMCPServiceRegistry servers={['planning', 'browser']} />
  {/* 기존 앱 컴포넌트들 */}
</WebMCPProvider>
```

## 재사용 가능한 연관 코드

### 프록시 초기화 로직

**파일**: `src/features/tools/WebMCPToolProvider.tsx` (lines 25-39)

```typescript
const [{ loading: isLoading }, initializeProxy] = useAsyncFn(async () => {
  // Worker 생성 및 프록시 초기화
  const workerInstance = new MCPWorker();
  const proxy = new WebMCPProxy({ workerInstance });
  await proxy.initialize();
});
```

### 서버 로드 로직

**파일**: `src/features/tools/WebMCPToolProvider.tsx` (lines 42-79)

```typescript
const loadServer = useCallback(async (serverName: string) => {
  // 서버 상태 관리 및 도구 목록 로드
});
```

### 서버 프록시 생성 로직

**파일**: `src/hooks/use-web-mcp-server.ts` (lines 49-123)

```typescript
async getServerProxy<T extends WebMCPServerProxy>(serverName: string): Promise<T> {
  // 캐싱, 도구 메서드 동적 생성, 응답 처리
}
```

### 도구 실행 로직

**파일**: `src/features/tools/WebMCPToolProvider.tsx` (lines 82-100)

```typescript
const executeTool = useCallback(async (serviceId: string, call: ToolCall) => {
  // MCP 도구 호출 및 응답 처리
});
```

### 관련 타입 정의

**파일**: `src/hooks/use-web-mcp-server.ts` (lines 14-18)

```typescript
export interface WebMCPServerProxy {
  name: string;
  isLoaded: boolean;
  tools: MCPTool[];
  [methodName: string]: unknown;
}
```

### BuiltInService 인터페이스

**파일**: `src/features/tools/index.ts`

```typescript
export interface BuiltInService {
  executeTool: (call: ToolCall) => Promise<MCPResponse>;
  listTools: () => MCPTool[];
  loadService: () => Promise<void>;
  unloadService: () => Promise<void>;
  getServiceContext: () => Promise<string>;
}
```
