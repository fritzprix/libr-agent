# Refactoring Plan: Platform-Specific Shell Execution Tool Names

## 작업의 목적

현재 `execute_shell` 도구는 플랫폼에 관계없이 단일 이름으로 제공되지만, Unix 계열(bash/sh)과 Windows(cmd.exe) 시스템에서 서로 다른 셸을 사용합니다. 이로 인해:

1. **명확성 부족**: 도구 이름만으로는 어떤 셸이 사용되는지 명확하지 않음
2. **멀티플랫폼 혼란**: 크로스 플랫폼 환경에서 에이전트가 플랫폼별 동작을 예측하기 어려움
3. **문서화 복잡성**: 하나의 도구 설명에 두 플랫폼의 동작을 모두 기술해야 함

이 리팩토링은 Rust의 `cfg` 속성을 활용해 **플랫폼별로 명확한 도구 이름**을 제공하여 도구의 목적과 동작을 분명히 합니다:

- Unix 계열: `execute_shell` (bash/sh 사용)
- Windows: `execute_windows_cmd` (cmd.exe 사용)

---

## 현재의 상태 / 문제점

### 현재 구조

**도구 정의 위치:**

- `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`
  - `create_execute_shell_tool()` 함수가 단일 `MCPTool` 반환
  - 도구 이름: `"execute_shell"`
  - 스키마는 플랫폼 무관

**도구 등록:**

- `src-tauri/src/mcp/builtin/workspace/tools/mod.rs`
  - `code_tools()` 함수에서 `create_execute_shell_tool()` 호출
  - 반환된 도구를 `Vec<MCPTool>`에 추가

**도구 핸들링:**

- `src-tauri/src/mcp/builtin/workspace/mod.rs`
  - `call_tool()` 메서드에서 `"execute_shell"` 문자열 매칭
  - `handle_execute_shell(args)` 호출

**실제 실행 로직:**

- `src-tauri/src/mcp/builtin/workspace/code_execution.rs`
  - `handle_execute_shell()`: 동기/비동기 모드 분기
  - `execute_shell_with_isolation()`: 동기 실행
  - `execute_shell_async()`: 비동기 실행
  - `SessionIsolationManager`에 명령 생성 위임

- `src-tauri/src/session_isolation.rs`
  - `create_isolated_command()`: 격리 수준별 명령 생성
  - `create_basic_isolated_command()`: 기본 격리
  - **플랫폼 분기 지점**: `cfg!(target_os = "windows")` 체크
    - Windows: `cmd /C` 또는 PowerShell 직접 실행
    - Unix: `bash -c` 또는 `sh -c`

### 문제점

1. **도구 이름과 동작의 불일치**
   - 도구 이름은 `execute_shell`로 중립적이나, 실제로는 플랫폼별로 다른 셸 사용
   - Windows에서 "shell"이라는 이름이 혼란스러움 (일반적으로 cmd, PowerShell 등으로 구분)

2. **에이전트의 플랫폼 인식 부족**
   - LLM 에이전트가 도구 발견 시, 플랫폼별 차이를 인지하지 못함
   - Unix 명령어를 Windows에서 실행하거나 그 반대 시도 가능

3. **스키마와 예제의 혼란**
   - 현재 `code_tools.rs`의 예제는 Unix 명령어 중심 (`ls -la`, `grep`, `source`)
   - Windows에서는 이 명령어들이 대부분 작동하지 않음

4. **유지보수 복잡성**
   - 단일 도구 설명에 플랫폼별 동작을 모두 포함해야 함
   - 플랫폼별 테스트 케이스 작성 시 혼란

---

## 관련 코드의 구조 및 동작 방식 Summary (Bird's Eye View)

### 아키텍처 개요

```text
┌─────────────────────────────────────────────────────────────┐
│                   MCP Client (Frontend)                     │
│              Tool Discovery & Invocation                    │
└──────────────────────┬──────────────────────────────────────┘
                       │ call_tool("execute_shell", args)
                       ▼
┌─────────────────────────────────────────────────────────────┐
│        WorkspaceServer::call_tool() [mod.rs:751]            │
│          Route tool name to handler function                │
└──────────────────────┬──────────────────────────────────────┘
                       │ handle_execute_shell(args)
                       ▼
┌─────────────────────────────────────────────────────────────┐
│   WorkspaceServer::handle_execute_shell() [code_exec:500]   │
│   - Parse args (command, run_mode, timeout, isolation)     │
│   - Branch: sync → execute_shell_with_isolation()          │
│            async → execute_shell_async()                   │
└──────────────────────┬──────────────────────────────────────┘
                       │
          ┌────────────┴────────────┐
          ▼                         ▼
┌──────────────────────┐   ┌──────────────────────┐
│ execute_shell_with_  │   │ execute_shell_async()│
│ isolation() [sync]   │   │ [async background]   │
└──────┬───────────────┘   └──────┬───────────────┘
       │                          │
       └──────────┬───────────────┘
                  │ SessionIsolationManager::create_isolated_command()
                  ▼
┌─────────────────────────────────────────────────────────────┐
│    SessionIsolationManager [session_isolation.rs]           │
│    - create_isolated_command(config)                        │
│      → Branch by isolation_level:                           │
│         Basic   → create_basic_isolated_command()           │
│         Medium  → create_medium_isolated_command()          │
│         High    → create_high_isolated_command()            │
└──────────────────────┬──────────────────────────────────────┘
                       │ create_basic_isolated_command()
                       ▼
┌─────────────────────────────────────────────────────────────┐
│    Platform-Specific Command Construction                   │
│    [session_isolation.rs:110-200]                           │
│                                                              │
│    if cfg!(target_os = "windows") {                         │
│        if PowerShell detected:                              │
│            AsyncCommand::new("powershell")                  │
│        else:                                                │
│            AsyncCommand::new("cmd")                         │
│            cmd.args(["/C", command])                        │
│    } else {                                                 │
│        AsyncCommand::new("bash") or "sh"                    │
│        cmd.args(["-c", command])                            │
│    }                                                        │
└─────────────────────────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│    spawn_and_stream_to_files() [code_exec:14]               │
│    - tokio::process::Command::spawn()                       │
│    - Stream stdout/stderr to files                          │
│    - Respect cancellation token                             │
│    - Return (pid, exit_code, stdout, stderr)                │
└─────────────────────────────────────────────────────────────┘
```

### 주요 컴포넌트

#### 1. **도구 정의** (`tools/code_tools.rs`)

- `create_execute_shell_tool()`: MCPTool 스키마 생성
- 현재 단일 함수, 플랫폼 무관

#### 2. **도구 등록** (`tools/mod.rs`)

- `code_tools()`: 도구 벡터 반환
- `WorkspaceServer::list_tools()`에서 사용

#### 3. **도구 라우팅** (`mod.rs`)

- `call_tool()`: 도구 이름으로 핸들러 매칭
- 현재 `"execute_shell"` 하드코딩

#### 4. **실행 로직** (`code_execution.rs`)

- `handle_execute_shell()`: 파라미터 파싱 및 모드 분기
- `execute_shell_with_isolation()`: 동기 실행 + timeout
- `execute_shell_async()`: 비동기 백그라운드 실행
- `spawn_and_stream_to_files()`: 공통 프로세스 spawn/stream 로직

#### 5. **격리 관리** (`session_isolation.rs`)

- `SessionIsolationManager`: 플랫폼별 격리 명령 생성
- **핵심 플랫폼 분기**:
  - Windows: `cmd /C` 또는 PowerShell
  - Unix: `bash -c` 또는 `sh -c`
- 환경변수, 작업 디렉토리, PATH 설정

### 데이터 플로우

1. **도구 발견**: MCP 클라이언트가 `list_tools()` 호출 → `create_execute_shell_tool()` 반환
2. **도구 호출**: 클라이언트가 `call_tool("execute_shell", args)` 호출
3. **라우팅**: `WorkspaceServer::call_tool()`에서 `handle_execute_shell()` 호출
4. **파라미터 파싱**: `command`, `run_mode`, `timeout`, `isolation` 추출
5. **모드 분기**:
   - sync → `execute_shell_with_isolation()` (timeout 적용)
   - async → `execute_shell_async()` (백그라운드 spawn)
6. **격리 명령 생성**: `SessionIsolationManager::create_isolated_command()`
   - 플랫폼 감지 (`cfg!(target_os = "windows")`)
   - 셸 선택 (Windows: cmd/PowerShell, Unix: bash/sh)
7. **프로세스 실행**: `spawn_and_stream_to_files()`
   - `tokio::process::Command::spawn()`
   - stdout/stderr 스트리밍
8. **결과 반환**: MCPResponse (success/error)

---

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **플랫폼별 명확한 도구 이름**
   - Unix: `execute_shell` (bash/sh 사용)
   - Windows: `execute_windows_cmd` (cmd.exe 사용)

2. **플랫폼별 최적화된 스키마**
   - Unix: `ls`, `grep`, `bash` 관련 예제
   - Windows: `dir`, `type`, `cmd` 관련 예제

3. **에이전트 경험 향상**
   - 도구 이름만으로 플랫폼과 셸을 즉시 인지
   - 플랫폼별 명령어 예제로 학습 용이

4. **유지보수 개선**
   - 플랫폼별 코드 분리로 이해 용이
   - 테스트 케이스 작성 명확

### 해결 판정 기준

#### ✅ 필수 조건

1. **컴파일 성공**
   - Windows와 Unix 타겟 모두 컴파일 성공
   - `pnpm tauri build` 통과

2. **도구 발견 테스트**
   - Windows 빌드: `list_tools()`가 `execute_windows_cmd` 반환
   - Unix 빌드: `list_tools()`가 `execute_shell` 반환

3. **도구 호출 성공**
   - Windows: `call_tool("execute_windows_cmd", {"command": "dir"})`로 정상 실행
   - Unix: `call_tool("execute_shell", {"command": "ls"})`로 정상 실행

4. **기존 기능 유지**
   - 동기/비동기 모드 정상 작동
   - 격리 수준 (basic/medium/high) 정상 작동
   - 타임아웃, 프로세스 레지스트리, 출력 스트리밍 정상 작동

#### ✅ 검증 항목

1. **단위 테스트**
   - 각 플랫폼별 도구 생성 함수 테스트
   - 도구 이름 검증

2. **통합 테스트**
   - Windows: `execute_windows_cmd`로 `dir`, `echo` 실행
   - Unix: `execute_shell`로 `ls`, `echo` 실행

3. **문서 일관성**
   - 도구 description과 실제 동작 일치
   - 예제 명령어가 플랫폼에서 작동

---

## 수정이 필요한 코드 및 수정 부분

### 1. 도구 정의 수정 (`src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`)

**목표**: 플랫폼별로 다른 `MCPTool` 반환

**변경 사항**:

- 기존 `create_execute_shell_tool()` 함수를 플랫폼별로 분기
- `#[cfg(unix)]`와 `#[cfg(windows)]` 속성 사용

**수정 코드**:

```rust
// Unix 플랫폼용 도구 (기존 동작 유지, 이름 그대로)
#[cfg(unix)]
pub fn create_execute_shell_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "command".to_string(),
        string_prop_with_examples(
            Some(1),
            Some(1000),
            Some("Shell command to execute (bash/sh)"),
            vec![
                json!("ls -la"),
                json!("grep -r 'pattern' ."),
                json!("source script.sh"),
            ],
        ),
    );
    props.insert(
        "timeout".to_string(),
        integer_prop_with_default(
            Some(1),
            Some(crate::config::max_execution_timeout() as i64),
            crate::config::default_execution_timeout() as i64,
            Some("Timeout in seconds (sync mode only, default: 30)"),
        ),
    );
    props.insert(
        "run_mode".to_string(),
        enum_prop(
            vec!["sync", "async"],
            "sync",
            Some("Execution mode: 'sync' (wait for completion), 'async' (return immediately with process_id)"),
        ),
    );

    MCPTool {
        name: "execute_shell".to_string(),
        title: Some("Execute Shell Command (bash/sh)".to_string()),
        description: "Execute a shell command using bash or sh in a sandboxed environment.\n\n\
                      MODES:\n\
                      - 'sync' (default): Wait for completion, return stdout/stderr immediately\n\
                      - 'async': Run in background, return process_id immediately\n\n\
                      For async mode, use 'poll_process' to check status and retrieve output.\n\n\
                      PLATFORM: Unix (Linux, macOS) - uses bash or sh shell."
            .to_string(),
        input_schema: object_schema(props, vec!["command".to_string()]),
        output_schema: None,
        annotations: None,
    }
}

// Windows 플랫폼용 도구 (cmd.exe 명시)
#[cfg(windows)]
pub fn create_execute_shell_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "command".to_string(),
        string_prop_with_examples(
            Some(1),
            Some(1000),
            Some("Command to execute using cmd.exe"),
            vec![
                json!("dir /b"),
                json!("echo Hello World"),
                json!("type file.txt"),
            ],
        ),
    );
    props.insert(
        "timeout".to_string(),
        integer_prop_with_default(
            Some(1),
            Some(crate::config::max_execution_timeout() as i64),
            crate::config::default_execution_timeout() as i64,
            Some("Timeout in seconds (sync mode only, default: 30)"),
        ),
    );
    props.insert(
        "run_mode".to_string(),
        enum_prop(
            vec!["sync", "async"],
            "sync",
            Some("Execution mode: 'sync' (wait for completion), 'async' (return immediately with process_id)"),
        ),
    );

    MCPTool {
        name: "execute_windows_cmd".to_string(),
        title: Some("Execute Windows Command (cmd.exe)".to_string()),
        description: "Execute a command using Windows cmd.exe in a sandboxed environment.\n\n\
                      MODES:\n\
                      - 'sync' (default): Wait for completion, return stdout/stderr immediately\n\
                      - 'async': Run in background, return process_id immediately\n\n\
                      For async mode, use 'poll_process' to check status and retrieve output.\n\n\
                      PLATFORM: Windows - uses cmd.exe (Command Prompt).\n\
                      NOTE: For PowerShell features, the system may automatically use PowerShell if available."
            .to_string(),
        input_schema: object_schema(props, vec!["command".to_string()]),
        output_schema: None,
        annotations: None,
    }
}
```

### 2. 도구 라우팅 수정 (`src-tauri/src/mcp/builtin/workspace/mod.rs`)

**목표**: 플랫폼별 도구 이름으로 라우팅

**변경 사항**:

- `call_tool()` 메서드의 매칭 로직을 플랫폼별로 분기

**수정 코드** (line 740-760 부근):

```rust
        match tool_name {
            // File operation tools
            "read_file" => self.handle_read_file(args).await,
            "write_file" => self.handle_write_file(args).await,
            "list_directory" => self.handle_list_directory(args).await,
            "replace_lines_in_file" => self.handle_replace_lines_in_file(args).await,
            "import_file" => self.handle_import_file(args).await,
            // Code execution tools
            // Platform-specific shell execution tools
            #[cfg(unix)]
            "execute_shell" => self.handle_execute_shell(args).await,
            #[cfg(windows)]
            "execute_windows_cmd" => self.handle_execute_shell(args).await,
            // Export tools
            "export_file" => self.handle_export_file(args).await,
            "export_zip" => self.handle_export_zip(args).await,
            // Terminal/Process management tools
            "poll_process" => self.handle_poll_process(args).await,
            "read_process_output" => self.handle_read_process_output(args).await,
            "list_processes" => self.handle_list_processes(args).await,
            _ => {
                let request_id = Self::generate_request_id();
                Self::error_response(request_id, -32601, &format!("Tool '{tool_name}' not found"))
            }
        }
```

**주의**: `handle_execute_shell()` 내부 로직은 변경 불필요 (이미 플랫폼 분기 처리됨)

### 3. 문서 업데이트 (`docs/builtin-tools.md`)

**목표**: 플랫폼별 도구 문서 명확화

**변경 사항**:

- `execute_shell` 섹션을 플랫폼별로 분리
- Unix와 Windows 각각 독립된 섹션 작성

**추가 내용**:

````markdown
### execute_shell (Unix only)

**Platform**: Unix (Linux, macOS)  
**Shell**: bash or sh

Execute a shell command in a sandboxed environment using bash or sh.

**Parameters**:

- `command` (required, string): Shell command to execute
- `timeout` (optional, number): Timeout in seconds (default: 30, max: 300)
- `run_mode` (optional, enum): `"sync"` (default) or `"async"`

**Examples**:

```json
{
  "command": "ls -la",
  "run_mode": "sync"
}
```
````

---

### execute_windows_cmd (Windows only)

**Platform**: Windows  
**Shell**: cmd.exe (or PowerShell if available)

Execute a command using Windows cmd.exe in a sandboxed environment.

**Parameters**:

- `command` (required, string): Command to execute
- `timeout` (optional, number): Timeout in seconds (default: 30, max: 300)
- `run_mode` (optional, enum): `"sync"` (default) or `"async"`

**Examples**:

```json
{
  "command": "dir /b",
  "run_mode": "sync"
}
```

**Note**: The system may automatically use PowerShell if it's available and the command benefits from it.

````markdown
---

## 재사용 가능한 연관 코드

### 1. 플랫폼 감지 패턴 (`session_isolation.rs`)

**파일**: `src-tauri/src/session_isolation.rs`
**라인**: 393-415

**용도**: 런타임 플랫폼 감지 및 셸 선택

```rust
/// Get the appropriate shell command for the platform
fn get_shell_command(&self) -> &str {
    if cfg!(target_os = "windows") {
        "cmd"
    } else {
        "bash"
    }
}

async fn is_command_available(&self, command: &str) -> bool {
    let mut cmd = if cfg!(target_os = "windows") {
        AsyncCommand::new("where")
    } else {
        AsyncCommand::new("which")
    };
    cmd.arg(command);
    match cmd.output().await {
        Ok(output) => output.status.success(),
        Err(err) => {
            warn!("Failed to check command availability: {err}");
            false
        }
    }
}
```
````

### 2. 스키마 빌더 유틸리티 (`utils/schema_builder.rs`)

**파일**: `src-tauri/src/mcp/utils/schema_builder.rs`

**용도**: MCPTool 스키마 생성 헬퍼 함수

- `string_prop_with_examples()`: 문자열 프로퍼티 + 예제
- `integer_prop_with_default()`: 정수 프로퍼티 + 기본값
- `enum_prop()`: Enum 프로퍼티 + 기본값
- `object_schema()`: 객체 스키마 생성

### 3. 도구 등록 패턴 (`tools/mod.rs`)

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/mod.rs`  
**라인**: 18-26

**용도**: 도구를 벡터로 묶어서 반환

```rust
pub fn code_tools() -> Vec<MCPTool> {
    vec![
        code_tools::create_execute_shell_tool(),
    ]
}
```

**참고**: 이 함수는 수정 불필요 (cfg에 따라 자동으로 다른 도구 반환)

### 4. 명령 정규화 로직 (`code_execution.rs`)

**파일**: `src-tauri/src/mcp/builtin/workspace/code_execution.rs`  
**라인**: 396-488

**용도**: LLM이 생성한 명령어의 따옴표 자동 보정

```rust
fn normalize_shell_command(raw_command: &str) -> String {
    // ...existing code...
}

fn fix_consecutive_quotes(input: &str) -> String {
    // ...existing code...
}
```

**참고**: 이 로직은 플랫폼 무관하게 재사용 가능

---

## Test Code 추가 및 수정 가이드

### 1. 도구 생성 단위 테스트

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs` (테스트 모듈 추가)

**목적**: 플랫폼별로 올바른 도구 이름이 생성되는지 검증

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tool_name_platform_specific() {
        let tool = create_execute_shell_tool();

        #[cfg(unix)]
        assert_eq!(tool.name, "execute_shell");

        #[cfg(windows)]
        assert_eq!(tool.name, "execute_windows_cmd");
    }

    #[test]
    fn test_tool_schema_has_required_properties() {
        let tool = create_execute_shell_tool();
        let schema = tool.input_schema;

        assert!(schema.get("properties").is_some());
        let props = schema["properties"].as_object().unwrap();
        assert!(props.contains_key("command"));
        assert!(props.contains_key("timeout"));
        assert!(props.contains_key("run_mode"));
    }

    #[cfg(unix)]
    #[test]
    fn test_unix_tool_has_unix_examples() {
        let tool = create_execute_shell_tool();
        let examples = tool.input_schema["properties"]["command"]["examples"]
            .as_array()
            .unwrap();

        // Unix 명령어 예제 확인
        assert!(examples.iter().any(|e| e.as_str().unwrap().contains("ls")));
        assert!(examples.iter().any(|e| e.as_str().unwrap().contains("grep")));
    }

    #[cfg(windows)]
    #[test]
    fn test_windows_tool_has_windows_examples() {
        let tool = create_execute_shell_tool();
        let examples = tool.input_schema["properties"]["command"]["examples"]
            .as_array()
            .unwrap();

        // Windows 명령어 예제 확인
        assert!(examples.iter().any(|e| e.as_str().unwrap().contains("dir")));
        assert!(examples.iter().any(|e| e.as_str().unwrap().contains("echo")));
    }
}
```

### 2. 도구 라우팅 통합 테스트

**파일**: `src-tauri/src/mcp/builtin/workspace/mod.rs` (테스트 모듈 추가)

**목적**: 플랫폼별 도구 이름으로 핸들러가 호출되는지 검증

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::session::SessionManager;

    #[tokio::test]
    async fn test_platform_specific_tool_routing() {
        let session_manager = Arc::new(SessionManager::new());
        let server = WorkspaceServer::new(session_manager);

        #[cfg(unix)]
        let tool_name = "execute_shell";

        #[cfg(windows)]
        let tool_name = "execute_windows_cmd";

        let args = json!({
            "command": "echo test",
            "run_mode": "sync",
            "timeout": 5
        });

        let response = server.call_tool(tool_name, args).await;

        // 도구가 존재하고 실행됨 (에러가 "Tool not found"가 아님)
        if let Some(error) = response.get("error") {
            let message = error["message"].as_str().unwrap();
            assert!(!message.contains("not found"));
        }
    }

    #[tokio::test]
    async fn test_wrong_platform_tool_name_fails() {
        let session_manager = Arc::new(SessionManager::new());
        let server = WorkspaceServer::new(session_manager);

        // 반대 플랫폼 도구 이름으로 시도
        #[cfg(unix)]
        let wrong_tool_name = "execute_windows_cmd";

        #[cfg(windows)]
        let wrong_tool_name = "execute_shell";

        let args = json!({
            "command": "echo test"
        });

        let response = server.call_tool(wrong_tool_name, args).await;

        // "Tool not found" 에러 확인
        assert!(response.get("error").is_some());
        let message = response["error"]["message"].as_str().unwrap();
        assert!(message.contains("not found"));
    }
}
```

### 3. 도구 목록 테스트

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/mod.rs` (테스트 모듈 추가)

**목적**: `code_tools()` 함수가 올바른 도구를 반환하는지 검증

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_code_tools_returns_platform_tool() {
        let tools = code_tools();
        assert_eq!(tools.len(), 1);

        let tool = &tools[0];

        #[cfg(unix)]
        assert_eq!(tool.name, "execute_shell");

        #[cfg(windows)]
        assert_eq!(tool.name, "execute_windows_cmd");
    }
}
```

### 4. E2E 테스트 (선택사항)

**목적**: 실제 명령 실행 및 결과 검증

```rust
#[cfg(test)]
mod e2e_tests {
    use super::*;

    #[tokio::test]
    #[cfg(unix)]
    async fn test_execute_shell_unix_command() {
        let session_manager = Arc::new(SessionManager::new());
        let server = WorkspaceServer::new(session_manager);

        let args = json!({
            "command": "echo 'Hello Unix'",
            "run_mode": "sync"
        });

        let response = server.call_tool("execute_shell", args).await;

        // 성공 응답 확인
        assert!(response.get("result").is_some());
        let result = response["result"].as_str().unwrap();
        assert!(result.contains("Hello Unix"));
    }

    #[tokio::test]
    #[cfg(windows)]
    async fn test_execute_windows_cmd_command() {
        let session_manager = Arc::new(SessionManager::new());
        let server = WorkspaceServer::new(session_manager);

        let args = json!({
            "command": "echo Hello Windows",
            "run_mode": "sync"
        });

        let response = server.call_tool("execute_windows_cmd", args).await;

        // 성공 응답 확인
        assert!(response.get("result").is_some());
        let result = response["result"].as_str().unwrap();
        assert!(result.contains("Hello Windows"));
    }
}
```

### 테스트 실행 방법

```powershell
# 단위 테스트 실행
cargo test --package synaptic-flow --lib

# 특정 모듈 테스트
cargo test --package synaptic-flow code_tools::tests

# Windows 전용 테스트
cargo test --package synaptic-flow --target x86_64-pc-windows-msvc

# 통합 테스트 (느림, 선택사항)
cargo test --package synaptic-flow --test '*'
```

---

## 추가 고려 사항

### 1. 하위 호환성

**문제**: 기존 클라이언트가 `execute_shell` 이름을 하드코딩한 경우

**해결 방안**:

- Unix 빌드에서는 기존 이름 유지 (`execute_shell`)
- Windows 빌드에서만 새 이름 (`execute_windows_cmd`) 사용
- 마이그레이션 경고 메시지 (선택사항)

### 2. PowerShell 지원

**현재 상태**: `session_isolation.rs`에서 PowerShell 자동 감지 및 사용

**개선 방향** (이 리팩토링 범위 밖):

- 향후 `execute_powershell` 도구를 별도 추가 가능
- `execute_windows_cmd`는 cmd.exe 전용으로 명확화

### 3. 크로스 플랫폼 에이전트

**시나리오**: 멀티플랫폼 지원 에이전트가 동적으로 도구 발견

**대응**:

- 에이전트는 `list_tools()`로 사용 가능한 도구 확인
- 도구 이름에 플랫폼 정보 포함되어 있어 자동 선택 가능

### 4. 문서 일관성

**필요 작업**:

- `docs/builtin-tools.md`: 플랫폼별 섹션 추가
- `README.md`: 플랫폼별 도구 명시
- `CHANGELOG.md`: Breaking change 기록 (Windows만 해당)

---

## 작업 순서

1. **도구 정의 수정** (`code_tools.rs`)
   - cfg 속성 추가
   - 플랫폼별 함수 분기
   - 예제 및 설명 업데이트

2. **라우팅 로직 수정** (`mod.rs`)
   - `call_tool()` 매칭 로직에 cfg 추가

3. **테스트 추가**
   - 도구 생성 테스트
   - 라우팅 테스트
   - 도구 목록 테스트

4. **문서 업데이트**
   - `docs/builtin-tools.md`
   - `README.md` (필요 시)
   - `CHANGELOG.md`

5. **빌드 및 검증**
   - Windows 빌드: `pnpm tauri build --target x86_64-pc-windows-msvc`
   - Unix 빌드 (선택): `pnpm tauri build --target x86_64-unknown-linux-gnu`
   - 테스트 실행: `cargo test`

6. **통합 테스트**
   - Tauri 개발 모드에서 실제 도구 호출 테스트
   - Windows와 Unix에서 각각 검증

---

## 예상 영향 범위

### 변경 파일

1. ✏️ `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`
2. ✏️ `src-tauri/src/mcp/builtin/workspace/mod.rs`
3. ➕ 테스트 코드 (각 파일에 `#[cfg(test)]` 모듈 추가)
4. ✏️ `docs/builtin-tools.md`
5. ✏️ `CHANGELOG.md`

### 영향 없음

- `code_execution.rs`: 내부 로직 변경 불필요
- `session_isolation.rs`: 플랫폼 분기 이미 구현됨
- `terminal_manager.rs`: 프로세스 레지스트리 로직 무관
- 프론트엔드: 도구 발견은 동적이므로 변경 불필요

---

## 참고 자료

- [Rust Conditional Compilation](https://doc.rust-lang.org/reference/conditional-compilation.html)
- [cfg Attribute Reference](https://doc.rust-lang.org/reference/attributes/conditional-compilation.html)
- [MCP Protocol Specification](https://modelcontextprotocol.io/docs/concepts/tools)
- 기존 리팩토링 문서: `docs/history/refactoring_20251010_async_execute_shell.md`
