# MCP UI 다운로드 성공 이벤트 처리 문제 해결 Refactoring Plan

## 작업의 목적

MCP UI Resource Renderer에서 파일 다운로드 성공 후 **iframe과의 postMessage 통신 문제**를 해결하여 timeout 오류 없이 정상적인 다운로드 완료 피드백을 제공한다.

### 핵심 목표

- **올바른 postMessage API 사용**: 잘못된 targetOrigin 객체 형태를 표준 문자열 형태로 수정
- **중복 이벤트 핸들러 제거**: 두 개의 서로 다른 다운로드 완료 처리 로직을 하나로 통합
- **정확한 iframe 통신**: iframe 내 JavaScript와 parent 간의 메시지 전달 방향을 올바르게 구성
- **timeout 오류 해결**: 다운로드 성공 후 MCP UI가 적절한 완료 신호를 받도록 보장

## 현재의 상태 / 문제점

### 1. 중복된 이벤트 처리 시스템

**UIResourceRenderer.tsx**에서 동일한 다운로드 완료 이벤트를 **두 가지 다른 방식**으로 처리:

1. **기본 onUIAction 핸들러** (115-170라인): `tool` 타입 액션을 직접 처리
2. **별도 postMessage 이벤트 리스너** (194-260라인): iframe에서 온 `tool` 메시지를 처리

이로 인해 동일한 다운로드 요청에 대해 중복 실행 가능성과 이벤트 충돌 발생.

### 2. postMessage API 오남용

```tsx
// 현재 코드 - 잘못된 API 사용
window.postMessage(
  {
    type: 'download_complete',
    success: true,
    result,
  },
  { targetOrigin: '*' }, // ❌ 객체 형태는 잘못됨
);
```

**MDN 표준**: `postMessage(message, targetOrigin, [transfer])`에서 `targetOrigin`은 문자열이어야 함.

### 3. 메시지 전달 방향 불일치

```javascript
// WorkspaceServer HTML 내 JavaScript (수신 대기)
window.addEventListener('message', function (event) {
  if (event.data.type === 'download_complete') {
    // iframe이 parent로부터 메시지를 기다림
  }
});
```

```tsx
// UIResourceRenderer (현재 송신 방식)
window.postMessage(message, targetOrigin); // 자기 자신에게 메시지 전송
```

**문제**: iframe은 parent로부터 메시지를 기다리지만, 실제로는 window 자체에 메시지를 보내고 있음.

### 4. 실제 발생하는 시퀀스

1. **사용자 클릭**: iframe 내 다운로드 버튼 클릭
2. **메시지 전송**: iframe → parent로 `tool` 타입 postMessage
3. **다운로드 실행**: UIResourceRenderer가 Tauri 명령 호출하여 다운로드 성공
4. **응답 전송 시도**: 잘못된 API로 인해 iframe에 메시지가 도달하지 않음
5. **timeout 발생**: iframe이 무한 대기 상태가 되어 사용자에게 timeout 오류 표시

### 5. 컴파일 오류로 인한 추가 문제

현재 `src-tauri/src/lib.rs`에서 missing module 오류로 인해 실제 런타임 테스트가 불가능한 상태.

## 추가 분석 과제

### 1. iframe과 parent 간 보안 정책 확인

- **동일 출처 정책**: iframe 내용이 parent와 동일한 origin에서 실행되는지 확인
- **postMessage 보안**: `targetOrigin` 설정이 보안 요구사항을 충족하는지 검토
- **CSP (Content Security Policy)**: iframe 내 inline script 실행 권한 확인

### 2. ExternalUIResourceRenderer 동작 분석

- **@mcp-ui/client**: 외부 라이브러리가 제공하는 UIResourceRenderer의 내부 동작 방식
- **이벤트 위임**: ExternalUIResourceRenderer가 onUIAction을 어떻게 처리하는지
- **iframe 생명주기**: 동적으로 생성되는 iframe의 로딩 타이밍과 메시지 수신 준비 상태

### 3. Tauri 명령 실행 결과 형태 확인

- **downloadWorkspaceFile 반환값**: 실제 반환되는 result 객체의 구조
- **exportAndDownloadZip 반환값**: ZIP 파일 생성 결과 데이터
- **오류 형태**: Exception vs String vs Error 객체의 일관성

### 4. 멀티 다운로드 시나리오 테스트

- **동시 다운로드**: 여러 파일을 동시에 다운로드할 때의 이벤트 처리
- **세션별 격리**: 다른 세션에서 동시 다운로드 시 메시지 충돌 가능성
- **메모리 누수**: 이벤트 리스너의 정리 및 생명주기 관리

## 변경 이후의 상태 / 해결 판정 기준

### 1. 통합된 이벤트 처리 시스템

- **단일 핸들러**: 하나의 통합된 다운로드 완료 처리 로직만 존재
- **명확한 책임**: postMessage 이벤트 리스너가 iframe 메시지만 처리, onUIAction은 직접 호출만 처리
- **중복 제거**: 동일한 다운로드 요청에 대한 중복 실행 방지

### 2. 표준 준수 postMessage 통신

- **올바른 API 사용**: `postMessage(message, '*')` 형태로 수정
- **정확한 타겟팅**: iframe의 contentWindow로 직접 메시지 전달
- **양방향 통신**: iframe ↔ parent 간의 정확한 메시지 흐름 보장

### 3. 완료된 사용자 경험

- **즉시 피드백**: 다운로드 완료 시 iframe에 즉시 성공 메시지 표시
- **timeout 해결**: 무한 대기 상태 및 timeout 오류 완전 제거
- **상태 관리**: 다운로드 버튼의 로딩 상태가 정확히 해제

### 4. 판정 기준

- [ ] postMessage API가 MDN 표준에 맞게 수정됨
- [ ] 중복된 이벤트 핸들러가 제거되고 단일 처리 로직으로 통합됨
- [ ] iframe 내 JavaScript가 parent로부터 `download_complete` 메시지를 정상 수신
- [ ] 다운로드 성공 후 "✅ Download completed successfully!" 메시지가 iframe에 표시
- [ ] timeout 오류 없이 다운로드 버튼이 정상 상태로 복원
- [ ] 컴파일 오류 해결로 실제 런타임 테스트 가능
- [ ] 연속 다운로드 및 멀티 다운로드 시나리오에서 정상 동작

## 수정이 필요한 코드 및 수정부분

### 1. UIResourceRenderer.tsx - postMessage API 수정

**파일**: `src/components/ui/UIResourceRenderer.tsx`

**현재 문제 코드** (125-133라인):

```tsx
// Send success message back to iframe
window.postMessage(
  {
    type: 'download_complete',
    success: true,
    result,
  },
  { targetOrigin: '*' },
);
```

**수정 방향**:

```tsx
// iframe의 contentWindow로 직접 메시지 전송
// ExternalUIResourceRenderer의 iframe ref를 활용하여 정확한 타겟 지정
if (iframeRef.current?.contentWindow) {
  iframeRef.current.contentWindow.postMessage(
    {
      type: 'download_complete',
      success: true,
      result,
    },
    '*',
  );
}
```

### 2. 중복 핸들러 제거 및 통합

**현재 문제**: 동일한 로직이 두 곳에서 중복 실행

**수정 방향**:

```tsx
const UIResourceRenderer: React.FC<UIResourceRendererProps> = ({
  resource,
  onUIAction,
}) => {
  // 통합된 다운로드 처리 함수
  const handleDownload = useCallback(
    async (
      toolName: string,
      params: Record<string, unknown>,
      targetWindow?: Window,
    ) => {
      // 단일 다운로드 처리 로직
      // 결과를 targetWindow (iframe)로 전송
    },
    [downloadWorkspaceFile, exportAndDownloadZip],
  );

  // iframe에서 온 메시지만 처리
  const handlePostMessage = useCallback(
    async (event: MessageEvent) => {
      if (event.data.type === 'tool') {
        await handleDownload(
          event.data.payload.toolName,
          event.data.payload.params,
          event.source as Window,
        );
      }
    },
    [handleDownload],
  );

  // 직접 호출된 UIAction 처리 (onUIAction prop 사용 시)
  const handleUIAction = onUIAction
    ? onUIAction
    : async (action: UIAction) => {
        if (action.type === 'tool') {
          await handleDownload(action.payload.toolName, action.payload.params);
        }
        // 기타 action 타입 처리...
      };
};
```

### 3. iframe 참조 관리 시스템

**ExternalUIResourceRenderer 확장**:

```tsx
// iframe ref를 상위 컴포넌트에서 접근 가능하도록 수정
const UIResourceRenderer: React.FC<UIResourceRendererProps> = ({
  resource,
  onUIAction,
}) => {
  const iframeRef = useRef<HTMLIFrameElement>(null);

  return (
    <ExternalUIResourceRenderer
      resource={mcpUIResource}
      onUIAction={handleUIAction}
      iframeRef={iframeRef} // iframe 참조 전달
    />
  );
};
```

### 4. WorkspaceServer HTML 스크립트 개선

**파일**: `src-tauri/src/mcp/builtin/workspace.rs` (1600-1610라인)

**현재 코드**:

```javascript
window.addEventListener('message', function (event) {
  if (event.data.type === 'download_complete') {
    // 처리 로직
  }
});
```

**수정 방향**:

```javascript
// 메시지 출처 검증 추가
window.addEventListener('message', function (event) {
  // 보안: parent window에서 온 메시지만 처리
  if (event.source !== window.parent) return;

  if (event.data.type === 'download_complete') {
    if (event.data.success) {
      showStatus('✅ Download completed successfully!', 'success');
    } else {
      showStatus('❌ Download failed: ' + event.data.error, 'error');
    }
    resetButton();
  }
});
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 컴포넌트

**파일**: `src/components/ui/UIResourceRenderer.tsx`

- **기능**: MCP UI Resource 렌더링, postMessage 통신 관리
- **인터페이스**: `UIResourceRendererProps`, `UIAction` 타입
- **재사용**: 기존 ExternalUIResourceRenderer 래퍼 및 이벤트 처리 구조 유지

**파일**: `src/hooks/useRustBackend.ts`

- **기능**: Tauri 명령 호출, 파일 다운로드 API
- **인터페이스**: `downloadWorkspaceFile()`, `exportAndDownloadZip()` 함수
- **재사용**: 기존 API 시그니처 그대로 활용

**파일**: `src/lib/logger.ts`

- **기능**: 구조화된 로깅 시스템
- **인터페이스**: `getLogger()`, `logger.info/warn/error` 메서드
- **재사용**: 다운로드 이벤트 처리 과정의 디버깅 및 모니터링

### 확장 필요한 인터페이스

**파일**: `@mcp-ui/client` (외부 라이브러리)

```tsx
// 현재 사용 중인 인터페이스
<ExternalUIResourceRenderer
  resource={mcpUIResource}
  onUIAction={handleUIAction}
/>;

// 확장 필요 사항 (iframe ref 접근)
interface ExtendedUIResourceRendererProps {
  resource: UIResource;
  onUIAction?: (action: UIAction) => Promise<void>;
  iframeRef?: React.RefObject<HTMLIFrameElement>; // 추가 필요
}
```

**파일**: `src/types/mcp.ts`

```tsx
// 다운로드 완료 메시지 타입 정의
interface DownloadCompleteMessage {
  type: 'download_complete';
  success: boolean;
  result?: any;
  error?: string;
}

// postMessage 이벤트 데이터 타입 확장
type MCPUIMessage = UIAction | DownloadCompleteMessage;
```

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
// HTML 템플릿 생성 함수 개선
impl WorkspaceServer {
    /// 보안이 강화된 HTML UIResource 생성
    fn create_secure_html_export_ui(
        &self,
        title: &str,
        files: &[String],
        export_type: &str,
        download_path: &str,
    ) -> String {
        // CSP 헤더 추가
        // 메시지 출처 검증 로직 포함
        // timeout 처리 개선
    }
}
```

이 계획을 통해 MCP UI의 다운로드 완료 이벤트 처리를 표준에 맞게 수정하고, iframe과 parent 간의 안정적인 통신을 보장하여 timeout 오류를 완전히 해결할 수 있습니다.
