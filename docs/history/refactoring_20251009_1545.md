# Message Persistence → Backend SQLite (Development-mode)

**작성일**: 2025-10-09 15:45  
**작업자**: AI Agent  
**관련 이슈**: 메시지 저장소를 frontend(IndexedDB)에서 backend(SQLite)로 전환 (개발 모드, 마이그레이션 없음)

## 작업의 목적

- 개발 모드에서 메시지 저장을 일관된 로컬 백엔드(SQLite)에 두어 서버/백엔드 로직과 동일한 환경에서 개발 및 디버그를 진행할 수 있게 합니다.
- IndexedDB 기반의 프론트엔드 저장소를 운영/동기화하는 추가 복잡성을 제거합니다(마이그레이션 미실시).

## 현재의 상태 / 문제점

- 현재 메시지 저장/조회는 프론트엔드 IndexedDB(Dexie)에서 수행됩니다 (`src/lib/db/crud.ts`, `SessionHistoryContext.tsx`).
- 프런트엔드에서만 저장되면 백엔드 테스트 시 데이터 일관성/재현성이 낮고, 서버 쪽 테스트가 어렵습니다.
- 메시지 성능/페이징, 백엔드 쿼리 최적화 및 보안/권한 모델을 백엔드에서 테스트 불가능합니다.

## Birdeye View (동작 흐름)

기존(간단):

```text
UI -> SessionHistoryContext -> dbService.messages (IndexedDB)
```

변경(개발 모드):

```text
UI -> SessionHistoryContext (mutate optimistic) -> safeInvoke -> Tauri command -> Rust backend -> sqlite (local)
```

핵심 포인트: 낙관적 업데이트(optimistic mutate)는 유지합니다. 실패 시 롤백 로직은 기존과 동일하게 동작합니다.

## 변경 이후의 상태 / 해결 판정 기준

성공 기준:

1. `SessionHistoryContext`와 기존 UI는 변경 없이 메시지 작성/삭제/수정이 동작한다. (API 변경은 내부적인 호출 대상 변경)
2. `cargo build` 성공 및 Tauri 명령이 정상적으로 호출되어 메시지가 SQLite에 영속화된다.
3. 페이지네이션(페이징) 지원: `messages_get_page(sessionId, page, pageSize)` 명령이 `Page<Message>` 형태로 정확한 메타(총 건수, hasNext, hasPrevious)를 반환한다.
4. 단위/통합 테스트 통과(즉시 작성한 테스트 기준).

## 수정이 필요한 코드 및 수정부분 (파일/심볼, 최소 변경)

Backend (Rust) — 새 파일/수정

- `src-tauri/src/models/message.rs` (없다면 생성)
  - serde Serialize/Deserialize 가능한 `Message` 타입 정의
- `src-tauri/src/db/messages.rs` (신규 또는 기존 DB 레이어에 추가)
  - `get_messages_page(pool, session_id, page, page_size) -> Page<Message>`
  - `upsert_messages(pool, messages)`
  - `upsert_message(pool, message)`
  - `delete_message(pool, message_id)`
  - `delete_all_for_session(pool, session_id)`
- `src-tauri/src/commands/messages_commands.rs` (신규)
  - Tauri commands로 노출(아래 코드 스니펫 참고)
- `src-tauri/src/commands/mod.rs` (수정)
  - `pub mod messages_commands;` 및 `pub use messages_commands::*;` 추가

Frontend (TypeScript) — 수정

- `src/lib/rust-backend-client.ts` (중요: typesafe 인터페이스)
  - 단순한 raw `safeInvoke` 호출을 직접내보내는 대신, 각 Tauri 명령에 대해 타입 안전한 트랜스페어런트 인터페이스를 정의합니다.
  - 제공 항목(예시):
    - `getMessagesPageForSession(sessionId: string, page: number, pageSize: number): Promise<Page<Message>>`
    - `upsertMessages(messages: Message[]): Promise<void>` / `upsertMessage(message: Message): Promise<void>`
    - `deleteMessage(messageId: string): Promise<void>` / `deleteAllMessagesForSession(sessionId: string): Promise<void>`
  - 이 함수들은 내부적으로 `safeInvoke()`를 사용하지만, 호출부는 문자열 명령 이름이나 untyped payload를 직접 다루지 않습니다.
  - 장점: 컴파일 타임 타입 검사, 자동완성, 변경 영향 범위 축소, 테스트 용이성
  - 구현 옵션:
    1. 수동 작성: 각 함수에 명확한 시그니처를 제공하는 wrapper를 수동으로 추가
    2. 코드 생성: Rust 타입(serde)로부터 TS 타입 선언(.d.ts)과 wrapper를 자동 생성하는 스크립트(선택)

- `src/context/SessionHistoryContext.tsx`
  - SWR fetcher: `dbUtils.getMessagesPageForSession` -> `backend.getMessagesPageForSession`
  - persistence 호출: `dbService.messages.*` -> `backend` 호출
  - 낙관적 업데이트(mutate) 로직은 동일하게 유지
- `src/lib/db/crud.ts` (선택)
  - `messagesCRUD`를 직접 바꾸거나 `backendMessagesCRUD`를 추가하여 `dbService`에서 사용하도록 전환(개발 모드 편의)

## 핵심 코드 스니펫

1. SQL (DB 초기화에 추가)

```sql
CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  role TEXT,
  content TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  metadata TEXT
);
CREATE INDEX IF NOT EXISTS idx_messages_session_created ON messages(session_id, created_at);
```

### Rust: `Message` 타입

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
  pub id: String,
  pub session_id: String,
  pub role: Option<String>,
  pub content: Option<String>,
  pub created_at: i64,
  pub updated_at: i64,
  pub metadata: Option<serde_json::Value>,
}
```

### Rust: `Page<T>` 타입 (공통)

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Page<T> {
  pub items: Vec<T>,
  pub page: usize,
  pub page_size: isize,
  pub total_items: usize,
  pub has_next_page: bool,
  pub has_previous_page: bool,
}
```

### Rust: paginated query (sqlx 예시)

```rust
pub async fn get_messages_page(
  pool: &SqlitePool,
  session_id: &str,
  page: usize,
  page_size: usize,
) -> Result<Page<Message>, anyhow::Error> {
  if page_size == 0 { anyhow::bail!("page_size must be > 0"); }
  let offset = (page.saturating_sub(1)) as i64 * page_size as i64;

  let total: i64 = sqlx::query_scalar!("SELECT COUNT(1) FROM messages WHERE session_id = ?", session_id)
    .fetch_one(pool)
    .await?;

  let rows: Vec<Message> = sqlx::query_as!(
    Message,
    "SELECT id, session_id, role, content, created_at as \"created_at: i64\", updated_at as \"updated_at: i64\", metadata
     FROM messages WHERE session_id = ?
     ORDER BY created_at ASC
     LIMIT ? OFFSET ?",
    session_id,
    page_size as i64,
    offset
  )
  .fetch_all(pool)
  .await?;

  let total_usize = total as usize;
  let has_prev = page > 1;
  let has_next = page * page_size < total_usize;

  Ok(Page {
    items: rows,
    page,
    page_size: page_size as isize,
    total_items: total_usize,
    has_next_page: has_next,
    has_previous_page: has_prev,
  })
}
```

5. Rust: Tauri commands (`src-tauri/src/commands/messages_commands.rs`)

```rust
use tauri::command;
use crate::db::messages as messages_db;
use crate::models::Message;

#[command]
async fn messages_get_page(session_id: String, page: u32, page_size: u32) -> Result<Page<Message>, String> {
  let pool = get_sqlite_pool();
  messages_db::get_messages_page(&pool, &session_id, page as usize, page_size as usize)
    .await
    .map_err(|e| e.to_string())
}

#[command]
async fn messages_upsert_many(messages: Vec<Message>) -> Result<(), String> {
  let pool = get_sqlite_pool();
  messages_db::upsert_messages(&pool, messages).await.map_err(|e| e.to_string())
}

#[command]
async fn messages_upsert(message: Message) -> Result<(), String> {
  let pool = get_sqlite_pool();
  messages_db::upsert_message(&pool, message).await.map_err(|e| e.to_string())
}

#[command]
async fn messages_delete(message_id: String) -> Result<(), String> {
  let pool = get_sqlite_pool();
  messages_db::delete_message(&pool, &message_id).await.map_err(|e| e.to_string())
}

#[command]
async fn messages_delete_all_for_session(session_id: String) -> Result<(), String> {
  let pool = get_sqlite_pool();
  messages_db::delete_all_for_session(&pool, &session_id).await.map_err(|e| e.to_string())
}
```

6. Frontend: `rust-backend-client.ts` wrappers

```ts
export async function getMessagesPageForSession(
  sessionId: string,
  page: number,
  pageSize: number,
) {
  return safeInvoke<Page<Message>>('messages_get_page', {
    sessionId,
    page,
    pageSize,
  });
}

export async function upsertMessages(messages: Message[]) {
  return safeInvoke<void>('messages_upsert_many', { messages });
}

export async function upsertMessage(message: Message) {
  return safeInvoke<void>('messages_upsert', { message });
}

export async function deleteMessage(messageId: string) {
  return safeInvoke<void>('messages_delete', { messageId });
}

export async function deleteAllMessagesForSession(sessionId: string) {
  return safeInvoke<void>('messages_delete_all_for_session', { sessionId });
}
```

7. Frontend: `SessionHistoryContext.tsx` 변경 요약

- SWR fetcher 변경: `dbUtils.getMessagesPageForSession(sessionId, page, PAGE_SIZE)` -> `backend.getMessagesPageForSession(sessionId, page, PAGE_SIZE)`
- 저장/삭제 호출 변경: `dbService.messages.*` -> `backend.*` (위 wrapper 호출)
- 낙관적 업데이트(mutative) 로직은 유지 (revalidate: false, 실패 시 rollback)

## 재사용 가능한 연관 코드

- `src/context/SessionHistoryContext.tsx`: 페이징, 낙관적 업데이트 로직(수정 없음)
- `src/lib/db/crud.ts`: 기존 messages CRUD가 IndexedDB용으로 정의되어 있음(교체 또는 대체 wrapper 사용)
- `src-tauri/src/db/storage.rs` 또는 유사 DB 초기화 코드: sqlite pool 초기화 및 마이그레이션 로직에 messages 테이블 추가

## Test Code 추가 및 수정 가이드

### Rust 단위/통합 테스트

- `get_messages_page`: 빈 세션, 첫 페이지, 마지막 페이지, 페이지 초과 케이스
- `upsert_messages`: 중복 id, 트랜잭션 롤백 시나리오
- `delete_all_for_session`: 트랜잭션 무결성

### Frontend 테스트 (Vitest/Jest)

- `SessionHistoryContext`의 optimistic mutate: 성공시 유지, 실패시 rollback
- SWR 페이징 종료 조건: `hasNextPage`가 false일 때 더 이상 fetch하지 않음

## 위험 요소 및 대응 방안

| 위험                           | 영향도 | 대응                                                     |
| ------------------------------ | -----: | -------------------------------------------------------- |
| 타입 불일치(serde vs TS)       |   높음 | Message 타입 사전 동기화, 작은 스펙(primitive 타입) 유지 |
| 동시성 충돌                    |   중간 | updated_at 기준 last-writer-wins, DB 트랜잭션 사용       |
| UI/서버 간 페이징 방향 불일치  |   중간 | ORDER BY(ASC/DESC) 규칙 정하고 프런트/백엔드 동기화      |
| 빌드/명령 노출 실수 (`mod.rs`) |   낮음 | 변경 전 `mod.rs` 상태 확인 후 최소 변경으로 병합         |

## 예상 작업 시간 (개발 모드, 대략)

- Backend (DB 레이어 + commands + tests): 2–3시간
- Frontend (wrappers + SessionHistoryContext 변경 + tests): 1–2시간
- Smoke & validation: 0.5–1시간
- 총합: 3.5–6시간

## 파일 규칙

- 본 문서는 `docs/history/refactoring_20251009_1545.md`에 기록했습니다. 제출 시 동일한 규칙(`refactoring_{yyyyMMdd_hhmm}.md`)을 따라 주세요.

## 다음 단계 (권장 순서)

1. `src-tauri/src/models/message.rs` 및 DB 테이블 생성 코드 추가(파일 작성).
2. `src-tauri/src/db/messages.rs`의 DB 함수 구현 및 유닛 테스트 추가.
3. `src-tauri/src/commands/messages_commands.rs`에 Tauri 명령을 추가.
4. `src-tauri/src/commands/mod.rs`에 모듈 노출(주의: 현재 되돌린 상태였으니 파일 확인 후 적용).
5. `src/lib/rust-backend-client.ts`에 wrapper 추가.
6. `SessionHistoryContext.tsx`에서 fetcher/persistence 라우팅 변경.
7. 로컬 개발에서 빌드/작동 확인, 프론트엔드 자동화 테스트 실행.

---

필요하면 제가 이 순서대로 바로 코드를 생성/수정해 드릴게요 — 먼저 어떤 파일부터 만들까요? (추천: 백엔드 `messages_commands.rs` + DB 레이어 먼저.)
