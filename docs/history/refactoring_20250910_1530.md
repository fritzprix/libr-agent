# MCP 도구 응답 형식 통일 리팩토링 계획

## 작업의 목적

SynapticFlow의 MCP(Model Context Protocol) 도구 시스템에서 모든 도구가 일관된 `MCPResponse` 형식을 직접 반환하도록 통일하여, 중간 변환 과정을 최소화하고 시스템의 성능과 유지보수성을 향상시킵니다.

## 현재의 상태 / 문제점

### 1. 불일치한 응답 처리 방식

현재 4개의 도구 소스가 각각 다른 응답 처리 방식을 사용하고 있습니다:

- **MCPServerContext** (ExternalMCP): 정규화 없이 MCPResponse 직접 반환 ✅
- **WebMCPToolProvider** (BuiltInWeb): 정규화 없이 MCPResponse 직접 반환 ✅
- **RustMCPToolProvider** (BuiltInRust): `normalizeToolResult()` 사용하여 방어적 정규화 ❌
- **BrowserToolProvider**: `LocalMCPTool` (deprecated) 사용, 커스텀 변환 로직 ❌

### 2. 중복된 정규화 과정

`normalizeToolResult` 함수가 16곳에서 사용되어 불필요한 중간 변환을 수행:

- RustMCPToolProvider: 1곳
- planning-server.ts: 8곳
- content-store/server.ts: 5곳
- mcp-types.ts: 2곳 (함수 정의 + 테스트)

### 3. 타입 일관성 문제

브라우저 도구만 deprecated된 `LocalMCPTool` 타입을 사용하여 `Promise<unknown>` 반환:

```typescript
// 문제 있는 현재 타입
export type LocalMCPTool = MCPTool & {
  execute: (args: Record<string, unknown>) => Promise<unknown>;
};
```

### 4. 성능 및 복잡성 이슈

- 불필요한 JSON 파싱/생성 과정
- 복잡한 에러 감지 로직의 중복 적용
- 메모리 사용량 증가

## 추가 분석 과제

### 1. Rust 백엔드 응답 형식 검증

**Rust MCPResponse 생성 플로우 분석 완료:**

```rust
// 1. Tauri Command (src-tauri/src/lib.rs)
#[tauri::command]
async fn call_builtin_tool() -> mcp::MCPResponse

// 2. MCP Server Manager (src-tauri/src/mcp/server.rs)
pub async fn call_builtin_tool() -> MCPResponse

// 3. Builtin Registry (src-tauri/src/mcp/builtin/mod.rs)
pub async fn call_tool() -> MCPResponse

// 4. 구체적 서버 구현 (src-tauri/src/mcp/builtin/workspace/mod.rs)
async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse

// 5. 응답 생성 헬퍼 (src-tauri/src/mcp/builtin/workspace/utils.rs)
pub fn create_success_response(request_id: Value, message: &str) -> MCPResponse {
    MCPResponse::success(
        request_id,
        json!({
            "content": [{
                "type": "text",
                "text": message
            }]
        }),
    )
}
```

**검증 결과:** ✅ Rust 백엔드는 이미 올바른 MCPResponse 형식을 반환하고 있음

- MCPResponse 구조체 정의: `src-tauri/src/mcp/types.rs`
- 표준 content 배열 형식 사용
- JSON-RPC 2.0 준수 (`jsonrpc: "2.0"`)
- 일관된 에러 처리 (`MCPError` 구조체)

### 2. 웹 MCP 서버의 에러 처리 패턴 분석

- planning-server와 content-store에서 사용하는 에러 처리 패턴 파악
- 복잡한 에러 케이스(JSON 내부 에러, 중첩 구조) 처리 방식 정의

### 3. 브라우저 도구의 executeScript 의존성 분석

- `BrowserLocalMCPTool`에서 `executeScript` 파라미터가 필요한 도구들 식별
- 새로운 타입 시스템에서 이를 어떻게 처리할지 결정

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **타입 일관성**: 모든 도구가 `StrictLocalMCPTool` 또는 `WebMCPServer.callTool` 패턴 사용
2. **응답 형식 통일**: 모든 도구가 직접 `MCPResponse` 반환
3. **성능 향상**: `normalizeToolResult` 함수 완전 제거
4. **코드 간소화**: 중간 변환 로직 제거로 코드 복잡성 감소

### 검증 방법

- 모든 도구 실행 시 올바른 MCPResponse 형식 반환 확인
- 타입스크립트 컴파일 에러 없음
- 기존 기능 동작 테스트 통과
- 에러 케이스에서도 올바른 MCPError 형식 반환

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### Phase 0: 헬퍼 함수 추가

**파일**: `src/lib/mcp-response-utils.ts`

```typescript
// 추가 필요한 헬퍼 함수들
export function createMCPErrorResponse(
  message: string,
  code: number = -32603,
  id?: string | number | null,
): MCPResponse {
  return {
    jsonrpc: '2.0',
    id: id ?? createId(),
    error: { code, message },
  };
}

export function createMCPEmptyResponse(
  id?: string | number | null,
): MCPResponse {
  return {
    jsonrpc: '2.0',
    id: id ?? createId(),
    result: { content: [] },
  };
}
```

### Phase 1: 브라우저 도구 타입 통일

**파일**: `src/features/tools/browser-tools/CloseSessionTool.ts`

```typescript
// Before
import { LocalMCPTool } from './types';

export const closeSessionTool: LocalMCPTool = {
  execute: async (args: Record<string, unknown>) => {
    const { sessionId } = args as { sessionId: string };
    await closeBrowserSession(sessionId);
    return `Browser session closed: ${sessionId}`;
  },
};

// After
import { StrictLocalMCPTool } from './types';
import { createMCPTextResponse } from '@/lib/mcp-response-utils';

export const closeSessionTool: StrictLocalMCPTool = {
  execute: async (args: Record<string, unknown>) => {
    const { sessionId } = args as { sessionId: string };
    await closeBrowserSession(sessionId);
    return createMCPTextResponse(`Browser session closed: ${sessionId}`);
  },
};
```

### Phase 2: 웹 MCP 서버 정규화 제거

**파일**: `src/lib/web-mcp/modules/planning-server.ts`

```typescript
// Before
import { normalizeToolResult } from '@/lib/mcp-types';

case 'create_goal': {
  const result = state.createGoal(typedArgs.goal as string);
  return normalizeToolResult(`Goal created: "${result}"`, 'create_goal');
}

// After
import { createMCPTextResponse } from '@/lib/mcp-response-utils';

case 'create_goal': {
  const result = state.createGoal(typedArgs.goal as string);
  return createMCPTextResponse(`Goal created: "${result}"`);
}
```

### Phase 3: RustMCPToolProvider 정리

**파일**: `src/features/tools/RustMCPToolProvider.tsx`

**분석 결과:** Rust 백엔드는 이미 올바른 MCPResponse 형식을 반환하므로 `normalizeToolResult` 호출이 불필요함

```typescript
// Before
import { normalizeToolResult } from '@/lib/mcp-types';

executeTool: async (toolCall) => {
  const rawResult: MCPResponse = await callBuiltinTool(
    serviceId,
    toolName,
    args,
  );
  return normalizeToolResult(rawResult, toolName); // 불필요한 정규화
};

// After
executeTool: async (toolCall) => {
  const rawResult: MCPResponse = await callBuiltinTool(
    serviceId,
    toolName,
    args,
  );
  return rawResult; // Rust backend already returns proper MCPResponse
};
```

### Phase 4: normalizeToolResult 함수 제거

**파일**: `src/lib/mcp-types.ts`

```typescript
// 제거할 함수
export function normalizeToolResult(
  result: unknown,
  toolName: string,
  deterministicId?: string,
): MCPResponse {
  // 전체 함수 제거
}

// 제거할 테스트 함수
export function testErrorDetection(): void {
  // 전체 함수 제거
}
```

## 재사용 가능한 연관 코드

### 핵심 타입 정의

**파일**: `src/features/tools/browser-tools/types.ts`

```typescript
// 권장 타입 (이미 정의됨)
export type StrictLocalMCPTool = MCPTool & {
  execute: (args: Record<string, unknown>) => Promise<MCPResponse>;
};

// 브라우저 특화 타입 (executeScript 필요 시)
export type BrowserLocalMCPTool = MCPTool & {
  execute: BrowserToolExecuteFunction;
};
```

### 응답 생성 헬퍼 함수들

**파일**: `src/lib/mcp-response-utils.ts`

```typescript
// 기존 사용 가능한 헬퍼들
export function createMCPTextResponse(
  text: string,
  id?: string | number | null,
): MCPResponse;
export function createMCPStructuredResponse(
  text: string,
  structuredContent: Record<string, unknown>,
  id?: string | number | null,
): MCPResponse;
export function isMCPResponse(obj: unknown): obj is MCPResponse;
```

### 웹 MCP 서버 인터페이스

**파일**: `src/lib/mcp-types.ts`

```typescript
// 표준 웹 MCP 서버 패턴
export interface WebMCPServer {
  name: string;
  description?: string;
  version?: string;
  tools: MCPTool[];
  callTool: (name: string, args: unknown) => Promise<MCPResponse>;
  getServiceContext?: () => Promise<string>;
}
```

### 통합 도구 실행 인터페이스

**파일**: `src/features/tools/index.tsx`

```typescript
// 내장 서비스 인터페이스
export interface BuiltInService {
  listTools: () => MCPTool[];
  executeTool: (toolCall: ToolCall) => Promise<MCPResponse>;
  loadService?: () => Promise<void>;
  unloadService?: () => Promise<void>;
  getServiceContext?: (options?: ServiceContextOptions) => Promise<string>;
}
```

## 구현 순서 및 주의사항

### 1. 단계별 구현

- Phase 0 → Phase 1 → Phase 2 → Phase 3 → Phase 4 순서로 진행
- 각 단계 완료 후 기능 테스트 수행

### 2. 에러 처리 주의사항

- 기존 `normalizeToolResult`의 스마트한 에러 감지 로직 분석
- 각 도구에서 명시적 에러 처리 구현
- JSON 내부 에러, 중첩 구조 에러 등 복잡한 케이스 고려

### 3. 하위 호환성

- 기존 API 동작 방식 유지
- UI에서 기대하는 응답 형식 확인
- 점진적 마이그레이션으로 위험 최소화

### 4. 성능 검증

- 중간 변환 과정 제거로 인한 성능 향상 측정
- 메모리 사용량 변화 모니터링
- 에러 처리 성능 영향 확인

이 리팩토링을 통해 MCP 도구 시스템의 일관성, 성능, 유지보수성이 크게 향상될 것으로 예상됩니다.
