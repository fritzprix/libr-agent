# Session-Based File Persistence Refactoring Plan

## 작업의 목적

SynapticFlow 애플리케이션에서 **session-based file persistence**를 구현하여, 사용자가 세션을 전환하거나 재접속해도 각 세션의 파일들이 영속적으로 유지되고 세션 간 격리되도록 한다.

### 핵심 요구사항

- 세션별 독립적인 파일 작업공간 제공
- 파일의 영속성 보장 (세션 재접속 시에도 파일 유지)
- 크로스플랫폼 표준 디렉토리 사용
- 기존 MCP 서버 API 호환성 유지

## 현재의 상태 / 문제점

### 1. 임시 디렉토리 사용으로 인한 파일 손실

```rust
// src-tauri/src/mcp/builtin/utils.rs - SecurityValidator::new()
let tmp = std::env::temp_dir().join("synaptic-flow");
```

- 시스템 임시 디렉토리 사용으로 파일 영속성 부족
- 세션 재시작 시 파일 소실 가능

### 2. 세션 격리 부족

- 모든 세션이 동일한 작업공간 공유
- 다른 세션의 파일에 의도치 않은 접근 가능
- 세션별 파일 관리 불가능

### 3. 플랫폼별 하드코딩된 경로

```rust
// src-tauri/src/lib.rs - get_app_logs_dir()
#[cfg(target_os = "windows")]
let log_dir = {
    let local_appdata = env::var("LOCALAPPDATA")...
};
```

- 로그 디렉토리도 플랫폼별로 하드코딩됨
- dirs crate 표준 사용 필요

### 4. Frontend-Backend 세션 동기화 부족

- SessionContext에서 세션 변경 시 백엔드에 알림 없음
- MCP 서버들이 현재 활성 세션을 인식하지 못함

## 추가 분석 과제

1. **Migration Strategy**: 기존 임시 디렉토리의 데이터를 새로운 구조로 어떻게 이전할 것인가?
2. **Error Handling**: dirs::data_dir() 실패 시 fallback 전략
3. **Performance Impact**: 세션별 디렉토리 생성/관리의 성능 영향 분석
4. **Clean-up Policy**: 오래된 세션 디렉토리 정리 정책 필요성

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. ✅ 세션별 독립적인 파일 작업공간 생성
2. ✅ 세션 재접속 시 이전 파일들이 그대로 유지됨
3. ✅ filesystem.rs와 sandbox.rs가 세션별 디렉토리 사용
4. ✅ 크로스플랫폼 표준 디렉토리 구조 적용
5. ✅ 기존 MCP tool API 호환성 유지

### 목표 디렉토리 구조

```text
{dirs::data_dir()}/com.synaptic-flow.app/
├── workspaces/
│   ├── {session-id-1}/     # 세션별 모든 파일
│   ├── {session-id-2}/
│   └── default/           # fallback workspace
├── logs/                  # 앱 전체 로그
└── config/               # 앱 설정
```

### 검증 방법

- 세션 A에서 파일 생성 → 세션 B로 전환 → 세션 A로 복귀 시 파일 존재 확인
- sandbox 실행 결과 파일이 세션 재접속 후에도 유지되는지 확인
- 각 플랫폼에서 적절한 데이터 디렉토리 사용 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. SessionManager 구현 (신규)

```rust
// src-tauri/src/session.rs (신규 파일)
use std::sync::{Arc, RwLock, OnceLock};
use std::path::PathBuf;
use dirs;

static SESSION_MANAGER: OnceLock<SessionManager> = OnceLock::new();

pub struct SessionManager {
    current_session: Arc<RwLock<Option<String>>>,
}

impl SessionManager {
    pub fn new() -> Self {
        Self {
            current_session: Arc::new(RwLock::new(None)),
        }
    }

    pub fn set_session(&self, session_id: String) -> Result<(), String> {
        // 세션 디렉토리 생성 로직
    }

    pub fn get_session_workspace_dir(&self) -> PathBuf {
        // dirs::data_dir() 기반 세션 디렉토리 반환
    }
}

pub fn get_session_manager() -> &'static SessionManager {
    SESSION_MANAGER.get_or_init(SessionManager::new)
}
```

### 2. SecurityValidator 수정

```rust
// src-tauri/src/mcp/builtin/utils.rs
impl SecurityValidator {
    pub fn new() -> Self {
        let base_dir = get_session_manager().get_session_workspace_dir();
        // 기존 temp_dir 대신 세션별 디렉토리 사용
        Self { base_dir }
    }
}
```

### 3. Tauri Command 추가

```rust
// src-tauri/src/lib.rs
#[tauri::command]
async fn set_current_session(session_id: String) -> Result<(), String> {
    get_session_manager().set_session(session_id)
}

#[tauri::command]
async fn get_app_data_dir() -> Result<String, String> {
    // dirs crate 사용으로 변경
    dirs::data_dir()
        .map(|dir| dir.join("com.synaptic-flow.app"))
        .ok_or_else(|| "Failed to get data directory".to_string())
}
```

### 4. SessionContext 연동

```typescript
// src/context/SessionContext.tsx
const handleSelect = useCallback((id?: string) => {
  // 기존 로직...

  // 백엔드에 세션 변경 알림
  if (id) {
    invoke('set_current_session', { sessionId: id }).catch(logger.error);
  }
}, []);
```

### 5. Sandbox 영속성 적용

```rust
// src-tauri/src/mcp/builtin/sandbox.rs
fn determine_execution_working_dir() -> std::path::PathBuf {
    // 기존 temp_dir 로직 대신 세션 디렉토리 사용
    get_session_manager().get_session_workspace_dir()
}

// TempDir 사용하던 부분을 세션 디렉토리 사용으로 변경
async fn execute_code_in_sandbox(&self, ...) -> MCPResponse {
    let work_dir = Self::determine_execution_working_dir();
    let script_path = work_dir.join(format!("script_{}{file_extension}", Uuid::new_v4()));
    // 영속적 파일 저장
}
```

## 재사용 가능한 연관 코드

### 주요 파일 및 인터페이스

1. **`src-tauri/src/mcp/builtin/utils.rs`**
   - `SecurityValidator` 구조체: 파일 접근 보안 검증
   - `validate_path()` 메소드: 경로 유효성 검사
   - 현재 temp_dir 기반 → 세션 기반으로 변경 필요

2. **`src-tauri/src/mcp/builtin/filesystem.rs`**
   - `FilesystemServer` 구조체: 파일 시스템 MCP 서버
   - `SecureFileManager` 의존성: 보안 파일 관리
   - 6개 주요 도구: read_file, write_file, list_directory, replace_lines, grep, search_files

3. **`src-tauri/src/mcp/builtin/sandbox.rs`**
   - `SandboxServer` 구조체: 코드 실행 MCP 서버
   - 3개 실행 도구: execute_python, execute_typescript, execute_shell
   - `determine_execution_working_dir()`: 작업 디렉토리 결정 로직

4. **`src-tauri/src/services/secure_file_manager.rs`**
   - `SecureFileManager` 구조체: 보안 파일 관리 서비스
   - `SecurityValidator` 래핑하여 파일 작업 수행

5. **`src/context/SessionContext.tsx`**
   - `SessionContextType` 인터페이스: 세션 관리 타입
   - `handleSelect()`: 세션 선택 핸들러
   - `Session` 모델: 세션 데이터 구조

### 재사용 가능한 패턴

1. **전역 싱글톤 패턴**: `OnceLock`을 사용한 MCP_MANAGER와 동일한 패턴으로 SESSION_MANAGER 구현
2. **Tauri State 관리**: 기존 SecureFileManager State 패턴 참고
3. **에러 처리 패턴**: `Result<T, String>` 반환 타입으로 일관성 유지
4. **Context Provider 패턴**: 기존 SessionContext 패턴 확장

### 의존성 그래프

```text
SessionManager (신규)
    ↓
SecurityValidator (수정)
    ↓
SecureFileManager (수정)
    ↓
FilesystemServer, SandboxServer (수정)
    ↓
MCP Tool Calls (기존 API 유지)
```

## 구현 우선순위

### Phase 1: Core Infrastructure

1. SessionManager 구현
2. SecurityValidator 수정
3. Tauri command 추가

### Phase 2: Server Integration

1. FilesystemServer 연동
2. SandboxServer 연동
3. Frontend SessionContext 연동

### Phase 3: Polish & Migration

1. 기존 데이터 마이그레이션 로직
2. 에러 처리 강화
3. 크로스플랫폼 테스트

이 계획을 통해 점진적이고 안전한 refactoring을 수행하여 session-based file persistence를 달성할 수 있습니다.
