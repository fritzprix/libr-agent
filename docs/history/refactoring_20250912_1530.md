# Refactoring Plan: HTML Parser Simplification and Cheerio-based Parser Introduction

작성일: 2025-09-12 15:30

## 작업의 목적 (Objective)

- Simplify `src/lib/html-parser.ts` by removing duplicated selector generators and utilities, consolidating them into a single unique selector builder.
- Centralize input validation and attribute extraction to reduce repetition and improve maintainability.
- Keep the public API and TypeScript types stable while improving internal structure and readability.
- Introduce a Cheerio-based parsing path for server/worker contexts to support DOM-map and metadata extraction without a browser runtime.
- Preserve browser-only behavior for interactable extraction that depends on layout/visibility (getComputedStyle, getBoundingClientRect).

## 현재의 상태 / 문제점 (Current State / Problems)

- Multiple selector functions with overlapping behavior and subtle differences:
  - `generateSelector`, `generateSimpleSelector`, `generateHierarchicalSelector`, `generateElementSelectorWithIndex`, and a separate `generateUniqueSelector` used in interactable parsing.
  - Increases maintenance cost and risk of inconsistent selectors across features.
- Mixed case sensitivity assumptions:
  - Some tag checks use direct equality (e.g., `element.tagName === 'INPUT'`) while others normalize. This is OK in browsers (tagName is uppercase) but brittle across environments (e.g., JSDOM/Cheerio interop or future refactors).
- Scattered HTML input validation and error handling:
  - Similar checks appear in multiple public functions.
- Attribute extraction logic is duplicated across pipelines (basic/link/interactive attributes) and interactable parsing.
- The interactable extractor relies on visual information (computed style, geometry) that’s not available in Cheerio; attempting to “replace with Cheerio” would regress feature correctness.

## 추가 분석 과제 (Further Analysis)

- Validate selector uniqueness cost at scale:
  - Measure `querySelectorAll` counts and time for the unified builder on large DOMs.
  - Track selector length distribution; ensure we try shortest unique suffixes effectively.
- Measure output deltas:
  - Compare pre/post refactor selectors for a sample corpus; ensure functional parity (same element resolution).
- Cheerio parity checks:
  - Confirm that the Cheerio DOM-map output meets our required fields and ordering constraints (maxDepth/maxChildren/includeInteractiveOnly).

## 변경 이후의 상태 / 해결 판정 기준 (Target State / Acceptance Criteria)

- Single selector utility used everywhere (structured, dom-map, interactables) with consistent outcomes.
- No public API changes to:
  - `parseHTMLToStructured`
  - `parseHTMLToDOMMap`
  - `extractHTMLMetadata`
  - `parseHtmlToInteractables`
- TypeScript: passes strict checks (no `any` introduced); ESLint/Prettier clean.
- Build passes: `pnpm build`.
- Basic benchmarks show equal or improved performance (±10%) for DOM-map and structured parsing on representative pages.
- New Cheerio path compiles and returns valid `DOMMapResult` and `PageMetadata` for server-side contexts.

## 수정이 필요한 코드 및 수정 부분의 코드 스니핏 (Files & Key Changes)

Impacted files:

- `src/lib/html-parser.ts`
  - Replace multiple selector generators with a unified `buildUniqueSelector(element, document)`.
  - Normalize tag comparisons with `toUpperCase()` when checking membership in sets of uppercase tag names.
  - Add `validateHtmlInput(htmlString: string)` for centralized input validation.
  - Keep existing types and public function signatures intact.
  - Reuse attribute extractor manager across pipelines.

- New: `src/lib/html-parser-cheerio.ts` (server/worker optional)
  - Provide `parseHTMLToDOMMapCheerio()` implementing `DOMMapResult` using Cheerio.
  - Provide metadata helpers (`extractTitle`, `extractMetaURL`) using Cheerio.
  - Implement a Cheerio version of `buildUniqueSelector`.

Selected snippets (illustrative, not a diff):

1. Unified selector builder (browser DOM)

```ts
function isSelectorUnique(
  selector: string,
  el: Element,
  doc: Document,
): boolean {
  try {
    const list = doc.querySelectorAll(selector);
    return list.length === 1 && list[0] === el;
  } catch {
    return false;
  }
}

function safeCssEscape(value: string): string {
  // Prefer native CSS.escape if present
  // @ts-expect-error
  return typeof CSS !== 'undefined' && CSS.escape
    ? CSS.escape(value)
    : value.replace(/(["\\#.:>+~\[\]\(\)\s])/g, '\\$1');
}

export function buildUniqueSelector(element: Element, doc: Document): string {
  // 1) id
  const id = element.getAttribute('id');
  if (id) {
    const s = `#${safeCssEscape(id)}`;
    if (isSelectorUnique(s, element, doc)) return s;
  }

  // 2) data-testid
  const testId = element.getAttribute('data-testid');
  if (testId) {
    const s = `[data-testid="${safeCssEscape(testId)}"]`;
    if (isSelectorUnique(s, element, doc)) return s;
  }

  // 3) input name/type
  if (element.tagName.toLowerCase() === 'input') {
    const name = element.getAttribute('name');
    const type = element.getAttribute('type');
    if (name && type) {
      const s = `input[name="${safeCssEscape(name)}"][type="${safeCssEscape(type)}"]`;
      if (isSelectorUnique(s, element, doc)) return s;
    }
  }

  // 4) first valid class
  const className = element.getAttribute('class');
  if (className?.trim()) {
    const cls = className
      .trim()
      .split(/\s+/)
      .find((c) => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c));
    if (cls) {
      const s = `${element.tagName.toLowerCase()}.${cls}`;
      if (isSelectorUnique(s, element, doc)) return s;
    }
  }

  // 5) hierarchical nth-of-type path (shortest unique suffix)
  const parts: string[] = [];
  let node: Element | null = element;
  const limit = 8;
  while (node && node !== doc.documentElement && parts.length < limit) {
    const tag = node.tagName.toLowerCase();
    const nodeId = node.getAttribute('id');
    if (nodeId && /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(nodeId)) {
      parts.unshift(`${tag}#${nodeId}`);
      break;
    }
    const nodeClass = node.getAttribute('class');
    if (nodeClass?.trim()) {
      const cls = nodeClass
        .trim()
        .split(/\s+/)
        .find((c) => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c));
      if (cls) {
        parts.unshift(`${tag}.${cls}`);
        node = node.parentElement;
        continue;
      }
    }
    const p = node.parentElement;
    if (p) {
      const sibs = Array.from(p.children).filter(
        (s) => s.tagName === node!.tagName,
      );
      const idx = sibs.indexOf(node) + 1;
      parts.unshift(sibs.length > 1 ? `${tag}:nth-of-type(${idx})` : tag);
      node = p;
    } else {
      parts.unshift(tag);
      break;
    }
  }
  for (let i = 0; i < parts.length; i++) {
    const s = parts.slice(i).join(' > ');
    if (isSelectorUnique(s, element, doc)) return s;
  }
  return parts.join(' > ') || element.tagName.toLowerCase();
}
```

2. Centralized HTML input validation

```ts
function validateHtmlInput(html: string): string | null {
  if (!html || typeof html !== 'string') return 'Invalid HTML input';
  if (html.length === 0) return 'Invalid HTML input: empty string';
  return null;
}
```

3. Normalize tag checks

```ts
const isInteractive = INTERACTIVE_TAGS.has(element.tagName.toUpperCase());
```

4. Cheerio variant (new file)

```ts
// src/lib/html-parser-cheerio.ts
import { load, type CheerioAPI, type Element as CheerioElement } from 'cheerio';
// export function parseHTMLToDOMMapCheerio(html: string, options: DOMMapOptions = {}): DOMMapResult { /* ... */ }
```

## 재사용 가능한 연관 코드 (Related Reusable Code)

- `src/lib/logger.ts` — centralized logging (`getLogger`) used by parser modules.
- `src/lib/text-utils.ts` — `createCompactText()` used for robust text extraction.
- `src/lib/html-parser.ts` — existing public APIs and types consumed by features under `src/features/*`.
- (New) `src/lib/html-parser-cheerio.ts` — optional server/worker path for DOM-map & metadata.

## 작업 범위 & 단계 (Scope & Phases)

Phase 1 — Internal refactor (no API changes)

- Replace all usages of legacy selector helpers with `buildUniqueSelector()`.
- Add `validateHtmlInput()` and reuse it in all public functions.
- Normalize tag checks to use `toUpperCase()` where sets are uppercase.
- Deduplicate attribute extraction across pipelines via `AttributeExtractorManager`.

Phase 2 — Utilities extraction (optional)

- Move selector utilities to `src/lib/dom/selector.ts` and import in both DOM/Cheerio variants (keeping tree-shakeable exports).

Phase 3 — Cheerio parser addition (non-breaking)

- Add `src/lib/html-parser-cheerio.ts` implementing `parseHTMLToDOMMapCheerio()` and metadata helpers.
- Do NOT change `parseHtmlToInteractables`; continue using browser DOM due to visibility dependency.

Phase 4 — Tests & Validation

- Add unit tests for selector uniqueness and stability.
- Add snapshot tests for `parseHTMLToDOMMap` (DOM) vs `parseHTMLToDOMMapCheerio` (Cheerio) on the same inputs (excluding visibility fields).
- Run lint/format/build; add a basic benchmark script for selector generation.

## 해결 판정 기준 (How We’ll Verify)

- Quality gates
  - Lint: `pnpm lint` — PASS
  - Format: `pnpm format` — PASS
  - Build: `pnpm build` — PASS
  - Unit tests (new): selector uniqueness and DOM-map structure — PASS

- Functional parity
  - The public API outputs remain structurally compatible (fields and types unchanged).
  - Interactable extraction continues to respect visibility and enabled/disabled checks as before (manual smoke test on representative pages).

## 리스크 및 완화 (Risks & Mitigations)

- Risk: Selector behavior changes could break recorded automation.
  - Mitigation: Prefer shortest-unique-suffix strategy; add test corpus comparing pre/post selectors; provide a fallback to full hierarchical path if uniqueness not provable.
- Risk: Cheerio output order may differ slightly from browser DOM.
  - Mitigation: Limit to structural fields; document differences; add tests with tolerant ordering where appropriate.
- Risk: Performance regression from uniqueness checks on very large DOMs.
  - Mitigation: Cap hierarchical depth; early exits on id/testid/class; benchmark and tune `limit`.

## 롤아웃 & 롤백 전략 (Rollout / Rollback)

- Behind-the-scenes refactor in Phase 1 with no API changes.
- Introduce Cheerio variant as additive module (no default behavior change).
- If regressions found, revert to previous selector helpers (kept under git history) and disable Cheerio export without touching public API.

## 작업 체크리스트 (Execution Checklist)

- [ ] Implement `buildUniqueSelector()` and replace old helpers in `html-parser.ts`.
- [ ] Add `validateHtmlInput()` and apply across public functions.
- [ ] Normalize tag checks (`toUpperCase`) where applicable.
- [ ] Create `src/lib/html-parser-cheerio.ts` with DOM-map + metadata.
- [ ] Add unit tests for selectors and DOM-map outputs.
- [ ] Run lint/format/build and address any failures.
- [ ] Optional: extract selector utils into `src/lib/dom/selector.ts`.

## 참고 (Notes)

- Cheerio cannot replace visibility/layout-dependent logic; therefore, `parseHtmlToInteractables` remains browser-only.
- Use centralized logger (`getLogger`) and avoid `console.*` per project standards.
