---
title: 'Refactor: 메시지 BM25 인덱싱 및 검색 도입'
date: 2025-10-09
author: synaptic-flow/dev
---

# 목적

메시지 저장소를 Rust 백엔드(SQLite)로 이관한 상태에서, 메시지에 대해 BM25 기반의 검색 기능을 추가한다. 검색 결과는 반드시 해당 메시지가 속한 세션을 참조(sessionId)를 포함해야 하며, 인덱스는 점진적으로 확장(near-batch)하도록 설계한다. 프론트엔드에서는 `search_messages`(또는 `messages_search`) API만 노출한다.

요구 요약:

- 메시지 추가 시 인덱스는 즉시 재구성하지 않고 점진적으로(비실시간) 업데이트
- 검색 API 구현 및 페이지네이션 지원
- 인덱스의 디스크 퍼시스턴시(저장/로드) 지원
- 프론트엔드 클라이언트(`src/lib/rust-backend-client.ts`)는 `searchMessages` 단 하나의 호출만 제공

## 현재 상태 / 문제점

- 기존: 메시지 CRUD는 `src-tauri/src/commands/messages_commands.rs` 와 관련 DB 함수가 구현되어 있음. (Message 모델, get_page, upsert, delete 등)
- 아직: 검색 인덱스/검색 로직, 인덱스 저장/로드, 검색용 Tauri 명령이 없음.
- 프론트엔드는 `src/lib/rust-backend-client.ts`에서 메시지 CRUD wrapper를 제공함. 검색 wrapper는 미구현.

## 목표 후 상태 / 성공 판정 기준

- 백엔드에 세션 단위 BM25 인덱스 구현 및 파일 퍼시스턴시 존재
- `messages_search` Tauri 명령이 제공되며 `Page<SearchResult>`를 반환한다. `SearchResult`는 messageId와 sessionId를 포함한다.
- 메시지 업서트 후 일정 시간 내(설정가능) 인덱스에 반영되며, 대용량 세션에서도 부분/증분 재색인 전략으로 성능 저하가 적음
- 프론트엔드에서 `searchMessages`를 호출하여 정상 동작(정확성, 페이지네이션) 확인

## 관련 코드 (Birdseye view)

- `src-tauri/src/commands/messages_commands.rs` - Message 모델 및 메시지 CRUD 현재 위치. (첨부 참조)
- `src/lib/rust-backend-client.ts` - 기존 safeInvoke 기반 wrapper들. 여기서 `searchMessages`만 추가
- 새로 추가될/변경될 항목(권장):
  - `src-tauri/src/search/mod.rs` (검색/인덱스 관리)
  - `src-tauri/src/search/index_storage.rs` (인덱스 파일 입출력, atomic write)
  - `src-tauri/src/commands/messages_search.rs` (Tauri 명령/노출) 또는 기존 `messages_commands.rs`에 명령 추가
  - DB migration: `message_index_meta` 테이블 추가

## 상세 설계

### 데이터 구조

Rust side

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchResult {
  pub message_id: String,
  pub session_id: String,
  pub score: f32,
  pub snippet: Option<String>,
  pub created_at: i64,
}

// 기존의 Page<T> 타입을 재사용
```

TS side

```ts
export interface SearchResultTS {
  id: string; // messageId
  sessionId: string;
  score: number;
  snippet?: string;
  createdAt: Date;
}
```

### 인덱스 메타 테이블 (SQLite)

테이블: `message_index_meta`

```sql
CREATE TABLE IF NOT EXISTS message_index_meta (
  session_id TEXT PRIMARY KEY,
  index_path TEXT,
  last_indexed_at INTEGER DEFAULT 0,
  doc_count INTEGER DEFAULT 0
);
```

설명: 각 세션별로 인덱스 파일 경로와 마지막 인덱싱 시각을 보관한다. `last_indexed_at`은 메시지의 최신 `created_at`보다 작으면 재색인이 필요함을 의미한다.

### 인덱스 저장 포맷

- 권장: `bincode`(Rust serde)로 이진 직렬화 후 파일 저장(빠른 로드와 작은 용량)
- 저장 방식: 임시 파일에 직렬화 후 atomic rename으로 교체

### 인덱스 빌드 전략 (점진적 확장)

조합 전략: "Lazy build on demand" + "Background worker incremental rebuild"

- 메시지 upsert 시: DB에 저장만 수행. (현재 구현을 유지)
- Upsert 작업은 `message_index_meta`의 `last_indexed_at` 대비 최신 메시지가 있으면 'dirty' 상태로 남김.
- 검색 요청(`messages_search`) 시:
  - 세션 인덱스가 없거나 `dirty`이면, 작은 세션의 경우 동기적으로(요청 내) 인덱스를 빌드하고 검색 실행.
  - 큰 세션의 경우 인덱스 빌드를 백그라운드에서 실행하고, 요청에는 부분 검색(가능한 경우) 또는 "인덱스 빌드 중" 상태를 반환.
- 주기적 백그라운드 worker: dirty 세션들을 탐지하여 배치로 재색인(토큰화+인덱스 추가 또는 전체 재빌드). 이 worker는 토큰화/색인 비용을 분산한다.

대상별 고려사항

- 삭제/업데이트: tombstone 처리 대신 세션 단위 재빌드 권장(단순성)
- 동시성: 빌드 시 snapshot(쿼리 시점 메시지 목록)을 사용하고, 빌드 완료 후 atomic swap

### 인덱스 규모 제한 및 환경변수

운영 환경에서 인덱스의 최대 규모를 고정하면 메모리·성능 관리에 도움이 된다. 이 계획에서는 기본값을 **10,000**으로 제안하되, 런타임에서 쉽게 조정할 수 있도록 환경변수로 노출하도록 한다.

- 환경변수 이름: `MESSAGE_INDEX_MAX_DOCS` (정수, 기본 10000)
- 재색인 배치 크기(옵션): `REINDEX_BATCH_SIZE` (정수, 기본 1000)
- 동작: 인덱스 빌드 시 최신 N개 메시지만 포함한다(N은 `MESSAGE_INDEX_MAX_DOCS`). N을 초과하는 오래된 메시지는 hot 인덱스에서 제외된다. 필요 시 cold 인덱스 또는 전체 검색 경로를 별도로 제공한다.

장점 요약:

- 메모리 사용량과 검색 응답 시간을 안정적으로 제어할 수 있음
- 대규모 세션에서 인덱스 빌드 및 재구성 비용을 제한함

단점/주의:

- 오래된 메시지에 대한 검색 결과가 누락될 수 있음 → UI에 제한 안내 및 전체 검색 옵션 필요
- 삭제/버림 로직은 배치로 처리해야 하며, 메시지 추가마다 즉시 재빌드는 피해야 함

예: Rust에서 환경변수를 읽어 사용하는 간단한 코드 스니펫

```rust
fn max_hot_messages_from_env() -> usize {
  std::env::var("MESSAGE_INDEX_MAX_DOCS")
  .ok()
  .and_then(|s| s.parse::<usize>().ok())
  .filter(|&v| v > 0)
  .unwrap_or(10_000)
}

async fn build_hot_index(session_id: &str) -> Result<BM25Index, String> {
  let max_docs = max_hot_messages_from_env();
  let messages = sqlx::query("SELECT * FROM messages WHERE session_id = ? ORDER BY created_at DESC LIMIT ?")
    .bind(session_id)
    .bind(max_docs as i64)
    .fetch_all(pool)
    .await
    .map_err(|e| format!("db error: {e}"))?;

  // 오래된 것부터 추가하려면 반전
  let docs: Vec<_> = messages.into_iter().rev().map(|m| (m.id, tokenize(&m.content))).collect();
  let index = BM25Index::new(docs);
  Ok(index)
}
```

### 검색 API (Tauri command)

명령 이름: `messages_search`

시그니처(Rust):

```rust
#[command]
pub async fn messages_search(
  query: String,
  session_id: Option<String>,
  page: usize,
  page_size: usize,
) -> Result<Page<SearchResult>, String> { ... }
```

동작 요약:

- 요청 들어오면 세션별 인덱스 로드(메모리 캐시 우선)
- 인덱스가 없거나 dirty이면 동기/비동기 빌드 전략을 적용
- bm25로 쿼리 실행 -> (message_id, score) 리스트 획득
- 필요한 메타(생성시간, session_id) 조회 후 `Page<SearchResult>` 반환

### 프론트엔드 노출

파일: `src/lib/rust-backend-client.ts`

추가 함수(한 개만):

```ts
export async function searchMessages(
  query: string,
  sessionId?: string,
  page = 1,
  pageSize = 25,
): Promise<Page<SearchResultTS>> { ... }
```

요청 파라미터: { query, sessionId?, page, pageSize }

주의: 프론트엔드에는 이 함수만 추가한다(사용자 요구).

## 수정해야 할 파일 목록 (구체적)

- Add: `src-tauri/src/search/mod.rs` (검색 엔진 래퍼, index manager)
- Add: `src-tauri/src/search/index_storage.rs` (파일 IO 및 atomic write)
- Update: `src-tauri/src/commands/messages_commands.rs` or add `src-tauri/src/commands/messages_search.rs` (Tauri command 노출)
- Update: `src-tauri/src/main.rs` (앱 시작 시 인덱스 디렉터리 생성/백그라운드 worker 시작)
- Update: `src-tauri/Cargo.toml` (bm25 crate, bincode, optionally parking_lot or dashmap for in-memory cache)
- Update: `src/lib/rust-backend-client.ts` (add `searchMessages` wrapper)

## 코드 스니펫(참고)

Rust: 메시지 검색 명령(핵심 골격)

```rust
#[command]
pub async fn messages_search(
  query: String,
  session_id: Option<String>,
  page: usize,
  page_size: usize,
) -> Result<Page<SearchResult>, String> {
  // 1. ensure index loaded or build
  // 2. run bm25 search
  // 3. for results, query messages table for created_at (and session_id)
  // 4. create Page<SearchResult> and return
}
```

TS: client wrapper

```ts
export async function searchMessages(
  query,
  sessionId?,
  page = 1,
  pageSize = 25,
) {
  const res = await safeInvoke<Page<Record<string, unknown>>>(
    'messages_search',
    { query, sessionId, page, pageSize },
  );
  return {
    ...res,
    items: res.items.map((r) => ({
      id: r.messageId,
      sessionId: r.sessionId,
      score: r.score,
      snippet: r.snippet,
      createdAt: new Date(r.createdAt),
    })),
  };
}
```

## 테스트 계획

Rust 단위 테스트

- 인덱스 빌드 테스트: 주어진 메시지 집합으로 빌드 시 doc_count 일치
- 검색 정확도 테스트: 키워드를 포함한 메시지에서 높은 점수 부여
- persistence test: build -> store file -> load -> search

통합 테스트

- messages_upsert -> mark dirty -> reindex background -> messages_search에 반영

프론트엔드

- `searchMessages` wrapper 직렬화/역직렬화 검증

명령

```bash
# run rust tests
cd src-tauri && cargo test

# run frontend tests
pnpm test
```

## 롤아웃 계획 및 운영 고려

1. 개발 모드에서 먼저 활성화: 소규모 세션으로 동작 확인
2. 모니터링: 인덱스 빌드 시간, 검색 응답시간, doc_count, 오류율
3. 점진 롤아웃: config 플래그로 켜고 사용자에게 인덱싱 상태 노출
4. 인덱스 재구성이나 대량 업서트의 경우 사전 알림 및 백업(인덱스 파일 + SQLite DB) 권장

## 위험과 완화

- 대량 세션 재빌드 비용: 백그라운드 배치/샤딩으로 완화
- 토크나이저 다국어 문제: 한국어 등에서는 별도 토크나이저(형태소분석기) 도입 검토
- 인덱스 일관성 이슈: 빌드 시 snapshot 사용 및 atomic swap으로 해결

## 작업 우선순위 및 단계별 체크리스트

1. (핵심) `Cargo.toml`에 `bm25` 및 직렬화 의존성 추가
2. `message_index_meta` 테이블 생성 코드 추가 (existing create function 확장)
3. `src-tauri/src/search` 디렉터리와 `mod.rs` 생성: 인덱스 빌드 / load / store / search 구현
4. Tauri 명령 `messages_search` 구현 및 `src/lib/rust-backend-client.ts`에 `searchMessages` 추가
5. Rust 단위/통합 테스트 추가
6. 백그라운드 incremental reindex worker 추가 (옵션)
7. 문서/모니터링/롤아웃

## 참고 (도구, 버전)

- bm25 crate: 권장 v2.3.2 (기능: tokenizer, scorer, serializing 지원 여부 확인)
- 직렬화: `bincode + serde`
