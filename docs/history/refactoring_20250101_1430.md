# Refactoring Plan: Assistant별 Built-in 도구 활성화/비활성화 기능 구현

**작성일**: 2025-01-01 14:30  
**담당자**: AI Agent  
**관련 이슈**: Assistant별 Built-in Tool 토글 기능

---

## 1. 작업의 목적

AssistantEditor UI에서 Assistant 생성/편집 시 Built-in 도구(Browser Tools, Rust MCP Tools, Web MCP Tools)를 개별적으로 활성화/비활성화할 수 있는 토글 기능을 추가하여, 각 Assistant의 역할과 권한에 맞게 도구 접근을 제어할 수 있도록 한다.

### 주요 목표

1. **세밀한 권한 제어**: Assistant별로 필요한 도구만 선택적으로 활성화
2. **보안 강화**: 불필요한 도구 접근 차단 (예: 파일시스템, 브라우저 자동화)
3. **사용자 경험 개선**: 직관적인 토글 UI로 쉽게 도구 활성화/비활성화
4. **역할 기반 Agent 구성**: 특정 역할(예: 코드 리뷰어, 웹 스크래퍼)에 맞는 도구 세트 구성

---

## 2. 현재 상태 / 문제점

### 2.1 현재 Built-in 도구 통합 구조

**전역 도구 제공 방식**:

- 모든 Built-in 도구가 `BuiltInToolProvider`를 통해 전역적으로 관리됨
- Assistant와 관계없이 모든 도구가 동일하게 노출됨
- 도구 필터링이나 권한 제어 메커니즘이 없음

**도구 등록 흐름**:

```
App.tsx
  └─ BuiltInToolProvider
       ├─ BrowserToolProvider (등록: 'browser' 서비스)
       ├─ RustMCPToolProvider (등록: 'content_store', 'workspace' 등)
       └─ WebMCPServiceRegistry (등록: 'planning', 'playbook' 등)
```

**도구 이름 규칙**:

- 모든 Built-in 도구는 `builtin_<alias>__<toolname>` 형식
- `<alias>`는 `toValidJsName(serviceId)`로 생성 (예: `browser`, `content_store`, `workspace`)

### 2.2 문제점

1. **권한 제어 부재**: 모든 Assistant가 동일한 도구에 접근 가능
2. **보안 리스크**: 파일 시스템 접근, 브라우저 자동화 등 민감한 도구를 모든 Assistant가 사용 가능
3. **역할 구분 불가**: Assistant의 역할(예: 코드 분석 vs 웹 스크래핑)에 따른 도구 제한 불가
4. **UI 설정 부재**: 사용자가 Assistant 생성 시 도구를 선택할 수 있는 UI가 없음

### 2.3 관련 코드 구조 Summary (Birdeye View)

#### A. 데이터 모델 (`src/models/chat.ts`)

```typescript
export interface Assistant {
  id?: string;
  name: string;
  description?: string;
  systemPrompt: string;
  mcpConfig: MCPConfig;
  localServices?: string[]; // 현재 사용되지 않음 (legacy)
  isDefault: boolean;
  createdAt: Date;
  updatedAt: Date;
  // ❌ Built-in 도구 제어 필드 없음
}
```

#### B. 도구 통합 레이어 (`src/features/tools/index.tsx`)

**BuiltInToolProvider**:

- 전역 Built-in 도구 관리
- 서비스 등록: `register(serviceId, service)`
- 도구 목록 제공: `availableTools: MCPTool[]`
- 필터링 로직 없음

**주요 함수**:

```typescript
const availableTools: MCPTool[] = useMemo(() => {
  const tools: MCPTool[] = [];
  for (const [serviceId, entry] of serviceEntries.entries()) {
    if (entry.status === 'ready') {
      const alias = toValidJsName(serviceId);
      tools.push(
        ...entry.service.listTools().map((t) => ({
          ...t,
          name: `${BUILTIN_PREFIX}${alias}__${t.name}`,
        })),
      );
    }
  }
  return tools; // ❌ 모든 도구 반환 (필터링 없음)
}, [serviceEntries]);
```

#### C. 도구 사용 지점 (`src/context/ChatContext.tsx`)

```typescript
const aiServiceConfig = useMemo(
  (): AIServiceConfig => ({
    tools: [...availableTools, ...builtInTools], // ❌ Assistant와 무관하게 모든 도구 포함
    maxRetries: 3,
    maxTokens: 4096,
  }),
  [availableTools, builtInTools],
);
```

#### D. UI 레이어 (`src/features/assistant/AssistantEditor.tsx`)

현재 구조:

- 이름, 시스템 프롬프트, MCP Config 편집 가능
- Built-in 도구 선택 UI 없음
- `LocalServicesEditor`는 빈 컴포넌트 (기능 제거됨)

---

## 3. 변경 이후 상태 / 해결 판정 기준

### 3.1 변경 후 목표 상태

1. **데이터 모델**: `Assistant` 타입에 `allowedBuiltInServiceAliases` 필드 추가
2. **도구 필터링**: `ChatContext`에서 Assistant의 허용 목록에 따라 도구 필터링
3. **UI 제공**: `AssistantEditor`에 Built-in 도구 토글 UI 추가
4. **기본값 처리**: 신규 Assistant는 모든 도구 활성화 (빈 배열 = 제한 없음)

### 3.2 해결 판정 기준

✅ **필수 요구사항**:

1. Assistant 생성/편집 UI에서 Built-in 도구를 카테고리별로 토글 가능
2. 저장된 설정이 `allowedBuiltInServiceAliases`에 정확히 반영됨
3. Chat 실행 시 Assistant의 허용 목록에 따라 도구가 필터링됨
4. 기존 Assistant는 마이그레이션 없이 모든 도구 사용 가능 (하위 호환성)

✅ **동작 검증**:

1. 특정 도구를 비활성화한 Assistant로 채팅 시, 해당 도구가 `availableTools`에 포함되지 않음
2. 도구 호출 시 허용되지 않은 도구는 실행되지 않음
3. UI에서 토글 상태가 저장/로드 시 올바르게 반영됨

---

## 4. 수정이 필요한 코드 및 수정 부분

### 4.1 데이터 모델 확장

**파일**: `src/models/chat.ts`

```typescript
export interface Assistant {
  id?: string;
  name: string;
  description?: string;
  avatar?: string;
  systemPrompt: string;
  mcpConfig: MCPConfig;
  localServices?: string[];

  // ✅ 추가: Built-in 도구 제어 필드
  /**
   * 허용된 Built-in 서비스 alias 목록
   * - 각 Built-in 도구는 `builtin_<alias>__<toolname>` 형식
   * - 이 배열에 포함된 alias의 도구만 Assistant에게 노출됨
   * - undefined 또는 빈 배열 = 모든 도구 허용 (제한 없음)
   * - 예: ['browser', 'content_store', 'workspace', 'planning', 'playbook']
   */
  allowedBuiltInServiceAliases?: string[];

  isDefault: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

### 4.2 도구 필터링 로직 추가

**파일**: `src/context/ChatContext.tsx`

**현재 코드**:

```typescript
const aiServiceConfig = useMemo(
  (): AIServiceConfig => ({
    tools: [...availableTools, ...builtInTools],
    maxRetries: 3,
    maxTokens: 4096,
  }),
  [availableTools, builtInTools],
);
```

**수정 후**:

```typescript
// Built-in 도구 필터링 함수
const filterBuiltInTools = useCallback(
  (tools: MCPTool[]): MCPTool[] => {
    const currentAssistant = getCurrentAssistant();
    const allowedAliases = currentAssistant?.allowedBuiltInServiceAliases;

    // undefined 또는 빈 배열 = 모든 도구 허용
    if (!allowedAliases || allowedAliases.length === 0) {
      return tools;
    }

    // 허용된 alias의 도구만 필터링
    return tools.filter((tool) => {
      // 도구 이름 형식: builtin_<alias>__<toolname>
      const match = tool.name.match(/^builtin_([^_]+)__/);
      if (!match) return false;

      const toolAlias = match[1];
      return allowedAliases.includes(toolAlias);
    });
  },
  [getCurrentAssistant],
);

const aiServiceConfig = useMemo(
  (): AIServiceConfig => ({
    tools: [...availableTools, ...filterBuiltInTools(builtInTools)],
    maxRetries: 3,
    maxTokens: 4096,
  }),
  [availableTools, builtInTools, filterBuiltInTools],
);
```

### 4.3 Assistant 템플릿 업데이트

**파일**: `src/context/AssistantContext.tsx`

```typescript
export function getDefaultAssistant(): Assistant {
  return {
    createdAt: new Date(),
    name: 'Default Assistant',
    isDefault: true,
    mcpConfig: DEFAULT_MCP_CONFIG,
    systemPrompt: DEFAULT_PROMPT,
    allowedBuiltInServiceAliases: [], // ✅ 빈 배열 = 모든 도구 허용
    updatedAt: new Date(),
  };
}

export function getNewAssistantTemplate(): Assistant {
  return {
    name: 'New Assistant',
    systemPrompt: '...',
    mcpConfig: DEFAULT_MCP_CONFIG,
    allowedBuiltInServiceAliases: [], // ✅ 빈 배열 = 모든 도구 허용
    createdAt: new Date(),
    updatedAt: new Date(),
    isDefault: false,
  };
}
```

### 4.4 Built-in 도구 토글 UI 컴포넌트 생성

**신규 파일**: `src/features/assistant/BuiltInToolsEditor.tsx`

```typescript
import { useEditor } from '@/context/EditorContext';
import { Assistant } from '@/models/chat';
import { useBuiltInTool } from '@/features/tools';
import { useMemo } from 'react';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { toValidJsName } from '@/lib/utils';

interface BuiltInServiceInfo {
  alias: string;
  displayName: string;
  description: string;
  toolCount: number;
}

export default function BuiltInToolsEditor() {
  const { draft, update } = useEditor<Assistant>();
  const { availableTools, status } = useBuiltInTool();

  // 서비스별 도구 그룹화
  const services = useMemo((): BuiltInServiceInfo[] => {
    const serviceMap = new Map<string, BuiltInServiceInfo>();

    availableTools.forEach(tool => {
      const match = tool.name.match(/^builtin_([^_]+)__/);
      if (!match) return;

      const alias = match[1];
      if (!serviceMap.has(alias)) {
        serviceMap.set(alias, {
          alias,
          displayName: getServiceDisplayName(alias),
          description: getServiceDescription(alias),
          toolCount: 0,
        });
      }
      const info = serviceMap.get(alias)!;
      info.toolCount++;
    });

    return Array.from(serviceMap.values()).sort((a, b) =>
      a.displayName.localeCompare(b.displayName)
    );
  }, [availableTools]);

  const allowedAliases = draft.allowedBuiltInServiceAliases || [];
  const isAllEnabled = allowedAliases.length === 0;

  const handleToggle = (alias: string, enabled: boolean) => {
    update((draft) => {
      if (!draft.allowedBuiltInServiceAliases) {
        draft.allowedBuiltInServiceAliases = [];
      }

      // 빈 배열 = 모든 도구 허용 상태에서 하나를 비활성화하면
      // 나머지를 명시적으로 활성화 목록에 추가
      if (draft.allowedBuiltInServiceAliases.length === 0 && !enabled) {
        draft.allowedBuiltInServiceAliases = services
          .map(s => s.alias)
          .filter(a => a !== alias);
        return;
      }

      if (enabled) {
        // 활성화: 목록에 추가
        if (!draft.allowedBuiltInServiceAliases.includes(alias)) {
          draft.allowedBuiltInServiceAliases.push(alias);
        }
      } else {
        // 비활성화: 목록에서 제거
        draft.allowedBuiltInServiceAliases =
          draft.allowedBuiltInServiceAliases.filter(a => a !== alias);
      }
    });
  };

  const handleToggleAll = (enabled: boolean) => {
    update((draft) => {
      if (enabled) {
        // 모두 활성화 = 빈 배열 (제한 없음)
        draft.allowedBuiltInServiceAliases = [];
      } else {
        // 모두 비활성화 = 빈 배열이 아닌 비어있는 상태
        draft.allowedBuiltInServiceAliases = [];
      }
    });
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <Label className="text-base font-semibold">Built-in 도구</Label>
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground">
            모두 활성화
          </span>
          <Switch
            checked={isAllEnabled}
            onCheckedChange={handleToggleAll}
          />
        </div>
      </div>

      <div className="text-sm text-muted-foreground">
        이 Assistant가 사용할 수 있는 Built-in 도구를 선택하세요.
        비활성화된 도구는 사용할 수 없습니다.
      </div>

      <div className="space-y-3 border rounded-lg p-4">
        {services.map(service => {
          const isEnabled = isAllEnabled || allowedAliases.includes(service.alias);

          return (
            <div
              key={service.alias}
              className="flex items-start justify-between py-2"
            >
              <div className="flex-1">
                <div className="font-medium">{service.displayName}</div>
                <div className="text-sm text-muted-foreground">
                  {service.description}
                </div>
                <div className="text-xs text-muted-foreground mt-1">
                  도구 수: {service.toolCount}개
                </div>
              </div>
              <Switch
                checked={isEnabled}
                disabled={isAllEnabled}
                onCheckedChange={(checked) => handleToggle(service.alias, checked)}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
}

// 서비스 alias → 표시 이름 매핑
function getServiceDisplayName(alias: string): string {
  const displayNames: Record<string, string> = {
    browser: '브라우저 자동화',
    content_store: '콘텐츠 스토어',
    workspace: '워크스페이스',
    planning: '작업 계획',
    playbook: '플레이북',
  };
  return displayNames[alias] || alias;
}

// 서비스 설명
function getServiceDescription(alias: string): string {
  const descriptions: Record<string, string> = {
    browser: '웹 페이지 탐색, 클릭, 콘텐츠 추출 등',
    content_store: '파일 저장, 검색, BM25 인덱싱',
    workspace: '파일 읽기/쓰기, 코드 실행, 검색',
    planning: '목표 설정, 작업 계획 수립',
    playbook: '워크플로우 생성 및 실행',
  };
  return descriptions[alias] || '설명 없음';
}
```

### 4.5 AssistantEditor에 통합

**파일**: `src/features/assistant/AssistantEditor.tsx`

```typescript
import BuiltInToolsEditor from './BuiltInToolsEditor'; // ✅ 추가

export default function AssistantEditor() {
  const { draft, update } = useEditor<Assistant>();
  // ... 기존 코드 ...

  return (
    <div className="flex-1 flex flex-col h-full">
      <div className="flex-1 overflow-y-auto p-4">
        <div className="space-y-4">
          <InputWithLabel
            label="어시스턴트 이름 *"
            value={draft?.name || ''}
            onChange={(e) => update((draft) => { draft.name = e.target.value; })}
            placeholder="어시스턴트 이름을 입력하세요..."
          />

          <TextareaWithLabel
            label="시스템 프롬프트 *"
            value={draft?.systemPrompt || ''}
            onChange={(e) => update((draft) => { draft.systemPrompt = e.target.value; })}
            placeholder="AI가 수행할 역할과 행동 방식을 설명하세요..."
            className="h-32"
          />

          {/* ✅ Built-in 도구 토글 UI 추가 */}
          <BuiltInToolsEditor />

          <MCPConfigEditor
            mcpConfigText={mcpConfigText}
            onChange={handleMCPConfigUpdate}
          />
        </div>
      </div>
    </div>
  );
}
```

---

## 5. 재사용 가능한 연관 코드

### 5.1 유틸리티 함수

**파일**: `src/lib/utils.ts`

```typescript
/**
 * Built-in 도구 이름에서 서비스 alias 추출
 * @param toolName 도구 이름 (예: "builtin_browser__clickElement")
 * @returns 서비스 alias (예: "browser") 또는 null
 */
export function extractBuiltInServiceAlias(toolName: string): string | null {
  const match = toolName.match(/^builtin_([^_]+)__/);
  return match ? match[1] : null;
}

/**
 * 서비스 ID를 유효한 JavaScript 이름(alias)으로 변환
 * (기존 toValidJsName 함수 활용)
 */
export { toValidJsName };
```

### 5.2 관련 컴포넌트

**EditorContext** (`src/context/EditorContext.tsx`):

- `useEditor<T>()`: draft 상태 관리 및 업데이트
- `update(fn)`: Immer 패턴으로 draft 수정

**BuiltInToolProvider** (`src/features/tools/index.tsx`):

- `useBuiltInTool()`: 등록된 서비스 및 도구 목록 제공
- `availableTools`: 현재 등록된 모든 Built-in 도구
- `status`: 서비스별 로딩 상태

**UI 컴포넌트**:

- `Switch` (`@/components/ui/switch`): 토글 스위치
- `Label` (`@/components/ui/label`): 레이블

---

## 6. Test Code 가이드

### 6.1 단위 테스트

**파일**: `src/features/assistant/__tests__/BuiltInToolsEditor.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { EditorProvider } from '@/context/EditorContext';
import { BuiltInToolProvider } from '@/features/tools';
import BuiltInToolsEditor from '../BuiltInToolsEditor';
import { getNewAssistantTemplate } from '@/context/AssistantContext';

describe('BuiltInToolsEditor', () => {
  const renderEditor = () => {
    return render(
      <BuiltInToolProvider>
        <EditorProvider
          initialValue={getNewAssistantTemplate()}
          onFinalize={jest.fn()}
        >
          <BuiltInToolsEditor />
        </EditorProvider>
      </BuiltInToolProvider>
    );
  };

  it('should render all available services', () => {
    renderEditor();
    expect(screen.getByText('브라우저 자동화')).toBeInTheDocument();
    expect(screen.getByText('워크스페이스')).toBeInTheDocument();
  });

  it('should toggle service on/off', () => {
    renderEditor();
    const browserSwitch = screen.getAllByRole('switch')[1]; // 첫 번째는 "모두 활성화"

    // 초기 상태: 모두 활성화
    expect(browserSwitch).toBeChecked();

    // 비활성화
    fireEvent.click(browserSwitch);
    expect(browserSwitch).not.toBeChecked();

    // 재활성화
    fireEvent.click(browserSwitch);
    expect(browserSwitch).toBeChecked();
  });

  it('should toggle all services', () => {
    renderEditor();
    const toggleAllSwitch = screen.getAllByRole('switch')[0];

    // 모두 비활성화
    fireEvent.click(toggleAllSwitch);

    // 모든 개별 스위치가 비활성화되어야 함
    const switches = screen.getAllByRole('switch').slice(1);
    switches.forEach(sw => expect(sw).not.toBeChecked());
  });
});
```

### 6.2 통합 테스트

**파일**: `src/context/__tests__/ChatContext.test.tsx`

```typescript
describe('ChatContext - Built-in Tool Filtering', () => {
  it('should filter tools based on assistant allowedBuiltInServiceAliases', async () => {
    const assistant: Assistant = {
      name: 'Limited Assistant',
      systemPrompt: 'Test',
      mcpConfig: {},
      allowedBuiltInServiceAliases: ['browser'], // 브라우저만 허용
      isDefault: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    // Mock ChatContext with filtered tools
    const { result } = renderHook(() => useChatContext(), {
      wrapper: ({ children }) => (
        <AssistantContextProvider>
          <BuiltInToolProvider>
            <ChatProvider>{children}</ChatProvider>
          </BuiltInToolProvider>
        </AssistantContextProvider>
      ),
    });

    // availableTools에 browser 도구만 포함되어야 함
    const tools = result.current.availableTools;
    const browserTools = tools.filter(t => t.name.startsWith('builtin_browser__'));
    const workspaceTools = tools.filter(t => t.name.startsWith('builtin_workspace__'));

    expect(browserTools.length).toBeGreaterThan(0);
    expect(workspaceTools.length).toBe(0);
  });

  it('should allow all tools when allowedBuiltInServiceAliases is empty', async () => {
    const assistant: Assistant = {
      name: 'Unrestricted Assistant',
      systemPrompt: 'Test',
      mcpConfig: {},
      allowedBuiltInServiceAliases: [], // 빈 배열 = 제한 없음
      isDefault: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    // 모든 도구가 포함되어야 함
    // ... 테스트 로직
  });
});
```

### 6.3 E2E 테스트 시나리오

**시나리오 1**: Assistant 생성 및 도구 토글

1. Assistant 생성 UI 열기
2. Built-in 도구 섹션에서 "브라우저 자동화" 비활성화
3. Assistant 저장
4. 저장된 Assistant로 채팅 시작
5. AI가 브라우저 도구를 호출하려 할 때 실패하는지 확인

**시나리오 2**: 기존 Assistant 하위 호환성

1. `allowedBuiltInServiceAliases` 필드가 없는 기존 Assistant 로드
2. 모든 Built-in 도구가 사용 가능한지 확인

---

## 7. 추가 분석 과제

### 7.1 서비스 alias 동적 로딩

현재 계획은 하드코딩된 서비스 이름(`browser`, `workspace` 등)을 사용하지만, 향후 동적 서비스 추가 시 확장 가능하도록 다음을 고려:

- `BuiltInToolProvider`에서 등록된 서비스 목록을 동적으로 제공하는 API 추가
- `useBuiltInTool()`에 `getRegisteredServices()` 함수 추가
- UI에서 하드코딩 대신 동적 목록 사용

### 7.2 도구 그룹화 및 카테고리화

현재는 서비스 단위로 토글하지만, 향후 다음과 같은 세밀한 제어 고려:

- 서비스 내 개별 도구 선택 (예: 브라우저에서 "클릭"만 허용, "파일 다운로드"는 차단)
- 도구 카테고리화 (파일 시스템, 네트워크, 코드 실행 등)
- 위험도 레벨 표시 (안전, 주의, 위험)

### 7.3 마이그레이션 전략

기존 Assistant에 `allowedBuiltInServiceAliases` 필드가 없는 경우:

- DB 스키마 업데이트 필요 없음 (optional 필드)
- undefined → 빈 배열로 처리하여 하위 호환성 유지
- 향후 DB 마이그레이션 스크립트로 명시적 값 설정 고려

### 7.4 성능 최적화

도구 필터링이 매 렌더링마다 발생하지 않도록:

- `useMemo`로 필터링 결과 캐싱
- Assistant 변경 시에만 재계산
- 대량 도구 목록 처리 시 가상화(virtualization) 고려

---

## 8. 작업 체크리스트

### Phase 1: 데이터 모델 및 필터링 로직 (필수)

- [ ] `Assistant` 타입에 `allowedBuiltInServiceAliases` 필드 추가
- [ ] `ChatContext`에 도구 필터링 로직 추가
- [ ] Assistant 템플릿 업데이트 (기본값 설정)
- [ ] 유틸리티 함수 추가 (`extractBuiltInServiceAlias`)

### Phase 2: UI 구현 (필수)

- [ ] `BuiltInToolsEditor` 컴포넌트 생성
- [ ] 서비스 목록 동적 로딩 및 표시
- [ ] 토글 스위치 동작 구현
- [ ] "모두 활성화/비활성화" 기능 구현
- [ ] `AssistantEditor`에 통합

### Phase 3: 테스트 (필수)

- [ ] 단위 테스트 작성 (`BuiltInToolsEditor`)
- [ ] 통합 테스트 작성 (도구 필터링 로직)
- [ ] E2E 테스트 시나리오 실행
- [ ] 하위 호환성 테스트

### Phase 4: 문서화 및 배포 (권장)

- [ ] 사용자 가이드 업데이트
- [ ] 개발자 문서 업데이트 (`builtin-tools.md`)
- [ ] 변경 사항 CHANGELOG 작성
- [ ] 배포 및 모니터링

---

## 9. 예상 리스크 및 대응 방안

### 리스크 1: 기존 Assistant 동작 변경

**대응**:

- undefined 처리를 빈 배열과 동일하게 (제한 없음)
- 마이그레이션 스크립트 제공

### 리스크 2: UI 복잡도 증가

**대응**:

- 간단한 토글 UI로 시작
- 향후 고급 설정은 별도 섹션으로 분리

### 리스크 3: 도구 이름 규칙 변경

**대응**:

- `extractBuiltInServiceAlias` 함수로 추상화
- 정규식 패턴 중앙 관리

---

## 10. 참고 자료

- **Built-in Tools 문서**: `docs/builtin-tools.md`
- **Chat Feature 아키텍처**: `docs/architecture/chat-feature-architecture.md`
- **EditorContext 사용법**: `src/context/EditorContext.tsx`
- **BuiltInToolProvider 구조**: `src/features/tools/index.tsx`
- **도구 이름 규칙**: `toValidJsName()` 함수 (`src/lib/utils.ts`)

---

**작성 완료**: 2025-01-01 14:30  
**검토 필요**: 데이터 모델 변경, 필터링 로직, UI 구현  
**예상 소요 시간**: 2-3일 (테스트 포함)
