# Refactoring Plan: AI 서비스 벤더 간 상호 운용성 및 메시지 필드 유실 방지

## 작업의 목적

Claude Extended Thinking API 메시지 포맷 오류를 해결하고, AI 서비스 벤더 간 전환 시 발생하는 400 에러 및 메시지 필드 유실 문제를 근본적으로 해결한다. 사용자가 Anthropic에서 OpenAI/Groq/Gemini 등 다른 벤더로 전환해도 기존 대화 이력이 호환되며, 벤더별 특화 필드(thinking, tool_use, tool_calls 등)가 적절히 변환되거나 안전하게 제거되어 API 오류가 발생하지 않도록 한다.

## 현재의 상태 / 문제점

### 1. Claude Extended Thinking API 규칙 위반

- **문제**: assistant 메시지의 첫 번째 content 블록이 `thinking` 타입이 아닐 때 400 에러 발생
- **원인**: tool 결과 메시지 이후 다음 AI 호출 시, `tool_use` 블록이 `thinking` 블록보다 앞에 위치
- **에러 메시지**: `messages.1.content.0.type: Expected 'thinking' or 'redacted_thinking', but found 'tool_use'`

### 2. 벤더별 특화 필드 충돌

- **Anthropic**: `thinking`, `thinkingSignature`, `tool_use` 사용
- **OpenAI/Groq/Cerebras**: `tool_calls` 사용, `thinking` 미지원
- **Gemini**: 독자적인 `functionCall`, `parts` 구조
- **문제**: 벤더 전환 시 미지원 필드로 인한 API 호출 실패

### 3. 메시지 처리 과정에서의 필드 유실

- **BaseAIService.processMessageContent**: 텍스트가 아닌 content 타입 필터링으로 thinking, tool_use 정보 손실
- **중복 변환 로직**: `convertToAnthropicMessages`와 `convertSingleMessage`에서 동일 로직 중복
- **타입 안전성 부족**: Array.isArray 분기가 실제로는 실행되지 않는 죽은 코드 존재

### 4. 런타임 안전성 문제

- **tool_call_id 누락**: `m.tool_call_id!` 비단언 사용으로 undefined 시 런타임 오류 위험
- **thinking 파라미터**: 모델 지원 여부와 관계없이 항상 enabled로 설정

## 추가 분석 과제

### 1. 멀티모달 콘텐츠 처리 방향성

- 현재 `processMessageContent`는 텍스트만 추출하는데, 향후 이미지/첨부파일 지원 시 `processMultiModalContent` 활용 방안 검토
- Anthropic content 블록 구조와 다른 벤더의 멀티모달 지원 방식 호환성 분석

### 2. 도구 호출 다중성 처리

- Anthropic은 단일 `tool_use`, OpenAI 계열은 다중 `tool_calls` 지원
- 다중 도구 호출을 Anthropic으로 전환 시 순차 처리 또는 병합 전략 결정

### 3. 벤더별 모델 능력 메타데이터 활용

- `llmConfigManager`의 `supportReasoning` 등 모델별 능력 정보를 활용한 동적 기능 제어 방안
- 새로운 벤더 추가 시 확장 가능한 능력 정의 체계

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **API 오류 해결**: Claude Extended Thinking API 호출 시 400 에러 발생하지 않음
2. **벤더 간 전환 안정성**: 기존 대화 이력을 유지하며 다른 벤더로 전환 가능
3. **필드 유실 방지**: 벤더별 특화 필드가 적절히 보존되거나 안전하게 변환됨
4. **타입 안전성**: TypeScript 컴파일 오류 없이 엄격한 타입 체크 통과
5. **런타임 안정성**: undefined 참조, null pointer 등 런타임 오류 발생하지 않음

### 검증 방법

- Anthropic → OpenAI/Groq/Gemini 전환 테스트
- tool 호출이 포함된 대화 이력에서 벤더 전환 테스트
- thinking 필드가 포함된 메시지 저장/복원 테스트
- 빈 또는 부분적 필드를 가진 메시지 처리 테스트

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Anthropic 서비스 안정성 강화

**파일**: `src/lib/ai-service/anthropic.ts`

```typescript
// BEFORE (Line 272-280)
} else if (m.role === 'tool') {
  anthropicMessages.push({
    role: 'user',
    content: [
      {
        type: 'tool_result' as const,
        tool_use_id: m.tool_call_id!, // ❌ 위험한 비단언
        content: this.processMessageContent(m.content),
      },
    ],
  });
}

// AFTER
} else if (m.role === 'tool') {
  if (!m.tool_call_id) {
    logger.warn('Tool message missing tool_call_id, skipping', { messageId: m.id });
    continue;
  }
  anthropicMessages.push({
    role: 'user',
    content: [
      {
        type: 'tool_result' as const,
        tool_use_id: m.tool_call_id,
        content: this.processMessageContent(m.content),
      },
    ],
  });
}
```

```typescript
// BEFORE (Line 45-50) - thinking 항상 활성화
const completion = await this.withRetry(() =>
  this.anthropic.messages.create({
    // ...
    thinking: {
      budget_tokens: 1024,
      type: 'enabled',
    },
    // ...
  }),
);

// AFTER - 조건부 thinking 활성화
const shouldEnableThinking = this.shouldEnableThinking(
  options.modelName,
  config,
);
const completion = await this.withRetry(() =>
  this.anthropic.messages.create({
    // ...
    ...(shouldEnableThinking && {
      thinking: {
        budget_tokens: 1024,
        type: 'enabled',
      },
    }),
    // ...
  }),
);
```

### 2. 메시지 벤더별 정리 유틸리티 구현

**파일**: `src/lib/ai-service/message-normalizer.ts` (신규 생성)

```typescript
import { Message } from '@/models/chat';
import { AIServiceProvider } from './types';
import { getLogger } from '../logger';

const logger = getLogger('MessageNormalizer');

export class MessageNormalizer {
  /**
   * 벤더별로 메시지 배열을 정리하여 API 호환성 확보
   */
  static sanitizeMessagesForProvider(
    messages: Message[],
    targetProvider: AIServiceProvider,
  ): Message[] {
    return messages
      .map((msg) => this.sanitizeSingleMessage(msg, targetProvider))
      .filter((msg) => msg !== null) as Message[];
  }

  private static sanitizeSingleMessage(
    message: Message,
    targetProvider: AIServiceProvider,
  ): Message | null {
    const sanitized = { ...message };

    switch (targetProvider) {
      case AIServiceProvider.Anthropic:
        return this.sanitizeForAnthropic(sanitized);
      case AIServiceProvider.OpenAI:
      case AIServiceProvider.Groq:
      case AIServiceProvider.Cerebras:
      case AIServiceProvider.Fireworks:
        return this.sanitizeForOpenAIFamily(sanitized);
      case AIServiceProvider.Gemini:
        return this.sanitizeForGemini(sanitized);
      default:
        return sanitized;
    }
  }

  private static sanitizeForAnthropic(message: Message): Message {
    // tool_calls를 tool_use로 변환
    if (message.tool_calls && !message.tool_use) {
      const firstToolCall = message.tool_calls[0];
      if (firstToolCall) {
        message.tool_use = {
          id: firstToolCall.id,
          name: firstToolCall.function.name,
          input: JSON.parse(firstToolCall.function.arguments),
        };
      }
      delete message.tool_calls;
    }

    // tool 메시지에서 tool_call_id 없으면 제거
    if (message.role === 'tool' && !message.tool_call_id) {
      return null; // 필터링됨
    }

    return message;
  }

  private static sanitizeForOpenAIFamily(message: Message): Message {
    // thinking 관련 필드 제거
    delete message.thinking;
    delete message.thinkingSignature;

    // tool_use를 tool_calls로 변환
    if (message.tool_use && !message.tool_calls) {
      message.tool_calls = [
        {
          id: message.tool_use.id,
          type: 'function',
          function: {
            name: message.tool_use.name,
            arguments: JSON.stringify(message.tool_use.input),
          },
        },
      ];
      delete message.tool_use;
    }

    return message;
  }

  private static sanitizeForGemini(message: Message): Message {
    // Gemini 특화 정리 (구현 시 추가)
    delete message.thinking;
    delete message.thinkingSignature;
    // tool_calls 처리 로직 추가 예정
    return message;
  }
}
```

### 3. BaseAIService 공통 전처리 훅 추가

**파일**: `src/lib/ai-service/base-service.ts`

```typescript
// 기존 prepareStreamChat 메서드에 추가
protected prepareStreamChat(
  messages: Message[],
  options: {
    modelName?: string;
    systemPrompt?: string;
    availableTools?: MCPTool[];
    config?: AIServiceConfig;
  } = {},
): {
  config: AIServiceConfig;
  tools?: unknown[];
  sanitizedMessages: Message[]; // 추가
} {
  this.validateMessages(messages);
  const config = this.mergeConfig(options);

  const tools = options.availableTools
    ? convertMCPToolsToProviderTools(
        options.availableTools,
        this.getProvider(),
      )
    : undefined;

  // 벤더별 메시지 정리 추가
  const sanitizedMessages = this.sanitizeMessages(messages);

  return { config, tools, sanitizedMessages };
}

protected sanitizeMessages(messages: Message[]): Message[] {
  // 기본 구현: 변경 없음. 각 서비스에서 override 가능
  return messages;
}
```

### 4. 죽은 코드 정리

**파일**: `src/lib/ai-service/anthropic.ts`

```typescript
// BEFORE (Line 258-265) - 실행되지 않는 분기
} else if (hasContent) {
  const processedContent = this.processMessageContent(m.content);
  if (Array.isArray(processedContent)) { // ❌ 절대 true가 될 수 없음
    content.push(...processedContent);
  } else {
    content.push({ type: 'text' as const, text: processedContent });
  }
}

// AFTER - 단순화
} else if (hasContent) {
  const processedContent = this.processMessageContent(m.content);
  content.push({ type: 'text' as const, text: processedContent });
}
```

## 재사용 가능한 연관 코드

### 핵심 인터페이스 및 타입

- **파일**: `src/models/chat.ts`
  - `Message` 인터페이스: 벤더 중립적 메시지 구조
  - `ToolCall` 인터페이스: 표준 도구 호출 형식
- **파일**: `src/lib/ai-service/types.ts`
  - `AIServiceProvider` enum: 벤더 식별자
  - `AIServiceConfig` 인터페이스: 공통 설정 구조

### 변환 및 유틸리티

- **파일**: `src/lib/ai-service/tool-converters.ts`
  - `convertMCPToolsToProviderTools`: 벤더별 도구 스키마 변환
  - 각 벤더별 스키마 검증 및 정리 로직
- **파일**: `src/lib/llm-config-manager.ts`
  - 모델별 능력 정보 (`supportReasoning` 등)
  - 벤더별 기본 설정

### 베이스 서비스 구조

- **파일**: `src/lib/ai-service/base-service.ts`
  - `BaseAIService` 클래스: 공통 로직 및 추상 메서드
  - `prepareStreamChat`: 전처리 공통 로직
  - `validateMessages`: 메시지 검증
  - `handleStreamingError`: 오류 처리 표준화

### 개별 벤더 서비스

- **파일**: `src/lib/ai-service/anthropic.ts`
  - Anthropic 특화 thinking, tool_use 처리
- **파일**: `src/lib/ai-service/groq.ts`
  - Groq reasoning → thinking 매핑
- **파일**: `src/lib/ai-service/openai.ts`
  - OpenAI 표준 구현 (Fireworks도 상속)
- **파일**: `src/lib/ai-service/cerebras.ts`
  - Cerebras 스키마 제약 처리

### 확장 가능한 구조

1. **새 벤더 추가**: `AIServiceProvider`에 enum 추가 후 해당 서비스 클래스 구현
2. **새 능력 추가**: `llmConfigManager`에 능력 플래그 추가 후 각 서비스에서 활용
3. **새 메시지 타입**: `Message` 인터페이스 확장 후 각 변환기에서 처리 로직 추가

이 리팩토링을 통해 벤더 간 전환이 안전하고 예측 가능하며, 새로운 AI 서비스 통합 시에도 일관된 패턴으로 확장할 수 있는 구조를 확립한다.
