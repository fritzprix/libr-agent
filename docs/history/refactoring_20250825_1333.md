# Chat 메시지 저장 API 통합 리팩터링

## 작업 요약

- **완료 일시:** 2025년 8월 25일
- **작업 내용:**
  - `SessionHistoryContext`의 메시지 저장 API를 단일화하여 `addMessage`와 `addHistoryMessages`를 `addMessages(messages: Message[])`로 통합했습니다.
  - 병렬 낙관적 업데이트(mutate) 충돌로 인한 툴 결과(tool result) 유실 문제를 해결하기 위해 `ChatContext`에서 `addMessages`를 사용하도록 수정했습니다.
  - Tool-result의 `content`를 항상 문자열로 직렬화하여 렌더링 오류 가능성을 제거했습니다.
  - 관련하여 코드베이스의 `addMessage` 사용처를 점검하고, ESLint 및 Prettier를 적용하여 코드 품질을 유지했습니다.
  - 최종적으로 `pnpm tauri build`를 통해 빌드 성공을 확인했습니다.

---

## 원본 리팩터링 계획

### 작업의 목적

- `SessionHistoryContext`의 메시지 저장 API를 단일화하여 `addMessage`와 `addHistoryMessages`(또는 유사한 배치 API)를 `addMessages(messages: Message[])`로 통합한다.
- 병렬 낙관적 업데이트(mutate) 충돌로 인한 툴 결과(tool result) 유실 문제를 해소한다.
- 하위 호환성을 유지하면서 배치 추가의 원자성(atomicity)을 확보한다.

### 현재의 상태 / 문제점

- 여러 곳에서 `addMessage`를 병렬로 호출하거나 `Promise.all`로 다수의 메시지를 동시 저장하는 패턴이 존재함.
- SWR/낙관적 업데이트를 사용하는 경우, 병렬적인 mutate 호출이 서로를 덮어써 일부 메시지가 유실되는 현상이 관찰됨(툴 실행 결과가 잠깐 보였다가 사라지는 문제).
- ToolCaller에서 툴 응답의 `content` 필드에 배열/객체를 그대로 넣는 경우가 있어 직렬화/렌더링 단계에서 문제를 유발할 가능성 있음.

### 변경 이후의 상태 / 해결 판정 기준

- `addMessages(messages: Message[])` 단일 API로 다수 메시지를 원자적으로 추가할 수 있다.
- 기존 `addMessage(message)` 호출은 내부적으로 `addMessages([message])`로 동작하여 하위 호환성이 유지된다.
- 툴 실행 결과가 UI에 표시된 뒤 사라지는 현상이 재현되지 않아야 한다(수동 테스트 및 자동화된 통합 테스트 기준).
- SWR의 mutate 충돌로 인한 손실 케이스가 재현 불가 혹은 현저히 감소해야 함.

### 수정이 필요한 코드 및 수정부분의 코드 스니핏

- 변경 대상 파일(예시):

  - `src/context/SessionHistoryContext.tsx`
  - `src/context/ChatContext.tsx`
  - Tool 결과를 생성/저장하는 위치(예: `ToolCaller` / `use-ai-service.ts`) — content 직렬화 확인.


#### 1) `SessionHistoryContext` — 배치 추가 API `addMessages`

- 목적: 낙관적 업데이트를 한 번의 mutate로 처리하여 충돌을 피함.

```ts
// new: addMessages(messages: Message[]) -> Promise<Message[]>
const addMessages = useCallback(async (messagesToAdd: Message[]) => {
  if (!currentSession) throw new Error('No active session.');
  messagesToAdd.forEach(validateMessage);
  const messagesWithSessionId = messagesToAdd.map((m) => ({ ...m, sessionId: currentSession.id }));

  const previousData = data;

  await mutate((currentData) => {
    if (!currentData || currentData.length === 0) {
      return [{ items: messagesWithSessionId, page: 1, pageSize: PAGE_SIZE, totalItems: messagesWithSessionId.length }];
    }
    const newData = [...currentData];
    const last = { ...newData[newData.length - 1] };
    last.items = [...last.items, ...messagesWithSessionId];
    newData[newData.length - 1] = last;
    return newData;
  }, { revalidate: false });

  try {
    await dbService.messages.upsertMany(messagesWithSessionId);
  } catch (e) {
    await mutate(previousData, { revalidate: false });
    throw e;
  }

  return messagesWithSessionId;
}, [currentSession, mutate, data]);

// 기존 addMessage는 내부적으로 addMessages([message]) 호출
const addMessage = useCallback(async (message: Message) => {
  const [added] = await addMessages([message]);
  return added;
}, [addMessages]);
```


#### 2) `ChatContext.submit` — 배치 API 사용으로 마이그레이션

- 목적: `messageToAdd`가 여러 개일 때 병렬 `addMessage` 대신 `addMessages` 사용

```ts
// 변경 전: Promise.all(messageToAdd.map(... addMessage ...))
// 변경 후:
if (messageToAdd?.length) {
  const messagesWithSession = messageToAdd.map((m) => ({ ...m, sessionId: currentSession.id }));
  if (typeof addMessages === 'function') {
    await addMessages(messagesWithSession);
    messagesToSend = [...messages, ...messagesWithSession];
  } else {
    // 안전한 폴백: 순차 저장
    const persisted: Message[] = [];
    for (const msg of messagesWithSession) {
      const added = await addMessage(msg);
      persisted.push(added);
    }
    messagesToSend = [...messages, ...persisted];
  }
}
```


#### 3) Tool 결과 직렬화 권장(선택적, 권고)

- ToolCaller 또는 AI service에서 tool 결과의 `content` 값을 항상 문자열 혹은 렌더러가 처리 가능한 포맷으로 직렬화하여 저장.

```ts
const toolResultMessage: Message = {
  id: createId(),
  role: 'tool',
  content: typeof result.content === 'string' ? result.content : JSON.stringify(result.content ?? ''),
  tool_call_id: toolCall.id,
  sessionId: currentSession.id,
};
```
