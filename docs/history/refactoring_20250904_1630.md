# WorkspaceServer 모듈 분리 리팩토링 계획

## 작업의 목적

WorkspaceServer의 단일 파일(workspace.rs)이 2000줄 이상으로 비대해져 유지보수성이 떨어지는 문제를 해결하고, 기능별로 명확히 분리된 모듈 구조로 개선하여 코드의 가독성과 확장성을 향상시킨다.

## 현재의 상태 / 문제점

### 현재 상태

- `src-tauri/src/mcp/builtin/workspace.rs` 파일이 약 2000줄 이상
- 파일 작업, 코드 실행, 내보내기 기능이 단일 파일에 혼재
- 도구 정의와 핸들러 구현이 동일 파일에 위치
- UI 리소스 생성 로직도 포함되어 복잡성 증가

### 문제점

1. **단일 책임 원칙 위반**: 하나의 파일이 너무 많은 책임을 담당
2. **코드 가독성 저하**: 관련 없는 기능들이 섞여 있어 이해가 어려움
3. **유지보수 어려움**: 특정 기능 수정 시 전체 파일을 파악해야 함
4. **테스트 복잡성**: 개별 기능별 단위 테스트가 어려움
5. **확장성 제약**: 새로운 기능 추가 시 파일 크기가 더욱 증가

## 추가 분석 과제

1. **의존성 분석**: 각 모듈 간 의존성 관계를 명확히 파악하여 순환 의존성 방지
2. **성능 영향 평가**: 모듈 분리가 컴파일 시간과 런타임 성능에 미치는 영향 분석
3. **에러 처리 일관성**: 분리된 모듈들에서 일관된 에러 처리 패턴 적용 방안 검토
4. **테스트 전략 수립**: 각 모듈별 단위 테스트 및 통합 테스트 전략 계획

## 변경 이후의 상태 / 해결 판정 기준

### 목표 구조

```
src-tauri/src/mcp/builtin/workspace/
├── mod.rs                    # 메인 WorkspaceServer 구조체 (< 200줄)
├── file_operations.rs        # 파일 작업 핸들러들 (< 500줄)
├── code_execution.rs         # 코드 실행 핸들러들 (< 400줄)
├── export_operations.rs      # 내보내기 작업 핸들러들 (< 300줄)
├── tools/
│   ├── mod.rs               # 도구 정의 통합
│   ├── file_tools.rs        # 파일 작업 도구 정의
│   ├── code_tools.rs        # 코드 실행 도구 정의
│   └── export_tools.rs      # 내보내기 도구 정의
├── ui_resources.rs           # UI 리소스 생성 로직 (< 200줄)
└── utils.rs                  # 공통 유틸리티 및 상수
```

### 해결 판정 기준

1. **파일 크기**: 각 개별 파일이 500줄 이하
2. **기능 분리**: 관련 기능들이 명확히 분리된 모듈에 위치
3. **컴파일 성공**: 기존 기능이 모두 정상 작동
4. **테스트 통과**: 모든 기존 테스트가 통과
5. **API 호환성**: 외부 인터페이스 변경 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 메인 모듈 파일 (mod.rs)

```rust
// 기존 workspace.rs 상단 부분
pub struct WorkspaceServer {
    file_manager: std::sync::Arc<SecureFileManager>,
}

impl WorkspaceServer {
    pub fn new(file_manager: std::sync::Arc<SecureFileManager>) -> Self {
        info!("WorkspaceServer using workspace directory: {:?}", file_manager.base_dir());
        Self { file_manager }
    }

    // 공통 유틸리티 메서드들만 유지
    pub fn get_workspace_dir(&self) -> &std::path::Path { ... }
    pub fn generate_request_id() -> Value { ... }
    pub fn success_response(request_id: Value, message: &str) -> MCPResponse { ... }
    // ...
}

#[async_trait]
impl BuiltinMCPServer for WorkspaceServer {
    fn tools(&self) -> Vec<MCPTool> {
        let mut tools = Vec::new();
        tools.extend(tools::file_tools());
        tools.extend(tools::code_tools());
        tools.extend(tools::export_tools());
        tools
    }

    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
        match tool_name {
            "read_file" => file_operations::handle_read_file(self, args).await,
            "write_file" => file_operations::handle_write_file(self, args).await,
            // ... 각 모듈로 위임
        }
    }
}
```

### 2. 파일 작업 모듈 (file_operations.rs)

```rust
// 기존 handle_read_file 등 파일 작업 핸들러들을 이동
pub async fn handle_read_file(server: &WorkspaceServer, args: Value) -> MCPResponse {
    let request_id = WorkspaceServer::generate_request_id();
    // 기존 구현 유지
}

pub async fn handle_write_file(server: &WorkspaceServer, args: Value) -> MCPResponse {
    // 기존 구현 이동
}
// ... 기타 파일 작업 핸들러들
```

### 3. 도구 정의 모듈 (tools/mod.rs)

```rust
// 기존 create_*_tool 함수들을 기능별로 분리
pub use file_tools::*;
pub use code_tools::*;
pub use export_tools::*;

pub fn all_tools() -> Vec<MCPTool> {
    let mut tools = Vec::new();
    tools.extend(file_tools());
    tools.extend(code_tools());
    tools.extend(export_tools());
    tools
}
```

## 재사용 가능한 연관 코드

### 관련 파일들

1. **`src-tauri/src/mcp/builtin/mod.rs`**: BuiltinMCPServer 트레이트 정의
2. **`src-tauri/src/mcp/mod.rs`**: MCPResponse, MCPTool 타입 정의
3. **`src-tauri/src/mcp/utils/schema_builder.rs`**: 스키마 빌더 유틸리티
4. **`src-tauri/src/services/mod.rs`**: SecureFileManager 정의

### 주요 인터페이스

```rust
// BuiltinMCPServer 트레이트 (변경 없음)
#[async_trait]
pub trait BuiltinMCPServer: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn tools(&self) -> Vec<MCPTool>;
    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse;
}

// 공통 응답 타입들 (변경 없음)
pub struct MCPResponse { ... }
pub struct MCPTool { ... }
```

### 공통 유틸리티 함수들

```rust
// utils.rs로 이동할 함수들
pub mod constants {
    pub const DEFAULT_EXECUTION_TIMEOUT: u64 = 30;
    pub const MAX_EXECUTION_TIMEOUT: u64 = 300;
    pub const MAX_CODE_SIZE: usize = 1024 * 1024;
    pub const MAX_FILE_SIZE: usize = 10 * 1024 * 1024;
}

// 공통 헬퍼 함수들
pub fn validate_timeout(timeout: Option<u64>) -> u64 { ... }
pub fn create_temp_script_file(code: &str, extension: &str) -> Result<TempDir, String> { ... }
```

## 작업 단계별 계획

### 1단계: 디렉토리 구조 생성

- `workspace/` 디렉토리 생성
- 각 모듈 파일들의 빈 템플릿 생성

### 2단계: 공통 코드 분리

- 상수와 유틸리티 함수들을 `utils.rs`로 이동
- UI 리소스 관련 코드를 `ui_resources.rs`로 이동

### 3단계: 도구 정의 분리

- 각 기능별 도구 정의를 `tools/` 하위 모듈로 분리

### 4단계: 핸들러 분리

- 파일 작업 핸들러들을 `file_operations.rs`로 이동
- 코드 실행 핸들러들을 `code_execution.rs`로 이동
- 내보내기 핸들러들을 `export_operations.rs`로 이동

### 5단계: 메인 모듈 정리

- `mod.rs`에 필요한 최소한의 코드만 유지
- 모든 기능을 하위 모듈로 위임하도록 수정

### 6단계: 테스트 및 검증

- 기존 기능이 모두 정상 작동하는지 확인
- 컴파일 오류 및 경고 해결
- 성능 영향 최소화 확인

이 리팩토링을 통해 코드의 모듈성과 유지보수성을 크게 향상시킬 수 있을 것으로 예상됩니다.
