# Web MCP 응답 구조 개선 및 NativeMCPResponse 도입 계획

## 작업의 목적

Web MCP 서버들의 응답 구조를 개선하여 LLM Agent가 실질적으로 활용할 수 있는 풍부한 텍스트 정보를 제공하면서, 동시에 UI 컴포넌트가 필요로 하는 구조화된 데이터에 대한 타입 안전성과 하위 호환성을 보장하는 통합된 응답 시스템을 구축한다.

## 현재의 상태 / 문제점

### 응답 데이터 구조 문제

1. **불충분한 LLM 정보**: `readContent`를 제외한 대부분의 도구가 `result.content`에 단순 상태 메시지만 반환 (예: "Found 5 content items")
2. **구조화된 데이터 접근성**: UI에서 필요한 상세 데이터는 `structuredContent`에만 있어 LLM이 활용 불가
3. **일관성 부족**: content-store와 planning-server 간 응답 형식의 일관성 부족

### 타입 시스템 한계

1. **하위 호환성 우려**: 현재 `ResourceAttachmentContext`는 `server.listContent().contents` 형태로 접근하지만, 새 구조에서는 `MCPResponse` 반환으로 깨질 가능성
2. **인터페이스 혼재**: Worker와 Proxy 간 통신과 Proxy와 Client 간 인터페이스가 구분되지 않음

### 구체적 문제 사례

- `listContent`: "Found 5 content items" → 파일 목록 상세 정보 필요
- `keywordSimilaritySearch`: "Search completed: 3 results found" → 검색 결과 컨텍스트 필요
- `createStore/addContent`: 기본 성공 메시지 → 생성된 리소스 정보 필요

## 추가 분석 과제

1. **Legacy 클라이언트 코드 영향 범위**: ResourceAttachmentContext 외에 다른 consumer들의 Web MCP 서버 사용 패턴 조사
2. **응답 크기 최적화**: 풍부한 텍스트 정보 제공 시 응답 크기가 성능에 미치는 영향 분석
3. **에러 처리 일관성**: 현재 각 서버별로 다른 에러 처리 방식의 통합 필요성 검토
4. **서비스 컨텍스트 통합**: `getServiceContext` 메서드와 새로운 응답 구조 간의 일관성 확보 방안

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **풍부한 LLM 응답**: 모든 도구의 `result.content`에 LLM이 활용할 수 있는 상세한 정보 포함
2. **완전한 하위 호환성**: 기존 클라이언트 코드 변경 없이 정상 작동
3. **타입 안전성**: 구조화된 데이터에 대한 정확한 타입 추론 제공
4. **일관된 응답 형식**: 모든 Web MCP 서버에서 동일한 응답 패턴 적용

### 구체적 검증 방법

- ResourceAttachmentContext에서 `server.listContent({ storeId }).contents` 접근 시 정상 동작
- LLM Agent가 `listContent` 결과로부터 파일 목록과 메타데이터 정보 획득 가능
- `keywordSimilaritySearch` 결과에서 검색 컨텍스트와 스코어 정보 확인 가능
- Planning 서버의 모든 도구에서 상태 변경 내역과 현재 상태 정보 제공

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 타입 정의 확장 (`src/lib/mcp-types.ts`)

```typescript
// 추가할 타입 정의
export interface NativeMCPResponse<T = unknown> extends MCPResponse {
  structuredResult?: T;
}

// WebMCPMessage 타입도 NativeMCPResponse 지원하도록 확장
export interface WebMCPWorkerResponse<T = unknown>
  extends NativeMCPResponse<T> {
  // Worker 내부 통신용 확장 필드 (필요시)
}
```

### 2. Content-Store 서버 응답 개선 (`src/lib/web-mcp/modules/content-store/server.ts`)

```typescript
// listContent 응답 개선
const fileListText =
  summaries.length > 0
    ? summaries
        .map(
          (c, index) =>
            `${index + 1}. ${c.filename} (${(c.size / 1024).toFixed(1)}KB, ${c.lineCount} lines)
       Type: ${c.mimeType} | ID: ${c.contentId}
       Uploaded: ${new Date(c.uploadedAt).toLocaleDateString()}
       Preview: ${c.preview.substring(0, 150)}...`,
        )
        .join('\n\n')
    : 'No files found in this store.';

// keywordSimilaritySearch 응답 개선
const searchResultsText = results
  .map(
    (r, index) =>
      `${index + 1}. ${r.filename}:${r.lineRange[0]}-${r.lineRange[1]} (relevance: ${r.score.toFixed(2)})
   Match Type: ${r.relevanceType}
   Context: ${r.context.substring(0, 250)}...
   Content ID: ${r.contentId} | Chunk ID: ${r.chunkId}`,
  )
  .join('\n\n');
```

### 3. Planning 서버 일관성 개선 (`src/lib/web-mcp/modules/planning-server.ts`)

```typescript
// get_current_state 응답 개선
const stateText = `Current Planning State:

Goal: ${currentState.goal || 'No active goal set'}
${currentState.lastClearedGoal ? `Previous Goal: ${currentState.lastClearedGoal}` : ''}

Active Todos (${currentState.todos.filter((t) => t.status === 'pending').length}/${currentState.todos.length}):
${
  currentState.todos
    .map(
      (t) => `  ID:${t.id} [${t.status === 'completed' ? '✓' : ' '}] ${t.name}`,
    )
    .join('\n') || '  No todos created'
}

Recent Activity Log (${currentState.observations.length}/${MAX_OBSERVATIONS}):
${
  currentState.observations
    .map((obs, idx) => `  ${idx + 1}. ${obs}`)
    .join('\n') || '  No recent observations'
}

Next Actions: ${currentState.goal ? 'Continue with pending todos' : 'Create a goal to get started'}`;

return createMCPStructuredResponse(stateText, currentState);
```

### 4. Worker 응답 래핑 (`src/lib/web-mcp/mcp-worker.ts`)

```typescript
case 'callTool': {
  try {
    const result = await server.callTool(toolName, args);

    // NativeMCPResponse로 래핑하여 structuredResult 추가
    const nativeResponse: NativeMCPResponse<unknown> = {
      ...result,
      structuredResult: result.structuredContent || extractDataFromResult(result),
      id,
    };

    return nativeResponse;
  } catch (toolError) {
    // 에러 처리 로직 유지
  }
}

// structuredContent에서 실제 데이터 추출하는 헬퍼 함수
function extractDataFromResult(result: MCPResponse): unknown {
  if (result.structuredContent) {
    return result.structuredContent;
  }

  // content에서 JSON 파싱 시도
  if (result.result?.content?.[0]?.text) {
    try {
      return JSON.parse(result.result.content[0].text);
    } catch {
      return undefined;
    }
  }

  return undefined;
}
```

### 5. Proxy Unwrapping 로직 (`src/lib/web-mcp/mcp-proxy.ts`)

```typescript
private parseResponse<T = unknown>(
  response: NativeMCPResponse<T>,
  expectJson = false,
): T {
  // 새로운 우선순위 체계
  // 1. structuredResult (NativeMCPResponse의 핵심)
  if (response.structuredResult !== undefined) {
    return response.structuredResult;
  }

  // 2. 기존 structuredContent
  if (response.structuredContent !== undefined) {
    return response.structuredContent as T;
  }

  // 3. content 텍스트에서 JSON 파싱
  const result = toToolResult<T>(response);
  if (result.data !== undefined) {
    return result.data;
  }

  // 4. 텍스트 내용 (JSON 파싱 시도)
  if (result.text && expectJson) {
    try {
      return JSON.parse(result.text) as T;
    } catch {
      return result.text as unknown as T;
    }
  }

  return result.text as unknown as T || result.raw as unknown as T;
}

// callTool은 여전히 raw NativeMCPResponse 반환
async callTool(
  serverName: string,
  toolName: string,
  args: Record<string, unknown> = {},
): Promise<NativeMCPResponse<unknown>> {
  return this.sendMessage<NativeMCPResponse<unknown>>({
    type: 'callTool',
    serverName,
    toolName,
    args,
  });
}
```

## 재사용 가능한 연관 코드

### 핵심 파일 및 인터페이스

1. **타입 정의**: `src/lib/mcp-types.ts`
   - `MCPResponse`, `WebMCPMessage` 인터페이스
   - `NativeMCPResponse<T>` 새 타입 추가

2. **응답 유틸리티**: `src/lib/mcp-response-utils.ts`
   - `createMCPStructuredResponse()`, `createMCPTextResponse()` 함수
   - 일관된 응답 생성을 위한 헬퍼 함수들

3. **Tool Result 파싱**: `src/lib/web-mcp/tool-result.ts`
   - `toToolResult<T>()` 함수로 응답 파싱 로직 재사용

4. **서버 인터페이스**: `src/hooks/use-web-mcp-server.ts`
   - `WebMCPServerProxy` 타입 정의
   - 동적 프록시 생성 로직

### 재사용 가능한 응답 패턴

```typescript
// 표준 응답 생성 패턴
function createEnhancedResponse<T>(
  summaryText: string,
  structuredData: T,
  additionalContext?: string,
): MCPResponse {
  const enhancedText = additionalContext
    ? `${summaryText}\n\n${additionalContext}`
    : summaryText;

  return createMCPStructuredResponse(enhancedText, structuredData);
}

// 리스트 응답 포맷팅 헬퍼
function formatItemList<T>(
  items: T[],
  formatter: (item: T, index: number) => string,
  emptyMessage: string = 'No items found',
): string {
  return items.length > 0 ? items.map(formatter).join('\n\n') : emptyMessage;
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가

1. **NativeMCPResponse 타입 테스트**

   ```typescript
   // tests/lib/mcp-types.test.ts
   describe('NativeMCPResponse', () => {
     it('should extend MCPResponse with structuredResult', () => {
       const response: NativeMCPResponse<{ data: string }> = {
         jsonrpc: '2.0',
         id: 'test',
         result: { content: [{ type: 'text', text: 'test' }] },
         structuredResult: { data: 'test' },
       };
       expect(response.structuredResult).toEqual({ data: 'test' });
     });
   });
   ```

2. **Proxy 응답 파싱 테스트**

   ```typescript
   // tests/lib/web-mcp/mcp-proxy.test.ts
   describe('WebMCPProxy.parseResponse', () => {
     it('should prioritize structuredResult over other data', () => {
       // structuredResult 우선순위 테스트
     });

     it('should maintain backward compatibility', () => {
       // 기존 응답 형식 호환성 테스트
     });
   });
   ```

### 통합 테스트 수정

1. **ResourceAttachmentContext 호환성 테스트**

   ```typescript
   // tests/context/ResourceAttachmentContext.test.ts
   describe('ResourceAttachmentProvider', () => {
     it('should receive listContent results in expected format', async () => {
       // server.listContent({ storeId }).contents 접근 패턴 테스트
     });
   });
   ```

2. **End-to-End 서버 응답 테스트**

   ```typescript
   // tests/integration/web-mcp-servers.test.ts
   describe('Web MCP Servers Integration', () => {
     it('should provide rich text content for LLM consumption', () => {
       // LLM용 풍부한 텍스트 응답 검증
     });

     it('should provide structured data for UI components', () => {
       // UI용 구조화된 데이터 접근 검증
     });
   });
   ```

### 테스트 시나리오

1. **하위 호환성 검증**: 기존 클라이언트 코드가 수정 없이 동작하는지 확인
2. **응답 품질 검증**: LLM이 활용할 수 있는 충분한 정보가 포함되었는지 확인
3. **타입 안전성 검증**: 구조화된 데이터 접근 시 올바른 타입 추론이 되는지 확인
4. **성능 영향 검증**: 응답 크기 증가가 성능에 미치는 영향 측정
