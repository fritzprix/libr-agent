# MCP Server Management Architecture Refactoring

**Date:** 2025-11-01 14:00  
**Author:** Development Team  
**Status:** Planning

---

## 목적 (Purpose)

MCP 서버 설정을 독립적인 엔티티로 분리하여 관리의 유연성과 재사용성을 향상시킨다. 현재 Assistant가 MCP 설정을 직접 embedding하는 구조를 개선하여, MCP 서버를 중앙에서 관리하고 Assistant는 참조만 하도록 변경한다.

**주요 목표:**

- MCP 서버 설정의 중복 제거 및 중앙 관리
- Assistant 편집 UI 단순화 (MCP 설정 분리)
- MCP 서버 관리 전용 UI 제공 (Settings)
- 확장 가능한 MCP 서버 선택 인터페이스

---

## 현재 상태 / 문제점

### 현재 구조

```typescript
// Assistant가 MCPConfig를 직접 포함
interface Assistant {
  id?: string;
  name: string;
  systemPrompt: string;
  mcpConfig: MCPConfig; // ❌ 전체 설정 embedding
  // ...
}

interface MCPConfig {
  mcpServers?: Record<string, MCPServerConfigV2 | LegacyMCPServerConfig>;
}
```

### 문제점

1. **중복 저장**: 여러 Assistant가 동일한 MCP 서버 설정을 중복 저장

   ```typescript
   // Assistant A
   { mcpConfig: { mcpServers: { filesystem: {...} } } }

   // Assistant B (동일한 filesystem 설정 중복)
   { mcpConfig: { mcpServers: { filesystem: {...} } } }
   ```

2. **유지보수 어려움**: MCP 서버 설정 변경 시 모든 Assistant를 찾아 업데이트 필요

3. **UI 복잡도**: Assistant 편집 = MCP 전체 설정 편집
   - `MCPConfigEditor` 컴포넌트가 JSON 텍스트 편집
   - 사용자가 MCP 프로토콜 스펙을 이해해야 함

4. **관리 기능 부족**:
   - MCP 서버 목록 조회 불가
   - 서버별 활성화/비활성화 불가
   - 서버 재사용 어려움

### 데이터 흐름 (현재)

```
AssistantEditor
  ├─ MCPConfigEditor (JSON 텍스트)
  │   └─ assistant.mcpConfig 직접 수정
  │
  └─ AssistantContext.saveAssistant()
      └─ IndexedDB에 전체 assistant 저장 (mcpConfig 포함)

ChatContext
  └─ MCPServerContext.connectServers(assistant.mcpConfig)
      └─ Rust Backend: list_tools_from_config()
          └─ MCP 서버 프로세스 spawn
```

---

## 변경 후 상태 / 해결 판정 기준

### 새로운 구조

```typescript
// MCP 서버를 독립적인 엔티티로
interface MCPServerEntity {
  // DB metadata
  id: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;

  // MCP protocol spec
  name: string;
  transport: TransportConfig;
  authentication?: OAuthConfig;
  metadata?: ServerMetadata;
}

// Assistant는 MCP 서버 ID만 참조
interface Assistant {
  id?: string;
  name: string;
  systemPrompt: string;
  mcpServerIds?: string[]; // ✅ ID 배열만 저장
  // ...
}
```

### 데이터 흐름 (변경 후)

```
Settings > MCPServerManagement
  ├─ MCP 서버 목록 표시 (pagination)
  ├─ MCPServerDialog로 개별 서버 편집
  └─ MCPServerRegistryContext
      └─ IndexedDB mcpServers 테이블

AssistantEditor
  ├─ 활성 MCP 서버 목록 조회
  ├─ Checkbox로 서버 선택/해제
  └─ assistant.mcpServerIds 업데이트

ChatContext
  └─ MCPServerContext.connectServersFromAssistant(assistant)
      ├─ assistant.mcpServerIds로 DB 조회
      ├─ MCPServerEntity[] → MCPConfig 변환
      └─ Rust Backend: list_tools_from_config()
```

### 성공 판정 기준

✅ **기능적 요구사항**

- [ ] Settings에서 MCP 서버 CRUD 가능
- [ ] MCP 서버 활성화/비활성화 토글 가능
- [ ] Assistant 편집 시 활성 서버 목록에서 선택 가능
- [ ] 선택된 MCP 서버들이 Chat에서 정상 작동
- [ ] Pagination으로 다수의 MCP 서버 관리 가능

✅ **비기능적 요구사항**

- [ ] 중복 데이터 제거 (MCP 설정 단일 저장소)
- [ ] Assistant 편집 UI 단순화 (JSON 편집 제거)
- [ ] 검색 기능으로 서버 필터링 가능
- [ ] DB Schema 단일 버전으로 단순화

---

## 관련 코드 구조 및 동작 방식 (Birdeye View)

### 현재 아키텍처

```
Frontend (React)
├─ Context Layer
│   ├─ AssistantContext
│   │   ├─ currentAssistant (includes mcpConfig)
│   │   └─ saveAssistant() → IndexedDB
│   │
│   └─ MCPServerContext
│       ├─ connectServers(mcpConfig)
│       └─ executeToolCall()
│
├─ UI Layer
│   ├─ AssistantEditor
│   │   ├─ MCPConfigEditor (JSON 텍스트)
│   │   └─ EditorContext
│   │
│   └─ SettingsPage
│       └─ API Key Settings only
│
└─ Database Layer
    └─ IndexedDB (Dexie)
        ├─ assistants (includes mcpConfig)
        ├─ sessions
        └─ messages

Backend (Rust)
└─ MCP Commands
    └─ list_tools_from_config(MCPConfig)
        ├─ Parse V1/V2 configs
        ├─ Spawn MCP server processes
        └─ List tools from servers
```

### 새로운 아키텍처

```
Frontend (React)
├─ Context Layer
│   ├─ MCPServerRegistryContext ✅ NEW
│   │   ├─ allServers, activeServers
│   │   ├─ Pagination support (SWRInfinite 패턴 재사용)
│   │   └─ CRUD operations
│   │
│   ├─ AssistantContext (modified)
│   │   ├─ currentAssistant (mcpServerIds only)
│   │   └─ saveAssistant()
│   │
│   └─ MCPServerContext (modified)
│       ├─ connectServersFromAssistant(assistant)
│       │   └─ Load MCPServerEntity by IDs
│       └─ executeToolCall()
│
├─ UI Layer
│   ├─ Settings
│   │   └─ MCPServerManagement ✅ NEW
│   │       ├─ Server list (pagination)
│   │       ├─ Add/Edit/Delete buttons
│   │       └─ MCPServerDialog
│   │           └─ Transport-specific forms
│   │
│   └─ AssistantEditor (simplified)
│       ├─ Server selection (checkboxes)
│       ├─ Search filter
│       └─ NO MCPConfigEditor
│
└─ Database Layer
    └─ IndexedDB (Dexie)
        ├─ assistants (mcpServerIds only)
        ├─ mcpServers ✅ NEW
        ├─ sessions
        └─ messages

Backend (Rust)
└─ MCP Commands (unchanged)
    └─ list_tools_from_config(MCPConfig)
```

---

## 수정이 필요한 코드 및 코드 스니핏

### Phase 1: 타입 정의

#### 1.1 MCPServerEntity 추가

**파일:** `src/models/chat.ts`

```typescript
// 추가: MCP 서버 엔티티
export interface MCPServerEntity {
  // Database metadata
  id: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;

  // MCP Protocol spec (from MCPServerConfigV2)
  name: string;
  transport: TransportConfig;
  authentication?: OAuthConfig;
  metadata?: ServerMetadata;
}
```

#### 1.2 Assistant 타입 수정

**파일:** `src/models/chat.ts`

```typescript
// 수정: mcpConfig 제거, mcpServerIds 추가
export interface Assistant {
  id?: string;
  name: string;
  description?: string;
  avatar?: string;
  systemPrompt: string;

  mcpServerIds?: string[]; // ✅ 추가
  // mcpConfig: MCPConfig;  // ❌ 제거

  localServices?: string[];
  allowedBuiltInServiceAliases?: string[];
  isDefault: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

### Phase 2: Database Schema

#### 2.1 Schema 단순화 및 mcpServers 테이블 추가

**파일:** `src/lib/db/service.ts`

````typescript
// 수정: 단일 버전으로 squash
constructor() {
  super('MCPAgentDB');

  this.version(1).stores({
    assistants: '&id, createdAt, updatedAt, name',
    mcpServers: '&id, name, createdAt, updatedAt, isActive',  // ✅ 추가
    sessions: '&id, createdAt, updatedAt',
    messages: '&id, sessionId, [sessionId+threadId], createdAt',
    playbooks: '&id, agentId, createdAt, updatedAt, goal',
    objects: '&key, createdAt, updatedAt',
  });
}

// Table 선언 추가
#### 4.1 MCPServerManagement 생성
**파일:** `src/features/settings/MCPServerManagement.tsx` (신규)

```typescript
import { useMemo, useState } from 'react';
import useSWRInfinite from 'swr/infinite';
import { Plus } from 'lucide-react';
import { createId } from '@paralleldrive/cuid2';
import { MCPServerEntity } from '@/models/chat';
import { dbService } from '@/lib/db/service';
import { useMCPServerRegistry } from '@/context/MCPServerRegistryContext';
import { Button, Card, CardHeader, CardTitle, CardContent } from '@/components/ui';
import { MCPServerDialog } from './MCPServerDialog';

export function MCPServerManagement() {
  const { saveServer, deleteServer, toggleActive } = useMCPServerRegistry();

  // Follow SessionContext pattern: useSWRInfinite + Page<T>
  const { data, isLoading, isValidating, setSize } = useSWRInfinite(
    (pageIndex) => ['mcpServers', pageIndex],
    async ([, pageIndex]) => {
      // getPage is 1-based; pass pageIndex + 1
      return dbService.mcpServers.getPage(pageIndex + 1, 10);
    },
  );

  const pages = data ?? [];
  const servers = useMemo(() => pages.flatMap((p) => p.items), [pages]);
  const hasNextPage = useMemo(
    () => !(pages.length > 0 && !pages[pages.length - 1].hasNextPage),
    [pages],
  );

  const [editingServer, setEditingServer] = useState<MCPServerEntity | null>(
    null,
  );

  const handleCreateNew = () => {
    const newServer: MCPServerEntity = {
      id: createId(),
      name: 'New Server',
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      transport: {
        type: 'stdio',
        command: 'npx',
        args: [],
      },
    };
    setEditingServer(newServer);
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold">MCP Server Management</h2>
        <Button onClick={handleCreateNew}>
          <Plus className="w-4 h-4 mr-2" />
          Add Server
        </Button>
      </div>

      {isLoading ? (
        <div>Loading...</div>
      ) : (
        <>
          <div className="grid gap-4">
            {servers.map((server) => (
              <Card key={server.id}>
                <CardHeader className="flex flex-row items-center justify-between">
                  <div className="flex-1">
                    <CardTitle>{server.name}</CardTitle>
                    <p className="text-sm text-muted-foreground">
                      {server.metadata?.description || 'No description'}
                    </p>
                  </div>
                  <Switch
                    checked={server.isActive}
                    onCheckedChange={(checked) =>
                      toggleActive(server.id, checked)
                    }
                  />
                </CardHeader>
                <CardContent>
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setEditingServer(server)}
                    >
                      Edit
                    </Button>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => {
                        if (confirm(`Delete server "${server.name}"?`)) {
                          deleteServer(server.id);
                        }
                      }}
                    >
                      Delete
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>

          {hasNextPage && (
            <div className="flex justify-center pt-2">
              <Button
                variant="outline"
                disabled={isValidating}
                onClick={() => setSize((s) => s + 1)}
              >
                {isValidating ? 'Loading…' : 'Load more'}
              </Button>
            </div>
          )}
        </>
      )}

      {editingServer && (
        <MCPServerDialog
          server={editingServer}
          onSave={async (server) => {
            await saveServer(server);
            setEditingServer(null);
          }}
          onCancel={() => setEditingServer(null)}
        />
      )}
    </div>
  );
}
````

// Pagination (Settings용)
servers: MCPServerEntity[];
currentPage: number;
totalPages: number;
pageSize: number;
loading: boolean;
error?: string;

// Actions
loadPage: (page: number) => Promise<void>;
saveServer: (server: MCPServerEntity) => Promise<void>;
deleteServer: (id: string) => Promise<void>;
toggleActive: (id: string, active: boolean) => Promise<void>;
refreshAll: () => Promise<void>;
}

const MCPServerRegistryContext = createContext<MCPServerRegistryContextType | undefined>(undefined);

export const MCPServerRegistryProvider = ({ children }: { children: React.ReactNode }) => {
const [allServers, setAllServers] = useState<MCPServerEntity[]>([]);
const [servers, setServers] = useState<MCPServerEntity[]>([]);
const [currentPage, setCurrentPage] = useState(1);
const [pageSize] = useState(10);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string>();

// 전체 서버 로드 (캐시)
const refreshAll = useCallback(async () => {
try {
const all = await dbUtils.getAllMCPServers();
setAllServers(all);
} catch (err) {
logger.error('Failed to load all servers', err);
setError(err instanceof Error ? err.message : 'Unknown error');
}
}, []);

// Pagination 로드
const loadPage = useCallback(async (page: number) => {
setLoading(true);
try {
const result = await dbService.mcpServers.getPage(page, pageSize);
setServers(result.items);
setCurrentPage(page);
setError(undefined);
} catch (err) {
logger.error('Failed to load page', err);
setError(err instanceof Error ? err.message : 'Unknown error');
} finally {
setLoading(false);
}
}, [pageSize]);

const saveServer = useCallback(async (server: MCPServerEntity) => {
await dbService.mcpServers.upsert(server);
await refreshAll();
await loadPage(currentPage);
}, [refreshAll, loadPage, currentPage]);

const deleteServer = useCallback(async (id: string) => {
await dbService.mcpServers.delete(id);
await refreshAll();
await loadPage(currentPage);
}, [refreshAll, loadPage, currentPage]);

const toggleActive = useCallback(async (id: string, active: boolean) => {
const server = allServers.find(s => s.id === id);
if (server) {
await saveServer({ ...server, isActive: active });
}
}, [allServers, saveServer]);

const activeServers = useMemo(
() => allServers.filter(s => s.isActive),
[allServers]
);

const totalPages = useMemo(
() => Math.ceil(allServers.length / pageSize),
[allServers.length, pageSize]
);

// 초기 로드
useEffect(() => {
refreshAll();
loadPage(1);
}, [refreshAll, loadPage]);

return (
<MCPServerRegistryContext.Provider value={{
      allServers,
      activeServers,
      servers,
      currentPage,
      totalPages,
      pageSize,
      loading,
      error,
      loadPage,
      saveServer,
      deleteServer,
      toggleActive,
      refreshAll,
    }}>
{children}
</MCPServerRegistryContext.Provider>
);
};

export function useMCPServerRegistry() {
const context = useContext(MCPServerRegistryContext);
if (!context) {
throw new Error('useMCPServerRegistry must be used within MCPServerRegistryProvider');
}
return context;
}

````

#### 3.x 캐시 무효화 전략 (SWR + 이벤트)

레지스트리 변경 시 다음을 수행해 목록/선택/연결 상태를 일관성 있게 갱신합니다.

- 목록 UI(Settings): SWR 키 `['mcpServers', pageIndex]` 전역 무효화 → useSWRInfinite가 재검증
- 선택 UI(AssistantEditor): 레지스트리 컨텍스트의 `allServers/activeServers`를 즉시 새로고침
- 연결 상태(Chat): 현재 Assistant가 참조하는 서버에 영향이 있는 경우 재연결 트리거

구현 요지:

```typescript
// src/context/MCPServerRegistryContext.tsx
import { mutate } from 'swr';

const invalidateMCPServerPages = async () => {
  await mutate((key) => Array.isArray(key) && key[0] === 'mcpServers');
};

const broadcastChange = () => {
  if (typeof window !== 'undefined') {
    try {
      window.dispatchEvent(new CustomEvent('libragent:mcp-servers-changed'));
    } catch {}
  }
};

const saveServer = useCallback(async (server: MCPServerEntity) => {
  await dbService.mcpServers.upsert(server);
  await refreshAll();
  await invalidateMCPServerPages();
  broadcastChange();
}, [refreshAll]);

const deleteServer = useCallback(async (id: string) => {
  await dbService.mcpServers.delete(id);
  await refreshAll();
  await invalidateMCPServerPages();
  broadcastChange();
}, [refreshAll]);

const toggleActive = useCallback(async (id: string, active: boolean) => {
  const found = allServers.find((s) => s.id === id);
  if (!found) return;
  await saveServer({ ...found, isActive: active });
  await invalidateMCPServerPages();
  broadcastChange();
}, [allServers, saveServer]);
````

```typescript
// src/context/AssistantContext.tsx (연결 재시도)
useEffect(() => {
  const handler = () => {
    const cur = currentAssistantRef.current;
    if (cur) {
      connectServersFromAssistant(cur);
    }
  };
  window.addEventListener('libragent:mcp-servers-changed', handler);
  return () =>
    window.removeEventListener('libragent:mcp-servers-changed', handler);
}, [connectServersFromAssistant]);
```

```typescript
// src/features/settings/MCPServerManagement.tsx
// 별도 무효화 호출 불필요 — RegistryContext가 mutate 전파, 여기서는 useSWRInfinite가 자동 재검증
```

#### 3.2 MCPServerContext 수정

**파일:** `src/context/MCPServerContext.tsx`

```typescript
// 수정: connectServers 대신 connectServersFromAssistant
const connectServersFromAssistant = useCallback(
  async (assistant: Assistant) => {
    setError(undefined);

    if (!assistant.mcpServerIds || assistant.mcpServerIds.length === 0) {
      setAvailableTools([]);
      setServerStatus({});
      return;
    }

    try {
      // 1. DB에서 서버 엔티티 조회
      const entities = await dbUtils.getMCPServersByIds(assistant.mcpServerIds);

      // 2. 활성화된 서버만 필터링
      const activeEntities = entities.filter((e) => e.isActive);

      if (activeEntities.length === 0) {
        setAvailableTools([]);
        setServerStatus({});
        return;
      }

      // 3. MCPConfig 구성 (DB metadata 제외)
      const mcpConfig: MCPConfig = {
        mcpServers: Object.fromEntries(
          activeEntities.map((entity) => [
            entity.name,
            {
              name: entity.name,
              transport: entity.transport,
              authentication: entity.authentication,
              metadata: entity.metadata,
            } as MCPServerConfigV2,
          ]),
        ),
      };

      // 4. 기존 로직 실행
      const serverStatus: Record<string, boolean> = {};
      Object.keys(mcpConfig.mcpServers).forEach((name) => {
        serverStatus[name] = false;
      });

      setServerStatus(serverStatus);
      const rawToolsByServer = await listToolsFromConfig(mcpConfig);
      toolsByServer.current = rawToolsByServer;

      const availableTools: MCPTool[] = Object.entries(
        rawToolsByServer,
      ).flatMap(([serverName, tools]) => {
        if (!aliasToIdTableRef.current.has(serverName)) {
          aliasToIdTableRef.current.set(toValidJsName(serverName), serverName);
        }
        return tools.map((t) => ({
          ...t,
          name: `${toValidJsName(serverName)}__${t.name}`,
        }));
      });

      setAvailableTools(availableTools);

      const connectedServers = await getConnectedServers();
      for (const serverName of connectedServers) {
        if (Object.prototype.hasOwnProperty.call(serverStatus, serverName)) {
          serverStatus[serverName] = true;
        }
      }
      setServerStatus({ ...serverStatus });

      logger.debug(
        `Total tools loaded: ${availableTools.length} across ${Object.keys(rawToolsByServer).length} servers`,
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      setError(errorMessage);
      logger.error('Error connecting servers from assistant:', { error });
      setAvailableTools([]);
      setServerStatus({});
    }
  },
  [listToolsFromConfig, getConnectedServers],
);

// Context value 업데이트
const value: MCPServerContextType = useMemo(
  () => ({
    availableTools,
    isLoading,
    error,
    getAvailableTools,
    status: serverStatus,
    connectServersFromAssistant, // ✅ 변경
    executeToolCall,
    sampleFromModel,
  }),
  [
    availableTools,
    isLoading,
    error,
    serverStatus,
    getAvailableTools,
    connectServersFromAssistant, // ✅ 변경
    executeToolCall,
    sampleFromModel,
  ],
);
```

#### 3.3 AssistantContext 수정

**파일:** `src/context/AssistantContext.tsx`

```typescript
// 수정: connectServers → connectServersFromAssistant
const { connectServersFromAssistant } = useMCPServer();

useEffect(() => {
  currentAssistantRef.current = currentAssistant;
  if (currentAssistant) {
    connectServersFromAssistant(currentAssistant); // ✅ 변경
  }
}, [currentAssistant, connectServersFromAssistant]);
```

### Phase 4: UI Components

#### 4.1 MCPServerManagement 생성

**파일:** `src/features/settings/MCPServerManagement.tsx` (신규)

```typescript
import { useState } from 'react';
import { Plus } from 'lucide-react';
import { createId } from '@paralleldrive/cuid2';
import { MCPServerEntity } from '@/models/chat';
import { useMCPServerRegistry } from '@/context/MCPServerRegistryContext';
import { Button, Card, CardHeader, CardTitle, CardContent } from '@/components/ui';
import { MCPServerDialog } from './MCPServerDialog';
import { Pagination } from '@/components/ui/pagination';

export function MCPServerManagement() {
  const {
    servers,
    currentPage,
    totalPages,
    loading,
    loadPage,
    saveServer,
    deleteServer,
    toggleActive,
  } = useMCPServerRegistry();

  const [editingServer, setEditingServer] = useState<MCPServerEntity | null>(null);

  const handleCreateNew = () => {
    const newServer: MCPServerEntity = {
      id: createId(),
      name: 'New Server',
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      transport: {
        type: 'stdio',
        command: 'npx',
        args: [],
      },
    };
    setEditingServer(newServer);
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold">MCP Server Management</h2>
        <Button onClick={handleCreateNew}>
          <Plus className="w-4 h-4 mr-2" />
          Add Server
        </Button>
      </div>

      {loading ? (
        <div>Loading...</div>
      ) : (
        <>
          <div className="grid gap-4">
            {servers.map(server => (
              <Card key={server.id}>
                <CardHeader className="flex flex-row items-center justify-between">
                  <div className="flex-1">
                    <CardTitle>{server.name}</CardTitle>
                    <p className="text-sm text-muted-foreground">
                      {server.metadata?.description || 'No description'}
                    </p>
                  </div>
                  <Switch
                    checked={server.isActive}
                    onCheckedChange={(checked) => toggleActive(server.id, checked)}
                  />
                </CardHeader>
                <CardContent>
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setEditingServer(server)}
                    >
                      Edit
                    </Button>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => {
                        if (confirm(`Delete server "${server.name}"?`)) {
                          deleteServer(server.id);
                        }
                      }}
                    >
                      Delete
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>

          {totalPages > 1 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={loadPage}
            />
          )}
        </>
      )}

      {editingServer && (
        <MCPServerDialog
          server={editingServer}
          onSave={async (server) => {
            await saveServer(server);
            setEditingServer(null);
          }}
          onCancel={() => setEditingServer(null)}
        />
      )}
    </div>
  );
}
```

#### 4.2 MCPServerDialog 생성

**파일:** `src/features/settings/MCPServerDialog.tsx` (신규)

```typescript
import { useState } from 'react';
import { MCPServerEntity } from '@/models/chat';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  Button,
  InputWithLabel,
  TextareaWithLabel,
  Select,
  SelectTrigger,
  SelectValue,
  SelectContent,
  SelectItem,
} from '@/components/ui';

interface MCPServerDialogProps {
  server: MCPServerEntity;
  onSave: (server: MCPServerEntity) => Promise<void>;
  onCancel: () => void;
}

export function MCPServerDialog({ server, onSave, onCancel }: MCPServerDialogProps) {
  const [draft, setDraft] = useState(server);

  return (
    <Dialog open onOpenChange={onCancel}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>
            {server.id ? 'Edit MCP Server' : 'Add MCP Server'}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <InputWithLabel
            label="Server Name *"
            value={draft.name}
            onChange={(e) => setDraft({ ...draft, name: e.target.value })}
            placeholder="e.g., filesystem, github"
          />

          <TextareaWithLabel
            label="Description"
            value={draft.metadata?.description || ''}
            onChange={(e) => setDraft({
              ...draft,
              metadata: { ...draft.metadata, description: e.target.value }
            })}
            placeholder="Optional description for this server"
          />

          <div>
            <label className="block text-sm font-medium mb-2">Transport Type *</label>
            <Select
              value={draft.transport.type}
              onValueChange={(type: 'stdio' | 'http') => {
                if (type === 'stdio') {
                  setDraft({
                    ...draft,
                    transport: { type: 'stdio', command: '', args: [] }
                  });
                } else {
                  setDraft({
                    ...draft,
                    transport: { type: 'http', url: '' }
                  });
                }
              }}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="stdio">stdio</SelectItem>
                <SelectItem value="http">http</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {draft.transport.type === 'stdio' && (
            <>
              <InputWithLabel
                label="Command *"
                value={draft.transport.command}
                onChange={(e) => setDraft({
                  ...draft,
                  transport: { ...draft.transport, command: e.target.value }
                })}
                placeholder="e.g., npx, node, python"
              />

              <InputWithLabel
                label="Arguments"
                value={draft.transport.args?.join(' ') || ''}
                onChange={(e) => setDraft({
                  ...draft,
                  transport: {
                    ...draft.transport,
                    args: e.target.value.split(' ').filter(Boolean)
                  }
                })}
                placeholder="e.g., -y @modelcontextprotocol/server-filesystem /tmp"
              />
            </>
          )}

          {draft.transport.type === 'http' && (
            <InputWithLabel
              label="URL *"
              value={draft.transport.url}
              onChange={(e) => setDraft({
                ...draft,
                transport: { ...draft.transport, url: e.target.value }
              })}
              placeholder="https://api.example.com/mcp"
            />
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button
            onClick={() => onSave(draft)}
            disabled={!draft.name || (draft.transport.type === 'stdio' && !draft.transport.command)}
          >
            Save
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

#### 4.3 AssistantEditor 수정

**파일:** `src/features/assistant/AssistantEditor.tsx`

```typescript
// 수정: MCPConfigEditor 제거, 서버 선택 UI 추가
import { useState, useEffect } from 'react';
import { useEditor } from '@/context/EditorContext';
import { Assistant } from '@/models/chat';
import { useMCPServerRegistry } from '@/context/MCPServerRegistryContext';
import { Checkbox, Input } from '@/components/ui';

export default function AssistantEditor() {
  const { draft, update } = useEditor<Assistant>();
  const { activeServers } = useMCPServerRegistry();
  const [searchQuery, setSearchQuery] = useState('');

  const filteredServers = activeServers.filter(s =>
    s.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    s.metadata?.description?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleServerToggle = (serverId: string, enabled: boolean) => {
    update((draft) => {
      if (!draft.mcpServerIds) draft.mcpServerIds = [];

      if (enabled) {
        if (!draft.mcpServerIds.includes(serverId)) {
          draft.mcpServerIds.push(serverId);
        }
      } else {
        draft.mcpServerIds = draft.mcpServerIds.filter(id => id !== serverId);
      }
    });
  };

  return (
    <div className="w-full p-4 space-y-4">
      <InputWithLabel
        label="Assistant Name *"
        value={draft?.name || ''}
        onChange={(e) => update((draft) => { draft.name = e.target.value; })}
        placeholder="Enter assistant name..."
      />

      <TextareaWithLabel
        label="System Prompt *"
        value={draft?.systemPrompt || ''}
        onChange={(e) => update((draft) => { draft.systemPrompt = e.target.value; })}
        placeholder="Describe the AI's role and behavior..."
        className="h-32"
      />

      <BuiltInToolsEditor />
      <LocalServicesEditor />

      {/* ✅ MCP 서버 선택 UI (MCPConfigEditor 대체) */}
      <div>
        <label className="block text-sm font-medium mb-2">
          MCP Servers
        </label>

        {activeServers.length === 0 ? (
          <p className="text-sm text-muted-foreground">
            No active MCP servers. <Link to="/settings">Add servers in Settings</Link>
          </p>
        ) : (
          <>
            <Input
              placeholder="Search servers..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="mb-2"
            />

            <div className="max-h-64 overflow-y-auto border rounded-md p-2 space-y-2">
              {filteredServers.map(server => (
                <div
                  key={server.id}
                  className="flex items-start gap-2 p-2 hover:bg-accent rounded"
                >
                  <Checkbox
                    checked={draft.mcpServerIds?.includes(server.id) || false}
                    onCheckedChange={(checked) =>
                      handleServerToggle(server.id, checked as boolean)
                    }
                  />
                  <div className="flex-1">
                    <div className="font-medium">{server.name}</div>
                    {server.metadata?.description && (
                      <div className="text-xs text-muted-foreground">
                        {server.metadata.description}
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </>
        )}
      </div>
    </div>
  );
}

// ❌ MCPConfigEditor 컴포넌트 사용 제거
```

#### 4.4 SettingsPage 탭 추가

**파일:** `src/features/settings/SettingsPage.tsx`

```typescript
// 추가: MCP Servers 탭
import { MCPServerManagement } from './MCPServerManagement';

<Tabs defaultValue="api-key">
  <TabsList>
    <TabsTrigger value="api-key">API Keys</TabsTrigger>
    <TabsTrigger value="mcp-servers">MCP Servers</TabsTrigger>  {/* ✅ 추가 */}
    <TabsTrigger value="conversation-model">Conversation & Model</TabsTrigger>
    <TabsTrigger value="data-reset">Data & Reset</TabsTrigger>
  </TabsList>

  <TabsContent value="mcp-servers">
    <MCPServerManagement />  {/* ✅ 추가 */}
  </TabsContent>

  {/* ... 기존 탭들 */}
</Tabs>
```

### Phase 5: Provider 구조 업데이트

#### 5.1 App.tsx Provider 추가

**파일:** `src/app/App.tsx`

```typescript
// 추가: MCPServerRegistryProvider
import { MCPServerRegistryProvider } from '@/context/MCPServerRegistryContext';

<MCPServerRegistryProvider>  {/* ✅ 추가 */}
  <AssistantContextProvider>
    <MCPServerProvider>
      <WebMCPProvider>
        {/* ... 기존 컴포넌트들 */}
      </WebMCPProvider>
    </MCPServerProvider>
  </AssistantContextProvider>
</MCPServerRegistryProvider>
```

##### 권장 Provider 스택 (현재 구조 기반)

아래 순서는 현재 `App.tsx`의 실제 구성(첨부 코드 기준)을 따르며, `MCPServerRegistryProvider`의 정확한 위치를 명시합니다.

```
SettingsProvider
  └─ MCPServerRegistryProvider   ← 신규 (Registry CRUD/활성 목록/무효화 이벤트 제공)
      └─ MCPServerProvider       ← 런타임 MCP 연결(도구 로드/호출)
          └─ SystemPromptProvider
              └─ AssistantContextProvider
                  └─ SessionContextProvider
                      └─ BuiltInToolProvider
                          └─ WebMCPProvider
                              ├─ WebMCPServiceRegistry (servers=["planning","playbook","ui"])
                              ├─ BrowserToolProvider
                              └─ RustMCPToolProvider
                                  └─ SessionHistoryProvider
                                      └─ ResourceAttachmentProvider
                                          └─ ModelOptionsProvider
                                              └─ SidebarProvider
                                                  └─ DnDContextProvider
                                                      └─ App UI (Sidebar, Header, Routes, Toaster)
```

이유:

- Settings > MCP 서버 관리와 Assistant 서버 선택 UI가 레지스트리 컨텍스트를 사용하므로 앱 전반에서 접근 가능해야 합니다.
- AssistantContext는 `libragent:mcp-servers-changed` 이벤트를 구독해 재연결을 트리거하므로, 레지스트리와 MCPServerProvider 모두 상위에 존재해야 합니다.
- MCPServerProvider는 런타임 연결/도구 로딩을 담당하므로 레지스트리 변경(활성/비활성, CRUD) 이후 재연결 시나리오에 대응합니다.

##### App.tsx 적용 예시 (발췌)

```typescript
// src/app/App.tsx (excerpt)
import { MCPServerRegistryProvider } from '@/context/MCPServerRegistryContext';

function App() {
  return (
    <div className="h-screen w-full">
      <SettingsProvider>
        {/* ✅ 신규 Provider: 레지스트리 */}
        <MCPServerRegistryProvider>
          <MCPServerProvider>
            <SystemPromptProvider>
              <AssistantContextProvider>
                <SessionContextProvider>
                  <BuiltInToolProvider>
                    <WebMCPProvider>
                      <WebMCPServiceRegistry servers={["planning", "playbook", "ui"]} />
                      <BrowserToolProvider />
                      <RustMCPToolProvider />
                      <SessionHistoryProvider>
                        <ResourceAttachmentProvider>
                          <ModelOptionsProvider>
                            <SidebarProvider>
                              <DnDContextProvider>
                                {/* ... Sidebar, Header, Routes ... */}
                              </DnDContextProvider>
                            </SidebarProvider>
                            <Toaster />
                          </ModelOptionsProvider>
                        </ResourceAttachmentProvider>
                      </SessionHistoryProvider>
                    </WebMCPProvider>
                  </BuiltInToolProvider>
                </SessionContextProvider>
              </AssistantContextProvider>
            </SystemPromptProvider>
          </MCPServerProvider>
        </MCPServerRegistryProvider>
      </SettingsProvider>
    </div>
  );
}
```

---

## 재사용 가능한 연관 코드

### 기존 컴포넌트 재사용

**1. Pagination Component**

- **경로:** `src/components/ui/pagination.tsx` (필요시 생성)
- **용도:** MCPServerManagement에서 페이지네이션 UI

**2. Card Components**

- **경로:** `src/components/ui/card.tsx`
- **용도:** 서버 목록 표시

**3. Dialog Components**

- **경로:** `src/components/ui/dialog.tsx`
- **용도:** MCPServerDialog

**4. Form Components**

- **경로:** `src/components/ui/`
- **컴포넌트:** Input, Textarea, Select, Checkbox, Switch
- **용도:** 서버 편집 폼

### 유틸리티 함수

**1. ID 생성**

```typescript
import { createId } from '@paralleldrive/cuid2';
```

**2. Logger**

```typescript
import { getLogger } from '@/lib/logger';
const logger = getLogger('ComponentName');
```

**3. 이름 변환**

```typescript
import { toValidJsName } from '@/lib/utils';
```

---

## Test Code 가이드

### 단위 테스트

**1. CRUD Operations**

```typescript
// src/lib/db/crud.test.ts
describe('mcpServersCRUD', () => {
  it('should create a new MCP server', async () => {
    const server: MCPServerEntity = {
      id: 'test-id',
      name: 'test-server',
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      transport: { type: 'stdio', command: 'test' },
    };

    await mcpServersCRUD.upsert(server);
    const retrieved = await mcpServersCRUD.read('test-id');

    expect(retrieved).toBeDefined();
    expect(retrieved?.name).toBe('test-server');
  });

  it('should support pagination', async () => {
    const page = await mcpServersCRUD.getPage(1, 10);
    expect(page.items).toBeInstanceOf(Array);
    expect(page.page).toBe(1);
  });
});
```

**2. Context Operations**

```typescript
// src/context/MCPServerRegistryContext.test.tsx
describe('MCPServerRegistryContext', () => {
  it('should load all servers on mount', async () => {
    const { result } = renderHook(() => useMCPServerRegistry(), {
      wrapper: MCPServerRegistryProvider,
    });

    await waitFor(() => {
      expect(result.current.allServers).toBeDefined();
    });
  });

  it('should filter active servers', async () => {
    const { result } = renderHook(() => useMCPServerRegistry(), {
      wrapper: MCPServerRegistryProvider,
    });

    await waitFor(() => {
      const active = result.current.activeServers;
      expect(active.every((s) => s.isActive)).toBe(true);
    });
  });
});
```

### 통합 테스트

**1. Assistant MCP Server Connection**

```typescript
// src/context/AssistantContext.integration.test.tsx
describe('Assistant MCP Server Integration', () => {
  it('should connect MCP servers from assistant', async () => {
    // 1. MCP 서버 생성
    const server: MCPServerEntity = {
      /* ... */
    };
    await dbService.mcpServers.upsert(server);

    // 2. Assistant 생성 (서버 참조)
    const assistant: Assistant = {
      /* ... */
      mcpServerIds: [server.id],
    };

    // 3. Assistant 활성화
    const { result } = renderHook(() => useAssistantContext());
    act(() => {
      result.current.setCurrentAssistant(assistant);
    });

    // 4. MCP 도구 로드 확인
    await waitFor(() => {
      const { availableTools } = useMCPServer();
      expect(availableTools.length).toBeGreaterThan(0);
    });
  });
});
```

### E2E 테스트 시나리오

**1. MCP Server Management Flow**

```typescript
test('should manage MCP servers end-to-end', async () => {
  // 1. Settings 이동
  await page.goto('/settings');
  await page.click('[data-testid="mcp-servers-tab"]');

  // 2. 서버 추가
  await page.click('[data-testid="add-server-btn"]');
  await page.fill('[data-testid="server-name"]', 'test-server');
  await page.fill('[data-testid="command"]', 'npx');
  await page.click('[data-testid="save-btn"]');

  // 3. 서버 목록 확인
  const serverCard = await page.waitForSelector(
    '[data-testid="server-card-test-server"]',
  );
  expect(serverCard).toBeTruthy();

  // 4. Assistant에서 서버 선택
  await page.goto('/assistants');
  await page.click('[data-testid="create-assistant"]');
  await page.click('[data-testid="server-checkbox-test-server"]');
  await page.click('[data-testid="save-assistant"]');

  // 5. Chat에서 도구 사용 가능 확인
  // ...
});
```

---

## Clarification Q-list

### Q1: 기존 Assistant의 mcpConfig 마이그레이션

**질문:** 기존에 저장된 Assistant들의 `mcpConfig` 데이터를 어떻게 처리할 것인가?

**옵션:**

- A) 앱 시작 시 자동 마이그레이션 (한 번만 실행)
- B) 사용자에게 마이그레이션 프롬프트 표시
- C) 기존 데이터 무시 (새로 설정 필요)

**권장:** Option A (자동 마이그레이션)

- localStorage에 마이그레이션 완료 플래그 저장
- 한 번만 실행되도록 보장

**답변:** C 기존 데이터 무시

### Q2: MCP 서버 중복 처리

**질문:** 동일한 name을 가진 MCP 서버가 여러 개 생성될 수 있는가?

**옵션:**

- A) name을 unique constraint로 지정 (중복 불가)
- B) 중복 허용 (사용자 책임)
- C) 경고만 표시 (저장은 가능)

**권장:** Option A (중복 불가)

- DB schema에 unique index 추가
- 저장 시 중복 체크 및 에러 표시

**답변:** A 중복 불가

### Q3: MCP 서버 삭제 시 Assistant 처리

**질문:** 어떤 Assistant가 참조하는 MCP 서버를 삭제하려 할 때?

**옵션:**

- A) 삭제 불가 (참조 있음 경고)
- B) 강제 삭제 + Assistant의 참조 자동 제거
- C) Cascade delete (Assistant도 삭제)

**권장:** Option B (강제 삭제 + 참조 제거)

- 삭제 전 경고 메시지 표시
- 삭제 후 Assistant의 mcpServerIds에서 해당 ID 제거

**답변:** A 삭제 불가 / 참조 있음 경고

### Q4: Transport 타입별 세부 설정 UI

**질문:** HTTP Transport의 OAuth, SSE 등 고급 설정을 모두 UI로 제공할 것인가?

**옵션:**

- A) 모든 필드 UI 제공 (복잡)
- B) 기본 필드만 UI, 고급 설정은 JSON 편집
- C) Phase 1은 stdio만, Phase 2에서 HTTP 추가

**권장:** Option C (단계적 구현)

- Phase 1: stdio transport만 완전 지원
- Phase 2: HTTP transport 기본 필드
- Phase 3: OAuth/SSE 등 고급 기능

**답변:** C 우선 stdio만 지원

### Q5: Pagination vs Infinite Scroll

**질문:** MCP 서버 목록 UI에서 어떤 방식을 사용할 것인가?

**옵션:**

- A) Pagination (페이지 번호)
- B) Infinite Scroll
- C) Load More 버튼

**권장:** Option A (Pagination)

- 사용자가 현재 위치 파악 쉬움
- Settings 화면 특성상 적합
- 구현 단순
  **답변:** A Pagination

---

## 작업 순서 제안

1. **Phase 1-2 (Database)** - 1일
   - 타입 정의
   - DB Schema 추가
   - CRUD 구현

2. **Phase 3 (Context)** - 1일

- MCPServerRegistryContext
- MCPServerContext 수정
- AssistantContext 수정

3. **Phase 4 (UI - Settings)** - 1일
   - MCPServerManagement
   - MCPServerDialog
   - SettingsPage 탭 추가

4. **Phase 4 (UI - Assistant)** - 0.5일
   - AssistantEditor 수정
   - MCPConfigEditor 제거

5. **Phase 5 (Integration)** - 0.5일
   - Provider 구조 업데이트
   - 통합 테스트

6. **Testing & Polish** - 1일
   - 단위 테스트
   - 통합 테스트
   - 버그 수정

**총 예상 기간:** 5일

---

## 성공 메트릭

- [ ] MCP 서버 CRUD 동작 확인
- [ ] Assistant 편집에서 서버 선택 가능
- [ ] Chat에서 선택된 서버의 도구 사용 가능
- [ ] 중복 데이터 제거 확인 (DB 크기 감소)
- [ ] UI 복잡도 감소 (JSON 편집 제거)
- [ ] 모든 테스트 통과

---

## 추가 고려사항

### 성능

- IndexedDB 조회 최적화 (인덱스 활용)
- Context에서 불필요한 re-render 방지 (useMemo, useCallback)

### 보안

- MCP 서버 설정에 민감한 정보(API 키) 포함 시 암호화 고려

### UX

- 로딩 상태 표시 (Skeleton, Spinner)
- 에러 메시지 명확화
- 성공/실패 Toast 알림

### 확장성

- Future: MCP 서버 공유/Export 기능
- Future: 서버 템플릿 (preset configurations)
- Future: 서버 검색 및 필터링 (태그 시스템)
