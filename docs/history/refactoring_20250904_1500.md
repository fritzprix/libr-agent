# Workspace Export 기능 추가 (MCP-UI 기반) Refactoring Plan

## 작업의 목적

기존 WorkspaceServer에 **MCP-UI 기반 export 기능**을 추가하여 사용자가 작업 결과물을 직관적이고 우아한 방식으로 다운로드할 수 있도록 한다.

### 핵심 목표

- **MCP-UI UIResource 응답**: export 도구가 클릭 가능한 다운로드 링크가 포함된 HTML UI를 반환
- **개별 파일 Export**: workspace 내 단일 파일을 다운로드 가능한 형태로 제공
- **ZIP 패키지 Export**: 여러 파일을 구조화된 패키지로 묶어 제공
- **인터랙티브 UI**: 파일 목록, 다운로드 버튼, 메타데이터가 포함된 리치 UI 제공
- **기존 아키텍처 호환**: 현재 SecureFileManager 및 MCP-UI 체계와 완전 호환

## 현재의 상태 / 문제점

### 1. Export 기능 및 UI 한계

- **WorkspaceServer**: 파일 조작 및 코드 실행만 지원, export 기능 없음
- **텍스트 기반 응답**: MCP Tool 응답이 단순 텍스트로만 제공되어 사용자 경험 제한
- **수동 다운로드 프로세스**: 사용자가 별도 UI 조작을 통해 파일을 찾고 다운로드해야 함
- **워크플로우 단절**: 파일 생성 → 분석 → 결과 활용의 자연스러운 흐름 부족

### 2. UI 인터랙션 부족

- **정적 응답**: 현재 MCP Tool은 텍스트만 반환, 인터랙티브 요소 없음
- **MCP-UI 미활용**: UIResource 기반 리치 UI 응답 미사용
- **직접 액션 불가**: 응답 내에서 바로 다운로드하거나 추가 작업 수행 불가

### 2. 다운로드 메커니즘 한계

- **기존 read_file 명령어**: workspace 파일 읽기용, 다운로드 목적 아님
- **Direct URL 제공 불가**: Tauri asset protocol 미구성으로 파일 URL 직접 제공 어려움
- **ZIP 생성 불가**: `zip` crate 의존성 없음

### 3. 파일 관리 구조 부족

- **Workspace 구조**: exports 전용 디렉토리 없음
- **임시 파일 관리**: export된 파일의 생명주기 관리 부족
- **메타데이터 생성**: 자동 문서화 기능 없음

## 추가 분석 과제

### 1. MCP-UI 기반 Export 응답 방식 선택 ✅

- **선택**: **Option B: Remote-DOM UIResource** → 네이티브 컴포넌트 스타일 UI
- **이유**:
  - React 기반 SynapticFlow와 완벽한 일관성
  - 호스트 앱의 디자인 시스템 및 컴포넌트 라이브러리 활용
  - 타입 안전성 및 재사용 가능한 컴포넌트 구조
  - 네이티브 앱처럼 자연스러운 사용자 경험

### 2. 다운로드 트리거 메커니즘

- **UI Action 활용**: onUIAction으로 다운로드 요청 처리
- **Tool Call 연계**: UI에서 추가 MCP Tool 호출하여 실제 다운로드 수행
- **Direct File Access**: UIResource 내 직접 파일 접근 방식

### 2. ZIP 패키지 구조 표준화

- 자동 생성 메타데이터 포맷 정의
- 폴더 구조 컨벤션 수립
- 대용량 파일 처리 방식 검토

### 3. Export 히스토리 관리

- 생성된 export 파일의 자동 정리 정책
- 세션별 export 관리 방식
- 용량 제한 및 모니터링

## 변경 이후의 상태 / 해결 판정 기준

### 1. MCP-UI UIResource 기반 Export 도구

- `builtin_workspace__export_file`: 단일 파일 export UI 제공
- `builtin_workspace__export_zip`: ZIP 패키지 export UI 제공
- 두 도구 모두 클릭 가능한 다운로드 링크가 포함된 UIResource 반환

### 2. 향상된 사용자 경험

- **인터랙티브 UI**: 파일 목록, 메타데이터, 다운로드 버튼이 포함된 리치 UI
- **원클릭 다운로드**: UI 내 버튼 클릭으로 즉시 다운로드 실행
- **실시간 피드백**: 진행 상태, 에러 메시지 등 실시간 UI 업데이트

### 3. 향상된 Workspace 구조

```bash
workspace/
├── exports/              # 새로 추가
│   ├── files/           # 개별 export 파일
│   └── packages/        # ZIP 패키지
├── scripts/
├── data/
└── temp/
```

### 4. 판정 기준

- [ ] MCP-UI UIResource 응답 구현 완료
- [ ] ZIP 생성 라이브러리 의존성 추가 완료
- [ ] export_file, export_zip MCP Tool이 UIResource 반환
- [ ] UI에서 다운로드 버튼 클릭 시 정상 다운로드 동작
- [ ] onUIAction을 통한 다운로드 트리거 구현
- [ ] 메타데이터 자동 생성 기능 동작
- [ ] exports 디렉토리 자동 생성 및 관리

## 수정이 필요한 코드 및 수정부분

**파일**: `src-tauri/Cargo.toml`

```toml
[dependencies]
# ...기존 의존성들...
zip = "0.6"
chrono = { version = "0.4", features = ["serde"] }  # 이미 있음
serde_json = "1.0"  # UIResource 생성용
```

### 2. WorkspaceServer에 Remote-DOM 기반 Export Tools 추가

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
// 기존 imports에 추가
use std::io::Write;
use zip::write::FileOptions;
use serde_json::json;

impl WorkspaceServer {
    // 기존 코드...

    /// Remote-DOM 스크립트 생성 (Export UI)
    fn create_export_remote_dom_script(
        &self,
        title: &str,
        files: &[String],
        export_type: &str,
        download_path: &str,
    ) -> String {
        let files_json = serde_json::to_string(files).unwrap_or_else(|_| "[]".to_string());
        
        format!(
            r#"
// Remote-DOM Export UI Script
const {{ createRemoteComponent, createRemoteDocument, createRemoteText }} = window.RemoteDOM;

// Create main container
const container = document.createElement('div');
container.className = 'export-container p-6 max-w-2xl mx-auto';

// Title section
const titleElement = document.createElement('h1');
titleElement.className = 'text-2xl font-bold text-center mb-6 text-gray-800';
titleElement.textContent = '🎉 {}';
container.appendChild(titleElement);

// Export info card
const infoCard = document.createElement('div');
infoCard.className = 'bg-white rounded-lg shadow-md p-6 mb-6 border';
container.appendChild(infoCard);

// Export type
const exportTypeElement = document.createElement('h3');
exportTypeElement.className = 'text-lg font-semibold mb-3 text-gray-700';
exportTypeElement.textContent = '📦 Export Type: {}';
infoCard.appendChild(exportTypeElement);

// Metadata
const metadataDiv = document.createElement('div');
metadataDiv.className = 'text-sm text-gray-600 mb-4';
metadataDiv.innerHTML = `
  <p class="mb-1">📅 Created: {}</p>
  <p>📁 Files: {} items</p>
`;
infoCard.appendChild(metadataDiv);

// Files list
const filesSection = document.createElement('div');
filesSection.className = 'mb-4';
infoCard.appendChild(filesSection);

const filesTitle = document.createElement('h4');
filesTitle.className = 'font-medium mb-2 text-gray-700';
filesTitle.textContent = '📋 Included Files:';
filesSection.appendChild(filesTitle);

const filesList = document.createElement('ul');
filesList.className = 'space-y-1';
filesSection.appendChild(filesList);

// Populate files list
const files = {};
files.forEach(file => {{
  const listItem = document.createElement('li');
  listItem.className = 'bg-gray-50 px-3 py-2 rounded text-sm text-gray-700';
  listItem.textContent = file;
  filesList.appendChild(listItem);
}});

// Download section
const downloadSection = document.createElement('div');
downloadSection.className = 'text-center';
container.appendChild(downloadSection);

// Download button (using SynapticFlow's button component style)
const downloadBtn = document.createElement('button');
downloadBtn.className = 'bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg';
downloadBtn.textContent = '⬇️ Download Now';

downloadBtn.addEventListener('click', () => {{
  // MCP-UI Action: Tool 호출로 실제 다운로드 수행
  window.parent.postMessage({{
    type: 'tool',
    payload: {{
      toolName: 'download_file',
      params: {{
        path: '{}',
        type: '{}'
      }}
    }}
  }}, '*');
}});

downloadSection.appendChild(downloadBtn);

// Help text
const helpText = document.createElement('p');
helpText.className = 'text-sm text-gray-500 mt-3';
helpText.textContent = 'Click the button above to download your files';
downloadSection.appendChild(helpText);

// Append to root
root.appendChild(container);
            "#,
            title,
            export_type,
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            files.len(),
            files_json,
            download_path,
            export_type
        )
    }

    async fn handle_export_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let source_path_str = match args.get("path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: path",
                );
            }
        };

        let display_name = args
            .get("display_name")
            .and_then(|v| v.as_str())
            .unwrap_or_else(|| {
                std::path::Path::new(source_path_str)
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("exported_file")
            });

        // 경로 검증 및 파일 복사 로직 (이전과 동일)
        // ... 파일 처리 코드 ...

        let relative_path = format!("exports/files/{}", export_filename);

        // Remote-DOM 스크립트 생성
        let remote_dom_script = self.create_export_remote_dom_script(
            &format!("File Export: {}", display_name),
            &[source_path_str.to_string()],
            "Single File",
            &relative_path,
        );

        // UIResource 응답 생성 (Remote-DOM)
        let ui_resource = json!({
            "type": "resource",
            "resource": {
                "uri": format!("ui://export/file/{}", request_id),
                "mimeType": "application/vnd.mcp-ui.remote-dom+javascript; framework=react",
                "text": remote_dom_script
            }
        });

        Self::success_response_with_content(request_id, ui_resource)
    }

    async fn handle_export_zip(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        // ZIP 생성 로직 (이전과 동일)
        // ... ZIP 파일 생성 코드 ...

        let relative_path = format!("exports/packages/{}.zip", package_name);
        
        // 파일 목록 준비
        let file_names: Vec<String> = files_array
            .iter()
            .filter_map(|v| v.as_str().map(|s| s.to_string()))
            .collect();

        // Remote-DOM 스크립트 생성
        let remote_dom_script = self.create_export_remote_dom_script(
            &format!("ZIP Package: {}", package_name),
            &file_names,
            "ZIP Package",
            &relative_path,
        );

        // UIResource 응답 생성 (Remote-DOM)
        let ui_resource = json!({
            "type": "resource",
            "resource": {
                "uri": format!("ui://export/zip/{}", request_id),
                "mimeType": "application/vnd.mcp-ui.remote-dom+javascript; framework=react",
                "text": remote_dom_script
            }
        });

        Self::success_response_with_content(request_id, ui_resource)
    }
}

    /// Export 디렉토리 초기화
    fn ensure_exports_directory(&self) -> Result<std::path::PathBuf, String> {
        let exports_dir = self.get_workspace_dir().join("exports");
        if !exports_dir.exists() {
            std::fs::create_dir_all(&exports_dir)
                .map_err(|e| format!("Failed to create exports directory: {}", e))?;
        }
        Ok(exports_dir)
    }

    fn create_export_file_tool() -> MCPTool {
        let mut props = HashMap::new();
        props.insert(
            "path".to_string(),
            string_prop(Some(1), Some(1000), Some("Workspace 내 export할 파일 경로")),
        );
        props.insert(
            "display_name".to_string(),
            string_prop(None, None, Some("다운로드시 표시할 파일명 (선택적)")),
        );
        props.insert(
            "description".to_string(),
            string_prop(None, None, Some("파일 설명 (선택적)")),
        );

        MCPTool {
            name: "export_file".to_string(),
            title: Some("Export Single File".to_string()),
            description: "Export a single file from workspace for download".to_string(),
            input_schema: object_schema(props, vec!["path".to_string()]),
            output_schema: None,
            annotations: None,
        }
    }

    fn create_export_zip_tool() -> MCPTool {
        let mut props = HashMap::new();
        props.insert(
            "files".to_string(),
            array_schema(
                string_prop(Some(1), Some(1000), Some("포함할 파일 경로")),
                Some("ZIP에 포함할 파일 목록"),
            ),
        );
        props.insert(
            "package_name".to_string(),
            string_prop(None, None, Some("ZIP 패키지명 (선택적, 자동 생성)")),
        );
        props.insert(
            "include_metadata".to_string(),
            boolean_prop(Some("자동 생성 메타데이터 포함 여부 (기본: true)")),
        );

        MCPTool {
            name: "export_zip".to_string(),
            title: Some("Export ZIP Package".to_string()),
            description: "Export multiple workspace files as a ZIP package".to_string(),
            input_schema: object_schema(props, vec!["files".to_string()]),
            output_schema: None,
            annotations: None,
        }
    }

    async fn handle_export_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let source_path_str = match args.get("path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: path",
                );
            }
        };

        let display_name = args
            .get("display_name")
            .and_then(|v| v.as_str())
            .unwrap_or_else(|| {
                std::path::Path::new(source_path_str)
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("exported_file")
            });

        // 경로 검증
        let source_path = match self.validate_path_with_error(source_path_str, &request_id) {
            Ok(path) => path,
            Err(error_response) => return *error_response,
        };

        // exports 디렉토리 확인
        let exports_dir = match self.ensure_exports_directory() {
            Ok(dir) => dir,
            Err(e) => return Self::error_response(request_id, -32603, &e),
        };

        // 파일을 exports/files 디렉토리에 복사
        let files_dir = exports_dir.join("files");
        if let Err(e) = std::fs::create_dir_all(&files_dir) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to create files directory: {}", e),
            );
        }

        let export_filename = format!("{}_{}", 
            chrono::Utc::now().format("%Y%m%d_%H%M%S"), 
            display_name
        );
        let export_path = files_dir.join(&export_filename);

        // 파일 복사
        if let Err(e) = std::fs::copy(&source_path, &export_path) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to copy file: {}", e),
            );
        }

        // 상대 경로 생성 (workspace 기준)
        let relative_path = format!("exports/files/{}", export_filename);

        Self::success_response(
            request_id,
            &format!(
                "File exported successfully. Use frontend download utility with path: {}",
                relative_path
            ),
        )
    }

    async fn handle_export_zip(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let files_array = match args.get("files").and_then(|v| v.as_array()) {
            Some(files) => files,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: files",
                );
            }
        };

        let package_name = args
            .get("package_name")
            .and_then(|v| v.as_str())
            .unwrap_or(&format!("workspace_export_{}", 
                chrono::Utc::now().format("%Y%m%d_%H%M%S")
            ));

        let include_metadata = args
            .get("include_metadata")
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        // exports 디렉토리 확인
        let exports_dir = match self.ensure_exports_directory() {
            Ok(dir) => dir,
            Err(e) => return Self::error_response(request_id, -32603, &e),
        };

        let packages_dir = exports_dir.join("packages");
        if let Err(e) = std::fs::create_dir_all(&packages_dir) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to create packages directory: {}", e),
            );
        }

        let zip_filename = format!("{}.zip", package_name);
        let zip_path = packages_dir.join(&zip_filename);

        // ZIP 파일 생성
        let zip_file = match std::fs::File::create(&zip_path) {
            Ok(file) => file,
            Err(e) => {
                return Self::error_response(
                    request_id,
                    -32603,
                    &format!("Failed to create ZIP file: {}", e),
                );
            }
        };

        let mut zip = zip::ZipWriter::new(zip_file);
        let options = FileOptions::default()
            .compression_method(zip::CompressionMethod::Deflated)
            .unix_permissions(0o755);

        // 파일들을 ZIP에 추가
        for file_value in files_array {
            if let Some(file_path_str) = file_value.as_str() {
                let source_path = match self.validate_path_with_error(file_path_str, &request_id) {
                    Ok(path) => path,
                    Err(_) => continue, // 유효하지 않은 파일은 건너뛰기
                };

                if source_path.is_file() {
                    let file_content = match std::fs::read(&source_path) {
                        Ok(content) => content,
                        Err(_) => continue,
                    };

                    let zip_entry_name = source_path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("unknown_file");

                    if let Err(e) = zip.start_file(zip_entry_name, options) {
                        warn!("Failed to add file {} to ZIP: {}", zip_entry_name, e);
                        continue;
                    }

                    if let Err(e) = zip.write_all(&file_content) {
                        warn!("Failed to write file {} content: {}", zip_entry_name, e);
                        continue;
                    }
                }
            }
        }

        // 메타데이터 추가
        if include_metadata {
            let metadata = json!({
                "package_name": package_name,
                "created_at": chrono::Utc::now().to_rfc3339(),
                "files_count": files_array.len(),
                "generator": "SynapticFlow Workspace Export"
            });

            if let Ok(metadata_str) = serde_json::to_string_pretty(&metadata) {
                let _ = zip.start_file("metadata.json", options);
                let _ = zip.write_all(metadata_str.as_bytes());
            }

            // README 추가
            let readme_content = format!(
                "# {}\n\nExported from SynapticFlow Workspace\n\n\
                Created: {}\n\
                Files: {} items\n\n\
                This package contains files exported from your workspace.\n",
                package_name,
                chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                files_array.len()
            );

            let _ = zip.start_file("README.md", options);
            let _ = zip.write_all(readme_content.as_bytes());
        }

        if let Err(e) = zip.finish() {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to finalize ZIP: {}", e),
            );
        }

        // 상대 경로 생성
        let relative_path = format!("exports/packages/{}", zip_filename);

        Self::success_response(
            request_id,
            &format!(
                "ZIP package created successfully. Use frontend download utility with path: {}",
                relative_path
            ),
        )
    }
}

// tools() 메서드에 새 도구들 추가
fn tools(&self) -> Vec<MCPTool> {
    vec![
        // ...기존 도구들...
        
        // 새로 추가되는 export 도구들
        Self::create_export_file_tool(),
        Self::create_export_zip_tool(),
    ]
}

// call_tool() 메서드에 새 핸들러들 추가
async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
    match tool_name {
        // ...기존 도구들...
        
        // 새로 추가되는 export 도구들
        "export_file" => self.handle_export_file(args).await,
        "export_zip" => self.handle_export_zip(args).await,
        
        _ => {
            let request_id = Self::generate_request_id();
            Self::error_response(
                request_id,
                -32601,
                &format!("Tool '{}' not found", tool_name),
            )
        }
    }
}
```

### 3. 프론트엔드 MCP-UI 패키지 활용 (기존 설치됨)

**확인된 의존성**: SynapticFlow는 이미 MCP-UI 패키지를 설치하고 사용 중

```json
{
  "dependencies": {
    "@mcp-ui/client": "^5.6.2",    // ✅ 이미 설치되어 사용 중
    "@mcp-ui/server": "^5.2.0"     // ✅ 이미 설치됨 (서버사이드 유틸리티)
  }
}
```

**현재 사용 현황**:
- `UIResourceRenderer`에서 `@mcp-ui/client` 공식 라이브러리 사용 중
- 표준 MCP-UI 프로토콜 완전 호환
- HTML, External URL 리소스 타입 지원

### 4. Remote-DOM 지원을 위한 추가 패키지 (필요시 설치)

**Remote-DOM 활성화를 위한 의존성 추가**:

```json
{
  "dependencies": {
    "@remote-dom/core": "^2.0.0"  // Option B 구현 시 필요
  }
}
```

### 4. Remote-DOM 컴포넌트 라이브러리 구성

**파일**: `src/lib/remote-dom-components.tsx` (신규)

```typescript
import { 
  createRemoteComponent, 
  createRemoteElement 
} from '@remote-dom/core';

// SynapticFlow 스타일의 컴포넌트 라이브러리
export const synapticFlowComponentLibrary = {
  // 기본 HTML 요소들
  'div': createRemoteElement('div'),
  'h1': createRemoteElement('h1'),
  'h3': createRemoteElement('h3'),
  'h4': createRemoteElement('h4'),
  'p': createRemoteElement('p'),
  'ul': createRemoteElement('ul'),
  'li': createRemoteElement('li'),
  'button': createRemoteElement('button'),
  
  // 커스텀 UI 컴포넌트들
  'ui-button': createRemoteComponent({
    name: 'ui-button',
    render: ({ children, className, onClick, ...props }) => (
      <button
        className={`
          bg-blue-500 hover:bg-blue-600 text-white font-medium 
          py-3 px-6 rounded-lg transition-colors duration-200 
          shadow-md hover:shadow-lg disabled:opacity-50
          ${className || ''}
        `}
        onClick={onClick}
        {...props}
      >
        {children}
      </button>
    )
  }),
  
  'ui-card': createRemoteComponent({
    name: 'ui-card',
    render: ({ children, className, ...props }) => (
      <div
        className={`
          bg-white rounded-lg shadow-md border border-gray-200
          ${className || ''}
        `}
        {...props}
      >
        {children}
      </div>
    )
  }),
  
  'ui-badge': createRemoteComponent({
    name: 'ui-badge',
    render: ({ children, variant = 'default', className, ...props }) => {
      const variantClasses = {
        default: 'bg-gray-100 text-gray-800',
        primary: 'bg-blue-100 text-blue-800',
        success: 'bg-green-100 text-green-800'
      };
      
      return (
        <span
          className={`
            inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
            ${variantClasses[variant]}
            ${className || ''}
          `}
          {...props}
        >
          {children}
        </span>
      );
    }
  }),
};
```

### 5. Remote-DOM UIResourceRenderer 구성

**파일**: `src/components/ui/RemoteDOMResourceRenderer.tsx` (신규)

```typescript
import React from 'react';
import { UIResourceRenderer } from '@mcp-ui/client';
import { synapticFlowComponentLibrary } from '@/lib/remote-dom-components';
import { downloadFromWorkspace } from '@/lib/workspace-download';
import { useUnifiedMCP } from '@/hooks/use-unified-mcp';
import { getLogger } from '@/lib/logger';

const logger = getLogger('RemoteDOMResourceRenderer');

interface RemoteDOMResourceRendererProps {
  resource: any;
}

export function RemoteDOMResourceRenderer({ 
  resource 
}: RemoteDOMResourceRendererProps) {
  const { callTool } = useUnifiedMCP();

  const handleUIAction = async (action: any) => {
    logger.info('Remote-DOM UI Action received', { action });

    try {
      if (action.type === 'tool' && action.payload.toolName === 'download_file') {
        const { path, type } = action.payload.params;
        
        // 실제 다운로드 수행
        await downloadFromWorkspace(path, {
          filename: path.split('/').pop(),
          mimeType: type === 'ZIP Package' ? 'application/zip' : 'application/octet-stream'
        });

        logger.info('Download completed successfully', { path, type });
      }
    } catch (error) {
      logger.error('Failed to handle Remote-DOM UI action', { action, error });
    }
  };

  return (
    <UIResourceRenderer
      resource={resource}
      onUIAction={handleUIAction}
      remoteDomProps={{
        library: synapticFlowComponentLibrary,
        // Remote-DOM 전용 설정
        remoteElements: {
          // 추가 원격 요소들 정의 가능
        }
      }}
      supportedContentTypes={['remoteDom']}
    />
  );
}

```rust
fn create_download_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "path".to_string(),
        string_prop(Some(1), Some(1000), Some("다운로드할 파일의 workspace 상대 경로")),
    );
    props.insert(
        "type".to_string(),
        string_prop(None, None, Some("파일 타입 (Single File, ZIP Package)")),
    );

    MCPTool {
        name: "download_file".to_string(),
        title: Some("Download File".to_string()),
        description: "Download file from workspace exports directory".to_string(),
        input_schema: object_schema(props, vec!["path".to_string()]),
        output_schema: None,
        annotations: None,
    }
}

async fn handle_download_file(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let file_path = match args.get("path").and_then(|v| v.as_str()) {
        Some(path) => path,
        None => {
            return Self::error_response(
                request_id,
                -32602,
                "Missing required parameter: path",
            );
        }
    };

    // workspace 기준 절대 경로 생성
    let full_path = self.get_workspace_dir().join(file_path);
    
    // 파일 존재 확인
    if !full_path.exists() {
        return Self::error_response(
            request_id,
            -32603,
            &format!("Export file not found: {}", file_path),
        );
    }

    // Tauri command를 통한 다운로드 지시
    let download_instruction = format!(
        "File is ready for download. Use Tauri read_file command with path: {} 
        Then create Blob and trigger download in frontend.",
        file_path
    );

    Self::success_response(request_id, &download_instruction)
}
```

### 6. Chat 컴포넌트에서 Remote-DOM UIResource 처리

**파일**: `src/features/chat/ChatMessage.tsx` (기존 수정)

```typescript
import { RemoteDOMResourceRenderer } from '@/components/ui/RemoteDOMResourceRenderer';

// 기존 메시지 렌더링 로직에 추가
function renderMessageContent(content: any) {
  // Remote-DOM UIResource 응답 처리
  if (
    content.type === 'resource' && 
    content.resource?.uri?.startsWith('ui://export/') &&
    content.resource?.mimeType?.includes('remote-dom')
  ) {
    return <RemoteDOMResourceRenderer resource={content.resource} />;
  }

  // 기존 렌더링 로직...
  return <div>{content.text}</div>;
}
```

### 7. 다운로드 처리를 위한 추가 MCP Tool

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
fn create_download_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "path".to_string(),
        string_prop(Some(1), Some(1000), Some("다운로드할 파일의 workspace 상대 경로")),
    );
    props.insert(
        "type".to_string(),
        string_prop(None, None, Some("파일 타입 (Single File, ZIP Package)")),
    );

    MCPTool {
        name: "download_file".to_string(),
        title: Some("Download File".to_string()),
        description: "Download file from workspace exports directory".to_string(),
        input_schema: object_schema(props, vec!["path".to_string()]),
        output_schema: None,
        annotations: None,
    }
}

async fn handle_download_file(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let file_path = match args.get("path").and_then(|v| v.as_str()) {
        Some(path) => path,
        None => {
            return Self::error_response(
                request_id,
                -32602,
                "Missing required parameter: path",
            );
        }
    };

    // workspace 기준 절대 경로 생성
    let full_path = self.get_workspace_dir().join(file_path);
    
    // 파일 존재 확인
    if !full_path.exists() {
        return Self::error_response(
            request_id,
            -32603,
            &format!("Export file not found: {}", file_path),
        );
    }

    // Tauri command를 통한 다운로드 지시
    let download_instruction = format!(
        "File is ready for download. Use Tauri read_file command with path: {} 
        Then create Blob and trigger download in frontend.",
        file_path
    );

    Self::success_response(request_id, &download_instruction)
}
```

```typescript
import { invoke } from '@tauri-apps/api/tauri';
import { getLogger } from '@/lib/logger';

const logger = getLogger('WorkspaceDownload');

export interface DownloadOptions {
  filename?: string;
  mimeType?: string;
}

/**
 * Workspace 내 파일을 다운로드합니다
 */
export async function downloadFromWorkspace(
  relativePath: string,
  options: DownloadOptions = {}
): Promise<void> {
  try {
    logger.info('Starting workspace file download', { relativePath, options });

    // Tauri 명령어로 파일 읽기
    const fileData = await invoke<number[]>('read_file', { 
      filePath: relativePath 
    });

    // Blob 생성
    const blob = new Blob([new Uint8Array(fileData)], {
      type: options.mimeType || 'application/octet-stream'
    });

    // 파일명 결정
    const filename = options.filename || 
      relativePath.split('/').pop() || 
      'workspace_export';

    // 다운로드 트리거
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    URL.revokeObjectURL(url);

    logger.info('Workspace file download completed', { 
      filename, 
      size: blob.size 
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('Workspace file download failed', { 
      relativePath, 
      error: errorMessage 
    });
    throw new Error(`Download failed: ${errorMessage}`);
  }
}

/**
 * MCP Tool export 응답을 처리하여 다운로드를 수행합니다
 */
export function handleExportResponse(
  response: { content?: { text?: string }[] }
): void {
  try {
    const text = response.content?.[0]?.text;
    if (!text) {
      throw new Error('Invalid export response format');
    }

    // "Use frontend download utility with path: exports/..." 형태의 메시지 파싱
    const pathMatch = text.match(/Use frontend download utility with path: (.+)$/);
    if (!pathMatch) {
      throw new Error('Could not extract file path from response');
    }

    const relativePath = pathMatch[1].trim();
    const filename = relativePath.split('/').pop();

    // 다운로드 실행
    downloadFromWorkspace(relativePath, { filename });

  } catch (error) {
    logger.error('Failed to handle export response', { response, error });
    throw error;
  }
}
```

### 6. 간소화된 다운로드 유틸리티

**파일**: `src/lib/workspace-download.ts` (신규)

```typescript
import { invoke } from '@tauri-apps/api/tauri';
import { getLogger } from '@/lib/logger';

const logger = getLogger('WorkspaceDownload');

export interface DownloadOptions {
  filename?: string;
  mimeType?: string;
}

/**
 * Workspace 내 파일을 다운로드합니다 (MCP-UI에서 호출)
 */
export async function downloadFromWorkspace(
  relativePath: string,
  options: DownloadOptions = {}
): Promise<void> {
  try {
    logger.info('Starting workspace file download', { relativePath, options });

    // Tauri 명령어로 파일 읽기
    const fileData = await invoke<number[]>('read_file', { 
      filePath: relativePath 
    });

    // Blob 생성 및 다운로드
    const blob = new Blob([new Uint8Array(fileData)], {
      type: options.mimeType || 'application/octet-stream'
    });

    const filename = options.filename || 
      relativePath.split('/').pop() || 
      'workspace_export';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    logger.info('Workspace file download completed', { 
      filename, 
      size: blob.size 
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('Workspace file download failed', { 
      relativePath, 
      error: errorMessage 
    });
    throw new Error(`Download failed: ${errorMessage}`);
  }
}
```

### 8. Remote-DOM Export UI 사용 예시

**Chat에서 export 도구 사용 예시**:

```bash
사용자: "작업한 파일들을 ZIP으로 내보내줘"
AI: export_zip 도구 호출 → Remote-DOM UI 응답 → SynapticFlow 네이티브 스타일 컴포넌트 → 다운로드 버튼 클릭 → 파일 다운로드
```

**MCP Tool 응답 비교**:

- **기존**: `"ZIP package created successfully. Use frontend download utility with path: exports/packages/..."`

- **Remote-DOM 개선**: SynapticFlow의 네이티브 Button, Card, Badge 컴포넌트를 사용한 완전히 일관된 UI
  ```typescript
  // 사용자에게 보이는 UI (SynapticFlow 컴포넌트 스타일)
  <ui-card className="p-6">
    <h1 className="text-2xl font-bold">🎉 ZIP Package: workspace_export_20250904</h1>
    <ui-badge variant="primary">ZIP Package</ui-badge>
    <ul>
      <li>📄 report.txt</li>
      <li>📊 data.csv</li>
    </ul>
    <ui-button onClick={triggerDownload}>
      ⬇️ Download Now
    </ui-button>
  </ui-card>
  ```

**Remote-DOM의 핵심 장점**:

1. **완벽한 디자인 일관성**: SynapticFlow의 기존 컴포넌트와 100% 동일한 스타일
2. **타입 안전성**: TypeScript 기반 컴포넌트 라이브러리
3. **재사용성**: 한 번 정의한 컴포넌트를 모든 MCP Tool에서 활용
4. **확장성**: 새로운 컴포넌트 추가 시 전체 시스템에서 즉시 사용 가능

**MCP Tool 응답 예시**:

- 기존: `"ZIP package created successfully. Use frontend download utility with path: exports/packages/..."`
- 개선: 클릭 가능한 다운로드 버튼, 파일 목록, 메타데이터가 포함된 인터랙티브 HTML UI

## 재사용 가능한 연관 코드

### 1. MCP-UI 기반 Workspace 인프라

- **파일**: `src-tauri/src/mcp/builtin/workspace.rs`
- **주요 기능**: UIResource 생성, HTML UI 템플릿, MCP-UI Action 처리
- **재사용 메서드**: `create_export_ui_html()`, `success_response_with_content()`, `handle_download_file()`

### 2. UI 응답 처리 시스템

- **파일**: `src/components/ui/UIResourceRenderer.tsx`
- **주요 기능**: UIResource 렌더링, onUIAction 이벤트 처리
- **재사용 인터페이스**: `WorkspaceUIResourceRenderer`, `handleUIAction`

### 3. MCP-UI 클라이언트 라이브러리

- **라이브러리**: `@mcp-ui/client`, `@mcp-ui/server`
- **주요 기능**: UIResource 렌더링, HTML iframe 관리, UI Action 통신
- **재사용 컴포넌트**: `<UIResourceRenderer />`, `createUIResource()`

### 4. 파일 시스템 보안 (기존 활용)

- **파일**: `src-tauri/src/services/secure_file_manager.rs`
- **주요 기능**: 경로 검증, 안전한 파일 읽기/쓰기
- **재사용 인터페이스**: `read_file()`, `write_file()`, `validate_path()`

### 5. Tauri 명령어 체계 (기존 활용)

- **파일**: `src-tauri/src/lib.rs`
- **기존 명령어**: `read_file`, `write_file`
- **재사용 방법**: export된 파일을 기존 read_file 명령어로 읽어 다운로드

### 6. Chat UI 통합 시스템

- **파일**: `src/features/chat/ChatMessage.tsx`
- **주요 기능**: UIResource 감지 및 전용 렌더러 호출
- **재사용 방법**: 기존 메시지 렌더링 로직에 UIResource 처리 추가

### 4. MCP 스키마 빌더

- **파일**: `src-tauri/src/mcp/utils/schema_builder.rs`
- **주요 기능**: 도구 스키마 정의 유틸리티
- **재사용 함수**: `object_schema()`, `string_prop()`, `boolean_prop()`, `array_schema()`

### 5. 프론트엔드 MCP 클라이언트

- **파일**: `src/hooks/use-unified-mcp.ts`
- **주요 기능**: MCP 도구 호출 인터페이스
- **재사용 방법**: export 도구 호출에 기존 `callTool` 메서드 활용

### 6. 로깅 시스템

- **파일**: `src/lib/logger.ts`
- **주요 기능**: 구조화된 로깅
- **재사용 방법**: export 과정의 상세 로그 기록

## 구현 단계

### Phase 1: Remote-DOM 기본 인프라 구축 (2-3일)

1. MCP-UI 및 Remote-DOM 라이브러리 설정 및 의존성 추가
2. SynapticFlow 컴포넌트 라이브러리 구성 (ui-button, ui-card, ui-badge 등)
3. WorkspaceServer에 Remote-DOM UIResource 응답 기능 추가
4. RemoteDOMResourceRenderer 컴포넌트 구현 및 테스트

### Phase 2: Export Tool Remote-DOM 통합 (3일)

1. export_file MCP Tool을 Remote-DOM UIResource 응답으로 구현
2. Remote-DOM 스크립트 생성 로직 및 컴포넌트 매핑
3. onUIAction을 통한 다운로드 트리거 구현
4. download_file MCP Tool 구현 및 연동

### Phase 3: ZIP 지원 및 고급 컴포넌트 (2-3일)

1. export_zip MCP Tool을 Remote-DOM UIResource 응답으로 구현
2. 파일 목록 표시용 커스텀 컴포넌트 개발
3. ZIP 메타데이터 및 진행 상태 표시 UI
4. 다중 파일 처리 최적화

### Phase 4: UI/UX 완성 및 통합 (2일)

1. SynapticFlow 디자인 시스템과 완전한 일관성 확보
2. Chat 메시지 렌더링에 Remote-DOM UIResource 처리 통합
3. 컴포넌트 라이브러리 확장 및 재사용성 향상
4. 성능 최적화 및 에러 처리 개선
