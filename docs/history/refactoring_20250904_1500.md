# Workspace Export ê¸°ëŠ¥ ì¶”ê°€ (MCP-UI ê¸°ë°˜) Refactoring Plan

## ì‘ì—…ì˜ ëª©ì 

ê¸°ì¡´ WorkspaceServerì— **MCP-UI ê¸°ë°˜ export ê¸°ëŠ¥**ì„ ì¶”ê°€í•˜ì—¬ ì‚¬ìš©ìê°€ ì‘ì—… ê²°ê³¼ë¬¼ì„ ì§ê´€ì ì´ê³  ìš°ì•„í•œ ë°©ì‹ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

### í•µì‹¬ ëª©í‘œ

- **MCP-UI UIResource ì‘ë‹µ**: export ë„êµ¬ê°€ í´ë¦­ ê°€ëŠ¥í•œ ë‹¤ìš´ë¡œë“œ ë§í¬ê°€ í¬í•¨ëœ HTML UIë¥¼ ë°˜í™˜
- **ê°œë³„ íŒŒì¼ Export**: workspace ë‚´ ë‹¨ì¼ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ì œê³µ
- **ZIP íŒ¨í‚¤ì§€ Export**: ì—¬ëŸ¬ íŒŒì¼ì„ êµ¬ì¡°í™”ëœ íŒ¨í‚¤ì§€ë¡œ ë¬¶ì–´ ì œê³µ
- **ì¸í„°ë™í‹°ë¸Œ UI**: íŒŒì¼ ëª©ë¡, ë‹¤ìš´ë¡œë“œ ë²„íŠ¼, ë©”íƒ€ë°ì´í„°ê°€ í¬í•¨ëœ ë¦¬ì¹˜ UI ì œê³µ
- **ê¸°ì¡´ ì•„í‚¤í…ì²˜ í˜¸í™˜**: í˜„ì¬ SecureFileManager ë° MCP-UI ì²´ê³„ì™€ ì™„ì „ í˜¸í™˜

## í˜„ì¬ì˜ ìƒíƒœ / ë¬¸ì œì 

### 1. Export ê¸°ëŠ¥ ë° UI í•œê³„

- **WorkspaceServer**: íŒŒì¼ ì¡°ì‘ ë° ì½”ë“œ ì‹¤í–‰ë§Œ ì§€ì›, export ê¸°ëŠ¥ ì—†ìŒ
- **í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‘ë‹µ**: MCP Tool ì‘ë‹µì´ ë‹¨ìˆœ í…ìŠ¤íŠ¸ë¡œë§Œ ì œê³µë˜ì–´ ì‚¬ìš©ì ê²½í—˜ ì œí•œ
- **ìˆ˜ë™ ë‹¤ìš´ë¡œë“œ í”„ë¡œì„¸ìŠ¤**: ì‚¬ìš©ìê°€ ë³„ë„ UI ì¡°ì‘ì„ í†µí•´ íŒŒì¼ì„ ì°¾ê³  ë‹¤ìš´ë¡œë“œí•´ì•¼ í•¨
- **ì›Œí¬í”Œë¡œìš° ë‹¨ì ˆ**: íŒŒì¼ ìƒì„± â†’ ë¶„ì„ â†’ ê²°ê³¼ í™œìš©ì˜ ìì—°ìŠ¤ëŸ¬ìš´ íë¦„ ë¶€ì¡±

### 2. UI ì¸í„°ë™ì…˜ ë¶€ì¡±

- **ì •ì  ì‘ë‹µ**: í˜„ì¬ MCP Toolì€ í…ìŠ¤íŠ¸ë§Œ ë°˜í™˜, ì¸í„°ë™í‹°ë¸Œ ìš”ì†Œ ì—†ìŒ
- **MCP-UI ë¯¸í™œìš©**: UIResource ê¸°ë°˜ ë¦¬ì¹˜ UI ì‘ë‹µ ë¯¸ì‚¬ìš©
- **ì§ì ‘ ì•¡ì…˜ ë¶ˆê°€**: ì‘ë‹µ ë‚´ì—ì„œ ë°”ë¡œ ë‹¤ìš´ë¡œë“œí•˜ê±°ë‚˜ ì¶”ê°€ ì‘ì—… ìˆ˜í–‰ ë¶ˆê°€

### 2. ë‹¤ìš´ë¡œë“œ ë©”ì»¤ë‹ˆì¦˜ í•œê³„

- **ê¸°ì¡´ read_file ëª…ë ¹ì–´**: workspace íŒŒì¼ ì½ê¸°ìš©, ë‹¤ìš´ë¡œë“œ ëª©ì  ì•„ë‹˜
- **Direct URL ì œê³µ ë¶ˆê°€**: Tauri asset protocol ë¯¸êµ¬ì„±ìœ¼ë¡œ íŒŒì¼ URL ì§ì ‘ ì œê³µ ì–´ë ¤ì›€
- **ZIP ìƒì„± ë¶ˆê°€**: `zip` crate ì˜ì¡´ì„± ì—†ìŒ

### 3. íŒŒì¼ ê´€ë¦¬ êµ¬ì¡° ë¶€ì¡±

- **Workspace êµ¬ì¡°**: exports ì „ìš© ë””ë ‰í† ë¦¬ ì—†ìŒ
- **ì„ì‹œ íŒŒì¼ ê´€ë¦¬**: exportëœ íŒŒì¼ì˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬ ë¶€ì¡±
- **ë©”íƒ€ë°ì´í„° ìƒì„±**: ìë™ ë¬¸ì„œí™” ê¸°ëŠ¥ ì—†ìŒ

## ì¶”ê°€ ë¶„ì„ ê³¼ì œ

### 1. MCP-UI ê¸°ë°˜ Export ì‘ë‹µ ë°©ì‹ ì„ íƒ âœ…

- **ì„ íƒ**: **Option B: Remote-DOM UIResource** â†’ ë„¤ì´í‹°ë¸Œ ì»´í¬ë„ŒíŠ¸ ìŠ¤íƒ€ì¼ UI
- **ì´ìœ **:
  - React ê¸°ë°˜ SynapticFlowì™€ ì™„ë²½í•œ ì¼ê´€ì„±
  - í˜¸ìŠ¤íŠ¸ ì•±ì˜ ë””ìì¸ ì‹œìŠ¤í…œ ë° ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©
  - íƒ€ì… ì•ˆì „ì„± ë° ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
  - ë„¤ì´í‹°ë¸Œ ì•±ì²˜ëŸ¼ ìì—°ìŠ¤ëŸ¬ìš´ ì‚¬ìš©ì ê²½í—˜

### 2. ë‹¤ìš´ë¡œë“œ íŠ¸ë¦¬ê±° ë©”ì»¤ë‹ˆì¦˜

- **UI Action í™œìš©**: onUIActionìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ ìš”ì²­ ì²˜ë¦¬
- **Tool Call ì—°ê³„**: UIì—ì„œ ì¶”ê°€ MCP Tool í˜¸ì¶œí•˜ì—¬ ì‹¤ì œ ë‹¤ìš´ë¡œë“œ ìˆ˜í–‰
- **Direct File Access**: UIResource ë‚´ ì§ì ‘ íŒŒì¼ ì ‘ê·¼ ë°©ì‹

### 2. ZIP íŒ¨í‚¤ì§€ êµ¬ì¡° í‘œì¤€í™”

- ìë™ ìƒì„± ë©”íƒ€ë°ì´í„° í¬ë§· ì •ì˜
- í´ë” êµ¬ì¡° ì»¨ë²¤ì…˜ ìˆ˜ë¦½
- ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ë°©ì‹ ê²€í† 

### 3. Export íˆìŠ¤í† ë¦¬ ê´€ë¦¬

- ìƒì„±ëœ export íŒŒì¼ì˜ ìë™ ì •ë¦¬ ì •ì±…
- ì„¸ì…˜ë³„ export ê´€ë¦¬ ë°©ì‹
- ìš©ëŸ‰ ì œí•œ ë° ëª¨ë‹ˆí„°ë§

## ë³€ê²½ ì´í›„ì˜ ìƒíƒœ / í•´ê²° íŒì • ê¸°ì¤€

### 1. MCP-UI UIResource ê¸°ë°˜ Export ë„êµ¬

- `builtin_workspace__export_file`: ë‹¨ì¼ íŒŒì¼ export UI ì œê³µ
- `builtin_workspace__export_zip`: ZIP íŒ¨í‚¤ì§€ export UI ì œê³µ
- ë‘ ë„êµ¬ ëª¨ë‘ í´ë¦­ ê°€ëŠ¥í•œ ë‹¤ìš´ë¡œë“œ ë§í¬ê°€ í¬í•¨ëœ UIResource ë°˜í™˜

### 2. í–¥ìƒëœ ì‚¬ìš©ì ê²½í—˜

- **ì¸í„°ë™í‹°ë¸Œ UI**: íŒŒì¼ ëª©ë¡, ë©”íƒ€ë°ì´í„°, ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ì´ í¬í•¨ëœ ë¦¬ì¹˜ UI
- **ì›í´ë¦­ ë‹¤ìš´ë¡œë“œ**: UI ë‚´ ë²„íŠ¼ í´ë¦­ìœ¼ë¡œ ì¦‰ì‹œ ë‹¤ìš´ë¡œë“œ ì‹¤í–‰
- **ì‹¤ì‹œê°„ í”¼ë“œë°±**: ì§„í–‰ ìƒíƒœ, ì—ëŸ¬ ë©”ì‹œì§€ ë“± ì‹¤ì‹œê°„ UI ì—…ë°ì´íŠ¸

### 3. í–¥ìƒëœ Workspace êµ¬ì¡°

```bash
workspace/
â”œâ”€â”€ exports/              # ìƒˆë¡œ ì¶”ê°€
â”‚   â”œâ”€â”€ files/           # ê°œë³„ export íŒŒì¼
â”‚   â””â”€â”€ packages/        # ZIP íŒ¨í‚¤ì§€
â”œâ”€â”€ scripts/
â”œâ”€â”€ data/
â””â”€â”€ temp/
```

### 4. íŒì • ê¸°ì¤€

- [ ] MCP-UI UIResource ì‘ë‹µ êµ¬í˜„ ì™„ë£Œ
- [ ] ZIP ìƒì„± ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ì¡´ì„± ì¶”ê°€ ì™„ë£Œ
- [ ] export_file, export_zip MCP Toolì´ UIResource ë°˜í™˜
- [ ] UIì—ì„œ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì‹œ ì •ìƒ ë‹¤ìš´ë¡œë“œ ë™ì‘
- [ ] onUIActionì„ í†µí•œ ë‹¤ìš´ë¡œë“œ íŠ¸ë¦¬ê±° êµ¬í˜„
- [ ] ë©”íƒ€ë°ì´í„° ìë™ ìƒì„± ê¸°ëŠ¥ ë™ì‘
- [ ] exports ë””ë ‰í† ë¦¬ ìë™ ìƒì„± ë° ê´€ë¦¬

## ìˆ˜ì •ì´ í•„ìš”í•œ ì½”ë“œ ë° ìˆ˜ì •ë¶€ë¶„

**íŒŒì¼**: `src-tauri/Cargo.toml`

```toml
[dependencies]
# ...ê¸°ì¡´ ì˜ì¡´ì„±ë“¤...
zip = "0.6"
chrono = { version = "0.4", features = ["serde"] }  # ì´ë¯¸ ìˆìŒ
serde_json = "1.0"  # UIResource ìƒì„±ìš©
```

### 2. WorkspaceServerì— Remote-DOM ê¸°ë°˜ Export Tools ì¶”ê°€

**íŒŒì¼**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
// ê¸°ì¡´ importsì— ì¶”ê°€
use std::io::Write;
use zip::write::FileOptions;
use serde_json::json;

impl WorkspaceServer {
    // ê¸°ì¡´ ì½”ë“œ...

    /// Remote-DOM ìŠ¤í¬ë¦½íŠ¸ ìƒì„± (Export UI)
    fn create_export_remote_dom_script(
        &self,
        title: &str,
        files: &[String],
        export_type: &str,
        download_path: &str,
    ) -> String {
        let files_json = serde_json::to_string(files).unwrap_or_else(|_| "[]".to_string());
        
        format!(
            r#"
// Remote-DOM Export UI Script
const {{ createRemoteComponent, createRemoteDocument, createRemoteText }} = window.RemoteDOM;

// Create main container
const container = document.createElement('div');
container.className = 'export-container p-6 max-w-2xl mx-auto';

// Title section
const titleElement = document.createElement('h1');
titleElement.className = 'text-2xl font-bold text-center mb-6 text-gray-800';
titleElement.textContent = 'ğŸ‰ {}';
container.appendChild(titleElement);

// Export info card
const infoCard = document.createElement('div');
infoCard.className = 'bg-white rounded-lg shadow-md p-6 mb-6 border';
container.appendChild(infoCard);

// Export type
const exportTypeElement = document.createElement('h3');
exportTypeElement.className = 'text-lg font-semibold mb-3 text-gray-700';
exportTypeElement.textContent = 'ğŸ“¦ Export Type: {}';
infoCard.appendChild(exportTypeElement);

// Metadata
const metadataDiv = document.createElement('div');
metadataDiv.className = 'text-sm text-gray-600 mb-4';
metadataDiv.innerHTML = `
  <p class="mb-1">ğŸ“… Created: {}</p>
  <p>ğŸ“ Files: {} items</p>
`;
infoCard.appendChild(metadataDiv);

// Files list
const filesSection = document.createElement('div');
filesSection.className = 'mb-4';
infoCard.appendChild(filesSection);

const filesTitle = document.createElement('h4');
filesTitle.className = 'font-medium mb-2 text-gray-700';
filesTitle.textContent = 'ğŸ“‹ Included Files:';
filesSection.appendChild(filesTitle);

const filesList = document.createElement('ul');
filesList.className = 'space-y-1';
filesSection.appendChild(filesList);

// Populate files list
const files = {};
files.forEach(file => {{
  const listItem = document.createElement('li');
  listItem.className = 'bg-gray-50 px-3 py-2 rounded text-sm text-gray-700';
  listItem.textContent = file;
  filesList.appendChild(listItem);
}});

// Download section
const downloadSection = document.createElement('div');
downloadSection.className = 'text-center';
container.appendChild(downloadSection);

// Download button (using SynapticFlow's button component style)
const downloadBtn = document.createElement('button');
downloadBtn.className = 'bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg';
downloadBtn.textContent = 'â¬‡ï¸ Download Now';

downloadBtn.addEventListener('click', () => {{
  // MCP-UI Action: Tool í˜¸ì¶œë¡œ ì‹¤ì œ ë‹¤ìš´ë¡œë“œ ìˆ˜í–‰
  window.parent.postMessage({{
    type: 'tool',
    payload: {{
      toolName: 'download_file',
      params: {{
        path: '{}',
        type: '{}'
      }}
    }}
  }}, '*');
}});

downloadSection.appendChild(downloadBtn);

// Help text
const helpText = document.createElement('p');
helpText.className = 'text-sm text-gray-500 mt-3';
helpText.textContent = 'Click the button above to download your files';
downloadSection.appendChild(helpText);

// Append to root
root.appendChild(container);
            "#,
            title,
            export_type,
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            files.len(),
            files_json,
            download_path,
            export_type
        )
    }

    async fn handle_export_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let source_path_str = match args.get("path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: path",
                );
            }
        };

        let display_name = args
            .get("display_name")
            .and_then(|v| v.as_str())
            .unwrap_or_else(|| {
                std::path::Path::new(source_path_str)
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("exported_file")
            });

        // ê²½ë¡œ ê²€ì¦ ë° íŒŒì¼ ë³µì‚¬ ë¡œì§ (ì´ì „ê³¼ ë™ì¼)
        // ... íŒŒì¼ ì²˜ë¦¬ ì½”ë“œ ...

        let relative_path = format!("exports/files/{}", export_filename);

        // Remote-DOM ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
        let remote_dom_script = self.create_export_remote_dom_script(
            &format!("File Export: {}", display_name),
            &[source_path_str.to_string()],
            "Single File",
            &relative_path,
        );

        // UIResource ì‘ë‹µ ìƒì„± (Remote-DOM)
        let ui_resource = json!({
            "type": "resource",
            "resource": {
                "uri": format!("ui://export/file/{}", request_id),
                "mimeType": "application/vnd.mcp-ui.remote-dom+javascript; framework=react",
                "text": remote_dom_script
            }
        });

        Self::success_response_with_content(request_id, ui_resource)
    }

    async fn handle_export_zip(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        // ZIP ìƒì„± ë¡œì§ (ì´ì „ê³¼ ë™ì¼)
        // ... ZIP íŒŒì¼ ìƒì„± ì½”ë“œ ...

        let relative_path = format!("exports/packages/{}.zip", package_name);
        
        // íŒŒì¼ ëª©ë¡ ì¤€ë¹„
        let file_names: Vec<String> = files_array
            .iter()
            .filter_map(|v| v.as_str().map(|s| s.to_string()))
            .collect();

        // Remote-DOM ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
        let remote_dom_script = self.create_export_remote_dom_script(
            &format!("ZIP Package: {}", package_name),
            &file_names,
            "ZIP Package",
            &relative_path,
        );

        // UIResource ì‘ë‹µ ìƒì„± (Remote-DOM)
        let ui_resource = json!({
            "type": "resource",
            "resource": {
                "uri": format!("ui://export/zip/{}", request_id),
                "mimeType": "application/vnd.mcp-ui.remote-dom+javascript; framework=react",
                "text": remote_dom_script
            }
        });

        Self::success_response_with_content(request_id, ui_resource)
    }
}

    /// Export ë””ë ‰í† ë¦¬ ì´ˆê¸°í™”
    fn ensure_exports_directory(&self) -> Result<std::path::PathBuf, String> {
        let exports_dir = self.get_workspace_dir().join("exports");
        if !exports_dir.exists() {
            std::fs::create_dir_all(&exports_dir)
                .map_err(|e| format!("Failed to create exports directory: {}", e))?;
        }
        Ok(exports_dir)
    }

    fn create_export_file_tool() -> MCPTool {
        let mut props = HashMap::new();
        props.insert(
            "path".to_string(),
            string_prop(Some(1), Some(1000), Some("Workspace ë‚´ exportí•  íŒŒì¼ ê²½ë¡œ")),
        );
        props.insert(
            "display_name".to_string(),
            string_prop(None, None, Some("ë‹¤ìš´ë¡œë“œì‹œ í‘œì‹œí•  íŒŒì¼ëª… (ì„ íƒì )")),
        );
        props.insert(
            "description".to_string(),
            string_prop(None, None, Some("íŒŒì¼ ì„¤ëª… (ì„ íƒì )")),
        );

        MCPTool {
            name: "export_file".to_string(),
            title: Some("Export Single File".to_string()),
            description: "Export a single file from workspace for download".to_string(),
            input_schema: object_schema(props, vec!["path".to_string()]),
            output_schema: None,
            annotations: None,
        }
    }

    fn create_export_zip_tool() -> MCPTool {
        let mut props = HashMap::new();
        props.insert(
            "files".to_string(),
            array_schema(
                string_prop(Some(1), Some(1000), Some("í¬í•¨í•  íŒŒì¼ ê²½ë¡œ")),
                Some("ZIPì— í¬í•¨í•  íŒŒì¼ ëª©ë¡"),
            ),
        );
        props.insert(
            "package_name".to_string(),
            string_prop(None, None, Some("ZIP íŒ¨í‚¤ì§€ëª… (ì„ íƒì , ìë™ ìƒì„±)")),
        );
        props.insert(
            "include_metadata".to_string(),
            boolean_prop(Some("ìë™ ìƒì„± ë©”íƒ€ë°ì´í„° í¬í•¨ ì—¬ë¶€ (ê¸°ë³¸: true)")),
        );

        MCPTool {
            name: "export_zip".to_string(),
            title: Some("Export ZIP Package".to_string()),
            description: "Export multiple workspace files as a ZIP package".to_string(),
            input_schema: object_schema(props, vec!["files".to_string()]),
            output_schema: None,
            annotations: None,
        }
    }

    async fn handle_export_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let source_path_str = match args.get("path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: path",
                );
            }
        };

        let display_name = args
            .get("display_name")
            .and_then(|v| v.as_str())
            .unwrap_or_else(|| {
                std::path::Path::new(source_path_str)
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("exported_file")
            });

        // ê²½ë¡œ ê²€ì¦
        let source_path = match self.validate_path_with_error(source_path_str, &request_id) {
            Ok(path) => path,
            Err(error_response) => return *error_response,
        };

        // exports ë””ë ‰í† ë¦¬ í™•ì¸
        let exports_dir = match self.ensure_exports_directory() {
            Ok(dir) => dir,
            Err(e) => return Self::error_response(request_id, -32603, &e),
        };

        // íŒŒì¼ì„ exports/files ë””ë ‰í† ë¦¬ì— ë³µì‚¬
        let files_dir = exports_dir.join("files");
        if let Err(e) = std::fs::create_dir_all(&files_dir) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to create files directory: {}", e),
            );
        }

        let export_filename = format!("{}_{}", 
            chrono::Utc::now().format("%Y%m%d_%H%M%S"), 
            display_name
        );
        let export_path = files_dir.join(&export_filename);

        // íŒŒì¼ ë³µì‚¬
        if let Err(e) = std::fs::copy(&source_path, &export_path) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to copy file: {}", e),
            );
        }

        // ìƒëŒ€ ê²½ë¡œ ìƒì„± (workspace ê¸°ì¤€)
        let relative_path = format!("exports/files/{}", export_filename);

        Self::success_response(
            request_id,
            &format!(
                "File exported successfully. Use frontend download utility with path: {}",
                relative_path
            ),
        )
    }

    async fn handle_export_zip(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let files_array = match args.get("files").and_then(|v| v.as_array()) {
            Some(files) => files,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: files",
                );
            }
        };

        let package_name = args
            .get("package_name")
            .and_then(|v| v.as_str())
            .unwrap_or(&format!("workspace_export_{}", 
                chrono::Utc::now().format("%Y%m%d_%H%M%S")
            ));

        let include_metadata = args
            .get("include_metadata")
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        // exports ë””ë ‰í† ë¦¬ í™•ì¸
        let exports_dir = match self.ensure_exports_directory() {
            Ok(dir) => dir,
            Err(e) => return Self::error_response(request_id, -32603, &e),
        };

        let packages_dir = exports_dir.join("packages");
        if let Err(e) = std::fs::create_dir_all(&packages_dir) {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to create packages directory: {}", e),
            );
        }

        let zip_filename = format!("{}.zip", package_name);
        let zip_path = packages_dir.join(&zip_filename);

        // ZIP íŒŒì¼ ìƒì„±
        let zip_file = match std::fs::File::create(&zip_path) {
            Ok(file) => file,
            Err(e) => {
                return Self::error_response(
                    request_id,
                    -32603,
                    &format!("Failed to create ZIP file: {}", e),
                );
            }
        };

        let mut zip = zip::ZipWriter::new(zip_file);
        let options = FileOptions::default()
            .compression_method(zip::CompressionMethod::Deflated)
            .unix_permissions(0o755);

        // íŒŒì¼ë“¤ì„ ZIPì— ì¶”ê°€
        for file_value in files_array {
            if let Some(file_path_str) = file_value.as_str() {
                let source_path = match self.validate_path_with_error(file_path_str, &request_id) {
                    Ok(path) => path,
                    Err(_) => continue, // ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ì€ ê±´ë„ˆë›°ê¸°
                };

                if source_path.is_file() {
                    let file_content = match std::fs::read(&source_path) {
                        Ok(content) => content,
                        Err(_) => continue,
                    };

                    let zip_entry_name = source_path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("unknown_file");

                    if let Err(e) = zip.start_file(zip_entry_name, options) {
                        warn!("Failed to add file {} to ZIP: {}", zip_entry_name, e);
                        continue;
                    }

                    if let Err(e) = zip.write_all(&file_content) {
                        warn!("Failed to write file {} content: {}", zip_entry_name, e);
                        continue;
                    }
                }
            }
        }

        // ë©”íƒ€ë°ì´í„° ì¶”ê°€
        if include_metadata {
            let metadata = json!({
                "package_name": package_name,
                "created_at": chrono::Utc::now().to_rfc3339(),
                "files_count": files_array.len(),
                "generator": "SynapticFlow Workspace Export"
            });

            if let Ok(metadata_str) = serde_json::to_string_pretty(&metadata) {
                let _ = zip.start_file("metadata.json", options);
                let _ = zip.write_all(metadata_str.as_bytes());
            }

            // README ì¶”ê°€
            let readme_content = format!(
                "# {}\n\nExported from SynapticFlow Workspace\n\n\
                Created: {}\n\
                Files: {} items\n\n\
                This package contains files exported from your workspace.\n",
                package_name,
                chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                files_array.len()
            );

            let _ = zip.start_file("README.md", options);
            let _ = zip.write_all(readme_content.as_bytes());
        }

        if let Err(e) = zip.finish() {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to finalize ZIP: {}", e),
            );
        }

        // ìƒëŒ€ ê²½ë¡œ ìƒì„±
        let relative_path = format!("exports/packages/{}", zip_filename);

        Self::success_response(
            request_id,
            &format!(
                "ZIP package created successfully. Use frontend download utility with path: {}",
                relative_path
            ),
        )
    }
}

// tools() ë©”ì„œë“œì— ìƒˆ ë„êµ¬ë“¤ ì¶”ê°€
fn tools(&self) -> Vec<MCPTool> {
    vec![
        // ...ê¸°ì¡´ ë„êµ¬ë“¤...
        
        // ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” export ë„êµ¬ë“¤
        Self::create_export_file_tool(),
        Self::create_export_zip_tool(),
    ]
}

// call_tool() ë©”ì„œë“œì— ìƒˆ í•¸ë“¤ëŸ¬ë“¤ ì¶”ê°€
async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
    match tool_name {
        // ...ê¸°ì¡´ ë„êµ¬ë“¤...
        
        // ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” export ë„êµ¬ë“¤
        "export_file" => self.handle_export_file(args).await,
        "export_zip" => self.handle_export_zip(args).await,
        
        _ => {
            let request_id = Self::generate_request_id();
            Self::error_response(
                request_id,
                -32601,
                &format!("Tool '{}' not found", tool_name),
            )
        }
    }
}
```

### 3. í”„ë¡ íŠ¸ì—”ë“œ MCP-UI íŒ¨í‚¤ì§€ í™œìš© (ê¸°ì¡´ ì„¤ì¹˜ë¨)

**í™•ì¸ëœ ì˜ì¡´ì„±**: SynapticFlowëŠ” ì´ë¯¸ MCP-UI íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ê³  ì‚¬ìš© ì¤‘

```json
{
  "dependencies": {
    "@mcp-ui/client": "^5.6.2",    // âœ… ì´ë¯¸ ì„¤ì¹˜ë˜ì–´ ì‚¬ìš© ì¤‘
    "@mcp-ui/server": "^5.2.0"     // âœ… ì´ë¯¸ ì„¤ì¹˜ë¨ (ì„œë²„ì‚¬ì´ë“œ ìœ í‹¸ë¦¬í‹°)
  }
}
```

**í˜„ì¬ ì‚¬ìš© í˜„í™©**:
- `UIResourceRenderer`ì—ì„œ `@mcp-ui/client` ê³µì‹ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ì¤‘
- í‘œì¤€ MCP-UI í”„ë¡œí† ì½œ ì™„ì „ í˜¸í™˜
- HTML, External URL ë¦¬ì†ŒìŠ¤ íƒ€ì… ì§€ì›

### 4. Remote-DOM ì§€ì›ì„ ìœ„í•œ ì¶”ê°€ íŒ¨í‚¤ì§€ (í•„ìš”ì‹œ ì„¤ì¹˜)

**Remote-DOM í™œì„±í™”ë¥¼ ìœ„í•œ ì˜ì¡´ì„± ì¶”ê°€**:

```json
{
  "dependencies": {
    "@remote-dom/core": "^2.0.0"  // Option B êµ¬í˜„ ì‹œ í•„ìš”
  }
}
```

### 4. Remote-DOM ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì„±

**íŒŒì¼**: `src/lib/remote-dom-components.tsx` (ì‹ ê·œ)

```typescript
import { 
  createRemoteComponent, 
  createRemoteElement 
} from '@remote-dom/core';

// SynapticFlow ìŠ¤íƒ€ì¼ì˜ ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬
export const synapticFlowComponentLibrary = {
  // ê¸°ë³¸ HTML ìš”ì†Œë“¤
  'div': createRemoteElement('div'),
  'h1': createRemoteElement('h1'),
  'h3': createRemoteElement('h3'),
  'h4': createRemoteElement('h4'),
  'p': createRemoteElement('p'),
  'ul': createRemoteElement('ul'),
  'li': createRemoteElement('li'),
  'button': createRemoteElement('button'),
  
  // ì»¤ìŠ¤í…€ UI ì»´í¬ë„ŒíŠ¸ë“¤
  'ui-button': createRemoteComponent({
    name: 'ui-button',
    render: ({ children, className, onClick, ...props }) => (
      <button
        className={`
          bg-blue-500 hover:bg-blue-600 text-white font-medium 
          py-3 px-6 rounded-lg transition-colors duration-200 
          shadow-md hover:shadow-lg disabled:opacity-50
          ${className || ''}
        `}
        onClick={onClick}
        {...props}
      >
        {children}
      </button>
    )
  }),
  
  'ui-card': createRemoteComponent({
    name: 'ui-card',
    render: ({ children, className, ...props }) => (
      <div
        className={`
          bg-white rounded-lg shadow-md border border-gray-200
          ${className || ''}
        `}
        {...props}
      >
        {children}
      </div>
    )
  }),
  
  'ui-badge': createRemoteComponent({
    name: 'ui-badge',
    render: ({ children, variant = 'default', className, ...props }) => {
      const variantClasses = {
        default: 'bg-gray-100 text-gray-800',
        primary: 'bg-blue-100 text-blue-800',
        success: 'bg-green-100 text-green-800'
      };
      
      return (
        <span
          className={`
            inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
            ${variantClasses[variant]}
            ${className || ''}
          `}
          {...props}
        >
          {children}
        </span>
      );
    }
  }),
};
```

### 5. Remote-DOM UIResourceRenderer êµ¬ì„±

**íŒŒì¼**: `src/components/ui/RemoteDOMResourceRenderer.tsx` (ì‹ ê·œ)

```typescript
import React from 'react';
import { UIResourceRenderer } from '@mcp-ui/client';
import { synapticFlowComponentLibrary } from '@/lib/remote-dom-components';
import { downloadFromWorkspace } from '@/lib/workspace-download';
import { useUnifiedMCP } from '@/hooks/use-unified-mcp';
import { getLogger } from '@/lib/logger';

const logger = getLogger('RemoteDOMResourceRenderer');

interface RemoteDOMResourceRendererProps {
  resource: any;
}

export function RemoteDOMResourceRenderer({ 
  resource 
}: RemoteDOMResourceRendererProps) {
  const { callTool } = useUnifiedMCP();

  const handleUIAction = async (action: any) => {
    logger.info('Remote-DOM UI Action received', { action });

    try {
      if (action.type === 'tool' && action.payload.toolName === 'download_file') {
        const { path, type } = action.payload.params;
        
        // ì‹¤ì œ ë‹¤ìš´ë¡œë“œ ìˆ˜í–‰
        await downloadFromWorkspace(path, {
          filename: path.split('/').pop(),
          mimeType: type === 'ZIP Package' ? 'application/zip' : 'application/octet-stream'
        });

        logger.info('Download completed successfully', { path, type });
      }
    } catch (error) {
      logger.error('Failed to handle Remote-DOM UI action', { action, error });
    }
  };

  return (
    <UIResourceRenderer
      resource={resource}
      onUIAction={handleUIAction}
      remoteDomProps={{
        library: synapticFlowComponentLibrary,
        // Remote-DOM ì „ìš© ì„¤ì •
        remoteElements: {
          // ì¶”ê°€ ì›ê²© ìš”ì†Œë“¤ ì •ì˜ ê°€ëŠ¥
        }
      }}
      supportedContentTypes={['remoteDom']}
    />
  );
}

```rust
fn create_download_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "path".to_string(),
        string_prop(Some(1), Some(1000), Some("ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì˜ workspace ìƒëŒ€ ê²½ë¡œ")),
    );
    props.insert(
        "type".to_string(),
        string_prop(None, None, Some("íŒŒì¼ íƒ€ì… (Single File, ZIP Package)")),
    );

    MCPTool {
        name: "download_file".to_string(),
        title: Some("Download File".to_string()),
        description: "Download file from workspace exports directory".to_string(),
        input_schema: object_schema(props, vec!["path".to_string()]),
        output_schema: None,
        annotations: None,
    }
}

async fn handle_download_file(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let file_path = match args.get("path").and_then(|v| v.as_str()) {
        Some(path) => path,
        None => {
            return Self::error_response(
                request_id,
                -32602,
                "Missing required parameter: path",
            );
        }
    };

    // workspace ê¸°ì¤€ ì ˆëŒ€ ê²½ë¡œ ìƒì„±
    let full_path = self.get_workspace_dir().join(file_path);
    
    // íŒŒì¼ ì¡´ì¬ í™•ì¸
    if !full_path.exists() {
        return Self::error_response(
            request_id,
            -32603,
            &format!("Export file not found: {}", file_path),
        );
    }

    // Tauri commandë¥¼ í†µí•œ ë‹¤ìš´ë¡œë“œ ì§€ì‹œ
    let download_instruction = format!(
        "File is ready for download. Use Tauri read_file command with path: {} 
        Then create Blob and trigger download in frontend.",
        file_path
    );

    Self::success_response(request_id, &download_instruction)
}
```

### 6. Chat ì»´í¬ë„ŒíŠ¸ì—ì„œ Remote-DOM UIResource ì²˜ë¦¬

**íŒŒì¼**: `src/features/chat/ChatMessage.tsx` (ê¸°ì¡´ ìˆ˜ì •)

```typescript
import { RemoteDOMResourceRenderer } from '@/components/ui/RemoteDOMResourceRenderer';

// ê¸°ì¡´ ë©”ì‹œì§€ ë Œë”ë§ ë¡œì§ì— ì¶”ê°€
function renderMessageContent(content: any) {
  // Remote-DOM UIResource ì‘ë‹µ ì²˜ë¦¬
  if (
    content.type === 'resource' && 
    content.resource?.uri?.startsWith('ui://export/') &&
    content.resource?.mimeType?.includes('remote-dom')
  ) {
    return <RemoteDOMResourceRenderer resource={content.resource} />;
  }

  // ê¸°ì¡´ ë Œë”ë§ ë¡œì§...
  return <div>{content.text}</div>;
}
```

### 7. ë‹¤ìš´ë¡œë“œ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¶”ê°€ MCP Tool

**íŒŒì¼**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
fn create_download_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "path".to_string(),
        string_prop(Some(1), Some(1000), Some("ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì˜ workspace ìƒëŒ€ ê²½ë¡œ")),
    );
    props.insert(
        "type".to_string(),
        string_prop(None, None, Some("íŒŒì¼ íƒ€ì… (Single File, ZIP Package)")),
    );

    MCPTool {
        name: "download_file".to_string(),
        title: Some("Download File".to_string()),
        description: "Download file from workspace exports directory".to_string(),
        input_schema: object_schema(props, vec!["path".to_string()]),
        output_schema: None,
        annotations: None,
    }
}

async fn handle_download_file(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let file_path = match args.get("path").and_then(|v| v.as_str()) {
        Some(path) => path,
        None => {
            return Self::error_response(
                request_id,
                -32602,
                "Missing required parameter: path",
            );
        }
    };

    // workspace ê¸°ì¤€ ì ˆëŒ€ ê²½ë¡œ ìƒì„±
    let full_path = self.get_workspace_dir().join(file_path);
    
    // íŒŒì¼ ì¡´ì¬ í™•ì¸
    if !full_path.exists() {
        return Self::error_response(
            request_id,
            -32603,
            &format!("Export file not found: {}", file_path),
        );
    }

    // Tauri commandë¥¼ í†µí•œ ë‹¤ìš´ë¡œë“œ ì§€ì‹œ
    let download_instruction = format!(
        "File is ready for download. Use Tauri read_file command with path: {} 
        Then create Blob and trigger download in frontend.",
        file_path
    );

    Self::success_response(request_id, &download_instruction)
}
```

```typescript
import { invoke } from '@tauri-apps/api/tauri';
import { getLogger } from '@/lib/logger';

const logger = getLogger('WorkspaceDownload');

export interface DownloadOptions {
  filename?: string;
  mimeType?: string;
}

/**
 * Workspace ë‚´ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤
 */
export async function downloadFromWorkspace(
  relativePath: string,
  options: DownloadOptions = {}
): Promise<void> {
  try {
    logger.info('Starting workspace file download', { relativePath, options });

    // Tauri ëª…ë ¹ì–´ë¡œ íŒŒì¼ ì½ê¸°
    const fileData = await invoke<number[]>('read_file', { 
      filePath: relativePath 
    });

    // Blob ìƒì„±
    const blob = new Blob([new Uint8Array(fileData)], {
      type: options.mimeType || 'application/octet-stream'
    });

    // íŒŒì¼ëª… ê²°ì •
    const filename = options.filename || 
      relativePath.split('/').pop() || 
      'workspace_export';

    // ë‹¤ìš´ë¡œë“œ íŠ¸ë¦¬ê±°
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    URL.revokeObjectURL(url);

    logger.info('Workspace file download completed', { 
      filename, 
      size: blob.size 
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('Workspace file download failed', { 
      relativePath, 
      error: errorMessage 
    });
    throw new Error(`Download failed: ${errorMessage}`);
  }
}

/**
 * MCP Tool export ì‘ë‹µì„ ì²˜ë¦¬í•˜ì—¬ ë‹¤ìš´ë¡œë“œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤
 */
export function handleExportResponse(
  response: { content?: { text?: string }[] }
): void {
  try {
    const text = response.content?.[0]?.text;
    if (!text) {
      throw new Error('Invalid export response format');
    }

    // "Use frontend download utility with path: exports/..." í˜•íƒœì˜ ë©”ì‹œì§€ íŒŒì‹±
    const pathMatch = text.match(/Use frontend download utility with path: (.+)$/);
    if (!pathMatch) {
      throw new Error('Could not extract file path from response');
    }

    const relativePath = pathMatch[1].trim();
    const filename = relativePath.split('/').pop();

    // ë‹¤ìš´ë¡œë“œ ì‹¤í–‰
    downloadFromWorkspace(relativePath, { filename });

  } catch (error) {
    logger.error('Failed to handle export response', { response, error });
    throw error;
  }
}
```

### 6. ê°„ì†Œí™”ëœ ë‹¤ìš´ë¡œë“œ ìœ í‹¸ë¦¬í‹°

**íŒŒì¼**: `src/lib/workspace-download.ts` (ì‹ ê·œ)

```typescript
import { invoke } from '@tauri-apps/api/tauri';
import { getLogger } from '@/lib/logger';

const logger = getLogger('WorkspaceDownload');

export interface DownloadOptions {
  filename?: string;
  mimeType?: string;
}

/**
 * Workspace ë‚´ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤ (MCP-UIì—ì„œ í˜¸ì¶œ)
 */
export async function downloadFromWorkspace(
  relativePath: string,
  options: DownloadOptions = {}
): Promise<void> {
  try {
    logger.info('Starting workspace file download', { relativePath, options });

    // Tauri ëª…ë ¹ì–´ë¡œ íŒŒì¼ ì½ê¸°
    const fileData = await invoke<number[]>('read_file', { 
      filePath: relativePath 
    });

    // Blob ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
    const blob = new Blob([new Uint8Array(fileData)], {
      type: options.mimeType || 'application/octet-stream'
    });

    const filename = options.filename || 
      relativePath.split('/').pop() || 
      'workspace_export';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    logger.info('Workspace file download completed', { 
      filename, 
      size: blob.size 
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('Workspace file download failed', { 
      relativePath, 
      error: errorMessage 
    });
    throw new Error(`Download failed: ${errorMessage}`);
  }
}
```

### 8. Remote-DOM Export UI ì‚¬ìš© ì˜ˆì‹œ

**Chatì—ì„œ export ë„êµ¬ ì‚¬ìš© ì˜ˆì‹œ**:

```bash
ì‚¬ìš©ì: "ì‘ì—…í•œ íŒŒì¼ë“¤ì„ ZIPìœ¼ë¡œ ë‚´ë³´ë‚´ì¤˜"
AI: export_zip ë„êµ¬ í˜¸ì¶œ â†’ Remote-DOM UI ì‘ë‹µ â†’ SynapticFlow ë„¤ì´í‹°ë¸Œ ìŠ¤íƒ€ì¼ ì»´í¬ë„ŒíŠ¸ â†’ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ í´ë¦­ â†’ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
```

**MCP Tool ì‘ë‹µ ë¹„êµ**:

- **ê¸°ì¡´**: `"ZIP package created successfully. Use frontend download utility with path: exports/packages/..."`

- **Remote-DOM ê°œì„ **: SynapticFlowì˜ ë„¤ì´í‹°ë¸Œ Button, Card, Badge ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•œ ì™„ì „íˆ ì¼ê´€ëœ UI
  ```typescript
  // ì‚¬ìš©ìì—ê²Œ ë³´ì´ëŠ” UI (SynapticFlow ì»´í¬ë„ŒíŠ¸ ìŠ¤íƒ€ì¼)
  <ui-card className="p-6">
    <h1 className="text-2xl font-bold">ğŸ‰ ZIP Package: workspace_export_20250904</h1>
    <ui-badge variant="primary">ZIP Package</ui-badge>
    <ul>
      <li>ğŸ“„ report.txt</li>
      <li>ğŸ“Š data.csv</li>
    </ul>
    <ui-button onClick={triggerDownload}>
      â¬‡ï¸ Download Now
    </ui-button>
  </ui-card>
  ```

**Remote-DOMì˜ í•µì‹¬ ì¥ì **:

1. **ì™„ë²½í•œ ë””ìì¸ ì¼ê´€ì„±**: SynapticFlowì˜ ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ì™€ 100% ë™ì¼í•œ ìŠ¤íƒ€ì¼
2. **íƒ€ì… ì•ˆì „ì„±**: TypeScript ê¸°ë°˜ ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬
3. **ì¬ì‚¬ìš©ì„±**: í•œ ë²ˆ ì •ì˜í•œ ì»´í¬ë„ŒíŠ¸ë¥¼ ëª¨ë“  MCP Toolì—ì„œ í™œìš©
4. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì»´í¬ë„ŒíŠ¸ ì¶”ê°€ ì‹œ ì „ì²´ ì‹œìŠ¤í…œì—ì„œ ì¦‰ì‹œ ì‚¬ìš© ê°€ëŠ¥

**MCP Tool ì‘ë‹µ ì˜ˆì‹œ**:

- ê¸°ì¡´: `"ZIP package created successfully. Use frontend download utility with path: exports/packages/..."`
- ê°œì„ : í´ë¦­ ê°€ëŠ¥í•œ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼, íŒŒì¼ ëª©ë¡, ë©”íƒ€ë°ì´í„°ê°€ í¬í•¨ëœ ì¸í„°ë™í‹°ë¸Œ HTML UI

## ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê´€ ì½”ë“œ

### 1. MCP-UI ê¸°ë°˜ Workspace ì¸í”„ë¼

- **íŒŒì¼**: `src-tauri/src/mcp/builtin/workspace.rs`
- **ì£¼ìš” ê¸°ëŠ¥**: UIResource ìƒì„±, HTML UI í…œí”Œë¦¿, MCP-UI Action ì²˜ë¦¬
- **ì¬ì‚¬ìš© ë©”ì„œë“œ**: `create_export_ui_html()`, `success_response_with_content()`, `handle_download_file()`

### 2. UI ì‘ë‹µ ì²˜ë¦¬ ì‹œìŠ¤í…œ

- **íŒŒì¼**: `src/components/ui/UIResourceRenderer.tsx`
- **ì£¼ìš” ê¸°ëŠ¥**: UIResource ë Œë”ë§, onUIAction ì´ë²¤íŠ¸ ì²˜ë¦¬
- **ì¬ì‚¬ìš© ì¸í„°í˜ì´ìŠ¤**: `WorkspaceUIResourceRenderer`, `handleUIAction`

### 3. MCP-UI í´ë¼ì´ì–¸íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬

- **ë¼ì´ë¸ŒëŸ¬ë¦¬**: `@mcp-ui/client`, `@mcp-ui/server`
- **ì£¼ìš” ê¸°ëŠ¥**: UIResource ë Œë”ë§, HTML iframe ê´€ë¦¬, UI Action í†µì‹ 
- **ì¬ì‚¬ìš© ì»´í¬ë„ŒíŠ¸**: `<UIResourceRenderer />`, `createUIResource()`

### 4. íŒŒì¼ ì‹œìŠ¤í…œ ë³´ì•ˆ (ê¸°ì¡´ í™œìš©)

- **íŒŒì¼**: `src-tauri/src/services/secure_file_manager.rs`
- **ì£¼ìš” ê¸°ëŠ¥**: ê²½ë¡œ ê²€ì¦, ì•ˆì „í•œ íŒŒì¼ ì½ê¸°/ì“°ê¸°
- **ì¬ì‚¬ìš© ì¸í„°í˜ì´ìŠ¤**: `read_file()`, `write_file()`, `validate_path()`

### 5. Tauri ëª…ë ¹ì–´ ì²´ê³„ (ê¸°ì¡´ í™œìš©)

- **íŒŒì¼**: `src-tauri/src/lib.rs`
- **ê¸°ì¡´ ëª…ë ¹ì–´**: `read_file`, `write_file`
- **ì¬ì‚¬ìš© ë°©ë²•**: exportëœ íŒŒì¼ì„ ê¸°ì¡´ read_file ëª…ë ¹ì–´ë¡œ ì½ì–´ ë‹¤ìš´ë¡œë“œ

### 6. Chat UI í†µí•© ì‹œìŠ¤í…œ

- **íŒŒì¼**: `src/features/chat/ChatMessage.tsx`
- **ì£¼ìš” ê¸°ëŠ¥**: UIResource ê°ì§€ ë° ì „ìš© ë Œë”ëŸ¬ í˜¸ì¶œ
- **ì¬ì‚¬ìš© ë°©ë²•**: ê¸°ì¡´ ë©”ì‹œì§€ ë Œë”ë§ ë¡œì§ì— UIResource ì²˜ë¦¬ ì¶”ê°€

### 4. MCP ìŠ¤í‚¤ë§ˆ ë¹Œë”

- **íŒŒì¼**: `src-tauri/src/mcp/utils/schema_builder.rs`
- **ì£¼ìš” ê¸°ëŠ¥**: ë„êµ¬ ìŠ¤í‚¤ë§ˆ ì •ì˜ ìœ í‹¸ë¦¬í‹°
- **ì¬ì‚¬ìš© í•¨ìˆ˜**: `object_schema()`, `string_prop()`, `boolean_prop()`, `array_schema()`

### 5. í”„ë¡ íŠ¸ì—”ë“œ MCP í´ë¼ì´ì–¸íŠ¸

- **íŒŒì¼**: `src/hooks/use-unified-mcp.ts`
- **ì£¼ìš” ê¸°ëŠ¥**: MCP ë„êµ¬ í˜¸ì¶œ ì¸í„°í˜ì´ìŠ¤
- **ì¬ì‚¬ìš© ë°©ë²•**: export ë„êµ¬ í˜¸ì¶œì— ê¸°ì¡´ `callTool` ë©”ì„œë“œ í™œìš©

### 6. ë¡œê¹… ì‹œìŠ¤í…œ

- **íŒŒì¼**: `src/lib/logger.ts`
- **ì£¼ìš” ê¸°ëŠ¥**: êµ¬ì¡°í™”ëœ ë¡œê¹…
- **ì¬ì‚¬ìš© ë°©ë²•**: export ê³¼ì •ì˜ ìƒì„¸ ë¡œê·¸ ê¸°ë¡

## êµ¬í˜„ ë‹¨ê³„

### Phase 1: Remote-DOM ê¸°ë³¸ ì¸í”„ë¼ êµ¬ì¶• (2-3ì¼)

1. MCP-UI ë° Remote-DOM ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì • ë° ì˜ì¡´ì„± ì¶”ê°€
2. SynapticFlow ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì„± (ui-button, ui-card, ui-badge ë“±)
3. WorkspaceServerì— Remote-DOM UIResource ì‘ë‹µ ê¸°ëŠ¥ ì¶”ê°€
4. RemoteDOMResourceRenderer ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸

### Phase 2: Export Tool Remote-DOM í†µí•© (3ì¼)

1. export_file MCP Toolì„ Remote-DOM UIResource ì‘ë‹µìœ¼ë¡œ êµ¬í˜„
2. Remote-DOM ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ë¡œì§ ë° ì»´í¬ë„ŒíŠ¸ ë§¤í•‘
3. onUIActionì„ í†µí•œ ë‹¤ìš´ë¡œë“œ íŠ¸ë¦¬ê±° êµ¬í˜„
4. download_file MCP Tool êµ¬í˜„ ë° ì—°ë™

### Phase 3: ZIP ì§€ì› ë° ê³ ê¸‰ ì»´í¬ë„ŒíŠ¸ (2-3ì¼)

1. export_zip MCP Toolì„ Remote-DOM UIResource ì‘ë‹µìœ¼ë¡œ êµ¬í˜„
2. íŒŒì¼ ëª©ë¡ í‘œì‹œìš© ì»¤ìŠ¤í…€ ì»´í¬ë„ŒíŠ¸ ê°œë°œ
3. ZIP ë©”íƒ€ë°ì´í„° ë° ì§„í–‰ ìƒíƒœ í‘œì‹œ UI
4. ë‹¤ì¤‘ íŒŒì¼ ì²˜ë¦¬ ìµœì í™”

### Phase 4: UI/UX ì™„ì„± ë° í†µí•© (2ì¼)

1. SynapticFlow ë””ìì¸ ì‹œìŠ¤í…œê³¼ ì™„ì „í•œ ì¼ê´€ì„± í™•ë³´
2. Chat ë©”ì‹œì§€ ë Œë”ë§ì— Remote-DOM UIResource ì²˜ë¦¬ í†µí•©
3. ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¥ ë° ì¬ì‚¬ìš©ì„± í–¥ìƒ
4. ì„±ëŠ¥ ìµœì í™” ë° ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ 
