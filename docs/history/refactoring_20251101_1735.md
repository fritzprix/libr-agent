# Refactoring Plan: Taming Over-Complicated Modules

Date: 2025-11-01 17:35  
Branch: feat/on-board  
Author: Copilot

---

## 1) 작업의 목적

대형/복잡 모듈의 응집도를 높이고 결합도를 낮춰서 유지보수성을 개선하고, 렌더/실행 경로 최적화를 통해 응답성 및 안정성을 향상한다.

목표:

- 파일 단위 크기: 1000+ → < 400 LOC 단위로 분리 (최소 2~4개 서브모듈)
- 컨텍스트/서비스 레이어: 역할/경계 명확화, 단방향 의존성 유지
- 성능: 중요 경로(채팅, MCP 호출) 10~30% 지연 감소
- 테스트: 단위/계약 테스트 커버리지 확대 (핵심 경로 70%+)

---

## 2) 현재의 상태 / 문제점

최근 스캔 결과(./scripts/find_large_files.sh):

- 1063 LOC: `src/lib/web-mcp/modules/playbook-store.ts`
- 1023 LOC: `src/lib/web-mcp/modules/planning-server.ts`
- 986 LOC: `src/lib/rust-backend-client.ts`
- 983 LOC: `src/lib/web-mcp/modules/ui-tools.ts`
- 849 LOC: `src-tauri/src/mcp/server.rs`
- 843 LOC: `src/lib/mcp-types.ts`
- 724 LOC: `src/components/ui/sidebar.tsx`
- 705 LOC: `src/context/ResourceAttachmentContext.tsx`
- 622 LOC: `src/context/ChatContext.tsx`
- 578 LOC: `src/context/SessionContext.tsx`
- 561 LOC: `src/lib/logger.ts`
- 556 LOC: `src/features/chat/components/WorkspaceFilesPanel.tsx`

공통 문제 패턴:

- 단일 파일에서 여러 책임(로딩/비즈니스로직/상태/뷰)을 처리 → 응집도 저하
- 직접 의존이 복잡하게 얽혀 테스트/교체 어려움
- 거대한 타입/스키마 파일에서 재사용 어려움 (`mcp-types.ts`)
- 컨텍스트 파일에 I/O와 계산 로직 혼재 → 리렌더링 전파와 병목 발생

---

## 3) Birdeye View (구조/동작 요약)

도메인별 레이어:

- Web MCP 모듈: planning-server, playbook-store, ui-tools → 브라우저 워커/프록시, 명령 처리, 캐시/검색/검증, 도메인 로직.
- Service Layer: `rust-backend-client.ts` → Tauri 명령 래퍼, 안전 호출(safeInvoke), 결과 변환.
- Context Layer: Chat/Session/ResourceAttachment → 상태 분배, I/O 혼재, 파생 상태 계산.
- Types: `mcp-types.ts` → 프로토콜/콘텐츠/툴 정의가 단일 파일에 집중.

흐름 요약:

User → React UI → Context/Service → (Web Worker MCP or Tauri) → 도메인 모듈 → 응답/업데이트 → UI 반영

현재 단위 경계가 명확하지 않아 상호 침투(침식)가 발생하고, 테스트하기 힘든 구조.

---

## 4) 변경 이후의 상태 / 해결 판정 기준

바람직한 상태:

- 각 모듈은 단일 책임 기반으로 2~4개 서브모듈로 분리
- 컨텍스트는 얇게: 파생 상태/구독/액션만, I/O는 서비스로 위임
- 타입/스키마는 작은 단위로 분리, 재사용/트리쉐이킹 용이
- 공통 유틸/어댑터로 의존성 역전 (테스트 더블 주입 쉬움)

판정 기준:

- [ ] 상위 6개 대형 파일 각각 2개 이상 서브파일로 분리, 최대 파일 < 400 LOC
- [ ] 컨텍스트에서 서비스 호출/비즈니스 로직 70% 이상 분리
- [ ] MCP 호출/채팅 경로 벤치마크(로딩/응답) 10~30% 개선
- [ ] 핵심 경로 테스트 커버리지 70%+
- [ ] `pnpm refactor:validate` 전 과정 PASS

---

## 5) 수정이 필요한 코드 및 스니핏 (핵심 제안)

### 5.1 web-mcp: planning-server.ts (1023 LOC)

제안 분리:

- transport.ts: 워커/프록시, 메시지 전송/수신 어댑터
- commands.ts: 계획/세션/스텝 관리 명령 핸들러
- state.ts: 세션 스냅샷, 메모리/캐시 레이어
- schema.ts: zod 스키마/타입 내보내기

예시 스니핏:

```ts
// src/lib/web-mcp/modules/planning-server/commands.ts
import { z } from 'zod';
import { send } from './transport';
import { planSchema } from './schema';

export const createPlan = async (input: unknown) => {
  const parsed = planSchema.parse(input);
  return send('planning.create', parsed);
};
```

```ts
// src/lib/web-mcp/modules/planning-server/index.ts
export * from './commands';
export * from './state';
```

마이그레이션: 기존 `import { PlanningServerProxy } from .../planning-server` → `.../planning-server` (index 리에스크포트).

### 5.2 web-mcp: playbook-store.ts (1063 LOC)

제안 분리:

- repository.ts: 저장/로드/인덱싱
- search.ts: BM25 등 검색 전용 로직
- validator.ts: 스키마 검증, 마이그레이션
- cache.ts: 메모리 캐시/무효화 규칙

예시 스니핏:

```ts
// src/lib/web-mcp/modules/playbook-store/repository.ts
export interface PlaybookRecord {
  id: string;
  title: string;
  body: string;
}
export class PlaybookRepository {
  async save(pb: PlaybookRecord) {
    /* ... */
  }
  async fetch(id: string) {
    /* ... */
  }
}
```

### 5.3 web-mcp: ui-tools.ts (983 LOC)

제안 분리:

- tools/
  - navigation.ts (navigate, back, forward)
  - input.ts (type, click)
  - content.ts (extract, list)
- registry.ts: 툴 등록/검색, 공통 스키마

예시 스니핏:

```ts
// src/lib/web-mcp/modules/ui-tools/registry.ts
export interface Tool {
  name: string;
  run: (args: unknown) => Promise<unknown>;
}
export const toolRegistry = new Map<string, Tool>();
export function registerTool(tool: Tool) {
  toolRegistry.set(tool.name, tool);
}
```

### 5.4 lib: rust-backend-client.ts (986 LOC)

제안 분리:

- invoker.ts: safeInvoke, 공통 오류/리트라이, 결과 역직렬화
- fs.ts, mcp.ts, browser.ts: 도메인별 커맨드 래퍼
- types.ts: 커맨드/결과 타입들 분리

예시 스니핏:

```ts
// src/lib/rust-backend/invoker.ts
import { invoke } from '@tauri-apps/api/core';

export async function safeInvoke<T>(cmd: string, payload: unknown): Promise<T> {
  try {
    return await invoke<T>(cmd, payload as Record<string, unknown>);
  } catch (e) {
    /* normalize & rethrow */ throw e;
  }
}
```

### 5.5 lib: mcp-types.ts (843 LOC)

제안 분리:

- protocol.ts: 코어 프로토콜 타입 (messages, tools, resources)
- content.ts: Content/Attachment 타입
- schema.ts: zod 스키마 정의, from JSON schema (가능 시)

예시 스니핏:

```ts
// src/lib/mcp/types/protocol.ts
export interface MCPMessage {
  role: 'user' | 'assistant';
  content: unknown[];
}
```

### 5.6 context: ChatContext.tsx (622), SessionContext.tsx (578), ResourceAttachmentContext.tsx (705)

제안 분리(공통):

- services/ 디렉토리로 I/O/비즈니스 로직 이전
- context는 파생 상태와 액션 디스패치만 유지
- 이벤트(스크롤/입력) 최적화는 공용 hooks 로 이전 (`useThrottle`, `useDebounce`)

예시 스니핏:

```ts
// src/context/chat/chat-service.ts
export class ChatService {
  // pure async methods: buildPrompt, send, parse, etc.
}
```

```tsx
// src/context/ChatContext.tsx (간결화)
const service = useMemo(() => new ChatService(), []);
const submit = useCallback((msgs) => service.send(msgs), [service]);
```

### 5.7 components/ui/sidebar.tsx (724)

제안:

- Sidebar.tsx → 작은 컴포넌트(Section, Item, Footer)로 분할
- 데이터 계산(useMemo) vs 렌더링 분리, memo + key 안정화

---

## 6) 재사용 가능한 연관 코드

- `src/hooks/useThrottle.ts` (완료): 고빈도 이벤트 성능 안정화
- `src/hooks/useDebounce.ts` (신규 제안): 입력/검색 지연 처리
- `src/lib/services/*`: invoker, repository, validator, registry, cache 등의 공통 패턴
- `src/lib/types/*`: 작은 모듈로 타입/스키마 구성

---

## 7) Test Code 추가/수정 가이드

전략:

- 계약 테스트(Contract): transport/invoker 레벨에서 성공/오류 경로 검증
- 단위 테스트(Unit): repository, validator, registry 로직 커버
- 컨텍스트 통합 테스트: 얇아진 컨텍스트가 서비스에 위임되는지

예시:

```ts
// src/lib/rust-backend/__tests__/invoker.test.ts
import { safeInvoke } from '../invoker';

test('safeInvoke propagates normalized errors', async () => {
  // mock invoke → throw, expect normalized
});
```

```ts
// src/lib/web-mcp/modules/planning-server/__tests__/commands.test.ts
import { createPlan } from '../commands';

test('createPlan validates input and dispatches', async () => {
  // zod parse ok, transport called with proper channel
});
```

커버리지 목표: 핵심 경로 70%+, 실패 경로/엣지 케이스 1~2개 포함.

---

## 8) 작업 단계 (Phased Plan)

Phase 0 — 안전한 인프라 정리 (0.5일)

- 디렉토리 스캐폴드 추가: `src/lib/web-mcp/modules/{planning-server,playbook-store,ui-tools}/...`
- index 리에스크포트 준비, 타입 모듈 디렉토리 생성(`src/lib/mcp/types/*`)

Phase 1 — Services/Types 추출 (1~2일)

- `rust-backend-client.ts` → invoker + 도메인 래퍼 분리
- `mcp-types.ts` → protocol/content/schema 로 분리

Phase 2 — Web MCP 모듈 분할 (2~3일)

- planning-server, playbook-store, ui-tools 각각 3~4개 파일로 분리
- 레거시 import 호환을 위해 index.ts 유지

Phase 3 — Context 얇게 (1~2일)

- Chat/Session/ResourceAttachment의 I/O/로직 서비스 이전
- 컨텍스트는 파생 상태 + 액션 위임 유지, 이벤트 최적화 적용

Phase 4 — UI 컴포넌트 분리 (0.5~1일)

- `components/ui/sidebar.tsx` 소형 컴포넌트로 분할, memoization

Phase 5 — 검증/정리 (0.5~1일)

- `pnpm refactor:validate` 전체 통과
- 프로파일링(React DevTools, Performance): 개선 수치 기록

---

## 9) 성공 지표

- 대형 파일 6개 분리 완료, 최대 파일 < 400 LOC
- MCP/채팅 주요 경로에서 10~30% 응답 개선(프로파일링 기준)
- 테스트 70%+ 커버리지, CI 안정화
- 문서/디렉토리 구조 일관성 확보

---

## 10) 롤백 플랜

- 각 Phase 별 브랜치 분리: `refactor/phase-x-*`
- index 리에스크포트로 점진 마이그레이션 가능
- 문제 발생 시 이전 태그로 리버트, import 경로 영향 최소화

---

## 11) Clarification Q-list

1. Web MCP 모듈에서 브라우저/워커 분리 수준

- 워커/메인 스레드 교차가 잦은 부분을 어떤 기준으로 나눌지? (전송량/빈도 기반)

2. mcp-types 분해 범위

- 외부 MCP 서버 통합 시 호환성 이슈 고려해 zod 스키마 생성까지 진행할지?

3. Context 경량화 시 상태 관리 대안

- 현재 React Context 유지 vs 내부적으로 Zustand 래핑 도입(외부 API 동일)

4. 리팩토링 순서

- 가장 영향 큰 `rust-backend-client.ts` 우선 분리 vs Web MCP 모듈부터 분리 — 우선순위 확인 필요

---

## 12) 추가 참고

- 문서 규칙: `./docs/history/refactoring_{yyyyMMdd_hhmm}.md`
- 실행: `pnpm refactor:validate` (lint/format/Rust/build/dead-code)
- 성능 측정: React DevTools Profiler, Chrome Performance, Lighthouse
