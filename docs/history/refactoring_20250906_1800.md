# MCP Sampling 시스템 및 UI Action 처리 구현 계획

## 작업의 목적

MCP (Model Context Protocol) 스펙에 준수하는 올바른 Sampling 시스템을 구현하고, MCP-UI의 UI Action 처리를 완성하여 AI 에이전트가 사용자와 상호작용할 수 있는 완전한 환경을 구축한다.

### 주요 목표

1. **MCP Sampling 스펙 준수**: 서버가 클라이언트에게 LLM 추론을 요청하는 올바른 방향 구현
2. **Tauri Events 기반 통신**: Backend → Frontend 이벤트 채널 구축
3. **UI Action 처리 완성**: 모든 MCP-UI 액션 타입에 대한 완전한 구현
4. **기존 시스템 통합**: 현재 Chat/Tool 시스템과의 원활한 통합

---

## 현재의 상태 / 문제점

### 1. **잘못된 Sampling 구현**

```rust
// ❌ 잘못된 방향: 클라이언트가 서버에게 sampling 요청
pub async fn sample_from_model(&self, server_name: &str, request: SamplingRequest) -> MCPResponse
```

```typescript
// ❌ 잘못된 방향: 클라이언트가 서버에게 sampling 요청
export async function sampleFromModel(
  serverName: string,
  prompt: string,
): Promise<SamplingResponse>;
```

**문제점**: MCP 스펙에서는 **서버가 클라이언트에게** LLM 추론을 요청해야 하는데, 현재는 반대 방향으로 구현됨

### 2. **Backend → Frontend 통신 채널 부재**

- 현재는 Frontend → Backend 통신만 가능 (Tauri commands)
- 서버에서 클라이언트로 sampling 요청을 보낼 방법이 없음

### 3. **불완전한 UI Action 처리**

```tsx
// 현재 MessageRenderer.tsx의 handleUIAction
const handleUIAction = useCallback(
  async (result: UIActionResult) => {
    switch (result.type) {
      case 'tool':
        // 부분 구현됨 (await 누락)
        break;
      case 'intent':
      case 'prompt':
      case 'link':
      case 'notify':
        // 모두 빈 케이스
        break;
    }
  },
  [executeToolCall],
);
```

### 4. **타입 정의 불일치**

- 현재 Sampling 타입이 MCP 스펙과 맞지 않음
- `sampling/createMessage` 스펙 미준수

---

## 추가 분석 과제

### 1. **Tauri Events 성능 및 안정성**

- 대량의 sampling 요청 시 이벤트 시스템 성능 검증
- 네트워크 단절 시나리오에서의 타임아웃 처리

### 2. **동시성 제어 메커니즘**

- 여러 MCP 서버에서 동시에 sampling 요청이 올 때의 처리 방식
- 기존 ChatContext의 pending 상태와의 충돌 방지

### 3. **UI Action 확장성**

- 향후 추가될 수 있는 새로운 액션 타입에 대한 확장 구조
- 사용자 정의 액션 처리 방안

---

## 변경 이후의 상태 / 해결 판정 기준

### 1. **올바른 MCP Sampling 플로우 구현**

```
✅ MCP Server → (sampling request) → SynapticFlow Client → LLM → (response) → MCP Server
```

**판정 기준**:

- Rust Builtin MCP 서버에서 sampling 요청 가능
- Web Worker MCP 서버에서 sampling 요청 가능
- 요청 ID 기반 정확한 응답 매칭

### 2. **완전한 UI Action 처리**

**판정 기준**:

- `tool`: MCP 도구 호출 실행
- `intent`: 자연어로 변환하여 AI에게 전달
- `prompt`: 새로운 사용자 메시지 생성
- `link`: 외부 링크 열기
- `notify`: 알림 메시지 표시

### 3. **통합된 통신 시스템**

**판정 기준**:

- Frontend → Backend (기존 Tauri commands)
- Backend → Frontend (새로운 Tauri events)
- 양방향 통신의 안정성 확보

---

## 수정이 필요한 코드 및 수정부분

### Phase 1: 잘못된 구현 제거

#### 1.1 Rust Backend 정리

```rust
// src-tauri/src/lib.rs - 삭제할 부분
#[tauri::command]
async fn sample_from_mcp_server(
    server_name: String,
    prompt: String,
    options: Option<serde_json::Value>,
) -> Result<MCPResponse, String> {
    // 전체 함수 삭제
}
```

```rust
// src-tauri/src/mcp/server.rs - 삭제할 부분
impl MCPServerManager {
    pub async fn sample_from_model(
        &self,
        server_name: &str,
        request: SamplingRequest,
    ) -> MCPResponse {
        // 전체 메서드 삭제
    }
}
```

#### 1.2 Frontend 정리

```typescript
// src/lib/rust-backend-client.ts - 삭제할 부분
export async function sampleFromModel(
  serverName: string,
  prompt: string,
  options?: SamplingOptions,
): Promise<SamplingResponse> {
  // 전체 함수 삭제
}
```

```typescript
// src/context/MCPServerContext.tsx - 삭제할 부분
sampleFromModel: (
  serverName: string,
  prompt: string,
  options?: SamplingOptions,
) => Promise<SamplingResponse>;
```

### Phase 2: 올바른 타입 정의

#### 2.1 MCP 스펙 준수 타입

```typescript
// src/lib/mcp-types.ts - 추가할 부분
export interface SamplingRequestEvent {
  requestId: string;
  serverName: string;
  method: 'sampling/createMessage';
  params: {
    messages: SamplingMessage[];
    modelPreferences?: ModelPreferences;
    systemPrompt?: string;
    includeContext?: 'none' | 'thisServer' | 'allServers';
    temperature?: number;
    maxTokens?: number;
    stopSequences?: string[];
  };
}

export interface SamplingMessage {
  role: 'user' | 'assistant' | 'system';
  content: ContentBlock[];
}
```

### Phase 3: Tauri Events 구현

#### 3.1 Backend 이벤트 발송

```rust
// src-tauri/src/mcp/server.rs - 추가할 부분
impl MCPServerManager {
    pub async fn request_sampling(
        &self,
        app_handle: &AppHandle,
        server_name: &str,
        request: SamplingRequestEvent,
    ) -> Result<SamplingResponse, String> {
        let request_id = Uuid::new_v4().to_string();

        // Frontend로 sampling 요청 이벤트 전송
        app_handle.emit("mcp-sampling-request", &request)
            .map_err(|e| format!("Failed to emit sampling request: {e}"))?;

        // 응답 대기 로직
        // ...
    }
}
```

#### 3.2 Frontend 이벤트 처리

```typescript
// src/hooks/use-mcp-sampling.ts - 새 파일
export const useMCPSampling = () => {
  const { submit } = useChatContext();

  useEffect(() => {
    const unlisten = listen('mcp-sampling-request', async (event) => {
      const samplingRequest = event.payload as SamplingRequestEvent;
      // LLM 호출 및 응답 처리
      const response = await handleSamplingRequest(samplingRequest);
      await invoke('respond_to_sampling', {
        requestId: samplingRequest.requestId,
        response,
      });
    });

    return () => unlisten.then((fn) => fn());
  }, []);
};
```

### Phase 4: UI Action 완성

```tsx
// src/components/MessageRenderer.tsx - 수정할 부분
const handleUIAction = useCallback(
  async (result: UIActionResult) => {
    logger.debug('UI action received', {
      type: result.type,
      payload: result.payload,
    });

    switch (result.type) {
      case 'tool': {
        try {
          await executeToolCall({
            id: createId(),
            type: 'function',
            function: {
              name: result.payload.toolName,
              arguments: JSON.stringify(result.payload.params),
            },
          });
        } catch (error) {
          logger.error('Tool call failed', { error });
        }
        break;
      }

      case 'intent': {
        const intentMessage: Message = {
          id: createId(),
          role: 'user',
          content: stringToMCPContentArray(
            `User intent: ${result.payload.intent}`,
          ),
          sessionId: currentSession?.id || '',
        };
        await submit([intentMessage]);
        break;
      }

      case 'prompt': {
        const userMessage: Message = {
          id: createId(),
          role: 'user',
          content: stringToMCPContentArray(result.payload.prompt),
          sessionId: currentSession?.id || '',
        };
        await submit([userMessage]);
        break;
      }

      case 'link': {
        await handleLinkClick(
          new MouseEvent('click') as React.MouseEvent,
          result.payload.url,
        );
        break;
      }

      case 'notify': {
        // 알림을 시스템 메시지로 추가
        addMessage({
          id: createId(),
          role: 'system',
          content: stringToMCPContentArray(`🔔 ${result.payload.message}`),
          sessionId: currentSession?.id || '',
        });
        break;
      }
    }
  },
  [executeToolCall, submit, handleLinkClick, addMessage, currentSession],
);
```

---

## 재사용 가능한 연관 코드

### 1. **기존 Chat 시스템**

- **파일**: `src/context/ChatContext.tsx`
- **주요 기능**: 메시지 큐 관리, pending 상태 제어
- **인터페이스**: `submit()`, `addToMessageQueue()`, `handleUIAction()`

### 2. **Unified MCP 시스템**

- **파일**: `src/hooks/use-unified-mcp.ts`
- **주요 기능**: 다중 MCP 백엔드 통합 관리
- **인터페이스**: `executeToolCall()`, 도구 타입 resolution

### 3. **AI Service 시스템**

- **파일**: `src/hooks/use-ai-service.ts`
- **주요 기능**: LLM 통신 및 스트리밍 처리
- **인터페이스**: `submit(messages, systemPrompt)`

### 4. **기존 Tauri Commands**

- **파일**: `src-tauri/src/lib.rs`
- **주요 기능**: Frontend-Backend 통신 패턴
- **재사용 패턴**: `#[tauri::command]`, 에러 처리

### 5. **MCP 타입 시스템**

- **파일**: `src/lib/mcp-types.ts`, `src-tauri/src/mcp/types.rs`
- **주요 기능**: MCP 프로토콜 타입 정의
- **확장 포인트**: 새로운 sampling 타입 추가

### 6. **브라우저 서비스 참조**

- **파일**: `src-tauri/src/services/interactive_browser_server.rs`
- **주요 기능**: AppHandle 사용 패턴, 이벤트 리스너 등록
- **재사용 패턴**: Tauri window/event 관리

---

## 구현 우선순위

1. **High Priority**: 잘못된 구현 제거 및 타입 정의 (Phase 1, 2)
2. **Medium Priority**: Tauri Events 기반 통신 구현 (Phase 3)
3. **Medium Priority**: UI Action 처리 완성 (Phase 4)
4. **Low Priority**: 통합 테스트 및 최적화

이 계획을 통해 MCP 스펙을 준수하는 완전한 Sampling 시스템과 UI 상호작용 기능을 구현할 수 있다.
