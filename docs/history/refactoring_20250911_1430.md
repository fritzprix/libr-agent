# Refactoring Plan: Chat Planning Status Visualization

## 작업의 목적

Chat.tsx에 AI Agent의 Planning 상태를 실시간으로 시각화하는 기능을 추가하여, 사용자가 대화 중에 AI의 현재 계획, 목표, 진행 상황을 GUI로 확인할 수 있도록 한다.

## 현재의 상태 / 문제점

### 현재 상태

- Planning 서버(`planning-server.ts`)가 Web Worker에서 정상 동작 중
- AI Agent가 `WebMCPToolProvider`를 통해 Planning 도구들을 사용하여 목표 설정, 할일 관리, 관찰 기록을 수행
- `use-web-mcp-server.ts`가 싱글톤 패턴으로 구현되어 type-safe한 MCP 서버 접근 제공
- Chat.tsx가 compound component 패턴으로 구조화됨

### 문제점

- AI Agent의 Planning 상태(목표, 할일, 관찰)를 사용자가 실시간으로 확인할 수 없음
- Planning 서버에 UI용 상태 조회 기능이 없음 (`getServiceContext`는 텍스트 형태로만 제공)
- 사용자가 AI의 계획 진행 상황을 파악하기 어려워 대화의 맥락 이해가 제한됨

## 핵심 개선 사항 (대화 결과 반영)

### 1. 메시지 기반 상태 업데이트 채택

- **30초 polling 방식 대신** ChatContext의 `messages` 배열을 추적하여 새로운 메시지 발생 시에만 Planning 상태 업데이트
- `useRef`를 활용한 중복 호출 방지로 성능 최적화
- 즉각적인 UI 반응성과 불필요한 API 호출 최소화

### 2. shadcn/ui 및 next-theme 일관성

- **과도한 색상 사용 지양**: 현재 프로젝트의 neutral 색상 팔레트 유지
- **shadcn/ui 컴포넌트 활용**: Card, Button, Badge 등 기존 디자인 시스템과 일관된 컴포넌트 사용
- **next-theme 호환성**: 자동 다크모드 지원 및 theme-aware 스타일링

### 3. 타입 안전성 및 에러 처리 강화

- 구조화된 에러 상태 UI 제공
- 로딩 상태 및 재시도 메커니즘 구현
- TypeScript strict 모드 준수

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

- Chat 인터페이스에서 AI Agent의 현재 목표, 진행 중인 할일, 완료된 할일, 최근 관찰 내용을 실시간으로 확인 가능
- Planning 패널을 토글하여 필요시에만 표시하되, 대화 흐름을 방해하지 않음
- Type-safe한 Planning 상태 접근으로 개발자 경험 향상

### 성공 판정 기준

- [ ] Planning 서버에서 구조화된 상태 데이터를 JSON 형태로 조회 가능
- [ ] Chat 인터페이스에 Planning 패널이 토글 가능한 형태로 통합
- [ ] AI가 Planning 도구를 사용한 후 UI 상태가 적절한 시간 내에 업데이트됨
- [ ] 기존 Chat 기능에 영향 없이 Planning 시각화 기능이 동작
- [ ] TypeScript 컴파일 오류 없이 type-safe한 구현 완료

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Planning 서버 확장 (`src/lib/web-mcp/modules/planning-server.ts`)

**기존 구현 확인**: `get_current_state` 툴이 이미 구현되어 있음

```typescript
case 'get_current_state': {
  const currentState = {
    goal: state.getGoal(),
    lastClearedGoal: state.getLastClearedGoal(),
    todos: state.getTodos(),
    observations: state.getObservations(),
  };

  return {
    jsonrpc: '2.0',
    id: null,
    result: {
      content: [{
        type: 'text',
        text: JSON.stringify(currentState)
      }]
    }
  };
}
```

### 2. TypeScript 타입 정의 (`src/models/planning.ts` - 새로 생성)

```typescript
export interface SimpleTodo {
  name: string;
  status: 'pending' | 'completed';
}

export interface PlanningState {
  goal: string | null;
  lastClearedGoal: string | null;
  todos: SimpleTodo[];
  observations: string[];
}

export interface PlanningServerProxy extends WebMCPServerProxy {
  create_goal: (args: { goal: string }) => Promise<string>;
  add_todo: (args: {
    name: string;
  }) => Promise<{ success: boolean; todos: SimpleTodo[] }>;
  toggle_todo: (args: {
    index: number;
  }) => Promise<{ todo: SimpleTodo | null; todos: SimpleTodo[] }>;
  clear_todos: () => Promise<{ success: boolean }>;
  clear_session: () => Promise<void>;
  add_observation: (args: { observation: string }) => Promise<void>;
  get_current_state: () => Promise<PlanningState>;
}
```

### 3. Planning Panel 컴포넌트 (`src/features/chat/components/ChatPlanningPanel.tsx` - 새로 생성)

```typescript
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { useWebMCPServer } from '@/hooks/use-web-mcp-server';
import { useChatContext } from '@/context/ChatContext';
import type { PlanningServerProxy, PlanningState } from '@/models/planning';
import { getLogger } from '@/lib/logger';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { RefreshCw } from 'lucide-react';

const logger = getLogger('ChatPlanningPanel');

export function ChatPlanningPanel() {
  const { server, loading, error } = useWebMCPServer<PlanningServerProxy>('planning');
  const { messages } = useChatContext();
  const [planningState, setPlanningState] = useState<PlanningState | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const lastHandledMessageRef = useRef<{ id?: string }>({});

  const refreshState = useCallback(async () => {
    if (!server?.get_current_state) return;

    try {
      setIsRefreshing(true);
      const state = await server.get_current_state();
      setPlanningState(state);
      logger.info('Planning state updated');
    } catch (err) {
      logger.error('Failed to refresh planning state', err);
    } finally {
      setIsRefreshing(false);
    }
  }, [server]);

  // 메시지 기반 상태 업데이트 (30초 polling 대신)
  useEffect(() => {
    if (!server?.get_current_state || messages.length === 0) return;

    const lastMessage = messages[messages.length - 1];
    if (lastHandledMessageRef.current.id === lastMessage.id) {
      return;
    }
    lastHandledMessageRef.current.id = lastMessage.id;

    // 새로운 메시지가 있을 때만 Planning 상태 업데이트
    refreshState();
  }, [messages, refreshState]);

  if (loading) {
    return (
      <Card className="w-80 m-4">
        <CardContent className="p-6">
          <div className="animate-pulse text-muted-foreground">
            Loading planning state...
          </div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="w-80 m-4">
        <CardContent className="p-6">
          <div className="text-destructive text-sm mb-3">
            Error loading planning server
          </div>
          <Button onClick={refreshState} variant="outline" size="sm">
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-80 m-4">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <CardTitle className="text-lg">AI Planning</CardTitle>
          <Button
            onClick={refreshState}
            disabled={isRefreshing}
            variant="outline"
            size="sm"
          >
            <RefreshCw className={`h-4 w-4 ${isRefreshing ? 'animate-spin' : ''}`} />
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Goal Section */}
        <div>
          <h4 className="font-medium text-sm text-muted-foreground mb-2">
            Current Goal
          </h4>
          <div className="text-sm p-3 bg-muted rounded-md">
            {planningState?.goal || 'No active goal'}
          </div>
        </div>

        {/* Todos Section */}
        <div>
          <h4 className="font-medium text-sm text-muted-foreground mb-2">
            Tasks
          </h4>
          <div className="space-y-2">
            {planningState?.todos.length ? (
              planningState.todos.map((todo, index) => (
                <div key={index} className="flex items-start gap-2 text-sm">
                  <Badge
                    variant={todo.status === 'completed' ? 'default' : 'secondary'}
                    className="mt-0.5"
                  >
                    {todo.status === 'completed' ? '✓' : '○'}
                  </Badge>
                  <span
                    className={
                      todo.status === 'completed'
                        ? 'line-through text-muted-foreground'
                        : ''
                    }
                  >
                    {todo.name}
                  </span>
                </div>
              ))
            ) : (
              <div className="text-sm text-muted-foreground">No tasks</div>
            )}
          </div>
        </div>

        {/* Observations Section */}
        <div>
          <h4 className="font-medium text-sm text-muted-foreground mb-2">
            Recent Observations
          </h4>
          <div className="max-h-32 overflow-y-auto space-y-1">
            {planningState?.observations.length ? (
              planningState.observations.map((obs, index) => (
                <div
                  key={index}
                  className="text-xs p-2 bg-accent/50 rounded-sm border-l-2 border-accent"
                >
                  {obs}
                </div>
              ))
            ) : (
              <div className="text-sm text-muted-foreground">No observations</div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

### 4. Chat.tsx 수정

```typescript
import { ChatProvider } from '@/context/ChatContext';
import { useSessionContext } from '@/context/SessionContext';
import React, { useState } from 'react';
import { TimeLocationSystemPrompt } from '../prompts/TimeLocationSystemPrompt';
import ToolsModal from '../tools/ToolsModal';
import { ChatPlanningPanel } from './components/ChatPlanningPanel';
// ... other imports

function Chat({ children }: ChatProps) {
  const [showPlanningPanel, setShowPlanningPanel] = useState(false);

  return (
    <ChatProvider>
      <TimeLocationSystemPrompt />
      <div className="h-full w-full font-mono flex rounded-lg overflow-hidden shadow-2xl">
        {/* 메인 채팅 영역 */}
        <div className="flex-1 flex flex-col">
          {children}
          <ToolsModal
            isOpen={showToolsDetail}
            onClose={() => setShowToolsDetail(false)}
          />
        </div>

        {/* Planning 사이드 패널 */}
        {showPlanningPanel && <ChatPlanningPanel />}
      </div>
    </ChatProvider>
  );
}

// Compound component 추가
Chat.PlanningPanel = ChatPlanningPanel;
```

## 재사용 가능한 연관 코드

### 핵심 파일 및 인터페이스

1. **`src/hooks/use-web-mcp-server.ts`**
   - 기능: WebMCP 서버에 type-safe하게 접근하는 React Hook
   - 인터페이스: `useWebMCPServer<T>(serverName: string)`
   - 재사용: Planning 외 다른 MCP 서버 시각화에도 활용 가능

2. **`src/lib/web-mcp/mcp-proxy.ts`**
   - 기능: Web Worker MCP 통신 프록시
   - 인터페이스: `WebMCPProxy` 클래스의 `callTool`, `loadServer`, `listTools` 메서드
   - 재사용: 모든 Web MCP 서버 통신의 기반

3. **`src/features/chat/Chat.tsx`**
   - 기능: Compound component 패턴으로 구조화된 Chat 인터페이스
   - 패턴: `Chat.Header`, `Chat.Messages`, `Chat.Input` 등
   - 재사용: 새로운 Chat 관련 컴포넌트 추가시 동일 패턴 적용

4. **`src/context/ChatContext.tsx`**
   - 기능: Chat 상태 관리 및 공유
   - 인터페이스: ChatProvider, useChatContext
   - 재사용: Planning 상태를 Chat 전체에서 공유할 때 활용 가능

### 설계 패턴

- **Compound Component Pattern**: Chat.tsx에서 사용 중인 패턴, Planning Panel에도 적용
- **Singleton Pattern**: WebMCPProxyManager에서 사용 중, 전역 상태 관리에 참조
- **Hook Pattern**: use-web-mcp-server.ts의 패턴, 다른 MCP 서버용 Hook 개발시 참조

### 스타일링 가이드

- **Tailwind CSS**: 기존 Chat 컴포넌트들과 일관된 스타일링
- **Dark Mode**: `dark:` prefix 사용하여 다크 모드 지원
- **Responsive**: 화면 크기에 따른 Planning Panel 크기 조절

## 구현 순서 제안

1. **TypeScript 타입 정의 추가** (`src/models/planning.ts`)
2. **ChatPlanningPanel 컴포넌트 구현**
   - shadcn/ui 컴포넌트 (Card, Button, Badge) 활용
   - 메시지 기반 상태 업데이트 로직 구현
   - 적절한 에러 처리 및 로딩 상태 UI
3. **Chat.tsx에 Planning Panel 통합**
   - Compound Component 패턴 유지
   - 토글 기능 구현 (Planning Panel 표시/숨김)
4. **토글 버튼 추가** (ChatHeader 또는 적절한 위치)
5. **스타일링 및 반응형 디자인 완성**
   - neutral 색상 팔레트 사용
   - 다크모드 호환성 확인
6. **타입 안전성 검증 및 테스트**
   - TypeScript 컴파일 오류 해결
   - 실제 Planning 도구 사용 시나리오 테스트

## 추가 고려사항

### 성능 최적화

- `useCallback`, `useMemo` 활용으로 불필요한 리렌더링 방지
- Planning 상태 변경 시에만 컴포넌트 업데이트
- 메시지 배열 변화 감지의 효율성 최적화

### 사용자 경험

- Planning Panel의 접기/펴기 애니메이션 (shadcn/ui의 Collapsible 컴포넌트 활용)
- 키보드 단축키로 Planning Panel 토글 기능
- Planning 상태가 없을 때의 사용자 안내 메시지

### 확장성

- 다른 MCP 서버 시각화에도 적용 가능한 패턴 설계
- Planning Panel의 크기 조절 기능 (ResizablePanel 컴포넌트 고려)
- Planning 상태 변경 히스토리 기능 (필요시)
