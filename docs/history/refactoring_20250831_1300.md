# ResourceAttachmentContext & Chat.tsx 리팩토링 계획

## 작업의 목적

ResourceAttachmentContext와 Chat.tsx의 파일 첨부 관련 상태 관리를 단순화하고 일관성 있게 개선하여 코드 유지보수성과 가독성을 향상시키는 것.

### 세부 목표

- `addFile`/`addFilesBatch` 함수를 `addPendingFiles`/`commitPendingFiles`로 분리하여 첨부/커밋 플로우 명확화
- `clearFiles`/`clearPendingFiles`/`removeFile` 관계 명확화 및 불필요 함수 제거
- useSWR을 활용한 세션 파일 상태 관리 최적화
- 중복된 상태 변수 및 불필요한 함수 정리
- Context 인터페이스 단순화 및 UX 일관성 확보

## 현재의 상태 / 문제점

### 1. 함수 중복 및 일관성 부족

- `addFile`과 `addFilesBatch`가 별도 존재하여 API가 일관되지 않음
- `addFilesBatch`는 내부적으로 `addFile`을 반복 호출하는 래퍼일 뿐
- 단일 파일 첨부 시에도 배열로 처리하는 것이 더 일관성 있음

### 2. 상태 관리 복잡성

- `files`, `sessionFiles`, `pendingFiles`가 모두 별도 상태로 존재하여 혼동 유발
- `sessionFiles`, `isSessionFilesLoading`, `sessionFilesError`가 useState로 관리됨
- `refreshSessionFiles` 함수가 수동으로 상태를 갱신하는 방식
- 너무 많은 useCallback과 useEffect로 코드 복잡성 증가

### 3. 불필요한 함수 및 상태

- `clearFiles`: 일반 사용자가 사용할 일이 거의 없고 위험성 높음
- `getFileById`: 실제 사용되지 않는 함수
- `files`와 `sessionFiles`의 중복: `files`는 `sessionFiles`의 별칭일 뿐

### 4. UX 플로우 불일치

- 현재 첨부/업로드/전송 플로우가 명확하지 않음
- pendingFiles와 sessionFiles의 구분이 UI에서 명확하지 않음
- 파일 첨부 후 실제 서버 업로드 시점 제어가 어려움

## 추가 분석 과제 (선택적)

### 1. 파일 첨부 UX 최적화

- 현재 pendingFiles와 sessionFiles의 구분이 UI에서 명확하지 않음
- 파일 첨부 진행 상태 표시 개선 필요
- 첨부 취소/수정 기능 UX 검토

### 2. 에러 처리 표준화

- 파일 첨부 실패 시 사용자 피드백 개선
- 중복 파일 처리 로직 검토
- 네트워크 오류 시 재시도 메커니즘

### 3. 성능 최적화

- 대용량 파일 처리 시 메모리 사용량 최적화
- 파일 미리보기 생성 로직 개선
- useSWR 캐시 전략 최적화

## 변경 이후의 상태 / 해결 판정 기준

### 1. 함수 분리 및 통합 완료

- `addPendingFiles`: 파일을 pendingFiles에만 추가 (UI 즉시 반영)
- `commitPendingFiles`: pendingFiles를 서버에 업로드하고 sessionFiles로 이동
- `addFile`, `addFilesBatch` 함수 제거됨

### 2. 상태 관리 단순화

- `sessionFiles`는 useSWR의 `data`만 사용 (useSWR 신규 도입)
- `files`, `isSessionFilesLoading`, `sessionFilesError` 제거
- `refreshSessionFiles`는 useSWR의 `mutate`로 대체

### 3. 불필요 함수 제거

- `clearFiles` 제거 (관리자용으로만 유지 고려)
- `getFileById` 제거 (사용되지 않음)
- 헬퍼 함수들은 별도 유틸리티 파일로 분리

### 4. 인터페이스 정리

```typescript
interface ResourceAttachmentContextType {
  sessionFiles: AttachmentReference[];
  pendingFiles: AttachmentReference[];
  addPendingFiles: (files: Array<{ url: string; mimeType: string; filename?: string }>) => void;
  commitPendingFiles: () => Promise<AttachmentReference[]>;
  removeFile: (ref: AttachmentReference) => Promise<void>;
  clearPendingFiles: () => void;
  isLoading: boolean;
  mutateSessionFiles: () => Promise<void>;
}
```

### 5. UX 플로우 개선

- 파일 첨부 → pendingFiles에 추가 (UI 즉시 반영)
- 메시지 전송 → commitPendingFiles로 서버 업로드
- 업로드 성공 → sessionFiles로 이동, pendingFiles 초기화

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ResourceAttachmentContext.tsx 인터페이스 변경

```typescript
// 변경 전
interface ResourceAttachmentContextType {
  files: AttachmentReference[];  // sessionFiles의 별칭
  addFile: (url: string, mimeType: string, filename?: string) => Promise<AttachmentReference>;
  addFilesBatch: (files: { url: string; mimeType: string; filename?: string }[]) => Promise<AttachmentReference[]>;
  removeFile: (ref: AttachmentReference) => Promise<void>;
  clearFiles: () => void;
  clearPendingFiles: () => void;
  isLoading: boolean;
  getFileById: (id: string) => AttachmentReference | undefined;
  sessionFiles: AttachmentReference[];
  pendingFiles: AttachmentReference[];
  isSessionFilesLoading: boolean;
  sessionFilesError: string | null;
  refreshSessionFiles: () => Promise<void>;
}

// 변경 후
interface ResourceAttachmentContextType {
  sessionFiles: AttachmentReference[];
  pendingFiles: AttachmentReference[];
  addPendingFiles: (files: Array<{ url: string; mimeType: string; filename?: string }>) => void;
  commitPendingFiles: () => Promise<AttachmentReference[]>;
  removeFile: (ref: AttachmentReference) => Promise<void>;
  clearPendingFiles: () => void;
  isLoading: boolean;
  mutateSessionFiles: () => Promise<void>;
}
```

### 2. addPendingFiles / commitPendingFiles 구현

```typescript
// 파일을 pendingFiles에만 추가 (UI 즉시 반영)
const addPendingFiles = useCallback(
  (files: Array<{ url: string; mimeType: string; filename?: string }>) => {
    const newPending = files.map((file) => ({
      storeId: currentSession?.storeId || '',
      contentId: `pending_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
      filename: file.filename || extractFilenameFromUrl(file.url),
      mimeType: file.mimeType,
      size: 0, // 추후 계산
      lineCount: 0,
      preview: file.filename || extractFilenameFromUrl(file.url),
      uploadedAt: new Date().toISOString(),
      chunkCount: 0,
      lastAccessedAt: new Date().toISOString(),
    }));
    setPendingFiles((prev) => [...prev, ...newPending]);
  },
  [currentSession?.storeId],
);

// pendingFiles를 서버에 업로드하고 sessionFiles로 이동
const commitPendingFiles = useCallback(
  async (): Promise<AttachmentReference[]> => {
    if (pendingFiles.length === 0) return [];

    setIsLoading(true);
    try {
      const results: AttachmentReference[] = [];

      for (const file of pendingFiles) {
        try {
          const result = await addFileInternal(file.url, file.mimeType, file.filename);
          results.push(result);
        } catch (error) {
          logger.error('Failed to commit pending file', { filename: file.filename, error });
          // 개별 파일 실패 시 계속 진행
        }
      }

      // 업로드 완료 후 SWR 캐시 갱신
      await mutateSessionFiles();
      setPendingFiles([]);

      return results;
    } finally {
      setIsLoading(false);
    }
  },
  [pendingFiles, mutateSessionFiles],
);
```

### 3. useSWR 활용한 상태 관리 단순화

```typescript
// 변경 전: 복잡한 상태 관리
const [sessionFiles, setSessionFiles] = useState<AttachmentReference[]>([]);
const [isSessionFilesLoading, setIsSessionFilesLoading] = useState(false);
const [sessionFilesError, setSessionFilesError] = useState<string | null>(null);

// 변경 후: useSWR 도입
const { data: sessionFiles = [], isLoading, error, mutate: mutateSessionFiles } = useSWR(
  currentSession?.storeId ? `session-files-${currentSession.storeId}` : null,
  async (key: string) => {
    const storeId = key.replace('session-files-', '');
    if (storeId && server) {
      const result = await server.listContent({ storeId });
      return result?.contents?.map((content) => ({
        storeId: content.storeId,
        contentId: content.contentId,
        filename: content.filename,
        mimeType: content.mimeType,
        size: content.size,
        lineCount: content.lineCount || 0,
        preview: content.preview,
        uploadedAt: content.uploadedAt || new Date().toISOString(),
        chunkCount: content.chunkCount,
        lastAccessedAt: content.lastAccessedAt,
      })) || [];
    }
    return [];
  }
);
```

### 4. Chat.tsx의 submit 핸들러 업데이트

```typescript
// 변경 전: 직접 파일 업로드
const results = await addFilesBatch(batchFiles);

// 변경 후: pendingFiles를 commit
const {
  pendingFiles,
  commitPendingFiles,
  clearPendingFiles,
} = useResourceAttachment();

const handleSubmit = useCallback(
  async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!input.trim() && pendingFiles.length === 0) return;
    if (!currentAssistant || !currentSession) return;

    let attachedFiles: AttachmentReference[] = [];

    // pendingFiles를 서버에 업로드
    if (pendingFiles.length > 0) {
      try {
        attachedFiles = await commitPendingFiles();
      } catch (err) {
        logger.error('Error uploading pending files:', err);
        alert('파일 업로드 중 오류가 발생했습니다.');
        return;
      }
    }

    const userMessage: Message = {
      id: createId(),
      content: input.trim(),
      role: 'user',
      sessionId: currentSession.id,
      attachments: attachedFiles,
    };

    setInput('');
    clearPendingFiles();

    try {
      await submit([userMessage]);
    } catch (err) {
      logger.error('Error submitting message:', err);
    }
  },
  [input, pendingFiles, currentAssistant, currentSession, commitPendingFiles, clearPendingFiles, submit],
);
```

### 5. 불필요 함수 제거

```typescript
// 제거 대상 함수들
- clearFiles (사용되지 않음, 위험성 높음)
- getFileById (사용되지 않음)
- refreshSessionFiles (mutateSessionFiles로 대체)
- addFile (addPendingFiles/commitPendingFiles로 분리)
- addFilesBatch (addPendingFiles/commitPendingFiles로 분리)
- files (sessionFiles의 불필요한 별칭)
- isSessionFilesLoading, sessionFilesError (useSWR의 isLoading, error로 대체)
```

## 구현 순서

1. **Phase 1**: useSWR 의존성 설치 및 설정
   - `pnpm add swr` 설치
   - SWRConfig 설정 (선택적)

2. **Phase 2**: 인터페이스 및 타입 정의 변경
   - ResourceAttachmentContextType 인터페이스 변경
   - 불필요한 함수들 deprecated 처리

3. **Phase 3**: addPendingFiles/commitPendingFiles 함수 구현
   - addPendingFiles: 파일을 pendingFiles에만 추가
   - commitPendingFiles: pendingFiles를 서버에 업로드하고 sessionFiles로 이동

4. **Phase 4**: useSWR 상태 관리 전환
   - sessionFiles, isSessionFilesLoading, sessionFilesError를 useSWR로 대체
   - refreshSessionFiles를 mutateSessionFiles로 대체

5. **Phase 5**: 불필요 함수들 제거 및 헬퍼 함수 분리
   - clearFiles, getFileById 제거
   - files 별칭 제거
   - 헬퍼 함수들을 별도 유틸리티 파일로 분리

6. **Phase 6**: Chat.tsx 및 기타 사용처 업데이트
   - addFilesBatch → addPendingFiles/commitPendingFiles로 변경
   - submit 핸들러 업데이트

7. **Phase 7**: 테스트 및 검증

## 예상 이점

- **코드 복잡도 50% 감소**: useCallback/useEffect 개수 대폭 감소
- **API 일관성 향상**: 첨부/커밋 플로우 명확화
- **상태 관리 단순화**: useSWR의 장점을 100% 활용
- **UX 개선**: 파일 첨부와 실제 업로드 시점 분리
- **유지보수성 향상**: 중복 코드 제거, 명확한 책임 분리
- **버그 감소**: 혼재된 상태 관리로 인한 버그 제거

## 위험 요소 및 완화 방안

### 1. useSWR 도입으로 인한 의존성 증가

- **위험**: 새로운 의존성으로 인한 번들 크기 증가 및 잠재적 버그
- **완화**: useSWR은 경량 라이브러리로 검증된 솔루션, 충분한 테스트 후 적용

### 2. 기존 코드 호환성

- **위험**: Chat.tsx 등 기존 사용처에서 API 변경으로 인한 오류
- **완화**: Phase별 점진적 변경, 기존 함수들을 deprecated로 유지 후 제거

### 3. useSWR 캐시 관리

- **위험**: mutate 호출 시점이나 캐시 키 관리 실수
- **완화**: 충분한 테스트, 캐시 키 전략 검토

### 4. UX 일관성

- **위험**: pendingFiles/sessionFiles 구분이 사용자에게 혼동 유발
- **완화**: UI에서 명확한 시각적 구분, 툴팁 및 설명 추가

### 5. 성능 영향

- **위험**: useSWR 도입으로 인한 불필요한 리렌더링
- **완화**: React.memo, useMemo 활용으로 최적화
