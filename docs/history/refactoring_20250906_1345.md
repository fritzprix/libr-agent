# Chat Tool Execution UI 개선 - Send 버튼 활성화 및 Cancel 버튼 분리

## 작업의 목적

Tool 실행 중에도 사용자가 새로운 메시지를 입력할 수 있도록 하고, Cancel 기능을 별도 UI로 분리하여 UX를 개선한다. 또한 메시지 큐잉 시스템을 구현하여 tool → tool result → new input 순서로 처리되도록 한다.

## 현재의 상태 / 문제점

### 1. Send 버튼 비활성화 문제

- `ChatInput.tsx`에서 `isLoading` 상태일 때 Send 버튼이 완전히 비활성화됨
- `isLoading = aiServiceLoading || isToolExecuting`로 구성되어 tool 실행 중 입력 불가능
- 현재 코드:
  ```typescript
  disabled={isAttachmentLoading || (!isLoading && !input.trim() && attachedFiles.length === 0)}
  ```

### 2. Cancel 기능과 Send 기능 중첩

- 하나의 Submit 버튼이 상황에 따라 Send/Cancel 두 기능을 담당
- `isLoading` 상태에서는 Cancel 기능으로 동작하여 Send 기능 사용 불가
- 현재 코드:
  ```typescript
  if (isLoading) {
    cancel();
    return;
  }
  ```

### 3. 메시지 큐잉 시스템 부재

- Tool 실행 중 새 메시지 입력 시 대기열에 쌓는 메커니즘 없음
- Tool 완료 후 자동으로 다음 메시지 처리하는 기능 없음

## 추가 분석 과제

1. **ChatContext의 상태 관리 구조 분석**
   - `pendingCancel` 상태와 기존 `cancelRequestRef` 통합 방안
   - 메시지 큐 상태를 ChatContext에 추가할지 별도 hook으로 관리할지 결정

2. **Tool Processor와의 연동 방안**
   - `useToolProcessor`의 체크포인트에서 큐된 메시지 처리 로직
   - Tool 실행 완료 시점과 메시지 큐 처리 타이밍 동기화

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. Tool 실행 중에도 Send 버튼이 활성화되어 새 메시지 입력 가능
2. Cancel 버튼이 별도로 분리되어 AI/Tool 실행 중에만 표시
3. Cancel 대기 중 상태에서 amber 색상 progress rotation 표시
4. Tool 실행 중 입력된 메시지가 큐에 저장되어 tool 완료 후 순차 처리
5. 메시지 스택이 tool → tool result → new input 순서로 구성

### UI 동작 시나리오

- **대기 상태**: Send 버튼만 표시
- **AI 응답 중**: Send(활성화) + Cancel 버튼 표시
- **Tool 실행 중**: Send(활성화, "Queue message" 툴팁) + Cancel 버튼 표시
- **Cancel 대기 중**: Send(활성화) + Cancel(amber spinner) 버튼 표시

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ChatInput.tsx - 버튼 구조 변경

```typescript
// 현재 (수정 전)
<Button
  type="submit"
  disabled={
    isAttachmentLoading ||
    (!isLoading && !input.trim() && attachedFiles.length === 0)
  }
  title={isLoading ? 'Cancel request' : 'Send message'}
>
  {isLoading ? <X className="h-4 w-4" /> : <Send className="h-4 w-4" />}
</Button>

// 수정 후
<div className="flex gap-2">
  <Button
    type="submit"
    disabled={isAttachmentLoading || (!input.trim() && attachedFiles.length === 0)}
    title={isToolExecuting ? "Queue message" : "Send message"}
  >
    <Send className="h-4 w-4" />
  </Button>

  {isLoading && (
    <Button
      onClick={handleCancel}
      variant="destructive"
      size="sm"
      disabled={pendingCancel}
      title={pendingCancel ? "Cancelling..." : "Cancel request"}
    >
      {pendingCancel ? (
        <Loader2 className="h-4 w-4 animate-spin text-amber-500" />
      ) : (
        <Square className="h-4 w-4" />
      )}
    </Button>
  )}
</div>
```

### 2. ChatInput.tsx - handleSubmit 로직 분리

```typescript
// 현재 (수정 전)
const handleSubmit = useCallback(
  async (e: React.FormEvent) => {
    e.preventDefault();
    if (isLoading) {
      cancel();
      return;
    }
    // 메시지 전송 로직
  },
  [submit, input /* ... */],
);

// 수정 후
const handleSubmit = useCallback(
  async (e: React.FormEvent) => {
    e.preventDefault();

    if (isToolExecuting) {
      // Tool 실행 중이면 메시지를 큐에 추가
      addToMessageQueue({
        content: input.trim(),
        attachments: await commitPendingFiles(),
      });
      setInput('');
      clearPendingFiles();
    } else {
      // 일반 전송
      // 기존 로직 유지
    }
  },
  [isToolExecuting, addToMessageQueue /* ... */],
);

const handleCancel = useCallback(() => {
  setPendingCancel(true);
  cancel();
}, [cancel]);
```

### 3. ChatContext.tsx - 상태 관리 확장

```typescript
// 추가할 상태
const [pendingCancel, setPendingCancel] = useState(false);
const [messageQueue, setMessageQueue] = useState<Message[]>([]);

// 기존 isLoading 조건 유지 (Cancel 버튼 표시용)
const isLoading = aiServiceLoading || isToolExecuting;

// 메시지 큐 관리 함수
const addToMessageQueue = useCallback(
  (message: Partial<Message>) => {
    const queuedMessage: Message = {
      id: createId(),
      role: 'user',
      sessionId: currentSession?.id || '',
      ...message,
    };
    setMessageQueue((prev) => [...prev, queuedMessage]);
  },
  [currentSession],
);

// Tool 실행 완료 시 큐 처리
useEffect(() => {
  if (!isToolExecuting && messageQueue.length > 0) {
    const nextMessage = messageQueue[0];
    setMessageQueue((prev) => prev.slice(1));
    submit([nextMessage]);
  }
}, [isToolExecuting, messageQueue, submit]);
```

## 재사용 가능한 연관 코드

### 관련 파일 경로 및 주요 기능

1. **`/src/features/chat/components/ChatInput.tsx`**
   - 주요 기능: 사용자 입력 처리, Send/Cancel 버튼 UI
   - 인터페이스: `useChatContext()`, `useFileAttachment()`
   - 재사용 요소: handleSubmit 로직, 버튼 상태 관리

2. **`/src/context/ChatContext.tsx`**
   - 주요 기능: 채팅 상태 관리, AI 서비스 연동
   - 인터페이스: `ChatContextValue`, `submit`, `cancel`
   - 재사용 요소: isLoading 상태 조합, cancel 처리 로직

3. **`/src/hooks/use-tool-processor.ts`**
   - 주요 기능: Tool 실행 관리, 체크포인트 처리
   - 인터페이스: `onToolExecutionChange`, `processToolCalls`
   - 재사용 요소: Tool 실행 완료 감지, 상태 변경 콜백

4. **관련 UI 컴포넌트**
   - `Loader2`, `Square`, `Send`, `X` (lucide-react icons)
   - `Button` 컴포넌트의 variant, size 옵션
   - Tailwind CSS 색상 클래스: `text-amber-500`, `animate-spin`

### 재사용 가능한 패턴

1. **상태 기반 조건부 렌더링**: `{condition && <Component />}`
2. **비동기 상태 관리**: `useCallback` + `useState` 조합
3. **Progress 표시**: `animate-spin` + 색상 구분
4. **큐 처리 패턴**: `useEffect` + 배열 상태 관리
