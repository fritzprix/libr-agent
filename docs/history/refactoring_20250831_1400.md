# ResourceAttachmentContext 파일 첨부 시스템 리팩토링 계획

## 작업의 목적

Vite/Tauri 환경에서 파일 첨부 시 발생하는 HTML 내용 입력 문제와 파일 경로/URL 처리 혼동을 해결하여, 실제 파일 내용이 올바르게 첨부되고 preview/업로드/읽기가 정상적으로 작동하도록 개선하는 것.

### 세부 목표

- 파일 첨부 시 HTML 내용 대신 실제 파일 내용이 입력되도록 수정
- Vite 개발 환경과 Tauri 데스크탑 환경의 파일 경로 처리 차이를 명확히 구분
- Blob URL과 파일 시스템 경로를 적절히 분리하여 관리
- 파일 preview가 실제 파일 내용으로 표시되도록 개선
- 서버 업로드 시 환경별 최적의 파일 전송 방식 적용

## 현재의 상태 / 문제점

### 1. 파일 첨부 시 HTML 내용 입력 문제

- 첨부 파일의 내용이 Vite 개발 서버의 HTML(`<!doctype html>...<script type="module" src="/@vite/client"></script>`)로 입력됨
- 실제 파일의 원본 내용이 아닌 브라우저의 HTML이 첨부 파일로 처리됨
- 파일 preview와 업로드 시 모두 HTML 내용이 사용됨

### 2. 파일 경로/URL 처리 혼동

- Vite 개발 환경에서는 파일 경로가 `/src/app/main.tsx`, `/@vite/client` 등의 개발 서버 URL로 변환됨
- Tauri 데스크탑 환경에서는 파일 시스템 경로와 Blob URL이 혼재되어 사용됨
- `convertToBlobUrl` 함수에서 외부 URL을 fetch하여 Blob으로 변환하지만, 원본 파일 경로와의 매핑이 불명확

### 3. Blob URL 관리 미흡

- Blob URL 생성 후 적절한 시점에 `URL.revokeObjectURL()`이 호출되지 않아 메모리 누수 가능성
- 파일 첨부 취소나 업로드 실패 시 Blob URL 정리 로직이 불완전
- Blob URL과 실제 파일 시스템 경로 간의 연결이 끊어져 있어 파일 복구가 어려움

### 4. 환경별 파일 처리 차이

- 브라우저 환경: Blob URL만 사용 가능
- Tauri 환경: 파일 시스템 경로 직접 접근 가능
- 현재 코드는 환경 차이를 고려하지 않고 동일한 방식으로 처리하여 오류 발생

## 추가 분석 과제 (선택적)

### 1. 파일 타입별 처리 최적화

- 텍스트 파일: 내용 preview 표시
- 이미지 파일: 썸네일 생성 및 표시
- 바이너리 파일: 파일명과 크기 정보만 표시
- 대용량 파일: 청크 단위 처리 및 진행률 표시

### 2. 에러 처리 및 복구 메커니즘

- 네트워크 오류 시 재시도 로직
- 파일 손상 시 복구 방안
- Blob URL 생성 실패 시 폴백 처리

### 3. 성능 최적화

- 파일 미리보기 생성 시 메모리 사용량 최적화
- 대용량 파일 처리 시 UI 응답성 유지
- Blob URL 생성/해제 타이밍 최적화

## 변경 이후의 상태 / 해결 판정 기준

### 1. 파일 첨부 시 실제 내용 입력 완료

- 첨부 파일의 내용이 HTML이 아닌 실제 파일 내용으로 입력됨
- 파일 preview에 실제 파일 내용의 일부가 표시됨
- 서버에 업로드되는 파일이 원본 파일의 내용과 동일함

### 2. 환경별 파일 경로 처리 명확화

- Tauri 환경: 파일 시스템 경로를 우선적으로 사용
- 브라우저 환경: Blob URL을 사용하되 원본 경로 정보 유지
- 파일 첨부 시점에 환경을 감지하여 적절한 처리 방식 적용

### 3. Blob URL 관리 체계화

- Blob URL 생성 시 반드시 cleanup 함수 등록
- 파일 첨부 취소/완료/실패 시점에 Blob URL 자동 해제
- 메모리 누수 방지를 위한 주기적 정리 로직 구현

### 4. 파일 처리 플로우 개선

- 파일 첨부 → 환경 감지 → 적절한 경로 변환 → preview 생성 → 업로드 준비
- 각 단계에서 명확한 에러 처리 및 사용자 피드백 제공
- 파일 타입에 따른 최적화된 처리 방식 적용

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 파일 첨부 인터페이스 확장

```typescript
// 변경 전
addPendingFiles: (
  files: Array<{ url: string; mimeType: string; filename?: string }>,
) => void;

// 변경 후
addPendingFiles: (
  files: Array<{ 
    url: string; 
    mimeType: string; 
    filename?: string;
    originalPath?: string;  // 파일 시스템 경로 (Tauri 환경)
    file?: File;           // File 객체 (브라우저 환경)
  }>,
) => void;
```

### 2. 환경 감지 및 파일 처리 로직 개선

```typescript
// 환경 감지 헬퍼 함수
const isTauriEnvironment = useCallback(() => {
  return !!window.__TAURI__;
}, []);

// 파일 첨부 시 환경별 처리
const addPendingFiles = useCallback(
  (files: Array<{ 
    url: string; 
    mimeType: string; 
    filename?: string;
    originalPath?: string;
    file?: File;
  }>) => {
    const isTauri = isTauriEnvironment();
    
    const newPending = files.map((file) => {
      const actualFilename = file.filename || extractFilenameFromUrl(file.url);
      
      return {
        storeId: currentSession?.storeId || '',
        contentId: `pending_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
        filename: actualFilename,
        mimeType: file.mimeType,
        size: file.file?.size || 0,
        lineCount: 0,
        preview: isTauri && file.originalPath ? file.originalPath : file.url,
        originalPath: file.originalPath,  // Tauri용 원본 경로
        file: file.file,                  // 브라우저용 File 객체
        uploadedAt: new Date().toISOString(),
        chunkCount: 0,
        lastAccessedAt: new Date().toISOString(),
      };
    });
    
    setPendingFiles((prev) => [...prev, ...newPending]);
  },
  [currentSession?.storeId, isTauriEnvironment, extractFilenameFromUrl],
);
```

### 3. 파일 업로드 시 환경별 처리

```typescript
// 서버 업로드 시 환경별 최적 방식 적용
const addFileInternal = useCallback(
  async (
    url: string,
    mimeType: string,
    filename?: string,
    originalPath?: string,
    file?: File,
  ): Promise<AttachmentReference> => {
    const isTauri = isTauriEnvironment();
    let blobCleanup: (() => void) | null = null;
    
    try {
      // Tauri 환경에서는 파일 시스템 경로를 직접 사용
      if (isTauri && originalPath) {
        const result = await server.addContent({
          storeId: storeId,
          fileUrl: `file://${originalPath}`,  // 파일 시스템 경로를 file:// URL로 변환
          metadata: {
            filename: filename || extractFilenameFromUrl(originalPath),
            mimeType,
            size: 0,  // 파일 시스템에서 직접 계산 필요
            uploadedAt: new Date().toISOString(),
          },
        });
        return result;
      }
      
      // 브라우저 환경에서는 기존 방식 사용
      const blobResult = await convertToBlobUrl(url);
      blobCleanup = blobResult.cleanup;
      
      const result = await server.addContent({
        storeId: storeId,
        fileUrl: blobResult.blobUrl,
        metadata: {
          filename: filename || extractFilenameFromUrl(url),
          mimeType: blobResult.type || mimeType,
          size: blobResult.size,
          uploadedAt: new Date().toISOString(),
        },
      });
      
      return result;
    } finally {
      // Blob URL 정리
      if (blobCleanup) {
        blobCleanup();
      }
    }
  },
  [server, isTauriEnvironment, convertToBlobUrl, extractFilenameFromUrl],
);
```

### 4. 파일 preview 생성 개선

```typescript
// 파일 타입별 preview 생성
const generateFilePreview = useCallback(
  async (file: { 
    url: string; 
    mimeType: string; 
    originalPath?: string;
    file?: File;
  }): Promise<string> => {
    const isTauri = isTauriEnvironment();
    
    // 텍스트 파일인 경우 내용 일부 표시
    if (file.mimeType.startsWith('text/')) {
      try {
        if (isTauri && file.originalPath) {
          // Tauri 환경: 파일 시스템에서 직접 읽기
          const content = await readFile(file.originalPath);
          return content.substring(0, 200) + (content.length > 200 ? '...' : '');
        } else if (file.file) {
          // 브라우저 환경: File 객체에서 읽기
          const content = await file.file.text();
          return content.substring(0, 200) + (content.length > 200 ? '...' : '');
        } else {
          // URL에서 fetch
          const response = await fetch(file.url);
          const content = await response.text();
          return content.substring(0, 200) + (content.length > 200 ? '...' : '');
        }
      } catch (error) {
        logger.warn('Failed to generate text preview', { error });
        return file.filename || 'Text file';
      }
    }
    
    // 이미지 파일인 경우 파일명 표시
    if (file.mimeType.startsWith('image/')) {
      return `📷 ${file.filename || 'Image file'}`;
    }
    
    // 기타 파일은 파일명만 표시
    return file.filename || 'File';
  },
  [isTauriEnvironment],
);
```

### 5. Blob URL 관리 개선

```typescript
// Blob URL 생성 시 cleanup 추적
const convertToBlobUrl = useCallback(
  async (
    url: string,
  ): Promise<{
    blobUrl: string;
    cleanup: () => void;
    size: number;
    type: string;
  }> => {
    try {
      // 기존 Blob URL인 경우
      if (url.startsWith('blob:')) {
        return {
          blobUrl: url,
          cleanup: () => {}, // 기존 Blob URL은 해제하지 않음
          size: 0,
          type: '',
        };
      }

      // 외부 URL에서 fetch하여 Blob 생성
      logger.debug('Converting external URL to blob', { url });
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(
          `Failed to fetch ${url}: ${response.status} ${response.statusText}`,
        );
      }

      const blob = await response.blob();
      const blobUrl = URL.createObjectURL(blob);

      logger.debug('Successfully converted to blob URL', {
        originalUrl: url,
        blobUrl,
        size: blob.size,
        type: blob.type,
      });

      return {
        blobUrl,
        cleanup: () => {
          URL.revokeObjectURL(blobUrl);
          logger.debug('Blob URL revoked', { blobUrl });
        },
        size: blob.size,
        type: blob.type,
      };
    } catch (error) {
      logger.error('Failed to convert URL to blob', {
        url,
        error: error instanceof Error ? {
          message: error.message,
          stack: error.stack,
          name: error.name,
        } : error,
      });
      throw new Error(
        `Failed to process URL "${url}": ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  },
  [],
);
```

## 구현 순서

1. **Phase 1**: 환경 감지 및 인터페이스 확장
2. **Phase 2**: 파일 첨부 로직 개선 (addPendingFiles)
3. **Phase 3**: 파일 업로드 로직 개선 (addFileInternal)
4. **Phase 4**: 파일 preview 생성 로직 구현
5. **Phase 5**: Blob URL 관리 체계화
6. **Phase 6**: 에러 처리 및 복구 메커니즘 추가
7. **Phase 7**: 테스트 및 검증

## 예상 이점

- **파일 첨부 정확성 향상**: HTML 대신 실제 파일 내용이 첨부됨
- **환경 호환성 개선**: Vite/Tauri 환경 차이 적절히 처리
- **메모리 관리 최적화**: Blob URL 적절한 생성/해제
- **사용자 경험 개선**: 실제 파일 내용 기반 preview 제공
- **성능 향상**: 환경별 최적화된 파일 처리 방식 적용
- **유지보수성 향상**: 명확한 파일 경로/URL 처리 로직

## 위험 요소 및 완화 방안

### 1. 파일 시스템 접근 권한

- **위험**: Tauri 환경에서 파일 시스템 접근 실패 가능성
- **완화**: 권한 체크 및 폴백 처리 구현

### 2. 브라우저 호환성

- **위험**: File API 지원하지 않는 구형 브라우저
- **완화**: 기능 감지 및 적절한 폴백 제공

### 3. 메모리 사용량 증가

- **위험**: 대용량 파일 preview 생성 시 메모리 부하
- **완화**: 파일 크기 제한 및 청크 처리 적용

### 4. 네트워크 의존성

- **위험**: 외부 URL fetch 실패 시 파일 첨부 불가
- **완화**: 타임아웃 설정 및 오프라인 처리 로직
