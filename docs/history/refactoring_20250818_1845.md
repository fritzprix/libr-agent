# Browser Agent Server MCP 표준 준수 및 데이터 저장 개선 계획

## 작업의 목적

`BrowserAgentServer`의 MCP Response 구조를 표준에 맞게 수정하고, `extract_data` 툴에서 추출된 데이터를 파일로 저장하는 기능을 구현하여 MCP 표준을 완전히 준수하면서도 실용적인 데이터 관리를 제공합니다.

## 현재의 상태 / 문제점

### 1. **MCP 표준 위반: 비표준 `data` 필드 사용**

**파일**: `src-tauri/src/mcp/builtin/browser_agent_server.rs` (lines 388-447)

```rust
// ❌ 문제: MCP 표준에 없는 data 필드 사용
MCPResponse {
    jsonrpc: "2.0".to_string(),
    id: Some(request_id),
    result: Some(json!({
        "content": [{
            "type": "text",
            "text": format!("✅ Data extraction successful from session: {}", session_id)
        }],
        "data": {  // ← 이 필드는 MCP 표준에 없음
            "session_id": session_id,
            "script": script,
            "result": parsed_result
        }
    })),
    error: None,
}
```

- 모든 핸들러에서 비표준 `data` 필드를 사용하고 있음
- MCP 표준에서는 `result` 내에 `content` 배열만 허용됨
- 클라이언트가 `content` 배열만 처리하여 실제 데이터가 표시되지 않음

### 2. **`extract_data` 결과가 영구 저장되지 않음**

- 추출된 데이터가 MCP 응답에만 포함되고 파일로 저장되지 않음
- 큰 데이터의 경우 응답 크기 제한 문제 발생 가능성
- 추출 결과의 재사용이나 후속 분석이 어려움

### 3. **모든 핸들러의 일관성 부족**

**영향받는 핸들러들**:
- `handle_extract_data` (lines 388-447)
- `handle_create_browser_session` (lines 449-484)
- `handle_click_element` (lines 486-545)
- `handle_input_text` (lines 547-617)
- `handle_navigate_url` (lines 619-669)

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **MCP 표준 완전 준수**: 모든 핸들러에서 `data` 필드 제거, `content` 배열만 사용
2. **데이터 파일 저장**: `extract_data` 툴 실행 시 결과가 JSON 파일로 저장됨
3. **상대 경로 반환**: MCP 파일시스템 호환성을 위한 상대 경로 제공
4. **일관된 응답 구조**: 모든 툴에서 동일한 응답 패턴 사용

### 검증 방법

- `extract_data` 툴 실행 후 `crawl_cache` 디렉토리에 JSON 파일 생성 확인
- MCP 응답에서 `data` 필드가 완전히 제거되었는지 확인
- 상대 경로가 올바르게 반환되는지 확인
- 모든 핸들러가 동일한 응답 구조를 사용하는지 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. **`handle_extract_data` 메서드 완전 재구현**

**파일**: `src-tauri/src/mcp/builtin/browser_agent_server.rs` (lines 388-447)

```rust
// 현재 상태 - MCP 표준 위반
async fn handle_extract_data(&self, args: Value) -> MCPResponse {
    // ... 파라미터 추출 로직 ...

    match self.browser_server.execute_script(session_id, script).await {
        Ok(result) => {
            let parsed_result = match serde_json::from_str::<Value>(&result) {
                Ok(json_val) => json_val,
                Err(_) => json!(result),
            };

            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: Some(json!({
                    "content": [{
                        "type": "text",
                        "text": format!("✅ Data extraction successful from session: {}", session_id)
                    }],
                    "data": {  // ❌ 비표준 필드
                        "session_id": session_id,
                        "script": script,
                        "result": parsed_result
                    }
                })),
                error: None,
            }
        }
    }
}

// 수정 후 - MCP 표준 준수 + 파일 저장
async fn handle_extract_data(&self, args: Value) -> MCPResponse {
    let request_id = Value::String(Uuid::new_v4().to_string());

    let session_id = match args.get("session_id").and_then(|v| v.as_str()) {
        Some(id) => id,
        None => {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "Missing required parameter: session_id".to_string(),
                    data: None,
                }),
            };
        }
    };

    let script = match args.get("script").and_then(|v| v.as_str()) {
        Some(s) => s,
        None => {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "Missing required parameter: script".to_string(),
                    data: None,
                }),
            };
        }
    };

    match self.browser_server.execute_script(session_id, script).await {
        Ok(result) => {
            info!("Data extraction successful for session: {}", session_id);
            
            let parsed_result = match serde_json::from_str::<Value>(&result) {
                Ok(json_val) => json_val,
                Err(_) => json!(result),
            };

            let data_size = serde_json::to_string(&parsed_result)
                .map(|s| s.len())
                .unwrap_or(0);

            // ✅ 추출된 데이터를 파일로 저장
            match self.save_extracted_data(session_id, script, &parsed_result).await {
                Ok(saved_path) => {
                    match self.make_relative_path(&saved_path) {
                        Ok(relative_path) => {
                            // ✅ MCP 표준 준수: content 배열만 사용
                            MCPResponse {
                                jsonrpc: "2.0".to_string(),
                                id: Some(request_id),
                                result: Some(json!({
                                    "content": [
                                        {
                                            "type": "text",
                                            "text": format!("✅ Data extraction successful from session: {}", session_id)
                                        },
                                        {
                                            "type": "text",
                                            "text": format!("📊 **Data size:** {} bytes", data_size)
                                        },
                                        {
                                            "type": "text",
                                            "text": format!("💾 **Saved extraction data to:** {}", relative_path)
                                        }
                                    ]
                                })),
                                error: None,
                            }
                        }
                        Err(e) => {
                            warn!("Failed to convert to relative path: {}", e);
                            MCPResponse {
                                jsonrpc: "2.0".to_string(),
                                id: Some(request_id),
                                result: Some(json!({
                                    "content": [{
                                        "type": "text",
                                        "text": format!("✅ Data extraction successful from session: {}\n⚠️ Failed to create relative path: {}", session_id, e)
                                    }]
                                })),
                                error: None,
                            }
                        }
                    }
                }
                Err(e) => {
                    warn!("Failed to save extracted data: {}", e);
                    MCPResponse {
                        jsonrpc: "2.0".to_string(),
                        id: Some(request_id),
                        result: Some(json!({
                            "content": [{
                                "type": "text",
                                "text": format!("✅ Data extraction successful from session: {}\n⚠️ Failed to save data: {}", session_id, e)
                            }]
                        })),
                        error: None,
                    }
                }
            }
        }
        Err(e) => {
            warn!("Data extraction failed for session {}: {}", session_id, e);
            
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Script execution failed: {}", e),
                    data: None,
                }),
            }
        }
    }
}
```

### 2. **데이터 저장 메서드 추가**

**파일**: `src-tauri/src/mcp/builtin/browser_agent_server.rs` (새로 추가)

```rust
/// Save extracted data to JSON file
async fn save_extracted_data(
    &self,
    session_id: &str,
    script: &str,
    extracted_data: &Value,
) -> Result<PathBuf, String> {
    let crawl_dir = self.get_crawl_temp_dir().await?;
    
    // Generate unique filename based on session and timestamp
    let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S").to_string();
    let session_short = &session_id[..8.min(session_id.len())];
    let file_name = format!("extraction_{}_{}.json", session_short, timestamp);
    let file_path = crawl_dir.join(file_name);

    // Create extraction result structure
    let extraction_result = json!({
        "session_id": session_id,
        "script": script,
        "extracted_data": extracted_data,
        "extraction_timestamp": chrono::Utc::now().to_rfc3339(),
        "synaptic_flow_version": "1.0.0"
    });

    // Save as formatted JSON
    let json_content = serde_json::to_string_pretty(&extraction_result)
        .map_err(|e| format!("Failed to serialize extraction data: {}", e))?;

    tokio::fs::write(&file_path, json_content)
        .await
        .map_err(|e| format!("Failed to save extraction data: {}", e))?;

    info!("Saved extraction data to: {:?}", file_path);
    Ok(file_path)
}
```

### 3. **다른 핸들러들의 `data` 필드 제거**

**파일**: `src-tauri/src/mcp/builtin/browser_agent_server.rs`

#### handle_create_browser_session (lines 449-484)

```rust
// 현재 상태
MCPResponse {
    jsonrpc: "2.0".to_string(),
    id: Some(request_id),
    result: Some(json!({
        "content": [{
            "type": "text",
            "text": format!("✅ Browser session created successfully: {}\n🌐 URL: {}", session_id, url)
        }],
        "data": {  // ❌ 제거 필요
            "session_id": session_id,
            "url": url,
            "title": title.unwrap_or("Browser Session")
        }
    })),
    error: None,
}

// 수정 후
MCPResponse {
    jsonrpc: "2.0".to_string(),
    id: Some(request_id),
    result: Some(json!({
        "content": [
            {
                "type": "text",
                "text": format!("✅ Browser session created successfully: {}", session_id)
            },
            {
                "type": "text",
                "text": format!("🌐 **URL:** {}", url)
            },
            {
                "type": "text",
                "text": format!("📝 **Title:** {}", title.unwrap_or("Browser Session"))
            }
        ]
    })),
    error: None,
}
```

#### handle_click_element (lines 486-545)

```rust
// 현재 상태
result: Some(json!({
    "content": [{
        "type": "text",
        "text": format!("✅ Element clicked successfully: {}\n🎯 Selector: {}", result, selector)
    }],
    "data": {  // ❌ 제거 필요
        "session_id": session_id,
        "selector": selector,
        "result": result
    }
})),

// 수정 후
result: Some(json!({
    "content": [
        {
            "type": "text",
            "text": format!("✅ Element clicked successfully")
        },
        {
            "type": "text",
            "text": format!("🎯 **Selector:** {}", selector)
        },
        {
            "type": "text",
            "text": format!("📋 **Result:** {}", result)
        }
    ]
})),
```

#### handle_input_text (lines 547-617)

```rust
// 현재 상태
result: Some(json!({
    "content": [{
        "type": "text",
        "text": format!("✅ Text input successful: {}\n📝 Text: '{}' into selector: {}", result, text, selector)
    }],
    "data": {  // ❌ 제거 필요
        "session_id": session_id,
        "selector": selector,
        "text": text,
        "result": result
    }
})),

// 수정 후
result: Some(json!({
    "content": [
        {
            "type": "text",
            "text": "✅ Text input successful"
        },
        {
            "type": "text",
            "text": format!("🎯 **Selector:** {}", selector)
        },
        {
            "type": "text",
            "text": format!("📝 **Text:** '{}'", text)
        },
        {
            "type": "text",
            "text": format!("📋 **Result:** {}", result)
        }
    ]
})),
```

#### handle_navigate_url (lines 619-669)

```rust
// 현재 상태
result: Some(json!({
    "content": [{
        "type": "text",
        "text": format!("✅ Navigation successful: {}\n🌐 Navigated to: {}", result, url)
    }],
    "data": {  // ❌ 제거 필요
        "session_id": session_id,
        "url": url,
        "result": result
    }
})),

// 수정 후
result: Some(json!({
    "content": [
        {
            "type": "text",
            "text": "✅ Navigation successful"
        },
        {
            "type": "text",
            "text": format!("🌐 **Navigated to:** {}", url)
        },
        {
            "type": "text",
            "text": format!("📋 **Result:** {}", result)
        }
    ]
})),
```

### 4. **handle_crawl_page의 `data` 필드도 제거**

**파일**: `src-tauri/src/mcp/builtin/browser_agent_server.rs` (lines 267-320)

```rust
// 현재 상태
MCPResponse {
    jsonrpc: "2.0".to_string(),
    id: Some(request_id),
    result: Some(json!({
        "content": [{
            "type": "text",
            "text": status_message
        }],
        "data": response_data  // ❌ 제거 필요
    })),
    error: None,
}

// 수정 후
MCPResponse {
    jsonrpc: "2.0".to_string(),
    id: Some(request_id),
    result: Some(json!({
        "content": [
            {
                "type": "text",
                "text": status_message
            },
            {
                "type": "text",
                "text": format!("📊 **Extracted {} selectors**", selectors.len())
            },
            {
                "type": "text",
                "text": format!("⏰ **Crawled at:** {}", chrono::Utc::now().to_rfc3339())
            }
        ]
    })),
    error: None,
}
```

## 구현 순서

1. **데이터 저장 메서드 구현** (`save_extracted_data` 추가)
2. **handle_extract_data 메서드 완전 재구현** (파일 저장 + MCP 표준 준수)
3. **다른 핸들러들의 data 필드 제거** (create_browser_session, click_element, input_text, navigate_url)
4. **handle_crawl_page의 data 필드 제거**
5. **테스트 및 검증**

## 예상 소요 시간

- 데이터 저장 메서드 구현: 1시간
- handle_extract_data 재구현: 1시간
- 다른 핸들러들 수정: 2시간
- 테스트 및 검증: 1시간
- **총 예상 시간: 5시간**

## 위험 요소

- **기존 클라이언트 호환성**: `data` 필드에 의존하는 코드가 있을 경우 영향
- **파일 시스템 권한**: 파일 저장 시 권한 문제 발생 가능성
- **디스크 공간**: 추출 데이터 누적으로 인한 저장 공간 사용량 증가

## 추가 고려사항

- 추출된 데이터 파일의 정기적인 정리 메커니즘 필요
- 파일명 충돌 방지를 위한 더 정교한 네이밍 규칙 고려
- 큰 데이터 처리 시 메모리 사용량 최적화 필요
- MCP 표준 준수로 다른 MCP 클라이언트와의 호환성 향상
