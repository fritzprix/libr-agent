# Refactor: Centralize Rust backend invoke logic (Option 1)

작성일: 2025-08-24

## 목적

- `src/lib/tauri-mcp-client.ts`와 `src/hooks/use-rust-backend.ts`에 중복된 Tauri 호출 로직을 하나의 신뢰 가능한 구현으로 통합한다.
- React 컴포넌트는 훅을 사용하고 non-React 코드(서비스, 테스트 등)는 공유 클라이언트를 직접 사용하도록 역할을 분리해 유지보수성을 높인다.

## 요건 체크리스트

- [ ] 단일 공유 클라이언트 모듈 `src/lib/rust-backend-client.ts` 추가
- [ ] `src/hooks/use-rust-backend.ts`를 thin React 훅으로 변경(공유 클라이언트 래핑)
- [ ] `BuiltInToolContext.tsx`, `MCPServerContext.tsx` 등 컨텍스트에서 `tauriMCPClient` 사용을 훅으로 전환
- [ ] `src/lib/tauri-mcp-client.ts` 삭제(혹은 단계적 제거)
- [ ] 호출 명칭/파라미터(예: `list_builtin_servers` vs `list_builtin.servers`) 불일치 정리
- [ ] 빌드/린트/기초 테스트 통과

## 1) 작업의 목적 (요약)

- 중복 제거, API 일관성 확보, 테스트 용이성 향상, React/비-React 사용 시의 명확한 경계 정의.

## 2) 현재의 상태 / 문제점

- `tauri-mcp-client.ts`(클래스 기반)와 `use-rust-backend.ts`(hook + safeInvoke)에 유사한 기능이 중복되어 존재한다.
- 중복으로 인해 호출 이름/시그니처 충돌 가능성 및 버그가 발생함.
- non-React 코드에서 hook을 사용할 수 없어 병행 유지가 필요함.

## 3) 변경 이후의 상태 / 해결 판정 기준

- `src/lib/rust-backend-client.ts`에서 모든 Tauri invoke 로직을 제공한다.
- `use-rust-backend.ts`는 해당 클라이언트를 얇게 래핑하여 React 친화적 API를 제공한다.
- 기존 기능(서버 시작/중지, callTool, listTools, builtin APIs, file/log 등)은 동작과 타입을 유지한다.
- 빌드/린트/기본 통합 검증 통과:

- `pnpm lint && pnpm build && cargo fmt && cargo build`

### 성공 판정

- 위 명령 모두 통과
- `BuiltInToolContext`에서 내장 도구 로드/실행이 이전과 동일하게 동작

## 4) 수정이 필요한 코드 및 핵심 변경 스니펫

### A. 신규 공유 클라이언트 (요약)

```ts
// src/lib/rust-backend-client.ts
import { invoke } from '@tauri-apps/api/tauri';
import { getLogger } from '@/lib/logger';
const logger = getLogger('RustBackendClient');

async function safeInvoke<T>(
  cmd: string,
  args?: Record<string, unknown>,
): Promise<T> {
  try {
    logger.debug('invoke', { cmd, args });
    return await invoke<T>(cmd, args ?? {});
  } catch (err) {
    logger.error('invoke failed', { cmd, err });
    throw err;
  }
}

export async function listBuiltinServers(): Promise<string[]> {
  return safeInvoke<string[]>('list_builtin_servers');
}

export async function listBuiltinTools(
  serverName?: string,
): Promise<MCPTool[]> {
  return safeInvoke<MCPTool[]>(
    'list_builtin_tools',
    serverName ? { serverName } : undefined,
  );
}

export async function callBuiltinTool(
  serverName: string,
  toolName: string,
  args: Record<string, unknown>,
): Promise<MCPResponse> {
  return safeInvoke<MCPResponse>('call_builtin_tool', {
    serverName,
    toolName,
    arguments: args,
  });
}

export async function callTool(
  serverName: string,
  toolName: string,
  args: Record<string, unknown>,
) {
  return safeInvoke<MCPResponse>('call_mcp_tool', {
    serverName,
    toolName,
    arguments: args,
  });
}

export default {
  safeInvoke,
  listBuiltinServers,
  listBuiltinTools,
  callBuiltinTool,
  callTool,
};
```

### B. `use-rust-backend.ts`를 thin wrapper로 변경(요약)

```ts
// src/hooks/use-rust-backend.ts
import * as client from '@/lib/rust-backend-client';

export const useRustBackend = () => {
  return {
    listBuiltinServers: client.listBuiltinServers,
    listBuiltinTools: client.listBuiltinTools,
    callBuiltinTool: client.callBuiltinTool,
    callTool: client.callTool,
    // ... 필요시 추가 래핑/메모화
  } as const;
};
```

### C. `BuiltInToolContext.tsx` 변경 포인트

```diff
- import { tauriMCPClient } from '@/lib/tauri-mcp-client';
+ // use the hook
+ const { listBuiltinTools, callBuiltinTool } = useRustBackend();
```

## 5) 변경 대상 파일 목록

- 신규: `src/lib/rust-backend-client.ts`
- 수정: `src/hooks/use-rust-backend.ts`
- 수정: `src/context/BuiltInToolContext.tsx`
- 수정: `src/context/MCPServerContext.tsx`
- 수정: 기타 `import { tauriMCPClient }` 참조 파일들
- 삭제(단계적): `src/lib/tauri-mcp-client.ts`
- 문서: `./docs/history/refactoring_{yyyyMMdd_hhmm}.md`

## 6) 마이그레이션 단계 (권장)

1. 새 `rust-backend-client.ts` 파일을 추가(병행 가능).
2. `use-rust-backend.ts`를 새 클라이언트를 사용하는 얇은 래퍼로 변경.
3. `BuiltInToolContext` 및 `MCPServerContext` 등의 컨텍스트에서 `tauriMCPClient` 참조를 새 훅/클라이언트로 교체.
4. 전역 검색으로 남은 `tauriMCPClient` 사용처를 전환.
5. 모든 변경이 완료되면 `tauri-mcp-client.ts`를 제거.

## 7) 테스트 계획

- Unit:
  - `safeInvoke` 성공/실패를 mocking하여 동작 검증
  - `listBuiltinTools(serverName?)`의 인자별 응답 처리 검증
- Integration (manual quick checks):
  - 앱 실행 후 `BuiltInToolContext`가 내장 도구를 정상 로드/실행하는지 확인
  - web-worker 도구 호출 경로와 remote MCP 도구 호출이 정상 동작하는지 확인
- CI 검증 명령 예시:

```bash
pnpm lint
pnpm build
pnpm test
cargo fmt
cargo build
```

## 8) 위험 요소 및 롤백

- 위험: 백엔드(Tauri) 명령 이름/파라미터 불일치 → 마이그레이션 전에 명칭 통일 필요
- 대처: 단계적 전환(신규 클라이언트 추가 → 참조 전환 → 기존 파일 제거)
- 롤백: 작업 전 브랜치 보존, 필요 시 revert

## 9) 일정(권장)

- Day 1: 브랜치 생성, `rust-backend-client.ts` 초안 작성, 기본 unit tests
- Day 2: 훅/컨텍스트 전환 및 모든 참조 교체
- Day 3: 빌드·린트·테스트 및 수동 시나리오 점검
- Day 4: `tauri-mcp-client.ts` 삭제, 문서화 및 PR 제출

## 10) PR 템플릿 (요약)

- 제목: `refactor(rust-backend): centralize tauri invoke logic into shared client`
- 본문: 목적, 변경 파일 목록, 마이그레이션 단계, 테스트/검증 방법, 위험 및 롤백 전략

## 11) 변경 기록 파일

- 작업을 완료하면 `./docs/history/refactoring_20250824_XXXX.md` 형식으로 요약 기록을 추가합니다.

## 12) Requirements coverage

- 작업의 목적: 포함
- 현재의 상태 / 문제점: 포함
- 변경 이후의 상태 / 해결 판정 기준: 포함
- 수정이 필요한 코드 및 코드 스니펫: 포함
- file 규칙: `./docs/history/refactoring_{yyyyMMdd_hhmm}.md` 준수

## 다음 행동 제안

- 제가 바로 (A) `src/lib/rust-backend-client.ts` 초안 생성 및 (B) `use-rust-backend.ts` 변경 패치를 제작하고, (C) `BuiltInToolContext.tsx`와 `MCPServerContext.tsx`의 핵심 참조를 교체해 드리겠습니다. 변경 후 `pnpm lint && pnpm build`를 실행해 결과를 보고하겠습니다.
