# BM25 검색 엔진 라이브러리 교체 리팩토링

## 작업의 목적

winkBM25S 라이브러리의 consolidation 실패 문제로 인한 검색 불가 오류를 해결하기 위해, 검증된 대안 라이브러리인 `okapibm25`로 교체하여 안정적이고 성능이 향상된 BM25 검색 기능을 구현한다.

## 현재의 상태 / 문제점

### 핵심 문제

- **winkBM25S consolidation 실패**: `"winkBM25S: search is not possible unless learnings are consolidated!"` 오류 발생
- **중복 문서 ID 문제**: `"winkBM25S: Duplicate document encountered: undefined"` 오류로 두 번째 문서부터 추가 실패
- **은밀한 오류 무시**: consolidation 실패 시 경고만 로깅하고 계속 진행하여 검색 시점에서 오류 발생

### 현재 구조

```typescript
// src/lib/web-mcp/modules/bm25/bm25-search-engine.ts
export class BM25SearchEngine implements ISearchEngine {
  private bm25Indexes = new Map<string, LocalBM25Instance>();
  private chunkMappings = new Map<string, Map<string, FileChunk>>();

  async addToIndex(storeId: string, newChunks: FileChunk[]): Promise<void> {
    // 복잡한 초기화, 문서 추가, consolidation 과정
    // ❌ consolidation 실패 시 예외 처리 부족
  }

  async search(
    storeId: string,
    query: string,
    options: SearchOptions,
  ): Promise<SearchResult[]> {
    // ❌ consolidation 상태 확인 없이 검색 시도
  }
}
```

### 영향 범위

- `content-store` 모듈의 `similaritySearch` 기능 사용 불가
- 사용자의 검색 요청 실패로 인한 UX 저하

## 추가 분석 과제

### 성능 최적화 분석

- 대용량 문서 처리 시 메모리 사용량 모니터링
- 동시 다중 검색 요청 처리 성능 측정
- 인덱스 캐싱 전략 검토

### 호환성 검증

- 기존 검색 결과와의 점수 일관성 확인
- 다양한 언어 및 특수 문자 처리 테스트
- 엣지 케이스 시나리오 검증 (빈 문서, 매우 긴 문서 등)

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **기능적 요구사항**
   - ✅ `similaritySearch` 기능이 오류 없이 정상 동작
   - ✅ 기존 `ISearchEngine` 인터페이스 완벽 호환
   - ✅ 검색 결과 품질 유지 (BM25 알고리즘 정확성)

2. **성능 요구사항**
   - ✅ 검색 응답 시간 100ms 이내 (1000개 문서 기준)
   - ✅ 메모리 사용량 현재 대비 동일하거나 개선
   - ✅ 초기화 오버헤드 제거

3. **안정성 요구사항**
   - ✅ consolidation 관련 오류 완전 제거
   - ✅ 문서 추가 시 중복 ID 오류 해결
   - ✅ 예외 상황에 대한 명확한 에러 처리

### 테스트 시나리오

```typescript
// 성공 판정을 위한 테스트 케이스
const testScenarios = [
  { documents: 5, query: 'machine learning', expectedResults: '>0' },
  { documents: 1000, query: 'neural networks', responseTime: '<100ms' },
  { documents: 0, query: 'empty search', expectedResults: '0' },
];
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 패키지 의존성 변경

```json
// package.json
"dependencies": {
-  "wink-bm25-text-search": "3.1.2",
+  "okapibm25": "1.4.1"
}
```

### 2. BM25SearchEngine 클래스 교체

```typescript
// src/lib/web-mcp/modules/bm25/bm25-search-engine.ts

// 기존 코드 (제거)
import type { LocalBM25Instance } from './types';

export class BM25SearchEngine implements ISearchEngine {
  private bm25Indexes = new Map<string, LocalBM25Instance>();
  private chunkMappings = new Map<string, Map<string, FileChunk>>();

  async addToIndex(storeId: string, newChunks: FileChunk[]): Promise<void> {
    // 복잡한 consolidation 로직...
    try {
      bm25.consolidate();
    } catch (consolidateError) {
      logger.warn('BM25 consolidation failed, continuing anyway', {...});
    }
  }

// 새로운 코드 (추가)
import pkg from 'okapibm25';
const BM25 = pkg.default;

export class BM25SearchEngine implements ISearchEngine {
  private storeChunks = new Map<string, FileChunk[]>();

  async addToIndex(storeId: string, newChunks: FileChunk[]): Promise<void> {
    const existingChunks = this.storeChunks.get(storeId) || [];
    const allChunks = [...existingChunks];

    newChunks.forEach(newChunk => {
      if (!allChunks.some(existing => existing.id === newChunk.id)) {
        allChunks.push(newChunk);
      }
    });

    this.storeChunks.set(storeId, allChunks);
  }

  async search(storeId: string, query: string, options: SearchOptions): Promise<SearchResult[]> {
    const chunks = this.storeChunks.get(storeId) || [];
    if (chunks.length === 0) return [];

    const documents = chunks.map(chunk => this.preprocessText(chunk.text));
    const queryTerms = this.preprocessText(query).split(/\s+/).filter(Boolean);

    const results = BM25(
      documents,
      queryTerms,
      { k1: 1.2, b: 0.75 },
      (a, b) => b.score - a.score
    );

    return results
      .filter(result => result.score >= (options.threshold || 0))
      .slice(0, options.topN)
      .map((result): SearchResult => {
        const originalIndex = documents.indexOf(result.document);
        const chunk = chunks[originalIndex];

        return {
          contentId: chunk.contentId,
          chunkId: chunk.id,
          context: chunk.text,
          lineRange: [chunk.startLine, chunk.endLine],
          score: result.score,
          relevanceType: 'keyword',
        };
      });
  }
}
```

### 3. 타입 정의 수정

```typescript
// src/lib/web-mcp/modules/bm25/types.ts

// 기존 코드 (제거)
export interface LocalBM25Instance {
  defineConfig: (config: object) => void;
  addDoc: (doc: { id: string; text: string }) => void;
  consolidate: () => void;
  search: (query: string) => BM25SearchResult[];
}

// 새로운 코드 (추가)
export interface OkapiBM25Result {
  document: string;
  score: number;
}

export type BM25SearchResult = [string, number];
export type OkapiBM25Function = (
  documents: string[],
  query: string[],
  options?: { k1?: number; b?: number },
  sortFunction?: (a: OkapiBM25Result, b: OkapiBM25Result) => number,
) => number[] | OkapiBM25Result[];
```

### 4. 초기화 로직 간소화

```typescript
// src/lib/web-mcp/modules/bm25/bm25-search-engine.ts

// 기존 코드 (제거)
async initialize(): Promise<void> {
  if (this.isInitialized) return;
  logger.info('Initializing BM25 search engine');

  try {
    await import('wink-bm25-text-search');
    logger.info('BM25 library loaded successfully');
    this.isInitialized = true;
  } catch (error) {
    logger.error('Failed to initialize BM25 library', error);
    throw new Error('BM25 search engine initialization failed');
  }
}

// 새로운 코드 (추가)
async initialize(): Promise<void> {
  if (this.isInitialized) return;
  // okapibm25는 별도 초기화 불필요
  this.isInitialized = true;
  logger.info('OkapiBM25 search engine initialized');
}
```

## 재사용 가능한 연관 코드

### 관련 파일 및 인터페이스

1. **핵심 인터페이스 (변경 없음)**
   - `src/models/search-engine.ts` - `ISearchEngine`, `SearchResult`, `SearchOptions`
   - 기존 인터페이스 완벽 호환으로 다른 모듈 수정 불필요

2. **데이터 모델 (재사용)**
   - `src/lib/db/types.ts` - `FileChunk` 인터페이스
   - 기존 chunk 구조 그대로 활용

3. **상위 모듈 (변경 없음)**
   - `src/lib/web-mcp/modules/content-store/server.ts` - `similaritySearch` 함수
   - `src/lib/web-mcp/modules/content-store/search.ts` - `ContentSearchEngine` 클래스

### 주요 기능 매핑

```typescript
// 기존 winkBM25S 방식
const bm25 = BM25Constructor();
bm25.defineConfig({...});
bm25.addDoc({id, text});
bm25.consolidate(); // ❌ 실패 지점
const results = bm25.search(query);

// 새로운 okapibm25 방식
const results = BM25(documents, queryTerms, options, sortFn); // ✅ 단순화
```

### 유틸리티 함수 (재사용)

```typescript
// 텍스트 전처리 로직 동일하게 사용
private preprocessText(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}
```

### 로깅 및 에러 처리 (재사용)

```typescript
// 기존 로거 시스템 그대로 활용
const logger = createWorkerSafeLogger('bm25-search-engine');

// 성능 로깅 패턴 재사용
logger.info('Search completed', {
  storeId,
  query,
  resultsCount: results.length,
  processingTime: endTime - startTime,
});
```

## 마이그레이션 단계

### Phase 1: 준비 단계

1. `okapibm25` 패키지 설치 및 검증
2. 기존 테스트 케이스 분석 및 새로운 테스트 작성

### Phase 2: 구현 단계

1. `BM25SearchEngine` 클래스 교체
2. 타입 정의 업데이트
3. 유닛 테스트 실행 및 검증

### Phase 3: 검증 단계

1. 통합 테스트 및 성능 벤치마크
2. 기존 기능과의 호환성 확인
3. 프로덕션 배포 전 최종 검증

## 리스크 및 대응 방안

### 주요 리스크

1. **검색 점수 차이**: 라이브러리 변경으로 인한 점수 체계 변화
   - **대응**: 기존 결과와 비교 테스트 수행, 필요시 점수 정규화

2. **성능 회귀**: 새로운 라이브러리의 성능 특성 차이
   - **대응**: 벤치마크 테스트 통과 후 적용

3. **예상치 못한 호환성 문제**
   - **대응**: 단계적 마이그레이션 및 롤백 계획 수립
