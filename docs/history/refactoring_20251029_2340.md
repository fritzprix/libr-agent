# MCP Configuration Migration to Comprehensive Format

**Date**: 2025-10-29  
**Author**: AI Assistant + fritzprix  
**Status**: Planning Complete - Ready for Implementation

---

## 작업의 목적

LibrAgent의 MCP 서버 설정을 stdio 전용 레거시 포맷에서 **MCP 공식 스펙 (2025-06-18)** 을 완벽히 준수하는 포괄적인 포맷으로 마이그레이션하여, HTTP/SSE transport와 OAuth 2.1 기반 인증을 지원하는 원격 MCP 서버 연동을 가능하게 한다.

### 핵심 목표

1. **Transport 확장**: stdio → stdio + HTTP + SSE (Streamable HTTP)
2. **인증 지원**: 없음 → OAuth 2.1 with PKCE
3. **보안 강화**: 환경변수 API 키 → OS keychain + encrypted storage
4. **사용자 경험**: 수동 설정 → 자동 discovery + dynamic registration
5. **Backward Compatibility**: 기존 stdio 설정 100% 유지 보장

---

## 현재의 상태 / 문제점

### 1. 타입 정의 한계

#### TypeScript (src/models/chat.ts)

```typescript
export interface MCPConfig {
  mcpServers?: Record<
    string,
    {
      command: string;
      args?: string[];
      env?: Record<string, string>;
    }
  >;
}
```

#### Rust (src-tauri/src/mcp/types.rs)

```rust
pub struct MCPServerConfig {
    pub name: String,
    pub command: String,
    pub args: Vec<String>,
    pub env: HashMap<String, String>,
    pub transport: String, // 항상 "stdio"
    pub url: Option<String>, // 미사용
    pub port: Option<u16>, // 미사용
}
```

**문제점**:

- HTTP/SSE transport 설정 불가
- OAuth 인증 정보 저장 불가
- Protocol version 협상 불가
- Session management 불가

### 2. 보안 취약점

### 현재 방식: Assistant 정의에 API 키 하드코딩

```typescript
const assistant: Assistant = {
  systemPrompt: '...',
  mcpConfig: {
    mcpServers: {
      'remote-server': {
        command: 'npx',
        args: ['-y', '@modelcontextprotocol/server-example'],
        env: {
          API_KEY: 'sk-1234567890abcdef', // ❌ 평문 저장
        },
      },
    },
  },
};
```

**문제점**:

- IndexedDB에 평문 저장 (브라우저 DevTools로 접근 가능)
- 사용자별 인증 관리 불가
- Token refresh 메커니즘 없음

### 3. MCP 스펙 불일치

| MCP 스펙 요구사항              | 현재 구현 | 갭                               |
| ------------------------------ | --------- | -------------------------------- |
| Streamable HTTP Transport      | ❌ 미지원 | POST/GET/DELETE 핸들러 필요      |
| SSE (deprecated but supported) | ❌ 미지원 | Backward compatibility 위해 필요 |
| `MCP-Protocol-Version` 헤더    | ❌ 미지원 | 모든 HTTP 요청에 필수            |
| `Mcp-Session-Id` 헤더          | ❌ 미지원 | Stateful 통신 필수               |
| OAuth 2.1 with PKCE            | ❌ 미지원 | 원격 서버 인증 필수              |
| RFC 8414 Discovery             | ❌ 미지원 | 자동 엔드포인트 발견             |
| DNS Rebinding Protection       | ❌ 미지원 | 로컬 서버 보안 필수              |

---

## 관련 코드의 구조 및 동작 방식 (Bird's Eye View)

### 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                    Frontend (React + TypeScript)            │
├─────────────────────────────────────────────────────────────┤
│  MCPServerContext.tsx                                       │
│  ├─ connectServers(mcpConfig)  ← MCPConfig (stdio only)    │
│  ├─ executeToolCall(toolCall)                              │
│  └─ Tool Aliasing: ${serverAlias}__${toolName}            │
├─────────────────────────────────────────────────────────────┤
│  useRustBackend Hook                                        │
│  └─ safeInvoke() → Tauri Command Wrapper                   │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              Tauri Backend (Rust)                           │
├─────────────────────────────────────────────────────────────┤
│  commands/mcp_commands.rs                                   │
│  ├─ list_tools_from_config(config: MCPServerConfig)        │
│  └─ start_mcp_server(config: MCPServerConfig)              │
├─────────────────────────────────────────────────────────────┤
│  mcp/server.rs: MCPServerManager                            │
│  ├─ Global State: Mutex<HashMap<ServerAlias, Connection>>  │
│  ├─ start_stdio_server() ✅ 구현 완료                       │
│  ├─ start_http_server() ❌ 스텁                             │
│  └─ start_sse_server() ❌ 스텁                              │
├─────────────────────────────────────────────────────────────┤
│  mcp/types.rs: MCPServerConfig                              │
│  └─ stdio 전용 필드만 사용                                   │
├─────────────────────────────────────────────────────────────┤
│  External Dependency                                         │
│  └─ rmcp (Rust MCP Client Library)                          │
│     └─ TokioChildProcess transport (stdio only)            │
└─────────────────────────────────────────────────────────────┘
```

### 핵심 데이터 흐름

1. **사용자 액션**: Settings에서 Assistant + MCP 서버 설정
2. **저장**: IndexedDB에 `Assistant` 객체 저장 (mcpConfig 포함)
3. **연결 시도**: Chat 페이지에서 `MCPServerContext.connectServers()` 호출
4. **Rust 호출**: `start_mcp_server` Tauri command 실행
5. **프로세스 생성**: `MCPServerManager::start_stdio_server()` → 자식 프로세스 spawn
6. **RMCP 연결**: `rmcp::RunningService` 생성, stdin/stdout 통신
7. **도구 목록**: `list_tools` JSON-RPC 호출 → React state 업데이트
8. **도구 실행**: `executeToolCall()` → `call_tool` JSON-RPC → 결과 반환

---

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준 (Acceptance Criteria)

#### 1. Backward Compatibility (필수)

- [ ] 기존 stdio 설정이 수정 없이 작동
- [ ] 레거시 `MCPServerConfig` JSON이 자동으로 `MCPServerConfigV2`로 변환
- [ ] 기존 Assistant의 `mcpConfig` 필드 호환성 유지

#### 2. HTTP Transport (필수)

- [ ] HTTP POST `/mcp` 엔드포인트로 JSON-RPC 요청 가능
- [ ] `MCP-Protocol-Version: 2025-06-18` 헤더 자동 추가
- [ ] `Mcp-Session-Id` 헤더로 stateful 통신 지원
- [ ] 최소 1개 공개 MCP 서버 (예: Brave Search) 연동 성공

#### 3. OAuth 인증 (필수)

- [ ] OAuth 2.1 Authorization Code Grant with PKCE 구현
- [ ] RFC 8414 메타데이터 discovery 지원
- [ ] Access token OS keychain 저장
- [ ] Token refresh 자동 처리

#### 4. 보안 (필수)

- [ ] API 키/토큰 평문 저장 제거
- [ ] DNS rebinding protection 활성화 (로컬 서버)
- [ ] CORS Origin 검증 (원격 서버)

#### 5. 사용자 경험 (권장)

- [ ] Settings UI에서 HTTP/OAuth 서버 추가 가능
- [ ] OAuth 플로우 웹뷰 또는 시스템 브라우저 통합
- [ ] 연결 상태 실시간 피드백

---

## 수정이 필요한 코드 및 코드 스니펫

### Phase 0: 타입 정의 수정

#### 1. TypeScript 타입 (src/models/chat.ts)

**수정 전**:

```typescript
export interface MCPConfig {
  mcpServers?: Record<
    string,
    {
      command: string;
      args?: string[];
      env?: Record<string, string>;
    }
  >;
}
```

**수정 후**:

```typescript
// Discriminated union for transport-specific configs
export type TransportConfig =
  | {
      type: 'stdio';
      command: string;
      args?: string[];
      env?: Record<string, string>;
    }
  | {
      type: 'http';
      url: string;
      protocolVersion?: string; // Default: "2025-06-18"
      sessionId?: string;
      headers?: Record<string, string>;
      enableSSE?: boolean; // For backward compatibility
      security?: {
        enableDnsRebindingProtection?: boolean;
        allowedOrigins?: string[];
        allowedHosts?: string[];
      };
    };

export interface OAuthConfig {
  type: 'oauth2.1';
  discoveryUrl?: string; // RFC 8414
  authorizationEndpoint?: string; // Fallback
  tokenEndpoint?: string;
  registrationEndpoint?: string; // RFC 7591
  clientId?: string;
  redirectUri?: string;
  scopes?: string[];
  usePKCE: boolean; // Default: true
  resourceParameter?: string; // RFC 9728
}

export interface MCPServerConfigV2 {
  name: string;
  transport: TransportConfig;
  authentication?: OAuthConfig;
  metadata?: {
    description?: string;
    vendor?: string;
    version?: string;
  };
}

export interface MCPConfig {
  mcpServers?: Record<string, MCPServerConfigV2>;
}

// Legacy type alias for backward compatibility
export type LegacyMCPServerConfig = {
  command: string;
  args?: string[];
  env?: Record<string, string>;
};
```

#### 2. Rust 타입 (src-tauri/src/mcp/types.rs)

**추가**:

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum TransportConfig {
    Stdio {
        command: String,
        args: Vec<String>,
        #[serde(default)]
        env: HashMap<String, String>,
    },
    Http {
        url: String,
        #[serde(default = "default_protocol_version")]
        protocol_version: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        session_id: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        headers: Option<HashMap<String, String>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        enable_sse: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        security: Option<SecurityConfig>,
    },
}

fn default_protocol_version() -> String {
    "2025-06-18".to_string()
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    #[serde(default)]
    pub enable_dns_rebinding_protection: bool,
    #[serde(default)]
    pub allowed_origins: Vec<String>,
    #[serde(default)]
    pub allowed_hosts: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthConfig {
    #[serde(rename = "type")]
    pub oauth_type: String, // "oauth2.1"
    pub discovery_url: Option<String>,
    pub authorization_endpoint: Option<String>,
    pub token_endpoint: Option<String>,
    pub registration_endpoint: Option<String>,
    pub client_id: Option<String>,
    pub redirect_uri: Option<String>,
    pub scopes: Option<Vec<String>>,
    #[serde(default = "default_use_pkce")]
    pub use_pkce: bool,
    pub resource_parameter: Option<String>,
}

fn default_use_pkce() -> bool {
    true
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfigV2 {
    pub name: String,
    pub transport: TransportConfig,
    pub authentication: Option<OAuthConfig>,
    pub metadata: Option<ServerMetadata>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerMetadata {
    pub description: Option<String>,
    pub vendor: Option<String>,
    pub version: Option<String>,
}

// Wrapper for auto-detection
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MCPServerConfigWrapper {
    V2(MCPServerConfigV2),
    Legacy(MCPServerConfig),
}

// Auto-conversion trait
impl From<MCPServerConfig> for MCPServerConfigV2 {
    fn from(legacy: MCPServerConfig) -> Self {
        MCPServerConfigV2 {
            name: legacy.name,
            transport: TransportConfig::Stdio {
                command: legacy.command,
                args: legacy.args,
                env: legacy.env,
            },
            authentication: None,
            metadata: None,
        }
    }
}

impl From<MCPServerConfigWrapper> for MCPServerConfigV2 {
    fn from(wrapper: MCPServerConfigWrapper) -> Self {
        match wrapper {
            MCPServerConfigWrapper::V2(v2) => v2,
            MCPServerConfigWrapper::Legacy(legacy) => legacy.into(),
        }
    }
}
```

### Phase 1: Command Handlers 수정

#### src-tauri/src/commands/mcp_commands.rs

**수정 필요 함수**:

```rust
#[tauri::command]
pub async fn list_tools_from_config(
    config_wrapper: MCPServerConfigWrapper, // ← 변경
) -> Result<Vec<ToolInfo>, String> {
    let config: MCPServerConfigV2 = config_wrapper.into(); // ← 자동 변환

    match &config.transport {
        TransportConfig::Stdio { command, args, env } => {
            // 기존 로직 유지
        }
        TransportConfig::Http { url, protocol_version, .. } => {
            // HTTP transport 로직 추가
            list_tools_from_http(url, protocol_version, &config.authentication).await
        }
    }
}

async fn list_tools_from_http(
    url: &str,
    protocol_version: &str,
    auth: &Option<OAuthConfig>,
) -> Result<Vec<ToolInfo>, String> {
    let client = reqwest::Client::new();
    let mut headers = reqwest::header::HeaderMap::new();

    // Add required headers
    headers.insert(
        "MCP-Protocol-Version",
        protocol_version.parse().unwrap(),
    );

    // Add authorization if available
    if let Some(oauth) = auth {
        if let Some(token) = get_cached_token(&oauth).await? {
            headers.insert(
                reqwest::header::AUTHORIZATION,
                format!("Bearer {}", token).parse().unwrap(),
            );
        }
    }

    // Send JSON-RPC request
    let response = client
        .post(url)
        .headers(headers)
        .json(&json!({
            "jsonrpc": "2.0",
            "method": "tools/list",
            "id": 1
        }))
        .send()
        .await
        .map_err(|e| e.to_string())?;

    // Parse response
    // ...
}
```

### Phase 2: OAuth Flow 구현

#### src-tauri/src/mcp/oauth.rs (신규 파일)

```rust
use oauth2::{
    AuthorizationCode, ClientId, CsrfToken, PkceCodeChallenge, PkceCodeVerifier,
    RedirectUrl, Scope, TokenResponse,
};
use oauth2::basic::BasicClient;
use oauth2::reqwest::async_http_client;
use tauri::Manager;

pub struct OAuthManager {
    pkce_verifiers: Arc<Mutex<HashMap<String, PkceCodeVerifier>>>,
}

impl OAuthManager {
    pub async fn start_authorization_flow(
        &self,
        config: &OAuthConfig,
        server_id: &str,
    ) -> Result<String, String> {
        // 1. Discover endpoints (RFC 8414)
        let endpoints = if let Some(discovery_url) = &config.discovery_url {
            discover_endpoints(discovery_url).await?
        } else {
            // Use fallback endpoints
            OAuthEndpoints {
                authorization_endpoint: config.authorization_endpoint.clone().unwrap(),
                token_endpoint: config.token_endpoint.clone().unwrap(),
            }
        };

        // 2. Create PKCE challenge
        let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
        self.pkce_verifiers.lock().unwrap().insert(server_id.to_string(), pkce_verifier);

        // 3. Build authorization URL
        let client = BasicClient::new(
            ClientId::new(config.client_id.clone().unwrap()),
            None,
            AuthUrl::new(endpoints.authorization_endpoint)?,
            Some(TokenUrl::new(endpoints.token_endpoint)?),
        )
        .set_redirect_uri(RedirectUrl::new(config.redirect_uri.clone().unwrap())?);

        let (authorize_url, csrf_state) = client
            .authorize_url(CsrfToken::new_random)
            .add_scopes(config.scopes.iter().map(|s| Scope::new(s.clone())))
            .set_pkce_challenge(pkce_challenge)
            .url();

        // 4. Return URL for frontend to open
        Ok(authorize_url.to_string())
    }

    pub async fn exchange_code_for_token(
        &self,
        config: &OAuthConfig,
        server_id: &str,
        authorization_code: &str,
    ) -> Result<String, String> {
        // Retrieve PKCE verifier
        let verifier = self.pkce_verifiers.lock().unwrap()
            .remove(server_id)
            .ok_or("PKCE verifier not found")?;

        // Exchange code for token
        let client = /* ... */;
        let token_result = client
            .exchange_code(AuthorizationCode::new(authorization_code.to_string()))
            .set_pkce_verifier(verifier)
            .request_async(async_http_client)
            .await
            .map_err(|e| e.to_string())?;

        let access_token = token_result.access_token().secret().clone();

        // Store in OS keychain
        store_token_securely(server_id, &access_token).await?;

        Ok(access_token)
    }
}

async fn discover_endpoints(discovery_url: &str) -> Result<OAuthEndpoints, String> {
    let client = reqwest::Client::new();
    let metadata: AuthServerMetadata = client
        .get(discovery_url)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .json()
        .await
        .map_err(|e| e.to_string())?;

    Ok(OAuthEndpoints {
        authorization_endpoint: metadata.authorization_endpoint,
        token_endpoint: metadata.token_endpoint,
    })
}
```

### Phase 3: Token Storage (OS Keychain)

#### Cargo.toml 추가

```toml
[dependencies]
keyring = "2.0"
```

#### src-tauri/src/mcp/keychain.rs (신규 파일)

```rust
use keyring::Entry;

const SERVICE_NAME: &str = "com.libr-agent.mcp";

pub async fn store_token_securely(server_id: &str, token: &str) -> Result<(), String> {
    let entry = Entry::new(SERVICE_NAME, server_id)
        .map_err(|e| format!("Failed to create keychain entry: {}", e))?;

    entry.set_password(token)
        .map_err(|e| format!("Failed to store token: {}", e))?;

    Ok(())
}

pub async fn get_cached_token(server_id: &str) -> Result<Option<String>, String> {
    let entry = Entry::new(SERVICE_NAME, server_id)
        .map_err(|e| format!("Failed to create keychain entry: {}", e))?;

    match entry.get_password() {
        Ok(token) => Ok(Some(token)),
        Err(keyring::Error::NoEntry) => Ok(None),
        Err(e) => Err(format!("Failed to retrieve token: {}", e)),
    }
}

pub async fn delete_token(server_id: &str) -> Result<(), String> {
    let entry = Entry::new(SERVICE_NAME, server_id)
        .map_err(|e| format!("Failed to create keychain entry: {}", e))?;

    entry.delete_password()
        .map_err(|e| format!("Failed to delete token: {}", e))?;

    Ok(())
}
```

### Phase 4: HTTP Transport 구현

#### src-tauri/src/mcp/http_transport.rs (신규 파일)

```rust
use reqwest::{Client, Response};
use serde_json::{json, Value};
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct HttpTransport {
    client: Client,
    base_url: String,
    protocol_version: String,
    session_id: Option<String>,
    headers: HeaderMap,
}

impl HttpTransport {
    pub fn new(config: &HttpConfig, auth_token: Option<String>) -> Self {
        let mut headers = HeaderMap::new();

        // Add protocol version header
        headers.insert(
            "MCP-Protocol-Version",
            config.protocol_version.parse().unwrap(),
        );

        // Add authorization header if available
        if let Some(token) = auth_token {
            headers.insert(
                AUTHORIZATION,
                format!("Bearer {}", token).parse().unwrap(),
            );
        }

        // Add custom headers
        if let Some(custom_headers) = &config.headers {
            for (key, value) in custom_headers {
                headers.insert(
                    key.parse().unwrap(),
                    value.parse().unwrap(),
                );
            }
        }

        Self {
            client: Client::new(),
            base_url: config.url.clone(),
            protocol_version: config.protocol_version.clone(),
            session_id: config.session_id.clone(),
            headers,
        }
    }

    pub async fn send_request(&mut self, method: &str, params: Value) -> Result<Value, String> {
        let mut request_headers = self.headers.clone();

        // Add session ID if available
        if let Some(session_id) = &self.session_id {
            request_headers.insert(
                "Mcp-Session-Id",
                session_id.parse().unwrap(),
            );
        }

        let request_body = json!({
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": generate_request_id(),
        });

        let response = self.client
            .post(&self.base_url)
            .headers(request_headers)
            .json(&request_body)
            .send()
            .await
            .map_err(|e| e.to_string())?;

        // Extract session ID from response if present
        if let Some(session_id) = response.headers().get("Mcp-Session-Id") {
            self.session_id = Some(session_id.to_str().unwrap().to_string());
        }

        let response_json: Value = response.json().await.map_err(|e| e.to_string())?;

        if let Some(error) = response_json.get("error") {
            return Err(format!("JSON-RPC error: {}", error));
        }

        response_json.get("result")
            .cloned()
            .ok_or_else(|| "No result in response".to_string())
    }
}
```

### Phase 5: Frontend 수정

#### src/context/MCPServerContext.tsx

**수정 부분**:

```typescript
const connectServers = async (mcpConfig: MCPConfig) => {
  if (!mcpConfig.mcpServers) return;

  for (const [alias, serverConfig] of Object.entries(mcpConfig.mcpServers)) {
    try {
      // Check if OAuth is required
      if (serverConfig.authentication?.type === 'oauth2.1') {
        // Check for cached token
        const hasToken = await checkCachedToken(alias);

        if (!hasToken) {
          // Start OAuth flow
          const authUrl = await invokeRust('start_oauth_flow', {
            serverId: alias,
            config: serverConfig.authentication,
          });

          // Open system browser or webview
          await open(authUrl);

          // Wait for callback (implement deep link handling)
          await waitForOAuthCallback(alias);
        }
      }

      // Start MCP server connection
      const tools = await invokeRust('list_tools_from_config', {
        configWrapper: serverConfig, // Auto-converts V1 → V2
      });

      // Store tools with alias prefix
      setAvailableTools((prev) => ({
        ...prev,
        ...tools.reduce((acc, tool) => {
          acc[`${alias}__${tool.name}`] = tool;
          return acc;
        }, {}),
      }));
    } catch (error) {
      logger.error(`Failed to connect to ${alias}`, error);
    }
  }
};
```

---

## 재사용 가능한 연관 코드

### 기존 stdio Transport (유지)

**파일**: `src-tauri/src/mcp/server.rs`  
**함수**: `MCPServerManager::start_stdio_server()`  
**용도**: stdio transport는 그대로 유지, 새로운 HTTP/SSE transport와 병행 사용

### RMCP 라이브러리

**Crate**: `rmcp = "0.2.1"`  
**용도**: JSON-RPC 메시지 직렬화/역직렬화, stdio transport 지원  
**제약**: HTTP transport 미지원 → 직접 구현 필요

### Tauri 보안 API

**Plugin**: `tauri-plugin-secure-store` (검토 필요)  
**대안**: `keyring` crate로 OS keychain 직접 접근

### OAuth 2.1 라이브러리

**Crate**: `oauth2 = "4.4"`  
**기능**: Authorization Code Grant, PKCE, Token exchange  
**참고**: [oauth2-rs documentation](https://docs.rs/oauth2/latest/oauth2/)

### HTTP Client

**Crate**: `reqwest = "0.11"` (이미 프로젝트에 포함)  
**용도**: HTTP/HTTPS 요청, JSON 직렬화

---

## Test Code 추가 및 수정 가이드

### Unit Tests

#### 1. 타입 변환 테스트 (Rust)

**파일**: `src-tauri/src/mcp/types.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_legacy_to_v2_conversion() {
        let legacy = MCPServerConfig {
            name: "test-server".to_string(),
            command: "node".to_string(),
            args: vec!["server.js".to_string()],
            env: HashMap::new(),
            transport: "stdio".to_string(),
            url: None,
            port: None,
        };

        let v2: MCPServerConfigV2 = legacy.into();

        assert_eq!(v2.name, "test-server");
        match v2.transport {
            TransportConfig::Stdio { command, .. } => {
                assert_eq!(command, "node");
            }
            _ => panic!("Expected Stdio transport"),
        }
    }

    #[test]
    fn test_wrapper_deserialize_v2() {
        let json = r#"{
            "name": "http-server",
            "transport": {
                "type": "http",
                "url": "https://api.example.com/mcp",
                "protocol_version": "2025-06-18"
            }
        }"#;

        let wrapper: MCPServerConfigWrapper = serde_json::from_str(json).unwrap();
        let v2: MCPServerConfigV2 = wrapper.into();

        assert_eq!(v2.name, "http-server");
    }

    #[test]
    fn test_wrapper_deserialize_legacy() {
        let json = r#"{
            "name": "legacy-server",
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-example"],
            "env": {},
            "transport": "stdio"
        }"#;

        let wrapper: MCPServerConfigWrapper = serde_json::from_str(json).unwrap();
        let v2: MCPServerConfigV2 = wrapper.into();

        assert_eq!(v2.name, "legacy-server");
    }
}
```

#### 2. HTTP Transport 테스트 (Rust)

**파일**: `src-tauri/src/mcp/http_transport.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use wiremock::{MockServer, Mock, ResponseTemplate};
    use wiremock::matchers::{method, path, header};

    #[tokio::test]
    async fn test_http_transport_list_tools() {
        let mock_server = MockServer::start().await;

        Mock::given(method("POST"))
            .and(path("/mcp"))
            .and(header("MCP-Protocol-Version", "2025-06-18"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "jsonrpc": "2.0",
                "result": {
                    "tools": [
                        {"name": "test-tool", "description": "A test tool"}
                    ]
                },
                "id": 1
            })))
            .mount(&mock_server)
            .await;

        let config = HttpConfig {
            url: mock_server.uri(),
            protocol_version: "2025-06-18".to_string(),
            session_id: None,
            headers: None,
            enable_sse: None,
            security: None,
        };

        let mut transport = HttpTransport::new(&config, None);
        let result = transport.send_request("tools/list", json!({})).await;

        assert!(result.is_ok());
    }
}
```

### Integration Tests

#### 3. OAuth Flow 테스트

**파일**: `src-tauri/tests/oauth_integration_test.rs`

```rust
#[tokio::test]
async fn test_oauth_authorization_flow() {
    // Mock OAuth server
    let mock_server = MockServer::start().await;

    // Test discovery
    // Test authorization URL generation
    // Test token exchange
    // Test token storage
}
```

### Frontend Tests

#### 4. MCPServerContext 테스트

**파일**: `src/context/__tests__/MCPServerContext.test.tsx`

```typescript
import { renderHook, act } from '@testing-library/react';
import { useMCPServer } from '../MCPServerContext';

describe('MCPServerContext', () => {
  it('should handle legacy stdio config', async () => {
    const { result } = renderHook(() => useMCPServer());

    await act(async () => {
      await result.current.connectServers({
        mcpServers: {
          'legacy-server': {
            command: 'node',
            args: ['server.js'],
            env: {},
          },
        },
      });
    });

    expect(result.current.connectedServers).toContain('legacy-server');
  });

  it('should handle HTTP config with OAuth', async () => {
    // Test HTTP transport connection
    // Test OAuth flow triggering
  });
});
```

---

## 추가 분석 과제

### 1. RMCP HTTP Transport 지원 조사 (우선순위: 높)

**목적**: `rmcp` crate가 HTTP transport를 지원하는지 확인, 지원하지 않으면 대안 검토

**방법**:

```bash
# RMCP 소스코드 확인
git clone https://github.com/modelcontextprotocol/rmcp
cd rmcp
grep -r "http" src/
grep -r "HttpTransport" src/
```

**결과에 따른 대응**:

- 지원함: RMCP API 사용
- 지원 안 함: 직접 구현 (위의 `http_transport.rs` 사용)

### 2. Tauri Deep Link 설정 (우선순위: 중)

**목적**: OAuth callback을 위한 custom URL scheme 등록 (`libr-agent://oauth/callback`)

**참고**:

- [Tauri Deep Links Plugin](https://v2.tauri.app/plugin/deep-link/)
- macOS: Info.plist에 URL scheme 추가
- Windows: Registry에 URL protocol 등록
- Linux: .desktop 파일 수정

### 3. MCP 공개 서버 목록 조사 (우선순위: 낮)

**목적**: 테스트 및 데모용 공개 MCP 서버 확인

**후보**:

- Brave Search MCP (검색 도구)
- GitHub MCP (리포지토리 접근)
- Notion MCP (노트 연동)

**조사 항목**:

- OAuth 지원 여부
- API 키 발급 방법
- Rate limiting 정책

### 4. 보안 감사 (우선순위: 높)

**검토 항목**:

- [ ] Token 저장: OS keychain 사용 확인
- [ ] HTTPS 강제: 원격 서버는 HTTPS만 허용
- [ ] CORS 설정: Origin 검증 로직 확인
- [ ] PKCE 구현: Code verifier entropy 충분성
- [ ] Token refresh: Refresh token rotation 구현

---

## 구현 일정

| Phase     | 작업 내용                  | 예상 소요 시간 | 담당자 | 시작일 | 완료일 |
| --------- | -------------------------- | -------------- | ------ | ------ | ------ |
| Phase 0   | 타입 정의 수정 (TS + Rust) | 1일            | TBD    |        |        |
| Phase 1   | Command handlers 수정      | 2일            | TBD    |        |        |
| Phase 2   | OAuth 플로우 구현          | 2-3일          | TBD    |        |        |
| Phase 3   | OS Keychain 통합           | 1일            | TBD    |        |        |
| Phase 4   | HTTP Transport 구현        | 2-3일          | TBD    |        |        |
| Phase 5   | Frontend 수정 + UI         | 2일            | TBD    |        |        |
| Testing   | Unit + Integration tests   | 2일            | TBD    |        |        |
| QA        | 전체 기능 테스트           | 1일            | TBD    |        |        |
| **Total** |                            | **13-16일**    |        |        |        |

---

## 롤백 계획

### 위험 요소

1. **HTTP Transport 버그**: JSON-RPC 프로토콜 불일치
2. **OAuth 플로우 실패**: 브라우저 통합 문제
3. **Token 저장 실패**: OS keychain 권한 문제

### 롤백 절차

1. **Feature Flag 사용**:

   ```rust
   #[cfg(feature = "http-transport")]
   mod http_transport;
   ```

2. **Gradual Rollout**:
   - Week 1: stdio만 지원 (기존 동작)
   - Week 2: stdio + HTTP (beta 테스터)
   - Week 3: 전체 배포

3. **Backward Compatibility 보장**:
   - 기존 설정 파일 자동 변환
   - 변환 실패 시 경고 + stdio fallback

---

## 참고 자료

### MCP 공식 문서

- [MCP Specification 2025-06-18](https://modelcontextprotocol.io/specification/2025-06-18/)
- [Streamable HTTP Transport](https://modelcontextprotocol.io/specification/2025-06-18/basic/transports)
- [OAuth 2.1 Integration](https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization)

### RFC 표준

- [RFC 8414: OAuth 2.0 Authorization Server Metadata](https://www.rfc-editor.org/rfc/rfc8414.html)
- [RFC 7591: OAuth 2.0 Dynamic Client Registration](https://www.rfc-editor.org/rfc/rfc7591.html)
- [RFC 7636: PKCE](https://www.rfc-editor.org/rfc/rfc7636.html)
- [RFC 9728: Protected Resource Metadata](https://datatracker.ietf.org/doc/html/rfc9728)

### 구현 참고

- [TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [Python SDK](https://github.com/modelcontextprotocol/python-sdk)
- [oauth2-rs Documentation](https://docs.rs/oauth2/latest/oauth2/)

---

## 승인 체크리스트

- [ ] 설계 리뷰 완료
- [ ] 보안 감사 완료
- [ ] 테스트 계획 승인
- [ ] 일정 확정
- [ ] 담당자 할당

**Reviewer**: **\*\*\*\***\_**\*\*\*\***  
**Date**: **\*\*\*\***\_**\*\*\*\***  
**Signature**: **\*\*\*\***\_**\*\*\*\***
