# Workspace Export 기능 Tauri Command 방식 전환 Refactoring Plan

## 작업의 목적

기존 Asset Protocol 기반 export 기능을 **Tauri Command 방식**으로 전환하여 MCP-UI iframe에서 동적으로 생성된 파일을 안전하고 확실하게 다운로드할 수 있도록 한다.

### 핵심 목표

- **Tauri Command 기반 다운로드**: `window.__TAURI__.invoke()` 호출로 파일 다운로드 처리
- **MCP-UI 호환성**: iframe 내 postMessage 통신으로 host와 상호작용
- **브라우저 표준 활용**: 파일 저장 다이얼로그를 통한 사용자 친화적 다운로드
- **보안 강화**: 직접 파일 시스템 접근 대신 제어된 Tauri command 사용
- **Asset Protocol 제약 해결**: 정적 리소스 제한을 우회한 동적 파일 서빙

## 현재의 상태 / 문제점

### 1. Asset Protocol 제약으로 인한 다운로드 실패

- **Tauri Asset Protocol 한계**: `tauri://localhost/workspace/exports/packages/file.zip` 형태의 URL이 동작하지 않음
- **정적 vs 동적 리소스**: Asset Protocol은 빌드타임 정적 리소스만 지원, 런타임 생성 파일 불가
- **Scope 불일치**: `tauri.conf.json`의 `workspace/**` scope가 실제 동적 세션 디렉토리와 매핑되지 않음
- **iframe 보안 제약**: MCP-UI iframe에서 직접적인 파일 시스템 접근 불가

### 2. 현재 구현의 한계

- **HTML 다운로드 링크**: `<a href="tauri://localhost/...">` 방식이 "asset not found" 에러 발생
- **브라우저 호환성**: iframe 내에서 Tauri asset protocol 접근 제한
- **에러 처리 부족**: 다운로드 실패 시 사용자 피드백 없음
- **보안 검증 미흡**: 파일 경로 검증이 Asset Protocol에 의존

### 3. MCP-UI 통신 구조 부재

- **postMessage 핸들러 없음**: iframe에서 host로의 통신 채널 부재
- **UI Action 처리 누락**: MCP-UI 표준 액션 처리 로직 미구현
- **양방향 통신 부족**: host에서 iframe으로의 결과 피드백 메커니즘 없음

## 추가 분석 과제

### 1. Tauri File Dialog API 활용 방안

- **tauri-plugin-dialog**: 브라우저 파일 저장 다이얼로그 연동 방식
- **파일 스트리밍**: 대용량 파일 처리를 위한 청크 단위 전송 방식
- **Progress Callback**: 다운로드 진행률 실시간 업데이트 메커니즘

### 2. MCP-UI Action 표준 준수

- **Tool Call Action**: iframe에서 새로운 MCP Tool 호출 방식
- **Notification Action**: 다운로드 상태 알림 표준화
- **Error Handling**: MCP-UI 에러 응답 형식 준수

### 3. 파일 관리 정책 개선

- **임시 파일 정리**: 다운로드 완료 후 export 파일 자동 정리
- **동시 다운로드**: 여러 파일 동시 export 시 충돌 방지
- **권한 검증**: 파일 접근 권한 사전 검증 체계

## 변경 이후의 상태 / 해결 판정 기준

### 1. Tauri Command 기반 다운로드 시스템

- **download_workspace_file Command**: 파일 경로를 받아 브라우저 다운로드 실행
- **export_workspace_zip Command**: ZIP 파일 생성 및 즉시 다운로드
- **파일 저장 다이얼로그**: 사용자가 저장 위치 선택 가능
- **실시간 피드백**: 다운로드 성공/실패 상태 즉시 표시

### 2. 향상된 MCP-UI 통신

- **postMessage 기반 통신**: iframe ↔ host 양방향 통신 구현
- **UI Action 표준 준수**: MCP-UI 액션 형식으로 다운로드 요청
- **에러 핸들링**: 상세한 에러 메시지와 재시도 옵션 제공

### 3. 사용자 경험 개선

- **원클릭 다운로드**: 버튼 클릭 즉시 파일 저장 다이얼로그 표시
- **진행 상태 표시**: 파일 생성 및 다운로드 진행률 실시간 업데이트
- **다운로드 완료 알림**: 성공적인 다운로드 후 확인 메시지

### 4. 판정 기준

- [ ] `download_workspace_file` Tauri command 구현 완료
- [ ] MCP-UI iframe에서 postMessage 통신 동작
- [ ] 브라우저 파일 저장 다이얼로그 정상 표시
- [ ] export 파일 다운로드 성공률 100%
- [ ] 에러 발생 시 사용자 친화적 메시지 표시
- [ ] 대용량 ZIP 파일 다운로드 안정성 확보

## 수정이 필요한 코드 및 수정부분

### 1. Tauri Command 추가

**파일**: `src-tauri/src/lib.rs`

```rust
#[tauri::command]
async fn download_workspace_file(
    app_handle: tauri::AppHandle,
    file_path: String,
) -> Result<String, String> {
    use tauri::api::dialog::FileDialogBuilder;

    // SecureFileManager를 통해 workspace 디렉토리 가져오기
    let session_manager = get_session_manager();
    let file_manager = session_manager.get_file_manager();
    let workspace_dir = file_manager.base_dir();

    // 요청된 파일의 전체 경로 구성
    let full_path = workspace_dir.join(&file_path);

    // 파일 존재 및 보안 검증
    if !full_path.exists() {
        return Err(format!("File not found: {}", file_path));
    }

    if !full_path.starts_with(workspace_dir) {
        return Err("Access denied: Path outside workspace".to_string());
    }

    // 파일명 추출
    let file_name = full_path.file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("download");

    // 파일 내용 읽기
    let file_content = match tokio::fs::read(&full_path).await {
        Ok(content) => content,
        Err(e) => return Err(format!("Failed to read file: {}", e)),
    };

    // 파일 저장 다이얼로그 표시 및 저장
    let save_result = std::sync::Arc::new(std::sync::Mutex::new(None));
    let save_result_clone = save_result.clone();

    FileDialogBuilder::new()
        .set_file_name(file_name)
        .save_file(move |save_path| {
            if let Some(save_path) = save_path {
                let result = std::fs::write(save_path, &file_content);
                *save_result_clone.lock().unwrap() = Some(result);
            }
        });

    // 결과 대기 (간단한 동기화)
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    match save_result.lock().unwrap().as_ref() {
        Some(Ok(_)) => Ok("File downloaded successfully".to_string()),
        Some(Err(e)) => Err(format!("Failed to save file: {}", e)),
        None => Err("Download cancelled by user".to_string()),
    }
}

#[tauri::command]
async fn export_and_download_zip(
    app_handle: tauri::AppHandle,
    files: Vec<String>,
    package_name: String,
) -> Result<String, String> {
    // ZIP 생성 로직 (기존 handle_export_zip 활용)
    // 생성 완료 후 즉시 download_workspace_file 호출

    let session_manager = get_session_manager();
    let file_manager = session_manager.get_file_manager();
    let workspace_dir = file_manager.base_dir();

    // ZIP 파일 생성
    let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
    let zip_filename = format!("{}_{}.zip", package_name, timestamp);
    let zip_path = workspace_dir.join("exports/packages").join(&zip_filename);

    // ZIP 생성 로직 (기존 코드 재사용)
    // ... ZIP 생성 코드 ...

    // 생성된 ZIP 파일 즉시 다운로드
    let relative_path = format!("exports/packages/{}", zip_filename);
    download_workspace_file(app_handle, relative_path).await
}
```

**등록 추가**:

```rust
.invoke_handler(tauri::generate_handler![
    // 기존 handlers...
    download_workspace_file,
    export_and_download_zip,
])
```

### 2. HTML UIResource 수정

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
fn create_html_export_ui(
    &self,
    title: &str,
    files: &[String],
    export_type: &str,
    download_path: &str,
) -> String {
    let files_list = files
        .iter()
        .map(|f| format!("<li class='file-item'>{}</li>", html_escape::encode_text(f)))
        .collect::<Vec<_>>()
        .join("");

    format!(
        r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }}
        .container {{
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }}
        .download-btn {{
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(33, 150, 243, 0.3);
        }}
        .download-btn:hover {{
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(33, 150, 243, 0.5);
        }}
        .download-btn:disabled {{
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }}
        .status-message {{
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }}
        .success {{ background-color: rgba(76, 175, 80, 0.3); }}
        .error {{ background-color: rgba(244, 67, 54, 0.3); }}
        .loading {{ background-color: rgba(255, 193, 7, 0.3); }}
    </style>
</head>
<body>
    <div class="container">
        <h1>🎉 {}</h1>
        <div class="export-info">
            <h3>📦 Export Type: {}</h3>
            <p>📅 Created: {}</p>
            <p>📁 Files: {} items</p>
            <ul>{}</ul>
        </div>
        <div style="text-align: center;">
            <button id="downloadBtn" onclick="downloadFile()" class="download-btn">
                ⬇️ Download Now
            </button>
            <div id="statusMessage" class="status-message" style="display: none;"></div>
        </div>
    </div>

    <script>
        const downloadBtn = document.getElementById('downloadBtn');
        const statusMessage = document.getElementById('statusMessage');

        async function downloadFile() {{
            downloadBtn.disabled = true;
            downloadBtn.textContent = '⏳ Downloading...';
            showStatus('Preparing download...', 'loading');

            try {{
                // MCP-UI 표준 Tool Call Action으로 다운로드 요청
                window.parent.postMessage({{
                    type: 'tool',
                    payload: {{
                        toolName: 'download_workspace_file',
                        params: {{
                            filePath: '{}'
                        }}
                    }}
                }}, '*');

                showStatus('Download request sent!', 'success');
            }} catch (error) {{
                console.error('Download failed:', error);
                showStatus('Download failed: ' + error.message, 'error');
                resetButton();
            }}
        }}

        function showStatus(message, type) {{
            statusMessage.textContent = message;
            statusMessage.className = 'status-message ' + type;
            statusMessage.style.display = 'block';
        }}

        function resetButton() {{
            downloadBtn.disabled = false;
            downloadBtn.textContent = '⬇️ Download Now';
        }}

        // Listen for download completion from parent
        window.addEventListener('message', function(event) {{
            if (event.data.type === 'download_complete') {{
                if (event.data.success) {{
                    showStatus('✅ Download completed successfully!', 'success');
                }} else {{
                    showStatus('❌ Download failed: ' + event.data.error, 'error');
                }}
                resetButton();
            }}
        }});
    </script>
</body>
</html>"#,
        html_escape::encode_text(title),
        html_escape::encode_text(title),
        html_escape::encode_text(export_type),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
        files.len(),
        files_list,
        html_escape::encode_text(download_path)
    )
}
```

### 3. Frontend MCP-UI Action Handler 추가

**파일**: `src/components/ui/UIResourceRenderer.tsx`

```typescript
const handleUIAction = useCallback(async (event: MessageEvent) => {
  if (event.data.type === 'tool') {
    const { toolName, params } = event.data.payload;

    if (toolName === 'download_workspace_file') {
      try {
        // Tauri command 호출
        const result = await invoke('download_workspace_file', {
          filePath: params.filePath,
        });

        // 성공 결과를 iframe에 전송
        event.source?.postMessage(
          {
            type: 'download_complete',
            success: true,
            result,
          },
          '*',
        );
      } catch (error) {
        // 에러 결과를 iframe에 전송
        event.source?.postMessage(
          {
            type: 'download_complete',
            success: false,
            error: error.toString(),
          },
          '*',
        );
      }
    }
  }
}, []);

useEffect(() => {
  window.addEventListener('message', handleUIAction);
  return () => window.removeEventListener('message', handleUIAction);
}, [handleUIAction]);
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 컴포넌트

**파일**: `src/components/ui/UIResourceRenderer.tsx`

- **기능**: MCP-UI iframe 렌더링 및 postMessage 통신
- **인터페이스**: `UIResource` 타입, `onUIAction` 콜백
- **재사용**: postMessage 이벤트 리스너 확장

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

- **기능**: Export 디렉토리 관리, ZIP 생성 로직
- **재사용**: `ensure_exports_directory()`, ZIP 생성 코드
- **인터페이스**: `handle_export_file()`, `handle_export_zip()` 메서드

**파일**: `src-tauri/src/services/mod.rs`

- **기능**: SecureFileManager를 통한 안전한 파일 접근
- **재사용**: 파일 경로 검증, 워크스페이스 디렉토리 관리
- **인터페이스**: `validate_path()`, `base_dir()` 메서드

### 확장 필요한 타입 정의

**파일**: `src/models/chat.ts`

```typescript
interface UIAction {
  type: 'tool' | 'prompt' | 'notify' | 'link';
  payload: {
    toolName?: string;
    params?: Record<string, any>;
    prompt?: string;
    message?: string;
    url?: string;
  };
}

interface DownloadResult {
  type: 'download_complete';
  success: boolean;
  result?: string;
  error?: string;
}
```

**파일**: `src-tauri/src/lib.rs`

- **확장**: Tauri command 등록 리스트에 새로운 download commands 추가
- **재사용**: 기존 세션 관리 및 파일 매니저 인스턴스

이 계획을 통해 Asset Protocol의 제약을 완전히 우회하고, MCP-UI 표준을 준수하는 안정적인 파일 다운로드 시스템을 구축할 수 있습니다.
