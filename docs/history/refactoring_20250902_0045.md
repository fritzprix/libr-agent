# Refactoring Plan: Claude Extended Thinking API 메시지 포맷 수정

## 작업의 목적

Claude Extended Thinking API 규격에 맞는 메시지 포맷 변환 로직을 구현하여, thinking 블록이 포함된 assistant 메시지가 올바르게 처리되도록 수정

## 현재의 상태 / 문제점

### 문제 상황

- **API 오류**: `messages.1.content.0.type: Expected 'thinking' or 'redacted_thinking', but found 'tool_use'`
- **발생 시점**: Tool 실행 후 다음 AI 호출 시 Claude Extended Thinking API에서 메시지 포맷 검증 실패

### 근본 원인

1. `src/lib/ai-service/anthropic.ts:194-270`의 `convertToAnthropicMessages` 메서드가 `Message.thinking` 필드를 무시
2. Assistant 메시지에 thinking 데이터가 있어도 Anthropic API 형식으로 변환되지 않음
3. Extended Thinking API 요구사항: assistant 메시지의 첫 번째 content 블록이 반드시 `thinking` 타입이어야 함

### 데이터 플로우 분석

- ✅ Streaming 중 thinking 데이터 수집: `use-ai-service.ts:96-97`
- ✅ Message 객체에 thinking 저장: `use-ai-service.ts:132,150,160`
- ✅ IndexedDB 저장/복원: `SessionHistoryContext.tsx`
- ❌ **API 호출 시 thinking 블록 변환 누락**: `convertToAnthropicMessages`

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. Tool 실행 후 연속적인 AI 대화가 API 오류 없이 진행
2. Assistant 메시지의 thinking 데이터가 올바른 Anthropic API 포맷으로 변환
3. Extended Thinking API 규격 준수: `content[0].type === 'thinking'`

### 검증 방법

- "go to hackernews and research top 10 stories" 같은 tool 사용 시나리오에서 오류 미발생
- API 호출 시 메시지 구조가 `[{type: 'thinking', thinking: '...'}, ...]` 형태로 전송
- 기존 non-thinking 시나리오의 정상 동작 유지

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 핵심 수정 대상

**파일**: `src/lib/ai-service/anthropic.ts`  
**메서드**: `convertToAnthropicMessages` (라인 194-270)

```typescript
// 현재 코드 (문제)
} else if (m.role === 'assistant') {
  // ... existing validation logic ...

  if (m.tool_calls) {
    anthropicMessages.push({
      role: 'assistant',
      content: m.tool_calls.map((tc) => ({
        type: 'tool_use' as const,
        id: tc.id,
        name: tc.function.name,
        input: JSON.parse(tc.function.arguments),
      })),
    });
  }
  // ... 다른 조건들 ...
}

// 수정 후 코드
} else if (m.role === 'assistant') {
  // ... existing validation logic ...

  // Build content array with thinking block first if present
  const content = [];

  // Add thinking block as first element if exists
  if (m.thinking) {
    content.push({
      type: 'thinking' as const,
      thinking: m.thinking,
    });
  }

  // Add tool_use or text content after thinking
  if (m.tool_calls) {
    content.push(...m.tool_calls.map((tc) => ({
      type: 'tool_use' as const,
      id: tc.id,
      name: tc.function.name,
      input: JSON.parse(tc.function.arguments),
    })));
  } else if (hasContent) {
    const processedContent = this.processMessageContent(m.content);
    if (Array.isArray(processedContent)) {
      content.push(...processedContent);
    } else {
      content.push({ type: 'text' as const, text: processedContent });
    }
  }

  if (content.length > 0) {
    anthropicMessages.push({
      role: 'assistant',
      content,
    });
  }
}
```

### 보조 수정 대상

**파일**: `src/lib/ai-service/anthropic.ts`  
**메서드**: `convertSingleMessage` (라인 279-334)

- `convertToAnthropicMessages`와 동일한 thinking 처리 로직 적용

## 재사용 가능한 연관 코드

### 관련 파일 및 인터페이스

- **Message 타입 정의**: `src/models/chat.ts:30-44`
  - `thinking?: string` 필드 정의
  - Tool call, content 구조 정의

- **Thinking 데이터 수집**: `src/hooks/use-ai-service.ts:96-97`

  ```typescript
  if (parsedChunk.thinking) {
    thinking += parsedChunk.thinking;
  }
  ```

- **Streaming 응답 처리**: `src/lib/ai-service/anthropic.ts:79-83`
  ```typescript
  } else if (chunk.type === 'content_block_delta' &&
            chunk.delta.type === 'thinking_delta') {
    yield JSON.stringify({ thinking: chunk.delta.thinking });
  ```

### 참고할 기존 구현

- **Groq 서비스의 thinking 처리**: `src/lib/ai-service/groq.ts:104,150`
  - Similar thinking field handling pattern
- **BaseAIService**: `src/lib/ai-service/base-service.ts`
  - Abstract method signatures for message conversion

### API 스펙 참조

- Anthropic Extended Thinking API Documentation
- Content block type definitions: `'thinking' | 'text' | 'tool_use' | 'tool_result'`
- Message structure requirements for thinking-enabled models
