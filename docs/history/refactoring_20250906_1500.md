# Planning Server UIResource 분리 및 promptUser 도구 추가 Refactoring Plan

## 작업의 목적

Planning Server에서 기존 planning 도구들의 UIResource를 제거하여 단순화하고, 사용자 질의를 위한 새로운 `promptUser` 도구를 추가한다. 이를 통해 tool recurring 패턴에서 사용자 개입이 필요할 때 자연스럽게 UIResource를 통한 상호작용을 제공하며, Chat 메시지 큐잉 시스템과 연동하여 일관된 대화 흐름을 구현한다.

## 현재의 상태 / 문제점

### 1. Planning 도구들의 불필요한 UIResource

- `create_goal`, `clear_goal`, `add_todo`, `toggle_todo`, `clear_todos` (5개 도구)가 모두 UIResource 반환
- 각 도구 실행 시마다 `createGoalTodosUIResource()` 호출하여 HTML 기반 현황 표시
- 단순한 상태 업데이트 작업에 불필요한 UI 복잡성 추가
- 현재 코드:
  ```typescript
  const uiResource = createGoalTodosUIResource(
    state.getGoal(),
    state.getTodos(),
  );
  return normalizeToolResultWithUI(result, 'create_goal', uiResource);
  ```

### 2. 사용자 질의 기능 부재

- Tool recurring 중 사용자 추가 정보 요청 메커니즘 없음
- AI Agent가 의사결정 시 사용자 개입이 필요한 상황 처리 불가
- UIResource 기반 상호작용 인프라는 존재하지만 활용되지 않음

### 3. Tool Recurring 제어 로직 부재

- UIResource 반환 시 tool recurring 자동 중단 로직 없음
- `use-tool-processor.ts`에서 UIResource 감지 및 제어 기능 부재
- 사용자 응답을 Chat 메시지로 연결하는 표준화된 방법 없음

## 추가 분석 과제

1. **UIResourceRenderer에서 prompt 이벤트 처리 방식**
   - MCP-UI 표준 준수하는 `prompt` 타입 이벤트 처리 구조 확인
   - `onUIAction` prop을 통한 ChatContext 연동 방안 검토

2. **Tool Processor UIResource 감지 성능 최적화**
   - `mcpResponse.result.content` 배열 순회 최적화 방안
   - UIResource 타입 검사 로직의 정확성 검증

3. **promptUser 도구 사용 시나리오 정의**
   - yes/no, options, text 입력 타입별 UI 템플릿 설계
   - 복잡한 질의 시 context 정보 전달 방식

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **Planning 도구 단순화**: 기존 5개 도구가 UIResource 없이 텍스트 응답만 반환
2. **promptUser 도구 동작**: question, type, options 파라미터로 UIResource 생성 및 사용자 상호작용 가능
3. **Tool Recurring 제어**: UIResource 반환 시 자동으로 tool recurring 중단
4. **MCP-UI 표준 준수**: `prompt` 이벤트 타입으로 사용자 응답을 Chat으로 전달
5. **메시지 흐름 연결**: UIResource 응답 → prompt 이벤트 → Chat submit → 다음 tool 실행

### UI 동작 시나리오

- **기존 planning 도구**: 텍스트 기반 성공/실패 메시지만 표시
- **promptUser 도구**: UIResource 렌더링 → 사용자 입력 → prompt 이벤트 → 메시지 전송
- **Tool recurring**: promptUser 호출 시 중단 → 사용자 응답 후 재개

### 검증 방법

1. **Planning 도구 테스트**: `create_goal` 등 실행 시 UIResource 부재 확인
2. **promptUser 테스트**: 다양한 질의 타입(yesno, options, text)으로 UIResource 생성 확인
3. **통합 테스트**: Tool recurring 중 promptUser 호출 → 사용자 응답 → 다음 tool 실행 흐름 검증

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Planning Server - 기존 UIResource 제거

**파일**: `src/lib/web-mcp/modules/planning-server.ts`
**수정 범위**: 기존 planning 도구들의 UIResource 제거

```typescript
// 제거할 함수들
function generateGoalTodosHTML(goal: string | null, todos: SimpleTodo[]): string { /* ... */ }
function createGoalTodosUIResource(goal: string | null, todos: SimpleTodo[]) { /* ... */ }
function normalizeToolResultWithUI(result: unknown, toolName: string, uiResource?: unknown): MCPResponse { /* ... */ }

// 기존 도구들 수정 (5개 도구 모두 동일한 패턴)
case 'create_goal': {
  const result = state.createGoal(typedArgs.goal as string);
  // const uiResource = createGoalTodosUIResource(state.getGoal(), state.getTodos()); // 제거
  // return normalizeToolResultWithUI(result, 'create_goal', uiResource); // 제거
  return normalizeToolResult(result, 'create_goal'); // 변경
}
```

### 2. Planning Server - promptUser 도구 추가

**파일**: `src/lib/web-mcp/modules/planning-server.ts`
**수정 범위**: promptUser 도구 정의 및 구현

```typescript
// tools 배열에 추가
{
  name: 'promptUser',
  description: 'Ask the user for additional information during task execution',
  inputSchema: {
    type: 'object',
    properties: {
      question: { type: 'string' },
      type: { type: 'string', enum: ['yesno', 'options', 'text'] },
      options: { type: 'array', items: { type: 'string' } },
    },
    required: ['question', 'type'],
  },
}

// promptUser 구현 함수들 추가
function generatePromptHTML(params: { question: string; type: string; options?: string[] }): string {
  // 질의 타입별 HTML 생성 로직
}

function createPromptUIResource(params: { question: string; type: string; options?: string[] }) {
  const htmlContent = generatePromptHTML(params);
  return createUIResource({
    uri: `ui://prompt/${Date.now()}`,
    content: { type: 'rawHtml', htmlString: htmlContent },
    encoding: 'text',
  });
}

// callTool에 promptUser 케이스 추가
case 'promptUser': {
  const params = typedArgs as { question: string; type: string; options?: string[] };
  const uiResource = createPromptUIResource(params);
  return normalizeToolResult({ success: true, question: params.question }, 'promptUser').then(response => {
    if (response.result?.content) {
      response.result.content.unshift(uiResource as any);
    }
    return response;
  });
}
```

### 3. Tool Processor - UIResource 감지 및 Tool Recurring 제어

**파일**: `src/hooks/use-tool-processor.ts`
**수정 범위**: UIResource 감지 로직 추가

```typescript
// processToolCalls 함수 내부 수정
const toolPromises = tcMessage.tool_calls.map(async (toolCall) => {
  try {
    const mcpResponse = await executeToolCallRef.current(toolCall);

    // UIResource 감지 로직 추가
    if (
      mcpResponse.result?.content &&
      Array.isArray(mcpResponse.result.content)
    ) {
      const hasUIResource = mcpResponse.result.content.some(
        (item) =>
          item.type === 'resource' && item.resource?.uri?.startsWith('ui://'),
      );

      if (hasUIResource) {
        logger.info('Tool returned UIResource, stopping recurring', {
          toolName: toolCall.function.name,
          toolCallId: toolCall.id,
        });

        // UIResource 포함 메시지 생성 및 즉시 반환
        const toolResultMessage: Message = {
          id: createId(),
          assistantId: currentAssistant?.id,
          role: 'tool',
          content: mcpResponse.result?.content || '',
          tool_call_id: toolCall.id,
          sessionId: currentSession?.id || '',
          uiResource: extractUIResource(mcpResponse.result.content),
        };

        await submitRef.current([toolResultMessage], currentAssistant?.id);
        return 'UI_RESOURCE_STOP'; // 특별한 반환값으로 중단 표시
      }
    }

    // 기존 로직 계속...
  } catch (error) {
    // 기존 error 처리...
  }
});

// UIResource 결과 처리
const toolResults = await Promise.all(toolPromises);
if (toolResults.some((result) => result === 'UI_RESOURCE_STOP')) {
  return; // Tool recurring 중단
}
```

### 4. ChatContext - UIResource 이벤트 처리

**파일**: `src/context/ChatContext.tsx`
**수정 범위**: prompt 이벤트 핸들러 추가

```typescript
// UIResource 이벤트 핸들러 추가
const handleUIAction = useCallback(
  async (action: { type: string; payload: any }) => {
    if (action.type === 'prompt') {
      logger.info('Received prompt response from UIResource', {
        response: action.payload.prompt,
      });

      const userMessage: Message = {
        id: createId(),
        role: 'user',
        content: action.payload.prompt,
        sessionId: currentSession?.id || '',
      };

      await submit([userMessage]);
    }
  },
  [submit, currentSession],
);

// Context value에 추가
const value: ChatContextValue = useMemo(
  () => ({
    submit,
    isLoading,
    isToolExecuting,
    messages,
    cancel: handleCancel,
    addToMessageQueue,
    pendingCancel,
    handleUIAction, // 새로 추가
  }),
  [
    /* dependencies */
  ],
);
```

## 재사용 가능한 연관 코드

### 관련 파일 경로 및 주요 기능

1. **`src/lib/web-mcp/modules/planning-server.ts`**
   - 주요 기능: MCP planning 도구들, UIResource 생성
   - 인터페이스: `WebMCPServer`, `MCPTool`, `MCPResponse`
   - 재사용 요소: `normalizeToolResult`, `createUIResource` (promptUser용)

2. **`src/hooks/use-tool-processor.ts`**
   - 주요 기능: Tool 실행 관리, Tool recurring 제어
   - 인터페이스: `UseToolProcessorConfig`, `executeToolCall`
   - 재사용 요소: `processToolCalls`, `onToolExecutionChange` 콜백

3. **`src/context/ChatContext.tsx`**
   - 주요 기능: Chat 상태 관리, 메시지 처리
   - 인터페이스: `ChatContextValue`, `submit`, `addToMessageQueue`
   - 재사용 요소: 메시지 큐잉 시스템, 상태 관리 패턴

4. **`src/components/ui/UIResourceRenderer.tsx`**
   - 주요 기능: UIResource 렌더링, MCP-UI 이벤트 처리
   - 인터페이스: `UIActionResult`, `onUIAction` prop
   - 재사용 요소: postMessage 기반 이벤트 처리, MCP-UI 표준 준수

### 재사용 가능한 패턴

- **UIResource 생성**: `createUIResource` with `rawHtml` content type
- **MCP Response 구조**: `{ jsonrpc: '2.0', id, result: { content: [...] } }`
- **Tool 실행 흐름**: executeToolCall → MCPResponse → Message 생성 → submit
- **이벤트 처리**: postMessage → UIAction → ChatContext handler → submit

### 데이터 타입 및 인터페이스

- **MCPResponse**: `result.content[]` 배열에서 UIResource 감지
- **UIActionResult**: `{ type: 'prompt', payload: { prompt: string } }`
- **Message**: `uiResource` 필드로 UIResource 저장
- **PromptParams**: `{ question: string; type: 'yesno'|'options'|'text'; options?: string[] }`
