# Refactoring Plan: MCPResponse Direct Usage & serializeToolResult Removal

## 작업의 목적

현재 Tool 실행 결과 처리에서 불필요한 `serializeToolResult` 함수를 제거하고, MCPResponse의 content 배열을 직접 사용하여 더 직관적이고 확장 가능한 구조로 개선합니다.

**핵심 목표:**

- Tool 실행 결과의 복잡한 변환 과정 제거
- MCP 표준을 그대로 활용한 일관성 확보
- 다양한 content type (text, image, resource 등) 확장성 확보
- 코드 복잡도 감소 및 성능 개선

---

## 현재의 상태 / 문제점

### 1. 복잡한 데이터 변환 과정

```typescript
// 현재: MCPResponse → SerializedToolResult → Message
const mcpResponse = await executeToolCall(toolCall);
const serialized = serializeToolResult(mcpResponse, toolName, executionStartTime);
const toolResultMessage: Message = {
  content: serialized.text || '[UIResource: ...]',
  uiResource: serialized.uiResource,
  // ...
};
```

### 2. UIResource 분리로 인한 데이터 파편화

- MCPResponse의 content 배열에 있던 resource가 별도 필드로 분리됨
- 결국 Message에서 다시 합쳐지는 비효율성

### 3. 중복된 텍스트 처리 로직

- `mcpResponseToString`과 `serializeToolResult`의 텍스트 변환 로직 중복
- UIResource가 있을 때와 없을 때의 분기 처리 복잡성

### 4. Message.content의 타입 제한

```typescript
export interface Message {
  content: string; // 문자열만 지원, MCPContent 배열 불가
  uiResource?: UIResource | UIResource[]; // 별도 필드로 분리
}
```

---

## 변경 이후의 상태 / 해결 판정 기준

### 1. 직접적인 데이터 흐름

```typescript
// 변경 후: MCPResponse → Message (직접 변환)
const mcpResponse = await executeToolCall(toolCall);
const toolResultMessage: Message = {
  content: mcpResponse.result?.content || [],
  // uiResource 필드 제거 (content 배열에 포함)
};
```

### 2. 통합된 content 배열 관리

- 모든 content type이 하나의 배열에서 관리
- type과 mimeType에 따른 유연한 처리

### 3. 확장 가능한 구조

```typescript
// 다양한 content type 지원
content: [
  { type: 'text', text: 'Hello' },
  { type: 'image', source: { data: 'base64...', mimeType: 'image/png' } },
  { type: 'resource', resource: { uri: 'ui://...', mimeType: 'text/html' } }
]
```

### 4. 해결 판정 기준

- [ ] `serializeToolResult` 함수 완전 제거
- [ ] `SerializedToolResult` 인터페이스 제거
- [ ] Message.content가 `string | MCPContent[]` 타입 지원
- [ ] Tool 실행 결과가 MCPResponse.result.content로 직접 전달
- [ ] AI Service 레이어에서 MCPContent 배열 올바른 처리
- [ ] UI 렌더링에서 content type별 올바른 표시
- [ ] 기존 기능 동작 보장 (텍스트, UIResource 등)

---

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. `/src/models/chat.ts` - Message 인터페이스 수정

**현재:**

```typescript
export interface Message {
  id: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  tool_calls?: ToolCall[];
  tool_call_id?: string;
  isStreaming?: boolean;
  thinking?: string;
  assistantId?: string;
  attachments?: AttachmentReference[];
  tool_use?: { id: string; name: string; input: Record<string, unknown> };
  uiResource?: UIResource | UIResource[]; // 제거 예정
  createdAt?: Date;
  updatedAt?: Date;
}
```

**수정 후:**

```typescript
import type { MCPContent } from '../lib/mcp-types';

export interface Message {
  id: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string | MCPContent[]; // MCPContent 배열 지원 추가
  tool_calls?: ToolCall[];
  tool_call_id?: string;
  isStreaming?: boolean;
  thinking?: string;
  assistantId?: string;
  attachments?: AttachmentReference[];
  tool_use?: { id: string; name: string; input: Record<string, unknown> };
  // uiResource 필드 제거 - content 배열에 포함됨
  createdAt?: Date;
  updatedAt?: Date;
}
```

### 2. `/src/context/ChatContext.tsx` - serializeToolResult 제거 및 ToolCaller 수정

**현재:**

```typescript
interface SerializedToolResult {
  success: boolean;
  text?: string;
  uiResource?: UIResource | UIResource[];
  error?: string;
  metadata: Record<string, unknown>;
  toolName: string;
  executionTime: number;
}

const serializeToolResult = (
  mcpResponse: MCPResponse,
  toolName: string,
  executionStartTime: number,
): SerializedToolResult => {
  // ... 복잡한 변환 로직
};

// ToolCaller에서 사용
const mcpResponse = await executeToolCall(toolCall);
const serialized = serializeToolResult(mcpResponse, toolName, executionStartTime);
const toolResultMessage: Message = {
  content: serialized.text || '[UIResource: ...]',
  uiResource: serialized.uiResource,
  // ...
};
```

**수정 후:**

```typescript
// SerializedToolResult 인터페이스 제거
// serializeToolResult 함수 제거

// ToolCaller에서 직접 사용
const mcpResponse = await executeToolCall(toolCall);

// MCPResponse 에러 체크 유틸리티 함수
const isMCPError = (response: MCPResponse): boolean => {
  return !!response.error || !response.result;
};

const toolResultMessage: Message = {
  id: createId(),
  assistantId: currentAssistant?.id,
  role: 'tool',
  content: isMCPError(mcpResponse) 
    ? `Error: ${mcpResponse.error?.message || 'Tool execution failed'}`
    : mcpResponse.result?.content || [],
  tool_call_id: toolCall.id,
  sessionId: currentSession?.id || '',
};
```

### 3. `/src/lib/ai-service/base-service.ts` - MCPContent 배열 처리

**추가 필요:**

```typescript
import type { MCPContent } from '../mcp-types';

export abstract class BaseAIService {
  // MCPContent 배열을 LLM용 텍스트로 변환
  protected processMessageContent(content: string | MCPContent[]): string {
    if (typeof content === 'string') {
      return content;
    }
    
    // MCPContent 배열에서 텍스트만 추출
    return content
      .filter(item => item.type === 'text')
      .map(item => item.text)
      .join('\n');
  }

  // MLM용 - 이미지 content도 처리
  protected processMultiModalContent(content: string | MCPContent[]): Array<{type: string, text?: string, image?: string}> {
    if (typeof content === 'string') {
      return [{ type: 'text', text: content }];
    }

    return content.map(item => {
      switch (item.type) {
        case 'text':
          return { type: 'text', text: item.text };
        case 'image':
          return { 
            type: 'image', 
            image: item.source?.data || item.source?.uri 
          };
        default:
          return { type: 'text', text: `[${item.type}]` };
      }
    });
  }
}
```

### 4. `/src/lib/ai-service/openai.ts` - OpenAI 서비스 수정

**현재:**

```typescript
export class OpenAIService extends BaseAIService {
  async generateResponse(messages: Message[]): Promise<string> {
    const formattedMessages = messages.map(msg => ({
      role: msg.role,
      content: msg.content, // string만 처리
    }));
    // ...
  }
}
```

**수정 후:**

```typescript
export class OpenAIService extends BaseAIService {
  async generateResponse(messages: Message[]): Promise<string> {
    const formattedMessages = messages.map(msg => ({
      role: msg.role,
      content: this.processMessageContent(msg.content), // MCPContent 배열 처리
    }));
    // ...
  }
}
```

### 5. UI 컴포넌트 - 메시지 렌더링 수정

**새로 추가 필요:**

```typescript
// /src/components/MessageRenderer.tsx
import type { MCPContent } from '../lib/mcp-types';

interface MessageRendererProps {
  content: string | MCPContent[];
}

export const MessageRenderer: React.FC<MessageRendererProps> = ({ content }) => {
  if (typeof content === 'string') {
    return <div className="message-text">{content}</div>;
  }

  return (
    <div className="message-content">
      {content.map((item, index) => {
        switch (item.type) {
          case 'text':
            return (
              <div key={index} className="content-text">
                {item.text}
              </div>
            );
          case 'resource':
            return (
              <UIResourceRenderer 
                key={index} 
                resource={item.resource}
                mimeType={item.mimeType} 
              />
            );
          case 'image':
            return (
              <img 
                key={index} 
                src={item.source?.data || item.source?.uri} 
                alt="Tool output"
                className="content-image"
              />
            );
          default:
            return (
              <div key={index} className="content-unknown">
                [{item.type}]
              </div>
            );
        }
      })}
    </div>
  );
};
```

---

## 마이그레이션 단계

### Phase 1: 타입 시스템 업데이트

1. Message 인터페이스의 content 타입 확장
2. MCPContent 처리 유틸리티 함수 추가
3. 타입 에러 해결

### Phase 2: ChatContext 리팩토링

1. serializeToolResult 함수 제거
2. ToolCaller에서 MCPResponse 직접 사용
3. 에러 처리 로직 단순화

### Phase 3: AI Service 업데이트

1. BaseAIService에 MCPContent 처리 메서드 추가
2. 각 AI 서비스에서 새 메서드 활용
3. 기존 동작 보장 테스트

### Phase 4: UI 렌더링 개선

1. MessageRenderer 컴포넌트 추가
2. content type별 렌더링 로직 구현
3. 기존 UIResource 렌더링과 통합

### Phase 5: 검증 및 정리

1. 모든 기능 동작 확인
2. 사용하지 않는 코드 제거 (SerializedToolResult, uiResource 필드 등)
3. 문서 업데이트

---

## 예상 이슈 및 해결 방안

### 1. 기존 코드와의 호환성

**문제:** Message.content가 string에서 union type으로 변경
**해결:** 타입 가드 함수로 점진적 마이그레이션

```typescript
const isStringContent = (content: string | MCPContent[]): content is string => {
  return typeof content === 'string';
};
```

### 2. UI 렌더링 복잡도 증가

**문제:** content 배열 렌더링이 복잡해질 수 있음
**해결:** MessageRenderer 컴포넌트로 캡슐화

### 3. AI Service 호환성

**문제:** 일부 AI Service가 MCPContent를 올바르게 처리하지 못할 수 있음
**해결:** BaseAIService의 processMessageContent로 일관된 변환

---

## 검증 방법

1. **기능 테스트**
   - 텍스트 도구 실행 결과 정상 표시
   - UIResource 포함 도구 결과 정상 렌더링
   - 에러 발생 시 적절한 에러 메시지 표시

2. **타입 안전성**
   - TypeScript 컴파일 에러 없음
   - 런타임 타입 에러 없음

3. **성능 테스트**
   - 도구 실행 속도 개선 확인
   - 메모리 사용량 최적화 확인

4. **호환성 테스트**
   - 모든 AI Service에서 정상 동작
   - 기존 채팅 기록 정상 표시

이 리팩토링을 통해 더 직관적이고 확장 가능한 Tool 결과 처리 시스템을 구축할 수 있습니다.
