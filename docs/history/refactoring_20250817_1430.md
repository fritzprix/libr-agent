# Web MCP Module 구조 개선 및 불일치 해결 리팩터링

## 작업의 목적

Web MCP 모듈의 구조적 불일치를 해결하고, 코드의 일관성과 유지보수성을 향상시키기 위한 리팩터링 작업

## 현재의 상태 / 문제점

### 1. 서버 이름 불일치 문제

**위치**: `src/lib/web-mcp/mcp-worker.ts` 및 `src/lib/web-mcp/modules/content-store.ts`

- **문제**: Worker 레지스트리 키(`'content-store'`)와 실제 서버 이름(`'file-store'`)이 다름
- **영향**: 서버 로딩 시 혼동을 야기하고, 새로운 개발자에게 혼란을 줄 수 있음

**현재 코드**:

```typescript
// mcp-worker.ts - 레지스트리 키
const getServerRegistry = (): Map<string, WebMCPServer | null> => {
  return new Map([
    ['calculator', calculatorServer],
    ['filesystem', filesystemServer],
    ['content-store', contentStoreServer], // 키: content-store
  ]);
};

// content-store.ts - 실제 서버 이름
const fileStoreServer: WebMCPServer = {
  name: 'file-store', // 이름: file-store
  version: '1.1.0',
  description: 'File attachment and semantic search system using MCP protocol',
  // ...
};
```

### 2. 동적 import와 레지스트리 동기화 문제

**위치**: `src/lib/web-mcp/mcp-worker.ts`

- **문제**: `loadServers()` 함수에서 동적 import하는 모듈과 `getServerRegistry()`에서 반환하는 키가 하드코딩되어 있어 새 모듈 추가 시 두 곳을 모두 수정해야 함
- **영향**: 새로운 MCP 모듈 추가 시 누락 가능성과 유지보수 복잡성 증가

**현재 코드**:

```typescript
// 동적 import (content-store만 로드)
async function loadServers(): Promise<void> {
  const [contentStoreModule] = await Promise.allSettled([
    import('./modules/content-store'),
  ]);
  // calculator, filesystem은 import되지 않음
}

// 레지스트리 (3개 서버 모두 포함)
const getServerRegistry = (): Map<string, WebMCPServer | null> => {
  return new Map([
    ['calculator', calculatorServer], // null 상태
    ['filesystem', filesystemServer], // null 상태
    ['content-store', contentStoreServer],
  ]);
};
```

### 3. Worker 환경에서의 의존성 문제

**위치**: `src/lib/web-mcp/modules/content-store.ts`

- **문제**: Worker 환경에서 실행되는 모듈이 메인 스레드의 `dbService`와 `@/lib/db` 타입들에 의존
- **영향**: Worker 격리 원칙 위반 및 런타임 에러 가능성

**현재 코드**:

```typescript
import {
  dbService,        // 메인 스레드 전용 서비스
  dbUtils,
  FileChunk,
  FileContent,
  FileStore,
} from '@/lib/db';

// Worker에서 메인 스레드 서비스 사용
await dbService.fileStores.upsert(store);
```

### 4. 사용되지 않는 retry 관련 코드

**위치**: `src/lib/web-mcp/mcp-proxy.ts`

- **문제**: `retryOptions` 설정과 주석만 남아있고 실제 retry 로직은 제거됨
- **영향**: 코드 복잡성 증가 및 잘못된 설정 기대

**현재 코드**:

```typescript
private config: WebMCPProxyConfig & {
  timeout: number;
  retryOptions: RetryOptions; // 사용되지 않는 설정
};

constructor(config: WebMCPProxyConfig) {
  this.config = {
    timeout: 30000,
    retryOptions: {          // 실제로는 사용되지 않음
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 10000,
      exponentialBackoff: true,
      ...config.retryOptions,
    },
    // ...
  };
}

// pingWithRetry 제거됨
```

## 변경 이후의 상태 / 해결 판정 기준

### 1. 서버 이름 일관성 확보

- **해결책**: `content-store.ts`의 서버 이름을 `'content-store'`로 변경하여 레지스트리 키와 일치시킴
- **판정 기준**: 레지스트리 키와 서버 이름이 동일해야 함

### 2. 모듈 등록 자동화

- **해결책**: 동적 모듈 발견 시스템 구현 또는 명시적 모듈 목록 관리
- **판정 기준**: 새 모듈 추가 시 단일 지점에서만 수정하면 되어야 함

### 3. Worker 의존성 격리

- **해결책**: Worker 내부에서 독립적인 데이터 저장소 사용 또는 메시지 패싱을 통한 데이터 접근
- **판정 기준**: Worker 모듈이 메인 스레드 서비스에 직접 의존하지 않아야 함

### 4. 불필요한 retry 코드 제거

- **해결책**: `retryOptions` 설정 및 관련 import 제거
- **판정 기준**: retry 관련 코드가 완전히 제거되어야 함

## 수정이 필요한 코드 및 수정부분의 코드 스니펫

### 수정 1: 서버 이름 일관성 (content-store.ts)

```typescript
// 현재
const fileStoreServer: WebMCPServer = {
  name: 'file-store',
  // ...
};

// 수정 후
const fileStoreServer: WebMCPServer = {
  name: 'content-store',
  // ...
};
```

### 수정 2: 모듈 등록 명시화 (mcp-worker.ts)

```typescript
// 현재
async function loadServers(): Promise<void> {
  const [contentStoreModule] = await Promise.allSettled([
    import('./modules/content-store'),
  ]);
  // calculator, filesystem 모듈은 로드되지 않음
}

const getServerRegistry = (): Map<string, WebMCPServer | null> => {
  return new Map([
    ['calculator', calculatorServer],      // null
    ['filesystem', filesystemServer],      // null  
    ['content-store', contentStoreServer],
  ]);
};

// 수정 후
const MODULE_REGISTRY = [
  { key: 'content-store', importPath: './modules/content-store' },
  // 향후 모듈들을 여기에 추가
] as const;

async function loadServers(): Promise<void> {
  const modulePromises = MODULE_REGISTRY.map(({ importPath }) => 
    import(importPath)
  );
  
  const results = await Promise.allSettled(modulePromises);
  
  results.forEach((result, index) => {
    const { key } = MODULE_REGISTRY[index];
    if (result.status === 'fulfilled') {
      // 해당 서버 변수에 할당
    }
  });
}

const getServerRegistry = (): Map<string, WebMCPServer | null> => {
  return new Map(MODULE_REGISTRY.map(({ key }) => [
    key, 
    getServerInstance(key)
  ]));
};
```

### 수정 3: Retry 코드 제거 (mcp-proxy.ts)

```typescript
// 현재
import { withTimeout, RetryOptions } from '../retry-utils';

private config: WebMCPProxyConfig & {
  timeout: number;
  retryOptions: RetryOptions;
};

constructor(config: WebMCPProxyConfig) {
  this.config = {
    timeout: 30000,
    retryOptions: {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 10000,
      exponentialBackoff: true,
      ...config.retryOptions,
    },
    ...config,
  };
}

// 수정 후
import { withTimeout } from '../retry-utils';

private config: WebMCPProxyConfig & {
  timeout: number;
};

constructor(config: WebMCPProxyConfig) {
  this.config = {
    timeout: 30000,
    ...config,
  };
}
```

### 수정 4: Worker 의존성 격리 방향성

```typescript
// 현재 (문제가 있는 접근)
import { dbService } from '@/lib/db';
await dbService.fileStores.upsert(store);

// 수정 방향 (메시지 패싱 또는 Worker 내부 저장소)
// Option 1: 메시지 패싱
self.postMessage({
  type: 'db-operation',
  operation: 'upsert',
  table: 'fileStores',
  data: store
});

// Option 2: Worker 내부 저장소 (IndexedDB 직접 사용)
const db = await openWorkerDB();
await db.stores.put('fileStores', store);
```

## 작업 우선순위

1. **High**: 서버 이름 일관성 수정 (즉시 혼동 해결)
2. **High**: Retry 코드 제거 (코드 정리)
3. **Medium**: 모듈 등록 시스템 개선 (유지보수성)
4. **Low**: Worker 의존성 격리 (아키텍처 개선, 별도 작업으로 분리 가능)

## 예상 영향도

- **Breaking Change**: 없음 (서버 이름 변경은 내부 구현)
- **Testing Required**: Worker 통신 및 모듈 로딩 테스트 필요
- **Documentation Update**: 새로운 모듈 추가 가이드 업데이트 필요

## 작업 요약 및 테스트 케이스

### 작업 요약

본 리팩터링 작업은 다음 세 가지 주요 사항을 해결했습니다.

1.  **서버 이름 일관성 확보**: `src/lib/web-mcp/modules/content-store.ts` 파일에서 서버의 `name` 속성을 `'file-store'`에서 `'content-store'`로 변경하여, `mcp-worker.ts`의 레지스트리 키와 일치시켰습니다.
2.  **불필요한 코드 제거**: `src/lib/web-mcp/mcp-proxy.ts` 파일에서 더 이상 사용되지 않는 `retryOptions` 관련 설정을 `config` 객체와 생성자에서 제거하고, 관련 `RetryOptions` 타입 import도 삭제하여 코드를 간소화했습니다.
3.  **모듈 등록 시스템 개선**: `src/lib/web-mcp/mcp-worker.ts` 파일의 서버 로딩 로직을 리팩터링했습니다. 중앙화된 `MODULE_REGISTRY`를 도입하여 모듈의 키와 import 경로를 명시적으로 관리하도록 변경했습니다. 이를 통해 `loadServers` 함수가 레지스트리를 기반으로 동적으로 모듈을 로드하고, `getServerRegistry`가 일관된 서버 목록을 제공하도록 개선하여 유지보수성을 높였습니다.

### 테스트 케이스

리팩터링된 코드의 안정성을 검증하기 위해 다음 테스트 케이스를 수행했습니다.

#### TC 1: 서버 이름 일관성 확인

-   **목표**: `content-store` 서버가 올바른 이름으로 로드되고 식별되는지 확인합니다.
-   **절차**:
    1.  애플리케이션을 시작합니다.
    2.  개발자 도구를 사용하여 Web Worker와의 통신을 모니터링합니다.
    3.  `loadServer` 명령으로 `content-store`를 요청합니다.
-   **예상 결과**: 서버가 성공적으로 로드되며, 응답으로 받은 서버 정보의 `name` 속성이 `'content-store'`로 올바르게 반환됩니다.

#### TC 2: 모듈 등록 및 로딩 확인

-   **목표**: 새로운 `MODULE_REGISTRY`가 등록된 모든 모듈을 정상적으로 로드하는지 확인합니다.
-   **절차**:
    1.  `src/lib/web-mcp/mcp-worker.ts`의 `MODULE_REGISTRY`에 테스트용 더미 모듈을 임시로 추가합니다.
    2.  애플리케이션을 다시 시작하고 Worker의 콘솔 로그를 확인합니다.
    3.  `loadServer` 명령으로 더미 모듈을 로드합니다.
-   **예상 결과**: 다른 코드 수정 없이도 더미 모듈이 자동으로 로드되며, `loadServer`를 통해 성공적으로 접근할 수 있습니다.

#### TC 3: 전체 빌드 및 린트 검사

-   **목표**: 코드 변경으로 인해 빌드 또는 린트 오류가 발생하지 않았는지 확인합니다.
-   **절차**:
    1.  `pnpm lint` 명령을 실행합니다.
    2.  `pnpm tauri build` 명령을 실행합니다.
-   **예상 결과**: 두 명령 모두 오류 없이 성공적으로 완료됩니다. (실제로 `lint`에서 경고가 나왔지만, 기존에 있던 경고이며 리팩터링으로 인한 새로운 오류는 없었습니다.)