# Refactoring Plan — Dual MCP Response Contract (text + structured)

## 작업의 목적

- MCP 응답을 “사람/LLM 친화적 텍스트(content)”와 “내부 빌트인용 구조화 데이터(structuredContent)”로 동시에 제공하고, 클라이언트 프록시가 이를 일관적으로 해석하도록 개선한다.
- content-store와 planning-server 양쪽 스타일(구조화/텍스트)을 모두 안전히 지원하며, 타입을 통해 내부 로직의 안정성을 높인다.

## 현재의 상태 / 문제점

- content-store 서버는 `createMCPStructuredResponse`로 `result.structuredContent`에 핵심 데이터를 반환. planning-server는 `createMCPTextResponse`로 텍스트만 반환.
- 과거 `WebMCPContext` 프록시가 `result.content[0].text`만 파싱할 때 `structuredContent`가 무시되어 `storeId` 등 핵심 필드가 누락되는 이슈가 있었음(첨부 후 팝오버 미표시 등).
- 현재 프록시는 `structuredContent` 우선 → 텍스트(JSON try) → result 폴백 순으로 수정되었으나, “응답 계약”이 문서/주석/타입으로 고정되어 있지 않아 회귀 위험 존재.
- “텍스트와 데이터 둘 다”가 필요한 호출자는 별도 파싱/분기를 직접 구현해야 하는 불편.

## 추가 분석 과제 (선택)

- Web MCP 외 다른 MCP 모듈(브라우저 도구 등)의 `structuredContent` 활용 여부 조사 및 API 표준화 확장 범위 정의.
- mcp-worker에서 전달되는 MCPResponse의 일관성(에러/결과 경계, content 배열 보장 등) 점검.
- AI 전처리(`prepareMessagesForLLM`)와 첨부 메타데이터 결합 시 대형 입력에서의 성능/토큰 비용 파악.

## 변경 이후의 상태 / 해결 판정 기준

- 모든 MCP 서버는 텍스트 요약은 `result.content`로, 정형 데이터는 `result.structuredContent`로 제공.
- `WebMCPContext` 동적 프록시는 다음 우선순위로 반환:
  1. `structuredContent`가 있으면 그대로 반환
  2. 없으면 `content[0].text`를 JSON.parse 시도 후 실패 시 문자열 반환
  3. 그 외에는 `result` 객체 자체 반환
- “둘 다”가 필요한 호출자는 도우미/옵션을 통해 `ToolResult<T> = { text?: string; data?: T; raw: { content?: Array<{ type: string; text?: string }>; structuredContent?: unknown } }` 형태로 수신 가능.
- 해결 판정:
  - content-store: `createStore` 호출로 유효한 `storeId` 수신 및 세션 반영(첨부 후 Header 팝오버 노출).
  - `addContent` 이후 SWR `sessionFiles` 갱신 및 팝오버 카운트/내용 증가.
  - planning-server 텍스트 응답 기존 동작 유지.
  - 단위/통합 테스트 통과 및 회귀 없음.

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1) `src/context/WebMCPContext.tsx` — 응답 파싱 규약 고정 (적용됨)

동적 툴 메서드에서 MCPResponse 처리 시 `structuredContent` 우선.

```ts
if (mcpResponse && typeof mcpResponse === 'object' && 'result' in mcpResponse) {
  const result = (
    mcpResponse as {
      result?: {
        content?: Array<{ type: string; text?: string }>;
        structuredContent?: unknown;
      };
    }
  ).result;

  if (
    result &&
    'structuredContent' in result &&
    result.structuredContent !== undefined
  ) {
    return result.structuredContent;
  }
  if (result?.content?.[0]?.type === 'text' && result.content[0].text) {
    try {
      return JSON.parse(result.content[0].text);
    } catch {
      return result.content[0].text;
    }
  }
  return result;
}
```

### 2) `src/hooks/use-web-mcp-server.ts` — JSDoc로 계약 고지 (적용됨)

훅 사용자가 반환 규약을 이해할 수 있도록 주석 보강.

### 3) 선택: “둘 다” 반환용 도우미 추가

- 위치 후보: `src/lib/web-mcp/tool-result.ts` (새 파일)
- 제안 타입/헬퍼:

```ts
export interface MCPResultEnvelope {
  content?: Array<{ type: string; text?: string }>;
  structuredContent?: unknown;
}
export interface ToolResult<T> {
  text?: string;
  data?: T;
  raw: MCPResultEnvelope;
}

export function toToolResult<T>(mcpResponse: unknown): ToolResult<T> {
  const result = (mcpResponse as { result?: MCPResultEnvelope }).result ?? {};
  const data = (result as { structuredContent?: unknown }).structuredContent as
    | T
    | undefined;
  const text =
    Array.isArray(result.content) && result.content[0]?.type === 'text'
      ? result.content[0].text
      : undefined;
  return { text, data, raw: result };
}
```

사용 예:

```ts
// 필요 시: const res = await proxy.callTool(...); const both = toToolResult<AddContentOutput>(res);
```

### 4) 문서화 (적용됨)

- `src/lib/web-mcp/README.md`에 “MCP Response Contract(중요)” 섹션 추가 및 예시 보강.

## 재사용 가능한 연관 코드

- `src/context/WebMCPContext.tsx` — 동적 프록시 생성, 응답 파싱 규약의 기준 구현
- `src/hooks/use-web-mcp-server.ts` — 프록시 훅, JSDoc 고지
- `src/lib/web-mcp/mcp-proxy.ts` — 워커 통신, callTool 경로(도우미 적용 지점)
- `src/lib/mcp-response-utils.ts` — `createMCPStructuredResponse`, `createMCPTextResponse`
- 서버:
  - `src/lib/web-mcp/modules/content-store/server.ts` — 구조화 응답 사용
  - `src/lib/web-mcp/modules/planning-server.ts` — 텍스트 응답 사용
- 첨부 연계:
  - `src/context/ResourceAttachmentContext.tsx` — content-store 연동, ensureStoreExists/addContent/commitPendingFiles
  - `src/features/chat/components/SessionFilesPopover.tsx` — 세션 파일 표시

## Test Code 추가/수정 가이드

- 단위 테스트 (vitest)
  1. WebMCPContext 응답 파서
     - structuredContent만 있는 응답 → 그대로 반환
     - text만 있는 응답(JSON/비JSON) → JSON 또는 string 반환
     - 둘 다 있는 응답 → structuredContent 우선
  2. 도우미 `toToolResult`
     - text/data/raw 세 필드 매핑 검증
  3. content-store 서버 경계
     - createStore → storeId 존재
     - addContent → AddContentOutput 주요 필드 존재
- 통합 테스트
  - `ResourceAttachmentContext.commitPendingFiles` 경로에서 addContent Mock → SWR mutate 호출/`pendingFiles` 클리어/SessionFilesPopover 카운트 증가 확인
  - planning-server 텍스트 응답 유지 검증

## 해결 판정 기준 (체크리스트)

- [ ] content-store createStore/addContent 결과가 타입대로 수신되고 세션/파일 목록에 반영된다
- [ ] planning-server 도구 호출이 텍스트 응답으로 기존 동작을 유지한다
- [ ] “둘 다”가 필요한 호출자에서 ToolResult 헬퍼로 text+data 동시 획득 가능
- [ ] README/JSDoc에 응답 계약이 명시되어 신규/외부 모듈도 준수 가능
- [ ] 테스트(단위/통합)가 통과하고 회귀 없음

## 롤아웃/리스크 완화

- 기본 반환 규약은 기존 호출자 친화적(스마트 파싱)으로 유지 → 파괴적 변경 최소화
- “둘 다”는 선택 도입. 점진적으로 필요 지점에만 적용
- 문서/주석/테스트로 계약 고정 → 향후 회귀 방지
