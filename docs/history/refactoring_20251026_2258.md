# SQLite 통합 및 Repository 패턴 적용 리팩토링

**작성일**: 2025-10-26 22:58  
**대상**: SQLite 의존성 중앙화 및 데이터 레이어 재구조화  
**예상 기간**: 5주

---

## 1. 작업의 목적

### 1.1 핵심 목표

현재 프로젝트 전반에 분산되어 있는 SQLite 관련 코드를 중앙화하고, Repository 패턴을 도입하여 데이터 계층을 명확히 분리한다.

### 1.2 달성하고자 하는 것

- **중앙화된 데이터베이스 관리**: 모든 SQL 쿼리와 스키마를 한 곳에서 관리
- **마이그레이션 시스템**: 스키마 버전 관리 및 자동 마이그레이션
- **재사용 가능한 Repository**: 여러 command에서 공통으로 사용할 수 있는 데이터 접근 계층
- **테스트 용이성**: Repository를 Mock으로 대체 가능한 구조
- **트랜잭션 지원**: 복잡한 데이터 변경 작업에 대한 원자성 보장
- **MCP 활성화 지원**: 향후 MCP Server 활성화 기능 추가를 위한 확장성

---

## 2. 현재의 상태 / 문제점

### 2.1 SQLite 의존성 분포 현황

```text
현재 SQLite를 사용하는 모듈:
├── src-tauri/src/lib.rs                          # Pool 초기화
├── src-tauri/src/state.rs                        # Global pool 저장
├── src-tauri/src/commands/
│   ├── messages_commands.rs                      # messages, message_index_meta 테이블
│   ├── content_store_commands.rs                 # DELETE 쿼리
│   └── session_commands.rs                       # DELETE 쿼리
└── src-tauri/src/mcp/builtin/content_store/
    └── storage.rs                                # stores, contents, chunks 테이블
```

### 2.2 구체적 문제점

#### 문제 1: SQL 쿼리 분산

- `messages_commands.rs`: 10+ 함수에 SQL embedded
- `content_store/storage.rs`: 15+ 메서드에 SQL embedded
- 스키마 변경 시 여러 파일 수정 필요

#### 문제 2: 마이그레이션 부재

- 각 모듈에서 `CREATE TABLE IF NOT EXISTS` 직접 실행
- 스키마 버전 관리 불가
- 데이터베이스 업그레이드 전략 없음

#### 문제 3: 트랜잭션 관리 어려움

- Content + Chunks 저장 시 원자성 보장 어려움
- 여러 테이블 간 일관성 유지 복잡

#### 문제 4: 테스트 어려움

- SQL 로직이 command에 직접 embedded
- Mock/Stub 적용 불가
- 통합 테스트만 가능

#### 문제 5: 코드 중복

- CRUD 패턴이 여러 곳에 반복
- 에러 처리 로직 중복
- Pool 접근 방식 일관성 부족

---

## 3. 관련 코드의 구조 및 동작 방식 Summary

### 3.1 현재 데이터 흐름 (Bird's Eye View)

```
Frontend (TypeScript)
    ↓ Tauri Command
Commands Layer
├─ messages_commands.rs
│  ├─ pub mod db { ... }        # SQL 직접 작성
│  ├─ get_sqlite_pool()         # Global pool 접근
│  └─ sqlx::query(...)          # 쿼리 실행
│
├─ content_store_commands.rs
│  └─ sqlx::query("DELETE...")  # 직접 쿼리
│
└─ session_commands.rs
   └─ sqlx::query("DELETE...")  # 직접 쿼리
    ↓
Built-in MCP Server
└─ content_store/storage.rs
   ├─ ContentStoreStorage
   ├─ create_tables(&pool)      # SQL embedded
   ├─ add_content(&mut self)    # SQL embedded
   └─ list_content(&self)       # SQL embedded
    ↓
Global State (state.rs)
├─ SQLITE_POOL: OnceLock
└─ get_sqlite_pool()
    ↓
SQLite Database
├─ messages
├─ message_index_meta
├─ stores
├─ contents
└─ chunks
```

### 3.2 주요 테이블 스키마

**messages 테이블** (messages_commands.rs):

- 세션별 메시지 저장
- 인덱스: session_id, created_at

**content_store 테이블들** (storage.rs):

- stores: 1:1 with session
- contents: 파일 컨텐츠
- chunks: 컨텐츠 청크 (1:N)

### 3.3 문제가 되는 코드 패턴

```rust
// 패턴 1: SQL embedded in command
pub mod db {
    pub async fn list_messages(pool: &SqlitePool, ...) {
        sqlx::query("SELECT * FROM messages WHERE ...").execute(pool).await
    }
}

// 패턴 2: CREATE TABLE in runtime
async fn create_tables(pool: &SqlitePool) {
    sqlx::query("CREATE TABLE IF NOT EXISTS ...").execute(pool).await
}

// 패턴 3: 여러 테이블 수정 시 트랜잭션 부재
sqlx::query("DELETE FROM contents ...").execute(pool).await?;
sqlx::query("DELETE FROM stores ...").execute(pool).await?;  // 원자성 보장 안 됨
```

---

## 4. 변경 이후의 상태 / 해결 판정 기준

### 4.1 목표 아키텍처

```
Frontend (TypeScript)
    ↓ Tauri Command
Commands Layer (Application Logic)
├─ messages_commands.rs         # Repository 사용만
├─ content_store_commands.rs    # Repository 사용만
└─ session_commands.rs          # Repository 사용만
    ↓
Repository Layer (Data Access)
├─ MessageRepository
├─ ContentStoreRepository
└─ MCPActivationRepository
    ↓
Data Layer
├─ models/ (SQLx derive)
├─ migrations/ (SQL files)
└─ connection.rs
    ↓
SQLite Database
```

### 4.2 성공 판정 기준

#### 필수 조건 (Must Have)

- [ ] 모든 SQL 쿼리가 Repository 내부로 이동
- [ ] 마이그레이션 파일로 스키마 관리
- [ ] Commands는 Repository만 사용
- [ ] 기존 기능 100% 동작 (회귀 없음)
- [ ] 트랜잭션 지원 (content + chunks)

#### 권장 조건 (Should Have)

- [ ] 단위 테스트 커버리지 > 80%
- [ ] Repository 통합 테스트
- [ ] 에러 처리 통합 (DbError)
- [ ] 성능 저하 없음 (벤치마크)

#### 선택 조건 (Nice to Have)

- [ ] Migration rollback 지원
- [ ] Connection pooling 최적화
- [ ] 쿼리 로깅 및 모니터링

---

## 5. 수정이 필요한 코드 및 수정 부분

### 5.1 신규 생성 파일

#### 파일: `src-tauri/src/db/mod.rs`

```rust
pub mod connection;
pub mod error;
pub mod models;
pub mod repositories;

pub use connection::{get_pool, create_pool};
pub use error::DbError;
pub use repositories::{MessageRepository, ContentStoreRepository};

/// Initialize database and run migrations
pub async fn init(pool: &sqlx::SqlitePool) -> Result<(), DbError> {
    sqlx::migrate!("./migrations")
        .run(pool)
        .await
        .map_err(|e| DbError::Migration(e.to_string()))?;
    Ok(())
}
```

#### 파일: `src-tauri/src/db/error.rs`

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DbError {
    #[error("Database query failed: {0}")]
    Query(#[from] sqlx::Error),

    #[error("Migration failed: {0}")]
    Migration(String),

    #[error("Record not found: {0}")]
    NotFound(String),
}

impl From<DbError> for String {
    fn from(err: DbError) -> String {
        err.to_string()
    }
}
```

#### 파일: `src-tauri/src/db/models/message.rs`

```rust
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Message {
    pub id: String,
    pub session_id: String,
    pub role: String,
    pub content: String,
    // ... 나머지 필드
    pub created_at: i64,
    pub updated_at: i64,
}
```

#### 파일: `src-tauri/src/db/repositories/message_repository.rs`

```rust
use crate::db::{error::DbError, models::Message};
use sqlx::SqlitePool;

pub struct MessageRepository {
    pool: SqlitePool,
}

impl MessageRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }

    pub async fn list_by_session(
        &self,
        session_id: &str,
        page: usize,
        page_size: usize,
    ) -> Result<Vec<Message>, DbError> {
        // SQL 쿼리 구현
    }

    pub async fn upsert(&self, message: &Message) -> Result<(), DbError> {
        // Upsert 로직
    }

    // ... 기타 메서드
}
```

### 5.2 수정 필요 파일

#### 파일: `src-tauri/src/lib.rs`

**변경 전**:

```rust
// line 72-100
let pool = match sqlx::sqlite::SqlitePool::connect(&db_url).await {
    Ok(p) => p,
    Err(e) => { /* error handling */ }
};
state::set_sqlite_pool(pool.clone());
```

**변경 후**:

```rust
let pool = db::connection::create_pool(&db_url).await?;
db::init(&pool).await?;  // ← 마이그레이션 실행
state::set_sqlite_pool(pool.clone());
```

#### 파일: `src-tauri/src/commands/messages_commands.rs`

**변경 전** (line 54-100):

```rust
pub mod db {
    use sqlx::{Row, SqlitePool};

    pub async fn create_messages_table(pool: &SqlitePool) -> Result<(), String> {
        sqlx::query("CREATE TABLE IF NOT EXISTS messages ...").execute(pool).await
    }

    pub async fn list_messages(pool: &SqlitePool, ...) -> Result<...> {
        sqlx::query("SELECT * FROM messages ...").fetch_all(pool).await
    }
}
```

**변경 후**:

```rust
use crate::db::{MessageRepository, get_pool};

#[tauri::command]
pub async fn list_messages(
    session_id: String,
    page: usize,
    page_size: usize,
) -> Result<Vec<Message>, String> {
    let repo = MessageRepository::new(get_pool().clone());
    repo.list_by_session(&session_id, page, page_size)
        .await
        .map_err(|e| e.to_string())
}

// db 모듈 전체 제거
```

#### 파일: `src-tauri/src/mcp/builtin/content_store/storage.rs`

**변경 전** (line 48-100):

```rust
pub struct ContentStoreStorage {
    stores: HashMap<String, ContentStore>,
    contents: HashMap<String, ContentItem>,
    chunks: HashMap<String, Vec<ContentChunk>>,
    sqlite_pool: Option<SqlitePool>,  // ← 제거
}

async fn create_tables(pool: &SqlitePool) { /* SQL */ }
pub async fn add_content(&mut self, ...) { /* SQL */ }
```

**변경 후**:

```rust
pub struct ContentStoreStorage {
    stores: HashMap<String, ContentStore>,
    contents: HashMap<String, ContentItem>,
    chunks: HashMap<String, Vec<ContentChunk>>,
    // sqlite_pool 제거 - Repository로 분리
}

// SQL 관련 메서드 모두 제거
// In-memory 조작만 남김
```

#### 파일: `src-tauri/src/mcp/builtin/content_store/server.rs`

**변경 전** (line 10-45):

```rust
pub struct ContentStoreServer {
    session_manager: Arc<SessionManager>,
    storage: Mutex<storage::ContentStoreStorage>,
    search_engine: Arc<Mutex<search::ContentSearchEngine>>,
}

pub async fn new_with_sqlite(...) -> Result<Self, String> {
    let storage = storage::ContentStoreStorage::new_sqlite(database_url).await?;
    // ...
}
```

**변경 후**:

```rust
use crate::db::ContentStoreRepository;

pub struct ContentStoreServer {
    session_manager: Arc<SessionManager>,
    storage: Mutex<storage::ContentStoreStorage>,  // In-memory only
    repository: Arc<ContentStoreRepository>,        // ← 추가
    search_engine: Arc<Mutex<search::ContentSearchEngine>>,
}

pub fn new(session_manager: Arc<SessionManager>) -> Self {
    let repo = ContentStoreRepository::new(crate::db::get_pool().clone());
    // ...
}
```

### 5.3 마이그레이션 파일

#### 파일: `src-tauri/migrations/001_create_messages_table.sql`

```sql
-- Messages table
CREATE TABLE IF NOT EXISTS messages (
    id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL CHECK(session_id <> ''),
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    -- ... 나머지 컬럼
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_messages_session_created
ON messages(session_id, created_at);

-- Message index metadata
CREATE TABLE IF NOT EXISTS message_index_meta (
    session_id TEXT PRIMARY KEY,
    index_path TEXT,
    last_indexed_at INTEGER DEFAULT 0
);
```

#### 파일: `src-tauri/migrations/002_create_content_store_tables.sql`

```sql
CREATE TABLE IF NOT EXISTS stores (
    session_id TEXT PRIMARY KEY,
    name TEXT,
    description TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS contents (
    id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    filename TEXT NOT NULL,
    -- ... 나머지 컬럼
    FOREIGN KEY (session_id) REFERENCES stores(session_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS chunks (
    id TEXT PRIMARY KEY,
    content_id TEXT NOT NULL,
    chunk_index INTEGER NOT NULL,
    text TEXT NOT NULL,
    start_line INTEGER NOT NULL,
    end_line INTEGER NOT NULL,
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_chunks_content_id ON chunks(content_id);
CREATE INDEX IF NOT EXISTS idx_contents_session_id ON contents(session_id);
```

---

## 6. 재사용 가능한 연관 코드

### 6.1 참고할 기존 코드

#### 파일: `src-tauri/src/state.rs`

- **주요 기능**: Global SQLite pool 관리
- **재사용**: `get_sqlite_pool()` 함수 패턴
- **인터페이스**: `pub fn get_sqlite_pool() -> &'static SqlitePool`

#### 파일: `src-tauri/src/commands/messages_commands.rs` (line 54-291)

- **주요 기능**: Messages CRUD 로직
- **재사용**: 쿼리 로직을 Repository로 이동
- **인터페이스**:
  - `list_messages()` → `MessageRepository::list_by_session()`
  - `upsert_message()` → `MessageRepository::upsert()`
  - `delete_message()` → `MessageRepository::delete()`

#### 파일: `src-tauri/src/mcp/builtin/content_store/storage.rs` (line 145-450)

- **주요 기능**: Content store CRUD
- **재사용**: 쿼리 로직을 Repository로 이동
- **인터페이스**:
  - `create_store()` → `ContentStoreRepository::get_or_create_store()`
  - `add_content()` → `ContentStoreRepository::add_content_with_chunks()`
  - `list_content()` → `ContentStoreRepository::list_content()`

### 6.2 새로 만들 공통 패턴

#### Repository 기본 패턴

```rust
pub struct XxxRepository {
    pool: SqlitePool,
}

impl XxxRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }

    // CRUD methods
    pub async fn create(&self, item: &Xxx) -> Result<(), DbError> { }
    pub async fn get(&self, id: &str) -> Result<Xxx, DbError> { }
    pub async fn update(&self, item: &Xxx) -> Result<(), DbError> { }
    pub async fn delete(&self, id: &str) -> Result<(), DbError> { }
}
```

#### Transaction 패턴

```rust
pub async fn add_content_with_chunks(
    &self,
    item: &ContentItem,
    chunks: &[ContentChunk],
) -> Result<(), DbError> {
    let mut tx = self.pool.begin().await?;

    // Insert content
    sqlx::query("INSERT INTO contents ...").execute(&mut *tx).await?;

    // Insert chunks
    for chunk in chunks {
        sqlx::query("INSERT INTO chunks ...").execute(&mut *tx).await?;
    }

    tx.commit().await?;
    Ok(())
}
```

---

## 7. Test Code 추가 및 수정 가이드

### 7.1 단위 테스트 (Repository)

#### 파일: `src-tauri/tests/db/message_repository_test.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_test_db() -> SqlitePool {
        let pool = SqlitePool::connect(":memory:").await.unwrap();
        db::init(&pool).await.unwrap();
        pool
    }

    #[tokio::test]
    async fn test_create_and_get_message() {
        let pool = setup_test_db().await;
        let repo = MessageRepository::new(pool);

        let message = Message {
            id: "msg_1".to_string(),
            session_id: "session_1".to_string(),
            role: "user".to_string(),
            content: "Hello".to_string(),
            created_at: 1000,
            updated_at: 1000,
        };

        // Create
        repo.upsert(&message).await.unwrap();

        // Get
        let messages = repo.list_by_session("session_1", 1, 10).await.unwrap();
        assert_eq!(messages.len(), 1);
        assert_eq!(messages[0].content, "Hello");
    }

    #[tokio::test]
    async fn test_transaction_rollback() {
        // 트랜잭션 실패 시 롤백 검증
    }
}
```

### 7.2 통합 테스트 (Command)

#### 파일: `src-tauri/tests/commands/messages_commands_test.rs`

```rust
#[tokio::test]
async fn test_list_messages_command() {
    // Given: 테스트 DB 및 데이터 준비
    let pool = setup_test_db().await;
    let repo = MessageRepository::new(pool.clone());

    // Insert test data
    repo.upsert(&test_message()).await.unwrap();

    // When: Command 호출
    let result = list_messages("session_1".to_string(), 1, 10).await;

    // Then: 결과 검증
    assert!(result.is_ok());
    let messages = result.unwrap();
    assert_eq!(messages.len(), 1);
}
```

### 7.3 테스트 체크리스트

- [ ] MessageRepository 단위 테스트
  - [ ] CRUD 기본 동작
  - [ ] Pagination
  - [ ] Error handling
- [ ] ContentStoreRepository 단위 테스트
  - [ ] Content + Chunks 트랜잭션
  - [ ] Cascade delete 검증
  - [ ] Error handling

- [ ] Command 통합 테스트
  - [ ] 기존 기능 회귀 테스트
  - [ ] Repository 통합 검증

- [ ] Migration 테스트
  - [ ] 스키마 생성 검증
  - [ ] Index 생성 확인

---

## 8. 작업 단계별 가이드

### Phase 1: 기반 구조 생성 (Week 1)

**목표**: 새로운 db/ 디렉토리 구조 생성

```
작업:
1. db/ 디렉토리 및 하위 구조 생성
2. error.rs, connection.rs 작성
3. models/ 하위 파일 생성 (message.rs, content_store.rs)
4. migrations/ 디렉토리 및 SQL 파일 작성

검증:
- 컴파일 성공
- 마이그레이션 실행 성공 (in-memory DB)
```

### Phase 2: Repository 구현 (Week 2)

**목표**: MessageRepository, ContentStoreRepository 구현

```
작업:
1. MessageRepository 구현 및 단위 테스트
2. ContentStoreRepository 구현 및 단위 테스트
3. Transaction 로직 구현 및 검증

검증:
- 모든 단위 테스트 통과
- 기존 DB 스키마와 호환성 확인
```

### Phase 3: Command 마이그레이션 (Week 3)

**목표**: Commands를 Repository 사용으로 변경

```
작업:
1. messages_commands.rs 리팩토링
   - db 모듈 제거
   - Repository 사용으로 변경
2. content_store_commands.rs 리팩토링
3. 통합 테스트 작성 및 실행

검증:
- 기존 기능 100% 동작
- 통합 테스트 통과
```

### Phase 4: ContentStoreServer 리팩토링 (Week 4)

**목표**: storage.rs 간소화 및 Repository 통합

```
작업:
1. storage.rs에서 SQLite 관련 코드 제거
2. ContentStoreServer에 Repository 주입
3. Handler 로직 Repository 사용으로 변경

검증:
- Content Store MCP 서버 정상 동작
- 기존 기능 회귀 없음
```

### Phase 5: 최종 검증 및 문서화 (Week 5)

**목표**: 성능 검증 및 문서 정리

```
작업:
1. 성능 벤치마크
2. 코드 리뷰 및 리팩토링
3. 문서 업데이트
4. MCP Activation 준비 (선택)

검증:
- 성능 저하 없음
- 모든 테스트 통과
- 문서 완성
```

---

## 9. 추가 분석 과제

### 9.1 성능 영향 분석

**현재 불명확한 부분**:

- Repository 레이어 추가로 인한 성능 오버헤드
- Connection pooling 최적화 필요성

**분석 방향**:

- 기존 코드와 새 코드 벤치마크 비교
- Pool 크기 및 timeout 최적화
- 쿼리 실행 계획 분석 (EXPLAIN)

### 9.2 마이그레이션 전략

**현재 불명확한 부분**:

- 기존 DB에서 새 스키마로 전환 방법
- Down migration 필요성

**분석 방향**:

- 기존 사용자 DB 스키마 조사
- 마이그레이션 롤백 시나리오 정의
- 데이터 손실 방지 전략

### 9.3 트랜잭션 범위

**현재 불명확한 부분**:

- 어떤 작업에 트랜잭션이 필요한가
- Command 레벨 vs Repository 레벨 트랜잭션

**분석 방향**:

- 데이터 일관성이 중요한 작업 식별
- 트랜잭션 격리 수준 결정
- 성능 vs 일관성 트레이드오프 분석

---

## 10. 리스크 및 대응 방안

### 리스크 1: 기존 기능 회귀

- **위험도**: 높음
- **대응**: 통합 테스트 100% 커버리지, 단계적 배포

### 리스크 2: 성능 저하

- **위험도**: 중간
- **대응**: 벤치마크 수행, 필요 시 캐싱 추가

### 리스크 3: 마이그레이션 실패

- **위험도**: 중간
- **대응**: 백업 전략, 롤백 메커니즘

---

## 11. 참고 문서

- `docs/SQLITE_INTEGRATION_DESIGN.md` - 상세 설계
- `docs/CONTENT_STORE_STRUCTURE_ANALYSIS.md` - Content Store 분석
- `docs/SQLITE_SCHEMA_FOR_MCP_ACTIVATION.md` - MCP 활성화 스키마
- SQLx 문서: <https://github.com/launchbadge/sqlx>
- Repository 패턴: <https://martinfowler.com/eaaCatalog/repository.html>
