# MCP Sampling 지원 리팩토링 계획

## 작업의 목적

SynapticFlow에 MCP (Model Context Protocol) sampling 기능을 추가하여 AI 에이전트가 MCP 서버를 통해 직접 언어 모델에서 텍스트를 생성할 수 있도록 하는 것입니다. 이를 통해 더 풍부한 AI 상호작용과 컨텍스트 기반 텍스트 생성이 가능해집니다.

## 현재의 상태 / 문제점

### 현재 상태

- MCP 시스템은 tool calling만 지원 (서버에서 도구 실행)
- AI 서비스는 streamChat만 제공하며 sampling API 미지원
- MCP 서버가 자체적으로 언어 모델 호출 불가능
- sampling 관련 타입 정의 및 인터페이스 부재

### 문제점

1. **기능 제한**: MCP 서버가 LLM과 직접 상호작용할 수 없음
2. **프로토콜 불완전**: MCP 표준의 sampling 기능 미구현
3. **확장성 부족**: 새로운 AI 기능 추가 시 제약

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

- MCP 서버에서 sampling 요청을 통해 LLM 호출 가능
- 통합된 sampling API로 일관된 인터페이스 제공
- Web Worker MCP와 External MCP 모두에서 sampling 지원
- AI 서비스별 sampling 구현 완료

### 해결 판정 기준

1. ✅ MCP 서버에서 `sample_from_model` 도구 호출 성공
2. ✅ Tauri 백엔드에서 sampling 명령 처리 완료
3. ✅ 모든 AI 서비스에서 sampling API 구현 완료
4. ✅ Web Worker MCP에서 sampling 지원 확인
5. ✅ 통합 테스트: 에이전트가 MCP를 통해 텍스트 생성 성공

## 수정이 필요한 코드 및 수정부분

### 1. MCP 타입 정의 확장 (`src/lib/mcp-types.ts`)

**현재 코드:**
```typescript
export interface MCPResponse {
  jsonrpc: '2.0';
  id: string | number | null;
  result?: MCPResult;
  error?: MCPError;
}

export interface MCPResult {
  content?: MCPContent[];
  structuredContent?: Record<string, unknown>;
  isError?: boolean;
}
```

**수정 후 코드:**
```typescript
// Sampling 관련 타입 추가
export interface SamplingOptions {
  model?: string;
  maxTokens?: number;
  temperature?: number;
  topP?: number;
  topK?: number;
  stopSequences?: string[];
  presencePenalty?: number;
  frequencyPenalty?: number;
}

export interface SamplingRequest {
  prompt: string;
  options?: SamplingOptions;
}

export interface SamplingResult extends MCPResult {
  sampling?: {
    finishReason?: 'stop' | 'length' | 'tool_use' | 'error';
    usage?: {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
    };
    model?: string;
  };
}

export interface SamplingResponse extends MCPResponse {
  result?: SamplingResult;
}

export interface MCPResponse {
  jsonrpc: '2.0';
  id: string | number | null;
  result?: MCPResult | SamplingResult;
  error?: MCPError;
}

export interface MCPResult {
  content?: MCPContent[];
  structuredContent?: Record<string, unknown>;
  isError?: boolean;
}
```

### 2. AI Service 인터페이스 확장 (`src/lib/ai-service/types.ts`)

**현재 코드:**
```typescript
export interface IAIService {
  streamChat(
    messages: Message[],
    options?: {
      modelName?: string;
      systemPrompt?: string;
      availableTools?: MCPTool[];
      config?: AIServiceConfig;
    },
  ): AsyncGenerator<string, void, void>;

  listModels(): Promise<ModelInfo[]>;
  dispose(): void;
}
```

**수정 후 코드:**
```typescript
export interface IAIService {
  streamChat(
    messages: Message[],
    options?: {
      modelName?: string;
      systemPrompt?: string;
      availableTools?: MCPTool[];
      config?: AIServiceConfig;
    },
  ): AsyncGenerator<string, void, void>;

  /**
   * MCP sampling API - 단일 프롬프트에서 텍스트 생성
   */
  sampleText(
    prompt: string,
    options?: {
      modelName?: string;
      samplingOptions?: SamplingOptions;
      config?: AIServiceConfig;
    },
  ): Promise<SamplingResponse>;

  listModels(): Promise<ModelInfo[]>;
  dispose(): void;
}
```

### 3. Rust MCP 서버 매니저 확장 (`src-tauri/src/mcp.rs`)

**현재 코드:**
```rust
impl MCPServerManager {
    /// 도구를 호출합니다
    pub async fn call_tool(
        &self,
        server_name: &str,
        tool_name: &str,
        arguments: serde_json::Value,
    ) -> MCPResponse {
        // ... 기존 구현
    }
}
```

**수정 후 코드:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SamplingOptions {
    pub model: Option<String>,
    pub max_tokens: Option<u32>,
    pub temperature: Option<f64>,
    pub top_p: Option<f64>,
    pub top_k: Option<u32>,
    pub stop_sequences: Option<Vec<String>>,
    pub presence_penalty: Option<f64>,
    pub frequency_penalty: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SamplingRequest {
    pub prompt: String,
    pub options: Option<SamplingOptions>,
}

impl MCPServerManager {
    /// 도구를 호출합니다
    pub async fn call_tool(
        &self,
        server_name: &str,
        tool_name: &str,
        arguments: serde_json::Value,
    ) -> MCPResponse {
        // ... 기존 구현
    }

    /// MCP 서버에서 sampling을 수행합니다
    pub async fn sample_from_model(
        &self,
        server_name: &str,
        request: SamplingRequest,
    ) -> MCPResponse {
        let connections = self.connections.lock().await;
        let request_id = serde_json::Value::String(Uuid::new_v4().to_string());

        if let Some(connection) = connections.get(server_name) {
            // RMCP에서 sampling 지원 여부 확인 후 구현
            // 현재는 임시로 에러 반환
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32601,
                    message: "Sampling not yet implemented in RMCP".to_string(),
                    data: Some(serde_json::json!({
                        "server_name": server_name,
                        "request": request
                    })),
                }),
            }
        } else {
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32002,
                    message: format!("Server '{}' not found", server_name),
                    data: None,
                }),
            }
        }
    }
}
```

### 4. Tauri 명령 추가 (`src-tauri/src/lib.rs`)

**현재 코드:**
```rust
#[tauri::command]
async fn call_mcp_tool(
    server_name: String,
    tool_name: String,
    arguments: serde_json::Value,
) -> MCPResponse {
    get_mcp_manager()
        .call_tool(&server_name, &tool_name, arguments)
        .await
}
```

**수정 후 코드:**
```rust
#[tauri::command]
async fn call_mcp_tool(
    server_name: String,
    tool_name: String,
    arguments: serde_json::Value,
) -> MCPResponse {
    get_mcp_manager()
        .call_tool(&server_name, &tool_name, arguments)
        .await
}

#[tauri::command]
async fn sample_from_mcp_server(
    server_name: String,
    prompt: String,
    options: Option<serde_json::Value>,
) -> Result<MCPResponse, String> {
    let sampling_options = if let Some(opts) = options {
        serde_json::from_value::<mcp::SamplingOptions>(opts)
            .map_err(|e| format!("Invalid sampling options: {}", e))?
    } else {
        None
    };

    let request = mcp::SamplingRequest {
        prompt,
        options: sampling_options,
    };

    Ok(get_mcp_manager()
        .sample_from_model(&server_name, request)
        .await)
}
```

### 5. Tauri MCP 클라이언트 확장 (`src/lib/tauri-mcp-client.ts`)

**현재 코드:**
```typescript
export class TauriMCPClient {
  async callTool(
    serverName: string,
    toolName: string,
    arguments_: Record<string, unknown>,
  ): Promise<MCPResponse> {
    try {
      logger.debug('Calling MCP tool', { serverName, toolName, arguments_ });
      const result = (await invoke('call_mcp_tool', {
        serverName,
        toolName,
        arguments: arguments_,
      })) as MCPResponse;
      logger.debug('MCP tool call completed', { result });
      return result;
    } catch (error) {
      logger.error('Failed to call MCP tool', error);
      throw error;
    }
  }
}
```

**수정 후 코드:**
```typescript
export class TauriMCPClient {
  async callTool(
    serverName: string,
    toolName: string,
    arguments_: Record<string, unknown>,
  ): Promise<MCPResponse> {
    try {
      logger.debug('Calling MCP tool', { serverName, toolName, arguments_ });
      const result = (await invoke('call_mcp_tool', {
        serverName,
        toolName,
        arguments: arguments_,
      })) as MCPResponse;
      logger.debug('MCP tool call completed', { result });
      return result;
    } catch (error) {
      logger.error('Failed to call MCP tool', error);
      throw error;
    }
  }

  /**
   * MCP 서버에서 sampling을 수행합니다
   */
  async sampleFromModel(
    serverName: string,
    prompt: string,
    options?: SamplingOptions,
  ): Promise<SamplingResponse> {
    try {
      logger.debug('Sampling from MCP server', { serverName, prompt, options });
      const result = (await invoke('sample_from_mcp_server', {
        serverName,
        prompt,
        options,
      })) as SamplingResponse;
      logger.debug('MCP sampling completed', { result });
      return result;
    } catch (error) {
      logger.error('Failed to sample from MCP server', error);
      throw error;
    }
  }
}
```

### 6. MCP Server Context 확장 (`src/context/MCPServerContext.tsx`)

**현재 코드:**
```tsx
export interface MCPServerContextType {
  availableTools: MCPTool[];
  getAvailableTools: () => MCPTool[];
  isLoading: boolean;
  error?: string;
  status: Record<string, boolean>;
  connectServers: (mcpConfigs: MCPConfig) => Promise<void>;
  executeToolCall: (toolCall: {
    id: string;
    type: 'function';
    function: { name: string; arguments: string };
  }) => Promise<MCPResponse>;
}
```

**수정 후 코드:**
```tsx
export interface MCPServerContextType {
  availableTools: MCPTool[];
  getAvailableTools: () => MCPTool[];
  isLoading: boolean;
  error?: string;
  status: Record<string, boolean>;
  connectServers: (mcpConfigs: MCPConfig) => Promise<void>;
  executeToolCall: (toolCall: {
    id: string;
    type: 'function';
    function: { name: string; arguments: string };
  }) => Promise<MCPResponse>;
  sampleFromModel: (
    serverName: string,
    prompt: string,
    options?: SamplingOptions,
  ) => Promise<SamplingResponse>;
}

export const MCPServerProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  // ... 기존 state 및 로직

  const sampleFromModel = useCallback(
    async (
      serverName: string,
      prompt: string,
      options?: SamplingOptions,
    ): Promise<SamplingResponse> => {
      logger.debug('Context: Sampling from model', { serverName, prompt, options });
      return tauriMCPClient.sampleFromModel(serverName, prompt, options);
    },
    [],
  );

  const value: MCPServerContextType = useMemo(
    () => ({
      availableTools,
      isLoading,
      error,
      getAvailableTools,
      status: serverStatus,
      connectServers,
      executeToolCall,
      sampleFromModel,
    }),
    [
      availableTools,
      isLoading,
      error,
      serverStatus,
      getAvailableTools,
      connectServers,
      executeToolCall,
      sampleFromModel,
    ],
  );

  return (
    <MCPServerContext.Provider value={value}>
      {children}
    </MCPServerContext.Provider>
  );
};
```

### 7. Web MCP 시스템 확장 (`src/lib/web-mcp/mcp-worker.ts`)

**현재 코드:**
```typescript
async function handleMCPMessage(
  message: WebMCPMessage,
): Promise<WebMCPResponse> {
  const { id, type, serverName, toolName, args } = message;

  try {
    switch (type) {
      case 'ping':
        return { id, result: 'pong' };
      case 'callTool':
        // ... 기존 도구 호출 로직
    }
  } catch (error) {
    // ... 에러 처리
  }
}
```

**수정 후 코드:**
```typescript
async function handleMCPMessage(
  message: WebMCPMessage,
): Promise<WebMCPResponse> {
  const { id, type, serverName, toolName, args } = message;

  try {
    switch (type) {
      case 'ping':
        return { id, result: 'pong' };
      case 'callTool':
        // ... 기존 도구 호출 로직
        break;
      case 'sampleText':
        if (!serverName) {
          throw new Error('Server name is required for sampleText');
        }
        const { prompt, options } = args as { prompt: string; options?: SamplingOptions };
        const server = await loadMCPServer(serverName);
        
        // Web MCP 서버에 sampling 메서드가 있는지 확인
        if ('sampleText' in server && typeof server.sampleText === 'function') {
          const result = await server.sampleText(prompt, options);
          return { id, result };
        } else {
          throw new Error(`Server ${serverName} does not support text sampling`);
        }
    }
  } catch (error) {
    // ... 에러 처리
  }
}
```

### 8. Web MCP 서버 인터페이스 확장 (`src/lib/mcp-types.ts`)

**현재 코드:**
```typescript
export interface WebMCPServer {
  name: string;
  description?: string;
  version?: string;
  tools: MCPTool[];
  callTool: (name: string, args: unknown) => Promise<unknown>;
}
```

**수정 후 코드:**
```typescript
export interface WebMCPServer {
  name: string;
  description?: string;
  version?: string;
  tools: MCPTool[];
  callTool: (name: string, args: unknown) => Promise<unknown>;
  sampleText?: (prompt: string, options?: SamplingOptions) => Promise<SamplingResponse>;
}

export interface WebMCPMessage {
  id: string;
  type: 'listTools' | 'callTool' | 'ping' | 'loadServer' | 'sampleText';
  serverName?: string;
  toolName?: string;
  args?: unknown;
}
```

## 구현 순서

1. **Phase 1: 타입 정의** (1일)
   - `mcp-types.ts`에 sampling 관련 타입 추가
   - `ai-service/types.ts`에 IAIService 인터페이스 확장

2. **Phase 2: Rust 백엔드** (2일)
   - `mcp.rs`에 sampling 구조체 및 메서드 추가
   - `lib.rs`에 Tauri 명령 추가

3. **Phase 3: TypeScript 클라이언트** (1일)
   - `tauri-mcp-client.ts`에 sampling API 추가
   - `MCPServerContext.tsx`에 context 함수 추가

4. **Phase 4: Web MCP 확장** (1일)
   - Web Worker MCP에 sampling 지원 추가
   - 기존 MCP 모듈들에 sampling 메서드 구현

5. **Phase 5: AI 서비스 통합** (2일)
   - 각 AI 서비스에 `sampleText` 메서드 구현
   - 통합 테스트 및 검증

6. **Phase 6: UI 통합** (1일)
   - Chat Context에 sampling 통합
   - 사용자 인터페이스 업데이트

## 예상 소요 시간
**총 8일** (단계별 1-2일씩)

## 리스크 및 대응 방안

1. **RMCP 라이브러리 sampling 미지원**
   - 대응: 직접 JSON-RPC 메시지 구현으로 우회

2. **AI 서비스별 API 차이**
   - 대응: 공통 인터페이스로 추상화

3. **성능 이슈**
   - 대응: 적절한 타임아웃 및 캐싱 전략 적용
