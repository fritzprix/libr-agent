# Refactoring Plan: Phase 1 - FilesystemServer와 SandboxServer 기본 도구 확장

## 작업의 목적

SynapticFlow의 Tauri MCP 내장 도구를 실용적으로 확장하여 AI 에이전트가 파일 시스템과 기본적인 쉘 명령을 효과적으로 사용할 수 있도록 개선합니다.

### 주요 목표

1. `read_file` 도구에 줄 범위 읽기 옵션 추가
2. `search_files` 도구 추가로 패턴 기반 파일 찾기 지원
3. `execute_shell` 도구 추가로 기본적인 쉘 명령 실행 지원

## 현재의 상태 / 문제점

### FilesystemServer 한계점

- `read_file`: 전체 파일만 읽기 가능, 대용량 파일 처리 비효율
- 파일 검색 기능 부재: 패턴이나 조건으로 파일을 찾을 수 없음
- `list_directory`: 단일 디렉터리만 나열, 재귀적 탐색 불가

### SandboxServer 한계점

- Python, TypeScript 실행만 지원
- 일반적인 쉘 명령 실행 불가 (ls, grep, find 등)
- 시스템 도구 활용 제한

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **read_file 확장**:
   - `start_line`, `end_line` 파라미터로 특정 줄 범위만 읽기 가능
   - 대용량 파일에서 필요한 부분만 효율적으로 추출

2. **search_files 추가**:
   - glob 패턴으로 파일 검색 (`*.rs`, `**/*.tsx` 등)
   - 재귀적 디렉터리 탐색 지원
   - 파일 타입, 크기 등 기본 필터링 옵션

3. **execute_shell 추가**:
   - 기본적인 쉘 명령 실행 (`ls`, `grep`, `find` 등)
   - 작업 디렉터리 지정 가능
   - 실행 시간 제한 및 에러 처리

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. FilesystemServer - read_file 도구 확장

**파일**: `src-tauri/src/mcp/builtin/filesystem.rs`

#### 현재 코드 (create_read_file_tool 함수):

```rust
fn create_read_file_tool() -> MCPTool {
    MCPTool {
        name: "read_file".to_string(),
        title: Some("Read File".to_string()),
        description: "Read the contents of a file".to_string(),
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert(
                        "path".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(1000),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Path to the file to read".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props
                }),
                required: Some(vec!["path".to_string()]),
                additional_properties: Some(false),
                min_properties: None,
                max_properties: None,
            },
            // ... 나머지 필드들
        },
        output_schema: None,
        annotations: None,
    }
}
```

#### 수정 후 코드:

```rust
fn create_read_file_tool() -> MCPTool {
    MCPTool {
        name: "read_file".to_string(),
        title: Some("Read File".to_string()),
        description: "Read the contents of a file, optionally specifying line ranges".to_string(),
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert(
                        "path".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(1000),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Path to the file to read".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "start_line".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::Integer {
                                minimum: Some(1),
                                maximum: None,
                                exclusive_minimum: None,
                                exclusive_maximum: None,
                                multiple_of: None,
                            },
                            title: None,
                            description: Some("Starting line number (1-based, optional)".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "end_line".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::Integer {
                                minimum: Some(1),
                                maximum: None,
                                exclusive_minimum: None,
                                exclusive_maximum: None,
                                multiple_of: None,
                            },
                            title: None,
                            description: Some("Ending line number (1-based, optional)".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props
                }),
                required: Some(vec!["path".to_string()]),
                additional_properties: Some(false),
                min_properties: None,
                max_properties: None,
            },
            // ... 나머지 필드들
        },
        output_schema: None,
        annotations: None,
    }
}
```

#### handle_read_file 함수 수정:

```rust
async fn handle_read_file(&self, args: Value) -> MCPResponse {
    let request_id = Value::String(uuid::Uuid::new_v4().to_string());

    let path_str = match args.get("path").and_then(|v| v.as_str()) {
        Some(path) => path,
        None => {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "Missing required parameter: path".to_string(),
                    data: None,
                }),
            };
        }
    };

    let start_line = args.get("start_line").and_then(|v| v.as_u64()).map(|n| n as usize);
    let end_line = args.get("end_line").and_then(|v| v.as_u64()).map(|n| n as usize);

    // Validate line range
    if let (Some(start), Some(end)) = (start_line, end_line) {
        if start > end {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "start_line must be less than or equal to end_line".to_string(),
                    data: None,
                }),
            };
        }
    }

    // Validate path security
    let safe_path = match self.security.validate_path(path_str) {
        Ok(path) => path,
        Err(e) => {
            error!("Path validation failed: {}", e);
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Security error: {}", e),
                    data: None,
                }),
            };
        }
    };

    // Check file size
    if let Err(e) = self.security.validate_file_size(&safe_path, MAX_FILE_SIZE) {
        error!("File size validation failed: {}", e);
        return MCPResponse {
            jsonrpc: "2.0".to_string(),
            id: Some(request_id),
            result: None,
            error: Some(MCPError {
                code: -32603,
                message: format!("File size error: {}", e),
                data: None,
            }),
        };
    }

    // Read file with line range support
    let content = if start_line.is_some() || end_line.is_some() {
        self.read_file_lines(&safe_path, start_line, end_line).await
    } else {
        fs::read_to_string(&safe_path).await.map_err(|e| e.to_string())
    };

    match content {
        Ok(content) => {
            info!("Successfully read file: {:?}", safe_path);
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: Some(json!({
                    "content": [{
                        "type": "text",
                        "text": content
                    }]
                })),
                error: None,
            }
        }
        Err(e) => {
            error!("Failed to read file {:?}: {}", safe_path, e);
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Failed to read file: {}", e),
                    data: None,
                }),
            }
        }
    }
}

async fn read_file_lines(
    &self,
    path: &std::path::Path,
    start_line: Option<usize>,
    end_line: Option<usize>,
) -> Result<String, String> {
    use tokio::io::{AsyncBufReadExt, BufReader};

    let file = tokio::fs::File::open(path).await.map_err(|e| e.to_string())?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();
    let mut result_lines = Vec::new();
    let mut current_line = 1;

    let start = start_line.unwrap_or(1);
    let end = end_line.unwrap_or(usize::MAX);

    while let Ok(Some(line)) = lines.next_line().await {
        if current_line >= start && current_line <= end {
            result_lines.push(line);
        }

        if current_line > end {
            break;
        }

        current_line += 1;
    }

    Ok(result_lines.join("\n"))
}
```

### 2. FilesystemServer - search_files 도구 추가

#### Cargo.toml 의존성 추가:

```toml
[dependencies]
# 기존 의존성들...
walkdir = "2.4"
glob = "0.3"
```

#### 새로운 도구 추가:

```rust
fn create_search_files_tool() -> MCPTool {
    MCPTool {
        name: "search_files".to_string(),
        title: Some("Search Files".to_string()),
        description: "Search for files matching patterns with various filters".to_string(),
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert(
                        "pattern".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(500),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Glob pattern to match files (e.g., '*.rs', '**/*.tsx')".to_string()),
                            default: None,
                            examples: Some(vec![json!("*.rs"), json!("**/*.tsx"), json!("src/**/*.ts")]),
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "path".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(1000),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Root path to search from".to_string()),
                            default: Some(json!(".")),
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "max_depth".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::Integer {
                                minimum: Some(1),
                                maximum: Some(50),
                                exclusive_minimum: None,
                                exclusive_maximum: None,
                                multiple_of: None,
                            },
                            title: None,
                            description: Some("Maximum depth to search (optional)".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "file_type".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: None,
                                max_length: None,
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Filter by file type: 'file', 'dir', or 'both'".to_string()),
                            default: Some(json!("both")),
                            examples: None,
                            enum_values: Some(vec![json!("file"), json!("dir"), json!("both")]),
                            const_value: None,
                        },
                    );
                    props
                }),
                required: Some(vec!["pattern".to_string()]),
                additional_properties: Some(false),
                min_properties: None,
                max_properties: None,
            },
            title: None,
            description: None,
            default: None,
            examples: None,
            enum_values: None,
            const_value: None,
        },
        output_schema: None,
        annotations: None,
    }
}

async fn handle_search_files(&self, args: Value) -> MCPResponse {
    let request_id = Value::String(uuid::Uuid::new_v4().to_string());

    let pattern = match args.get("pattern").and_then(|v| v.as_str()) {
        Some(pattern) => pattern,
        None => {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "Missing required parameter: pattern".to_string(),
                    data: None,
                }),
            };
        }
    };

    let search_path = args.get("path").and_then(|v| v.as_str()).unwrap_or(".");
    let max_depth = args.get("max_depth").and_then(|v| v.as_u64()).map(|n| n as usize);
    let file_type = args.get("file_type").and_then(|v| v.as_str()).unwrap_or("both");

    // Validate search path security
    let safe_path = match self.security.validate_path(search_path) {
        Ok(path) => path,
        Err(e) => {
            error!("Path validation failed: {}", e);
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Security error: {}", e),
                    data: None,
                }),
            };
        }
    };

    // Search files
    match self.search_files_by_pattern(&safe_path, pattern, max_depth, file_type).await {
        Ok(results) => {
            let result_text = if results.is_empty() {
                format!("No files found matching pattern '{}' in '{}'", pattern, search_path)
            } else {
                format!(
                    "Found {} files matching pattern '{}':\n{}",
                    results.len(),
                    pattern,
                    serde_json::to_string_pretty(&results).unwrap_or_default()
                )
            };

            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: Some(json!({
                    "content": [{
                        "type": "text",
                        "text": result_text
                    }]
                })),
                error: None,
            }
        }
        Err(e) => {
            error!("File search failed: {}", e);
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Search failed: {}", e),
                    data: None,
                }),
            }
        }
    }
}

async fn search_files_by_pattern(
    &self,
    root_path: &std::path::Path,
    pattern: &str,
    max_depth: Option<usize>,
    file_type: &str,
) -> Result<Vec<serde_json::Value>, String> {
    use walkdir::WalkDir;
    use glob::Pattern;

    let glob_pattern = Pattern::new(pattern).map_err(|e| format!("Invalid pattern: {}", e))?;
    let mut results = Vec::new();

    let walker = if let Some(depth) = max_depth {
        WalkDir::new(root_path).max_depth(depth)
    } else {
        WalkDir::new(root_path)
    };

    for entry in walker {
        let entry = entry.map_err(|e| format!("Walk error: {}", e))?;
        let path = entry.path();

        // Check file type filter
        let is_dir = path.is_dir();
        let is_file = path.is_file();

        let should_include = match file_type {
            "file" => is_file,
            "dir" => is_dir,
            "both" => is_file || is_dir,
            _ => is_file || is_dir,
        };

        if !should_include {
            continue;
        }

        // Check pattern match
        if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
            if glob_pattern.matches(file_name) || glob_pattern.matches(&path.to_string_lossy()) {
                let metadata = entry.metadata().map_err(|e| format!("Metadata error: {}", e))?;

                results.push(json!({
                    "path": path.to_string_lossy(),
                    "name": file_name,
                    "type": if is_dir { "directory" } else { "file" },
                    "size": if is_file { Some(metadata.len()) } else { None }
                }));
            }
        }
    }

    Ok(results)
}
```

#### tools() 메서드에 새 도구 추가:

```rust
fn tools(&self) -> Vec<MCPTool> {
    vec![
        Self::create_read_file_tool(),
        Self::create_write_file_tool(),
        Self::create_list_directory_tool(),
        Self::create_search_files_tool(), // 새로 추가
    ]
}
```

#### call_tool() 메서드에 핸들러 추가:

```rust
async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
    match tool_name {
        "read_file" => self.handle_read_file(args).await,
        "write_file" => self.handle_write_file(args).await,
        "list_directory" => self.handle_list_directory(args).await,
        "search_files" => self.handle_search_files(args).await, // 새로 추가
        _ => {
            let request_id = Value::String(uuid::Uuid::new_v4().to_string());
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32601,
                    message: format!("Tool '{}' not found in filesystem server", tool_name),
                    data: None,
                }),
            }
        }
    }
}
```

### 3. SandboxServer - execute_shell 도구 추가

**파일**: `src-tauri/src/mcp/builtin/sandbox.rs`

#### 새로운 도구 추가:

```rust
fn create_execute_shell_tool() -> MCPTool {
    MCPTool {
        name: "execute_shell".to_string(),
        title: Some("Execute Shell Command".to_string()),
        description: "Execute a shell command in the current environment".to_string(),
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert(
                        "command".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(1000),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Shell command to execute".to_string()),
                            default: None,
                            examples: Some(vec![json!("ls -la"), json!("grep -r 'pattern' .")]),
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "timeout".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::Integer {
                                minimum: Some(1),
                                maximum: Some(300), // 5분 최대
                                exclusive_minimum: None,
                                exclusive_maximum: None,
                                multiple_of: None,
                            },
                            title: None,
                            description: Some("Timeout in seconds (default: 30)".to_string()),
                            default: Some(json!(30)),
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props.insert(
                        "working_dir".to_string(),
                        JSONSchema {
                            schema_type: JSONSchemaType::String {
                                min_length: Some(1),
                                max_length: Some(1000),
                                pattern: None,
                                format: None,
                            },
                            title: None,
                            description: Some("Working directory for command execution (optional)".to_string()),
                            default: None,
                            examples: None,
                            enum_values: None,
                            const_value: None,
                        },
                    );
                    props
                }),
                required: Some(vec!["command".to_string()]),
                additional_properties: Some(false),
                min_properties: None,
                max_properties: None,
            },
            title: None,
            description: None,
            default: None,
            examples: None,
            enum_values: None,
            const_value: None,
        },
        output_schema: None,
        annotations: None,
    }
}

async fn handle_execute_shell(&self, args: Value) -> MCPResponse {
    let request_id = Value::String(uuid::Uuid::new_v4().to_string());

    let command_str = match args.get("command").and_then(|v| v.as_str()) {
        Some(cmd) => cmd,
        None => {
            return MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32602,
                    message: "Missing required parameter: command".to_string(),
                    data: None,
                }),
            };
        }
    };

    let timeout_secs = args
        .get("timeout")
        .and_then(|v| v.as_u64())
        .unwrap_or(30)
        .min(300); // 최대 5분

    let working_dir = args.get("working_dir").and_then(|v| v.as_str());

    // Determine working directory
    let work_dir = if let Some(dir) = working_dir {
        std::path::PathBuf::from(dir)
    } else {
        Self::determine_execution_working_dir()
    };

    // Execute shell command
    let mut cmd = if cfg!(target_os = "windows") {
        let mut cmd = tokio::process::Command::new("cmd");
        cmd.args(&["/C", command_str]);
        cmd
    } else {
        let mut cmd = tokio::process::Command::new("sh");
        cmd.args(&["-c", command_str]);
        cmd
    };

    cmd.current_dir(&work_dir);

    let timeout_duration = std::time::Duration::from_secs(timeout_secs);

    match tokio::time::timeout(timeout_duration, cmd.output()).await {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let success = output.status.success();
            let exit_code = output.status.code().unwrap_or(-1);

            let result_text = if success {
                if stdout.trim().is_empty() && stderr.trim().is_empty() {
                    "Command executed successfully (no output)".to_string()
                } else if stderr.trim().is_empty() {
                    format!("Command executed successfully:\n{}", stdout.trim())
                } else {
                    format!(
                        "Command executed successfully:\nSTDOUT:\n{}\n\nSTDERR:\n{}",
                        stdout.trim(),
                        stderr.trim()
                    )
                }
            } else {
                format!(
                    "Command failed with exit code {}:\nSTDOUT:\n{}\n\nSTDERR:\n{}",
                    exit_code,
                    stdout.trim(),
                    stderr.trim()
                )
            };

            info!("Shell command executed: {} (exit: {})", command_str, exit_code);

            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: Some(json!({
                    "content": [{
                        "type": "text",
                        "text": result_text
                    }],
                    "isError": !success
                })),
                error: None,
            }
        }
        Ok(Err(e)) => {
            error!("Failed to execute shell command '{}': {}", command_str, e);
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Execution error: {}", e),
                    data: None,
                }),
            }
        }
        Err(_) => {
            error!("Shell command '{}' timed out after {} seconds", command_str, timeout_secs);
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32603,
                    message: format!("Command timed out after {} seconds", timeout_secs),
                    data: None,
                }),
            }
        }
    }
}
```

#### tools() 및 call_tool() 메서드 업데이트:

```rust
fn tools(&self) -> Vec<MCPTool> {
    vec![
        Self::create_execute_python_tool(),
        Self::create_execute_typescript_tool(),
        Self::create_execute_shell_tool(), // 새로 추가
    ]
}

async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
    match tool_name {
        "execute_python" => self.handle_execute_python(args).await,
        "execute_typescript" => self.handle_execute_typescript(args).await,
        "execute_shell" => self.handle_execute_shell(args).await, // 새로 추가
        _ => {
            let request_id = Value::String(uuid::Uuid::new_v4().to_string());
            MCPResponse {
                jsonrpc: "2.0".to_string(),
                id: Some(request_id),
                result: None,
                error: Some(MCPError {
                    code: -32601,
                    message: format!("Tool '{}' not found in sandbox server", tool_name),
                    data: None,
                }),
            }
        }
    }
}
```

## 구현 단계별 체크리스트

### Step 1: FilesystemServer read_file 확장

- [ ] input_schema에 start_line, end_line 파라미터 추가
- [ ] handle_read_file 함수에 줄 범위 검증 로직 추가
- [ ] read_file_lines 헬퍼 함수 구현
- [ ] 에러 처리 및 로깅 추가
- [ ] 테스트로 검증

### Step 2: FilesystemServer search_files 추가

- [ ] Cargo.toml에 walkdir, glob 의존성 추가
- [ ] create_search_files_tool 함수 구현
- [ ] handle_search_files 함수 구현
- [ ] search_files_by_pattern 헬퍼 함수 구현
- [ ] tools() 및 call_tool() 메서드에 등록
- [ ] 테스트로 검증

### Step 3: SandboxServer execute_shell 추가

- [ ] create_execute_shell_tool 함수 구현
- [ ] handle_execute_shell 함수 구현
- [ ] 크로스 플랫폼 명령어 실행 처리 (Windows/Unix)
- [ ] 타임아웃 및 에러 처리 구현
- [ ] tools() 및 call_tool() 메서드에 등록
- [ ] 테스트로 검증

### Step 4: 통합 테스트 및 검증

- [ ] `pnpm tauri dev`로 개발 환경에서 테스트
- [ ] 각 도구의 기본 기능 동작 확인
- [ ] 에러 케이스 처리 확인
- [ ] 문서 업데이트

## 예상 소요 시간

- **Step 1**: 2-3시간
- **Step 2**: 3-4시간
- **Step 3**: 2-3시간
- **Step 4**: 1-2시간
- **총 예상 시간**: 8-12시간

## 리스크 요소

1. **의존성 충돌**: walkdir, glob 패키지 추가 시 기존 의존성과의 충돌 가능성
2. **크로스 플랫폼 호환성**: Windows/macOS/Linux에서 쉘 명령 실행 방식 차이
3. **보안 이슈**: execute_shell의 무제한 명령 실행으로 인한 잠재적 보안 위험
4. **성능**: 대량 파일 검색 시 성능 저하 가능성

## 완료 기준

모든 체크리스트 항목이 완료되고, SynapticFlow 개발 환경에서 다음 시나리오가 정상 동작:

1. 파일의 특정 줄 범위 읽기
2. glob 패턴으로 프로젝트 내 파일 검색
3. 기본적인 쉘 명령 (ls, grep, find 등) 실행
