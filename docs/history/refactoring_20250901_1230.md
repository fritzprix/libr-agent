# AI Service 코드 중복 제거 리팩토링 계획

## 작업의 목적

AI Service 구현체들(`src/lib/ai-service/`)에서 발견된 코드 중복을 체계적으로 제거하여 코드의 유지보수성과 확장성을 향상시키고, 새로운 AI 서비스 제공자 추가 시 일관성 있는 개발 패턴을 제공한다.

## 현재의 상태 / 문제점

### 중복 현황 분석

- **전체 중복률: 35-40%**
- **완전 중복**: 에러 처리 패턴, 기본 검증 로직 (15%)
- **높은 중복**: 메시지 변환 구조, 설정 병합 로직 (20%)
- **중간 중복**: 스트리밍 처리 구조, 툴 변환 기본 패턴 (15%)

### 구체적 문제점

1. **에러 처리 완전 중복**

```typescript
// anthropic.ts, openai.ts, groq.ts 등에서 거의 동일한 패턴
throw new AIServiceError(
  `${provider} streaming failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
  this.getProvider(),
  undefined,
  error instanceof Error ? error : undefined,
);
```

**메시지 변환 로직 중복**

```typescript
// 모든 서비스에서 반복되는 패턴
if (systemPrompt) {
  messages.push({ role: 'system', content: systemPrompt });
}

for (const m of messages) {
  if (m.role === 'user') {
    messages.push({
      role: 'user',
      content: this.processMessageContent(m.content),
    });
  }
  // 유사한 role별 처리 로직 반복
}
```

3. **설정 병합 중복**

```typescript
// 모든 streamChat 메서드에서 반복
const config = { ...this.defaultConfig, ...options.config };
```

4. **기본 검증 호출 중복**

```typescript
// 모든 streamChat 메서드 시작 부분에서 반복
this.validateMessages(messages);
```

## 추가 분석 과제

1. **제공자별 특수 기능 분석**: Anthropic의 thinking, Groq의 reasoning 등 제공자 고유 기능들이 공통 인터페이스에 어떻게 반영되어야 하는지 추가 조사 필요

2. **스트리밍 응답 형식 표준화**: 각 제공자의 청크 응답 형식을 분석하여 공통 인터페이스 설계 가능성 검토

3. **툴 호출 결과 처리**: 제공자별로 다른 툴 호출 결과 처리 방식의 통합 가능성 분석

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **코드 감소**: 전체 AI 서비스 코드 30-35% 감소
2. **일관성**: 모든 서비스가 동일한 에러 처리 및 기본 검증 패턴 사용
3. **확장성**: 새로운 AI 서비스 추가 시 50% 이상 코드 재사용 가능
4. **유지보수성**: 공통 로직 변경 시 한 곳에서만 수정으로 전체 적용

### 검증 방법

- 기존 테스트 케이스 모두 통과
- 새로운 AI 서비스 구현 시 BaseAIService 상속만으로 80% 기능 구현
- ESLint 및 TypeScript 컴파일 오류 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. BaseAIService 확장 (최우선)

**파일**: `src/lib/ai-service/base-service.ts`

```typescript
// 추가할 메서드들
export abstract class BaseAIService implements IAIService {
  // ... 기존 코드 ...

  /**
   * 공통 에러 처리 헬퍼
   */
  protected handleStreamingError(
    error: unknown,
    context: {
      messages: Message[];
      options: any;
      config: AIServiceConfig;
    },
  ): never {
    const serviceProvider = this.getProvider();
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    const errorStack = error instanceof Error ? error.stack : undefined;

    logger.error(`${serviceProvider} streaming failed`, {
      error: errorMessage,
      stack: errorStack,
      requestData: {
        model: context.options.modelName || context.config.defaultModel,
        messagesCount: context.messages.length,
        hasTools: !!context.options.availableTools?.length,
        systemPrompt: !!context.options.systemPrompt,
      },
    });

    throw new AIServiceError(
      `${serviceProvider} streaming failed: ${errorMessage}`,
      serviceProvider,
      undefined,
      error instanceof Error ? error : undefined,
    );
  }

  /**
   * 설정 병합 헬퍼
   */
  protected mergeConfig(options?: {
    config?: AIServiceConfig;
  }): AIServiceConfig {
    return { ...this.defaultConfig, ...options?.config };
  }

  /**
   * streamChat 전처리 공통 로직
   */
  protected prepareStreamChat(
    messages: Message[],
    options: {
      modelName?: string;
      systemPrompt?: string;
      availableTools?: MCPTool[];
      config?: AIServiceConfig;
    } = {},
  ): {
    config: AIServiceConfig;
    tools?: any[];
  } {
    this.validateMessages(messages);
    const config = this.mergeConfig(options);

    const tools = options.availableTools
      ? convertMCPToolsToProviderTools(
          options.availableTools,
          this.getProvider(),
        )
      : undefined;

    return { config, tools };
  }

  /**
   * 기본 메시지 변환 템플릿 메서드
   */
  protected convertMessagesTemplate(
    messages: Message[],
    systemPrompt?: string,
  ): any[] {
    const result: any[] = [];

    if (systemPrompt) {
      result.push(this.createSystemMessage(systemPrompt));
    }

    for (const message of messages) {
      const converted = this.convertSingleMessage(message);
      if (converted) {
        result.push(converted);
      }
    }

    return result;
  }

  // 제공자별로 구현해야 할 추상 메서드들
  protected abstract createSystemMessage(systemPrompt: string): any;
  protected abstract convertSingleMessage(message: Message): any;
}
```

### 2. 개별 서비스 수정 예시

**파일**: `src/lib/ai-service/anthropic.ts`

```typescript
// 기존 streamChat 메서드를 단순화
async *streamChat(
  messages: Message[],
  options: {
    modelName?: string;
    systemPrompt?: string;
    availableTools?: MCPTool[];
    config?: AIServiceConfig;
  } = {},
): AsyncGenerator<string, void, void> {
  const { config, tools } = this.prepareStreamChat(messages, options);

  try {
    const anthropicMessages = this.convertToAnthropicMessages(messages);

    const completion = await this.withRetry(() =>
      this.anthropic.messages.create({
        model: options.modelName || config.defaultModel || 'claude-3-sonnet-20240229',
        max_tokens: config.maxTokens!,
        messages: anthropicMessages,
        stream: true,
        thinking: { budget_tokens: 1024, type: 'enabled' },
        system: options.systemPrompt,
        tools: tools as AnthropicTool[],
      }),
    );

    for await (const chunk of completion) {
      // 청크 처리 로직 (제공자 특수 로직)
      if (chunk.type === 'content_block_delta' && chunk.delta.type === 'text_delta') {
        yield JSON.stringify({ content: chunk.delta.text });
      }
      // ... 기타 청크 처리
    }
  } catch (error) {
    this.handleStreamingError(error, { messages, options, config });
  }
}

// 추상 메서드 구현
protected createSystemMessage(systemPrompt: string): any {
  // Anthropic은 시스템 메시지를 별도 파라미터로 처리하므로 null 반환
  return null;
}

protected convertSingleMessage(message: Message): any {
  // Anthropic 특화 메시지 변환 로직
  if (message.role === 'user') {
    return {
      role: 'user',
      content: this.processMessageContent(message.content),
    };
  }
  // ... 기타 역할별 처리
}
```

### 3. 기타 서비스 수정 패턴

**적용 대상 파일들**:

- `src/lib/ai-service/openai.ts`
- `src/lib/ai-service/groq.ts`
- `src/lib/ai-service/gemini.ts`
- `src/lib/ai-service/cerebras.ts`
- `src/lib/ai-service/ollama.ts`

각 파일에서 동일한 패턴으로 수정:

1. `prepareStreamChat` 사용으로 전처리 통합
2. `handleStreamingError` 사용으로 에러 처리 통합
3. 제공자별 특수 로직만 유지

## 재사용 가능한 연관 코드

### 기존 활용 가능한 코드

**파일**: `src/lib/ai-service/base-service.ts`

- **주요 기능**: `validateMessages`, `processMessageContent`, `withRetry`, `withTimeout`
- **인터페이스**: `IAIService`, `AIServiceConfig`
- **재사용 방법**: 추가 헬퍼 메서드들을 이 클래스에 확장

**파일**: `src/lib/ai-service/tool-converters.ts`

- **주요 기능**: `convertMCPToolsToProviderTools`, 제공자별 툴 변환 함수들
- **인터페이스**: `ProviderToolType`, `MCPTool`
- **재사용 방법**: 공통 전처리 로직에서 활용

**파일**: `src/lib/ai-service/types.ts`

- **주요 기능**: 타입 정의, 에러 클래스
- **인터페이스**: `AIServiceProvider`, `AIServiceError`
- **재사용 방법**: 추가 타입 정의 시 확장

**파일**: `src/lib/ai-service/factory.ts`

- **주요 기능**: 서비스 인스턴스 관리, 캐싱
- **재사용 방법**: 리팩토링 후에도 동일하게 활용

### 새로 생성될 공통 코드

**예상 새 파일**: `src/lib/ai-service/stream-helpers.ts`

- **용도**: 스트리밍 관련 공통 유틸리티
- **주요 기능**: 청크 검증, 응답 형식 표준화

**예상 새 파일**: `src/lib/ai-service/message-helpers.ts`

- **용도**: 메시지 변환 관련 공통 유틸리티
- **주요 기능**: 공통 메시지 검증, 역할별 처리 로직

## 작업 단계

1. **1단계**: BaseAIService 확장 (에러 처리, 설정 병합, 전처리 로직)
2. **2단계**: 개별 서비스들 단순화 적용
3. **3단계**: 통합 테스트 및 검증
4. **4단계**: 문서화 및 가이드라인 업데이트
