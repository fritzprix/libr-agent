# Assistant 선택 시 MCP Tools 동기화 이슈 해결

## 작업의 목적

SingleChatContainer에서 Assistant 선택 후 Chat 시작 시, 선택된 Assistant의 mcpConfig에 따른 tools가 제대로 로드되지 않는 레이스 컨디션 문제를 해결합니다.

## 현재의 상태 / 문제점

### 문제 현상

- Assistant A로 채팅 중 → Assistant B 선택 → Chat 시작 시 여전히 Assistant A의 tools가 표시됨
- MCP 서버 연결이 완료되기 전에 ChatRouter가 마운트되어 이전 Assistant의 tools를 사용하는 레이스 컨디션 발생

### 기술적 원인

1. **StartSingleChatView**: `handleAssistantSelect`에서 `setCurrentAssistant`와 `start` 함수가 동기적으로 실행
2. **AssistantContext**: `connectServers`가 비동기이지만 await하지 않음 (fire-and-forget)
3. **SessionContext**: 세션 생성 후 즉시 `setCurrent` → ChatRouter 마운트
4. **타이밍 이슈**: ChatRouter 마운트 시점에 새로운 Assistant의 tools 로딩이 미완료

### 현재 코드 플로우

```text
Assistant B 클릭 → setCurrentAssistant(B) → connectServers(B.mcpConfig) [비동기 시작]
                                       → start([B]) → setCurrent(session) → ChatRouter 마운트
                                                                           → 아직 A의 tools 사용
몇 초 후 → connectServers 완료 → tools B로 업데이트 (이미 늦음)
```

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

- Assistant 선택 시 해당 Assistant의 mcpConfig 기반 MCP 서버 연결이 완료된 후에만 Chat이 시작됨
- ChatRouter 마운트 시점에 올바른 tools가 준비되어 있음
- 사용자에게 명확한 로딩 상태 피드백 제공

### 해결 판정 기준

1. **기능적 검증**: Assistant A → Assistant B 전환 시 B의 tools만 표시됨
2. **UX 개선**: MCP 연결 중 로딩 상태 표시
3. **에러 처리**: MCP 연결 실패 시 적절한 에러 메시지 표시
4. **성능**: 중복 클릭 방지 및 불필요한 연결 시도 방지

### 새로운 코드 플로우

```text
Assistant B 클릭 → setIsStarting(true) → setCurrentAssistant(B) 
                                      → await connectServers(B.mcpConfig) [완료 대기]
                                      → await start([B]) → setCurrent(session) → ChatRouter 마운트
                                                                              → B의 tools 사용
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. StartSingleChatView.tsx - 전체 파일 교체

**현재 코드:**

```tsx
import { Button } from '@/components/ui';
import { useAssistantContext } from '@/context/AssistantContext';
import { useSessionContext } from '@/context/SessionContext';
import { Assistant } from '@/models/chat';
import { useCallback } from 'react';
import { Link } from 'react-router';

export default function StartSingleChatView() {
  const { assistants, setCurrentAssistant } = useAssistantContext();
  const { start } = useSessionContext();

  const handleAssistantSelect = useCallback(
    (assistant: Assistant) => {
      setCurrentAssistant(assistant);
      start([assistant]);
    },
    [start, setCurrentAssistant],
  );

  return (
    <div className="h-full w-full flex flex-col items-center justify-center font-mono p-4 space-y-2">
      {/* ... UI 코드 ... */}
    </div>
  );
}
```

**수정 후 코드:**

```tsx
import { Button } from '@/components/ui';
import { useAssistantContext } from '@/context/AssistantContext';
import { useSessionContext } from '@/context/SessionContext';
import { useMCPServer } from '@/hooks/use-mcp-server';
import { Assistant } from '@/models/chat';
import { getLogger } from '@/lib/logger';
import { useCallback, useState } from 'react';
import { Link } from 'react-router';

const logger = getLogger('StartSingleChatView');

export default function StartSingleChatView() {
  const { assistants, setCurrentAssistant } = useAssistantContext();
  const { start } = useSessionContext();
  const { connectServers } = useMCPServer();
  const [isStarting, setIsStarting] = useState(false);
  const [startingAssistantId, setStartingAssistantId] = useState<string | null>(null);

  const handleAssistantSelect = useCallback(
    async (assistant: Assistant) => {
      if (isStarting) return; // 중복 클릭 방지

      try {
        setIsStarting(true);
        setStartingAssistantId(assistant.id);
        logger.info('Starting chat with assistant', { assistantId: assistant.id, assistantName: assistant.name });

        // 1. Assistant 설정
        setCurrentAssistant(assistant);
        
        // 2. MCP 서버 연결 완료까지 대기
        logger.debug('Connecting MCP servers for assistant', { mcpConfig: assistant.mcpConfig });
        await connectServers(assistant.mcpConfig);
        logger.info('MCP servers connected successfully', { assistantId: assistant.id });

        // 3. 이제 안전하게 세션 시작
        await start([assistant]);
        logger.info('Chat session started successfully', { assistantId: assistant.id });
      } catch (error) {
        logger.error('Failed to start chat with assistant', { 
          assistantId: assistant.id, 
          error: error instanceof Error ? error.message : String(error) 
        });
        // TODO: 에러 토스트나 모달 표시
      } finally {
        setIsStarting(false);
        setStartingAssistantId(null);
      }
    },
    [start, setCurrentAssistant, connectServers, isStarting],
  );

  return (
    <div className="h-full w-full flex flex-col items-center justify-center font-mono p-4 space-y-2">
      <h2 className="text-2xl font-bold mb-6">
        Select an Assistant to Start a Chat
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 w-full max-w-4xl">
        {assistants.map((assistant) => {
          const isThisStarting = startingAssistantId === assistant.id;
          return (
            <div
              key={assistant.id}
              className={`border rounded-lg p-4 cursor-pointer transition-colors ${
                isStarting && !isThisStarting 
                  ? 'opacity-50 cursor-not-allowed' 
                  : 'hover:bg-gray-50'
              }`}
              onClick={() => !isStarting && handleAssistantSelect(assistant)}
            >
              <h3 className="text-lg font-semibold flex items-center gap-2">
                {assistant.name}
                {isThisStarting && (
                  <span className="text-sm text-blue-600">Starting...</span>
                )}
              </h3>
              <p className="text-sm mt-2 line-clamp-3">
                {assistant.systemPrompt}
              </p>
            </div>
          );
        })}
      </div>
      <Link to={'/assistants'}>
        <Button disabled={isStarting}>Manage Assistants</Button>
      </Link>
    </div>
  );
}
```

### 2. use-mcp-server.ts - 타입 export 추가

**현재 코드:**

```typescript
import { useContext } from 'react';
import { MCPServerContext } from '../context/MCPServerContext';
import type { MCPServerContextType } from '../context/MCPServerContext';

export const useMCPServer = (): MCPServerContextType => {
  const context = useContext(MCPServerContext);
  if (context === undefined) {
    throw new Error('useMCPServer must be used within a MCPServerProvider');
  }
  return context;
};
```

**수정 후 코드:**

```typescript
import { useContext } from 'react';
import { MCPServerContext } from '../context/MCPServerContext';

export const useMCPServer = () => {
  const context = useContext(MCPServerContext);
  if (context === undefined) {
    throw new Error('useMCPServer must be used within a MCPServerProvider');
  }
  return context;
};
```

## 구현 단계

1. **Phase 1**: `StartSingleChatView.tsx` 수정
   - 로딩 상태 추가
   - async/await 패턴 적용
   - 로깅 및 에러 처리 추가

2. **Phase 2**: 테스트 및 검증
   - Assistant 전환 시나리오 테스트
   - 에러 케이스 테스트 (MCP 연결 실패 등)
   - UX 개선사항 확인

3. **Phase 3**: 추가 개선사항 (필요시)
   - 에러 토스트 시스템 연동
   - 더 정교한 로딩 UI
   - MCP 연결 상태 모니터링

## 리스크 및 고려사항

- **Breaking Change**: 없음 (기존 API 유지)
- **성능 영향**: MCP 연결 대기로 인한 약간의 지연 (사용자 피드백으로 보완)
- **에러 처리**: MCP 연결 실패 시 사용자에게 명확한 피드백 필요
- **의존성**: `useMCPServer` 훅 사용 (이미 존재)

## 검증 시나리오

1. **정상 플로우**: Assistant A → Assistant B 선택 → B의 tools만 표시 확인
2. **로딩 상태**: MCP 연결 중 "Starting..." 메시지 표시 확인
3. **에러 케이스**: MCP 서버 실행 불가 시 적절한 에러 처리 확인
4. **중복 클릭**: 연결 중 다른 Assistant 클릭 시 무시 확인
