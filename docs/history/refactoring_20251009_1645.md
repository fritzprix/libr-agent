---
title: 'Refactor: History 페이지 — 전역 메시지 검색 및 정렬 개선'
date: 2025-10-09
author: synaptic-flow/dev
---

# Refactor: History 페이지 — 전역 메시지 검색 및 정렬 개선

## 목적 (Purpose)

`History` 화면에 전역 메시지 검색 기능을 도입하고, 검색 결과를 세션별로 집계하여 "참조(검색 히트) 많은 세션 우선"으로 정렬해 보여준다. 검색이 비어있을 경우 기존 날짜 기준 정렬(오름/내림)을 유지하며, 사용자에게 정렬 기준(시간 오름/내림)을 선택할 수 있는 간단한 UX를 제공한다.

### 핵심 목표 (Key Goals)

- 전역 메시지 검색(이미 구현된 `searchMessages` 호출)을 활용
- 검색 결과로부터 sessionId별 집계(count, latest timestamp, snippet)를 생성하여 세션 정렬에 사용
- query가 비어있을 때는 날짜 기준 기본 정렬(asc/desc) 적용
- SWR을 사용해 검색 결과를 캐싱하고, query/정렬/페이지 사이즈를 SWR key에 포함
- 입력 디바운스와 작은 UX(정렬 토글, 검색 상태 표시)를 추가

---

## 현재 상태 / 문제점 (Current State / Problems)

### 기존 구현

- `History.tsx`는 현재 `useSessionContext()`에서 제공하는 세션 페이지를 단순히 펼쳐서(`flatMap`) `SessionList`에 전달한다.
- 세션 목록은 날짜 기준으로만 정렬되며, 메시지 내용 기반 검색 기능이 없다.
- `rust-backend-client.ts`에 `searchMessages` 구현이 추가되어 있음(메시지 수준 결과 반환).
- 현재 `searchMessages`는 `sessionId`를 필수 인자로 받아 특정 세션 내 검색만 지원.

### 문제점

- 사용자가 과거 대화 내용을 검색할 수 없어 특정 세션을 찾기 어려움
- 많은 세션이 누적될 경우 원하는 대화를 찾기 위해 수동으로 스크롤 필요
- 전역 검색 기능이 백엔드에 구현되어 있으나 UI에서 활용되지 않음

---

## 변경 이후 상태 / 성공 판정 기준 (Target State / Success Criteria)

### 기대 결과

1. **검색 기능**: 사용자가 검색어를 입력하면 SWR로 검색이 수행되고, 세션 목록이 검색 히트 수 기준으로 정렬되어 표시된다.
2. **캐싱 성능**: SWR 캐시가 동작하고, 동일 쿼리에 대해서는 재요청을 줄여 응답성이 향상된다.
3. **정렬 옵션**: 검색어가 없을 때 사용자가 날짜 오름차순/내림차순을 선택할 수 있다.
4. **UX 개선**: 검색 상태(로딩, 결과 없음)가 명확히 표시되고, 각 세션에 검색 히트 수가 배지로 표시된다.

### 성공 판정 기준

- ✅ 검색어 입력 시 전역 메시지 검색이 수행되고 결과가 세션별로 집계됨
- ✅ 검색 결과가 히트 수 기준으로 정렬되어 표시됨
- ✅ 검색어가 없을 때 날짜 기준 정렬(asc/desc)이 정상 작동
- ✅ SWR 캐시가 동작하여 동일 쿼리에 대한 중복 요청 방지
- ✅ 로딩 상태와 에러 상태가 적절히 표시됨
- ✅ 모든 TypeScript 타입이 명시적으로 정의되고 `any` 사용 없음
- ✅ 코드 주석이 모두 영어로 작성됨

---

## 관련 파일 (Related Files - Birdseye View)

- `src/features/history/History.tsx` — 검색 UI, SWR 통합, 집계 로직 및 정렬 구현
- `src/lib/rust-backend-client.ts` — `searchMessages` wrapper (sessionId를 optional로 변경하여 전역 검색 허용)
- `src/context/SessionContext.tsx` — 기존 세션 페치/페이지네이션 로직 (변경 없음, 재사용)
- `src/features/session/SessionList.tsx` — 세션 목록 렌더링 (히트 배지 표시 추가)
- `src/components/ui/*` — shadcn/ui 컴포넌트 (Input, Badge, Spinner, ToggleGroup 등)

---

## 설계 및 구현 계획 (Design & Implementation Plan)

### 1. 검색 UX

- **검색 입력**: shadcn/ui `<Input>` 컴포넌트 사용, 검색 아이콘 포함
- **디바운스**: 입력값은 300ms 디바운스 후 SWR에 반영
- **정렬 토글**: shadcn/ui `<ToggleGroup>` 사용하여 날짜 오름차순/내림차순 선택
- **검색 상태 표시**: shadcn/ui `<Spinner>` 또는 `<Progress>` 사용, "Searching..." 또는 "No results" 표시
- **히트 배지**: shadcn/ui `<Badge>` 사용하여 각 세션의 검색 히트 수 표시

### 2. SWR 캐싱 전략

- **SWR key**: `['historySearch', normalizedQuery, sortMode, pageSize]` (query가 비었을 때는 `null`)
- **fetcher**: `searchMessages(query, undefined, 1, pageSize)` — 전역 검색을 위해 `sessionId`를 전달하지 않음
- **디바운스**: 입력값은 250~350ms 디바운스 후 SWR에 반영
- **캐시 설정**: `revalidateOnFocus: false`, `dedupingInterval: 5000ms`
- **에러 처리**: SWR의 `onError` 콜백과 centralized logger 사용

### 3. 데이터 흐름 (검색 모드)

1. 사용자가 검색어 입력
2. 디바운스된 검색어로 SWR이 `searchMessages` 호출
3. 반환된 message-level 결과에서 sessionId별 집계: `{ sessionId, count, latestCreatedAt, snippet }`
4. 집계 결과를 기반으로 세션 정렬 (count desc, 동일 시 latestCreatedAt desc)
5. 세션 메타는 먼저 로컬 `sessionPages`에서 조회, 없으면 placeholder 생성
6. `SessionList`에는 정렬된 session 배열과 hitMap 전달

### 4. 데이터 흐름 (기본 모드 - 검색어 비어있음)

1. 기존 `useSessionContext()`에서 반환하는 `sessionPages`를 펼쳐 사용
2. 사용자가 토글한 시간 정렬(asc/desc) 적용하여 정렬
3. `SessionList`에는 정렬된 session 배열 전달 (hitMap 없음)

### 5. 성능/정확도 고려사항

- **페이지 크기**: 단일 `searchMessages` 호출에서 pageSize를 200으로 설정하여 충분한 검색 결과 확보
- **클라이언트 집계**: 빠른 도입을 위해 frontend-side aggregation 사용
- **장기 개선**: 대규모 환경에서는 서버사이드 집계 API(`messages_search_aggregate`) 도입 권장
- **로깅**: 모든 검색 작업에 centralized logger 사용하여 디버깅 및 성능 모니터링

---

## 구체적 코드 스니펫 (Detailed Code Snippets)

### 1. TypeScript 인터페이스 정의

```typescript
// src/models/search.ts
/**
 * Aggregated search result for a single session
 */
interface SearchAggregation {
  sessionId: string;
  count: number;
  latest: number;
  snippet?: string;
}

/**
 * Session extended with search hit count
 */
interface SessionWithHits extends Session {
  searchHits?: number;
}

/**
 * Sort mode for session list
 */
type SortMode = 'asc' | 'desc';

/**
 * Search state for UI rendering
 */
interface SearchState {
  isSearching: boolean;
  hasResults: boolean;
  error: Error | null;
}
```

### 2. 디바운스 훅

```typescript
// src/hooks/useDebounced.ts
import { useState, useEffect } from 'react';

/**
 * Debounces a value by the specified delay
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds (default: 300)
 * @returns Debounced value
 */
export function useDebounced<T>(value: T, delay = 300): T {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const id = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(id);
  }, [value, delay]);

  return debounced;
}
```

### 3. SWR 사용 예 (History.tsx)

```typescript
import useSWR from 'swr';
import { getLogger } from '@/lib/logger';
import { searchMessages } from '@/lib/rust-backend-client';
import { useDebounced } from '@/hooks/useDebounced';

const logger = getLogger('History');

function History() {
  const [query, setQuery] = useState('');
  const [sortMode, setSortMode] = useState<SortMode>('desc');
  const debouncedQuery = useDebounced(query, 300);
  const pageSize = 200;

  // Build SWR key only when query is non-empty
  const swrKey = debouncedQuery?.trim()
    ? ['historySearch', debouncedQuery.trim(), sortMode, pageSize]
    : null;

  const {
    data: searchPage,
    error,
    isValidating,
  } = useSWR(
    swrKey,
    async () => {
      logger.debug('Fetching search results', {
        query: debouncedQuery,
        pageSize,
      });
      // Call searchMessages without sessionId for global search
      return await searchMessages(
        debouncedQuery!.trim(),
        undefined,
        1,
        pageSize,
      );
    },
    {
      revalidateOnFocus: false,
      dedupingInterval: 5000,
      onError: (err: Error) => {
        logger.error('Search failed', err);
      },
    },
  );

  // ... rest of component
}
```

### 4. 집계 및 정렬 로직 (useMemo)

```typescript
import { useMemo } from 'react';

// Aggregate search results by sessionId
const aggregated = useMemo((): SearchAggregation[] => {
  if (!searchPage?.items) {
    logger.debug('No search results to aggregate');
    return [];
  }

  const map = new Map<string, SearchAggregation>();

  for (const item of searchPage.items) {
    const sid = item.sessionId;
    const entry = map.get(sid) ?? {
      sessionId: sid,
      count: 0,
      latest: 0,
    };

    entry.count += 1;
    const ts = item.createdAt?.getTime() ?? 0;

    // Keep the latest timestamp and snippet
    if (ts > entry.latest) {
      entry.latest = ts;
      if (item.snippet) {
        entry.snippet = item.snippet;
      }
    }

    map.set(sid, entry);
  }

  // Convert to array and sort by count (desc), then by latest timestamp (desc)
  const arr = Array.from(map.values());
  arr.sort((a, b) => {
    const countDiff = b.count - a.count;
    if (countDiff !== 0) return countDiff;
    return b.latest - a.latest;
  });

  logger.debug('Aggregated search results', {
    totalSessions: arr.length,
    totalHits: arr.reduce((sum, a) => sum + a.count, 0),
  });

  return arr;
}, [searchPage]);
```

### 5. 세션 목록 구성

```typescript
// Create a map for quick session lookup
const sessionsById = useMemo(() => {
  const m = new Map<string, Session>();
  sessions.forEach((s) => m.set(s.id, s));
  return m;
}, [sessions]);

// Build ordered session list based on search or date sorting
const orderedSessions = useMemo((): SessionWithHits[] => {
  if (!debouncedQuery?.trim()) {
    // Default mode: sort by date
    logger.debug('Using date-based sorting', { sortMode });
    return sessions.slice().sort((a, b) => {
      const aT = new Date(a.createdAt).getTime();
      const bT = new Date(b.createdAt).getTime();
      return sortMode === 'asc' ? aT - bT : bT - aT;
    });
  }

  // Search mode: use aggregation-based sorting
  logger.debug('Using search-based sorting', {
    query: debouncedQuery,
    resultCount: aggregated.length,
  });

  return aggregated.map((agg): SessionWithHits => {
    const local = sessionsById.get(agg.sessionId);

    if (local) {
      // Attach search hit count to existing session
      return { ...local, searchHits: agg.count };
    }

    // Create placeholder session for sessions not in current page
    logger.warn('Session not found locally, creating placeholder', {
      sessionId: agg.sessionId,
    });

    return {
      id: agg.sessionId,
      name: `Session ${agg.sessionId.slice(0, 6)}`,
      createdAt: new Date(agg.latest).toISOString(),
      updatedAt: new Date(agg.latest).toISOString(),
      assistants: [],
      description: agg.snippet ?? '',
      type: 'chat',
      searchHits: agg.count,
    } as SessionWithHits;
  });
}, [debouncedQuery, sessions, aggregated, sessionsById, sortMode]);
```

### 6. UI 컴포넌트 구성 (History.tsx)

```typescript
import { Input } from '@/components/ui/input';
import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group';
import { Spinner } from '@/components/ui/spinner';
import { Badge } from '@/components/ui/badge';
import { Search, ArrowUp, ArrowDown } from 'lucide-react';

function History() {
  // ... state and hooks from above

  const searchState: SearchState = {
    isSearching: isValidating,
    hasResults: !!searchPage?.items.length,
    error: error ?? null,
  };

  return (
    <div className="flex flex-col h-full">
      {/* Search Header */}
      <div className="p-4 border-b space-y-4">
        {/* Search Input */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            type="text"
            placeholder="Search messages across all sessions..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            className="pl-9"
          />
        </div>

        {/* Sort Toggle (only visible when no search query) */}
        {!debouncedQuery?.trim() && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">Sort by date:</span>
            <ToggleGroup
              type="single"
              value={sortMode}
              onValueChange={(value) => value && setSortMode(value as SortMode)}
            >
              <ToggleGroupItem value="asc" aria-label="Ascending">
                <ArrowUp className="h-4 w-4" />
                <span className="ml-1">Oldest first</span>
              </ToggleGroupItem>
              <ToggleGroupItem value="desc" aria-label="Descending">
                <ArrowDown className="h-4 w-4" />
                <span className="ml-1">Newest first</span>
              </ToggleGroupItem>
            </ToggleGroup>
          </div>
        )}

        {/* Search Status */}
        {searchState.isSearching && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Spinner className="h-4 w-4" />
            <span>Searching...</span>
          </div>
        )}

        {searchState.error && (
          <div className="text-sm text-destructive">
            Search failed. Please try again.
          </div>
        )}

        {debouncedQuery?.trim() && !searchState.isSearching && !searchState.hasResults && (
          <div className="text-sm text-muted-foreground">
            No results found for "{debouncedQuery}"
          </div>
        )}
      </div>

      {/* Session List */}
      <SessionList
        sessions={orderedSessions}
        onSessionClick={handleSessionClick}
      />
    </div>
  );
}
```

### 7. SessionList 히트 배지 표시

```typescript
// src/features/session/SessionList.tsx
import { Badge } from '@/components/ui/badge';

interface SessionListProps {
  sessions: SessionWithHits[];
  onSessionClick: (sessionId: string) => void;
}

function SessionList({ sessions, onSessionClick }: SessionListProps) {
  return (
    <div className="divide-y">
      {sessions.map((session) => (
        <div
          key={session.id}
          onClick={() => onSessionClick(session.id)}
          className="p-4 hover:bg-accent cursor-pointer"
        >
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <h3 className="font-medium">{session.name}</h3>
              <p className="text-sm text-muted-foreground line-clamp-1">
                {session.description}
              </p>
            </div>

            {/* Display search hit count if available */}
            {session.searchHits !== undefined && session.searchHits > 0 && (
              <Badge variant="secondary" className="ml-2">
                {session.searchHits} {session.searchHits === 1 ? 'hit' : 'hits'}
              </Badge>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

---

## 필요한 변경 파일 목록 (Files to Modify)

### 필수 변경

1. **Update**: `src/lib/rust-backend-client.ts`
   - `searchMessages`의 `sessionId` 파라미터를 optional로 변경하여 전역 검색 허용

   ```typescript
   export async function searchMessages(
     query: string,
     sessionId?: string, // Make optional
     page?: number,
     pageSize?: number,
   ): Promise<MessageSearchPage> {
     // ... implementation
   }
   ```

2. **Update**: `src/features/history/History.tsx`
   - 검색 UI 추가 (Input, ToggleGroup, Spinner)
   - SWR 통합 및 디바운스 로직 구현
   - 세션별 집계 및 정렬 로직 추가
   - Centralized logger 통합

3. **Update**: `src/features/session/SessionList.tsx`
   - `SessionWithHits` 인터페이스 지원
   - 히트 배지 표시 로직 추가

### 새 파일 추가

4. **Create**: `src/models/search.ts`
   - TypeScript 인터페이스 정의 (SearchAggregation, SessionWithHits, SortMode, SearchState)

5. **Create**: `src/hooks/useDebounced.ts`
   - 디바운스 훅 구현

### 선택적 변경 (향후 개선)

6. **Optional**: 백엔드에 `messages_search_aggregate` 명령 추가
   - 서버사이드 집계로 성능 개선
   - 대규모 데이터 처리 최적화

---

## 테스트 계획 (Testing Plan)

### 유닛 테스트 (Frontend)

1. **Aggregation Logic Test**

   ```typescript
   describe('Search Aggregation', () => {
     it('should aggregate messages by sessionId', () => {
       const mockMessages = [
         { sessionId: 'A', createdAt: new Date('2025-01-01') },
         { sessionId: 'A', createdAt: new Date('2025-01-02') },
         { sessionId: 'B', createdAt: new Date('2025-01-03') },
       ];

       const result = aggregateSearchResults(mockMessages);

       expect(result).toHaveLength(2);
       expect(result[0]).toMatchObject({ sessionId: 'A', count: 2 });
       expect(result[1]).toMatchObject({ sessionId: 'B', count: 1 });
     });

     it('should sort by count descending, then by timestamp descending', () => {
       // Test implementation
     });
   });
   ```

2. **Sorting Logic Test**

   ```typescript
   describe('Session Sorting', () => {
     it('should sort by date ascending when query is empty and sortMode is asc', () => {
       // Test implementation
     });

     it('should sort by date descending when query is empty and sortMode is desc', () => {
       // Test implementation
     });

     it('should sort by search hits when query is present', () => {
       // Test implementation
     });
   });
   ```

3. **Debounce Hook Test**

   ```typescript
   describe('useDebounced', () => {
     it('should debounce value by specified delay', async () => {
       // Use fake timers to test debouncing behavior
     });
   });
   ```

### 통합/수동 테스트

1. **검색 기능 테스트**
   - 검색어 입력 시 전역 검색이 수행되는지 확인
   - 검색 결과가 히트 수 기준으로 정렬되는지 확인
   - 검색어 변경 시 디바운스가 동작하는지 확인

2. **정렬 기능 테스트**
   - 검색어가 없을 때 날짜 정렬(asc/desc)이 동작하는지 확인
   - 정렬 토글 UI가 올바르게 표시되는지 확인

3. **UX 테스트**
   - 로딩 상태가 적절히 표시되는지 확인
   - 에러 상태가 적절히 표시되는지 확인
   - "No results" 메시지가 올바르게 표시되는지 확인
   - 히트 배지가 각 세션에 올바르게 표시되는지 확인

4. **성능 테스트**
   - SWR 캐시가 동작하여 중복 요청을 방지하는지 확인
   - 대량의 검색 결과에서도 UI가 반응성을 유지하는지 확인

### 검증 명령

```bash
# Run all tests
pnpm test

# Run full validation pipeline
pnpm refactor:validate

# Check TypeScript compilation
pnpm tsc --noEmit

# Run linter
pnpm lint

# Format code
pnpm format
```

---

## 롤아웃 및 운영 고려사항 (Rollout & Operations)

### 사용자 커뮤니케이션

- 검색 인덱스의 범위(최근 N개 메시지만)을 UI에 명확히 표시하여 사용자 기대를 관리한다.
- 검색 기능 도입 시 릴리스 노트에 사용법과 제한사항을 명시한다.

### 성능 모니터링

- Centralized logger를 통해 검색 쿼리, 응답 시간, 에러율을 모니터링한다.
- SWR 캐시 히트율을 추적하여 캐싱 효과를 측정한다.
- 검색 결과가 200개 이상 필요한 경우를 식별하여 향후 페이지네이션 도입을 고려한다.

### 점진적 개선 계획

1. **Phase 1 (Current)**: Frontend-side aggregation으로 빠른 가치 제공
2. **Phase 2**: 사용 패턴 분석 후 서버사이드 집계 API 도입 검토
3. **Phase 3**: 검색 결과 하이라이팅 및 컨텍스트 표시 추가
4. **Phase 4**: 고급 검색 필터 (날짜 범위, assistant 타입 등) 추가

### 에러 처리 및 복구

- 검색 실패 시 자동으로 기본 날짜 정렬 모드로 폴백
- 네트워크 오류 시 재시도 로직 (SWR 자동 재시도 활용)
- 에러 발생 시 사용자에게 명확한 메시지와 복구 방법 제시

---

## 작업 우선순위 체크리스트 (Task Priority Checklist)

### Priority 1: Core Functionality (필수)

- [ ] 1. `src/models/search.ts`: TypeScript 인터페이스 정의 추가
- [ ] 2. `src/hooks/useDebounced.ts`: 디바운스 훅 구현
- [ ] 3. `src/lib/rust-backend-client.ts`: `sessionId`를 optional로 변경 (non-breaking change)
- [ ] 4. `src/features/history/History.tsx`: 검색 UI + SWR + aggregation + orderedSessions 구현
- [ ] 5. `src/features/session/SessionList.tsx`: 히트 배지 prop 및 렌더링 추가

### Priority 2: Testing & Validation (필수)

- [ ] 6. 유닛 테스트 작성 (aggregation, sorting, debounce)
- [ ] 7. `pnpm refactor:validate` 실행 및 모든 검증 통과
- [ ] 8. 수동 통합 테스트 수행

### Priority 3: Documentation (권장)

- [ ] 9. 코드 주석을 영어로 작성 (CLAUDE.md 가이드라인 준수)
- [ ] 10. README 또는 CHANGELOG에 새 기능 문서화

### Priority 4: Future Improvements (선택)

- [ ] 11. Backend: `messages_search_aggregate` API 추가 (서버사이드 집계)
- [ ] 12. 검색 결과 하이라이팅 기능 추가
- [ ] 13. 고급 검색 필터 (날짜 범위, assistant 타입) 추가

---

## 작성자 노트 (Author's Note)

빠른 가치 제공을 위해 우선 프론트엔드 집계(frontend-side aggregation)를 먼저 적용하고, 실제 사용량과 성능을 측정한 후 백엔드 집계(backend-side aggregation)를 도입하는 흐름을 권장합니다.

현재 접근 방식의 장점:

- ✅ 빠른 구현 및 배포
- ✅ 기존 백엔드 API 활용
- ✅ 클라이언트 캐싱(SWR)으로 성능 최적화
- ✅ 점진적 개선 가능

향후 개선 시 고려사항:

- 서버사이드 집계로 대규모 데이터 처리 최적화
- 검색 인덱싱 전략 개선 (Full-text search engine 도입 검토)
- 실시간 검색 제안 (autocomplete) 추가

---

**Document Version**: 1.1
**Last Updated**: 2025-10-09
**Status**: Ready for Implementation
