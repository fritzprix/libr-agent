# Windows 경로 처리 크로스 플랫폼 호환성 개선 계획

**작성일:** 2025-10-12  
**문서 ID:** refactoring_20251012_1910  
**우선순위:** Critical (P0)  
**예상 작업 기간:** 2-3일

---

## 1. 작업의 목적

### 핵심 목표

Linux/macOS에서 정상 동작하는 파일 관리 기능(특히 `import_file`)이 Windows에서 실패하는 문제를 해결하여, 모든 플랫폼에서 일관된 사용자 경험을 제공한다.

### 배경

- Linux/macOS에서 검증 완료된 workspace 파일 관리 기능이 Windows에서 체계적으로 실패
- 주요 원인: 경로 구분자 차이(Unix `/` vs Windows `\`), 드라이브 문자 처리, 경로 파싱 불일치
- 사용자 보고: Windows에서 파일 드래그 앤 드롭 시 "Windows drive paths not allowed" 에러 발생

### 기대 효과

- Windows 사용자의 파일 import 성공률 100% 달성
- 크로스 플랫폼 경로 처리 표준화
- 에러 메시지 개선으로 디버깅 시간 단축
- 향후 경로 관련 버그 예방

---

## 2. 현재 상태 / 문제점

### 2.1 프론트엔드 경로 파싱 문제 (Critical)

**위치:** `src/features/chat/components/WorkspaceFilesPanel.tsx:256`

**현재 코드:**

```typescript
const fileName = srcPath.split('/').pop() || 'unknown';
```

**문제:**

- Windows 경로 (`C:\Users\user\file.txt`)를 `/`로만 split하여 백슬래시를 인식하지 못함
- 결과적으로 전체 경로가 파일명으로 추출됨
- 예시: `"C:\Users\user\Downloads\test.pdf"` → fileName = `"C:\Users\user\Downloads\test.pdf"` (전체 경로)

**영향:**

- `dest_rel_path`가 절대경로로 백엔드에 전달됨
- 백엔드의 드라이브 문자 검증에서 거부됨

### 2.2 백엔드 경로 검증 정책 문제 (Critical)

**위치:** `src-tauri/src/mcp/builtin/utils.rs:95-98`

**현재 코드:**

```rust
if user_path.len() >= 2 && user_path.chars().nth(1) == Some(':') {
    return Err(SecurityError::PathTraversal(format!(
        "Windows drive paths not allowed: '{user_path}'"
    )));
}
```

**문제:**

- `validate_path`가 Windows 드라이브 문자를 무조건 거부
- 설계상 목적지(dest) 경로만 검증해야 하는데, 여러 곳에서 무차별 사용
- `validate_path_for_read` (읽기 전용, 절대경로 허용)와 혼용

**영향:**

- import_file의 dest_rel_path에 절대경로가 전달되면 즉시 실패
- 일부 읽기 작업에서도 의도치 않게 절대경로 거부 가능

### 2.3 에러 메시지 불친절 (High)

**위치:** `src-tauri/src/mcp/builtin/workspace/file_operations.rs:651-661`

**현재 코드:**

```rust
let src_path = match std::path::Path::new(src_path_str).canonicalize() {
    Ok(path) => path,
    Err(e) => {
        error!("Invalid source path {}: {}", src_path_str, e);
        return Self::error_response(
            request_id,
            -32603,
            &format!("Invalid source path: {e}"),
        );
    }
};
```

**문제:**

- 에러 메시지에 입력값이 포함되지 않아 원인 파악 어려움
- Windows 경로 형식에 대한 힌트 없음
- 프론트엔드 경로 파싱 오류로 인한 실패와 실제 파일 없음을 구분 못함

### 2.4 경로 정규화 부재 (Medium)

**위치:**

- `src-tauri/src/mcp/builtin/workspace/export_operations.rs:160`
- `src-tauri/src/mcp/builtin/workspace/terminal_manager.rs:19-41`
- `src-tauri/src/mcp/builtin/workspace/mod.rs:81, 148, 262, 264, 367, 369`

**문제:**

- 단순 문자열 치환 (`replace("\\", "/")`)으로 혼합 구분자 처리 불완전
- 경로를 String으로 저장 후 PathBuf 변환 시 정규화 없음
- 크로스 플랫폼 호환성 저하

### 2.5 OS별 명령어 변환 없음 (Medium)

**위치:** `src-tauri/src/mcp/builtin/workspace/code_execution.rs:397-451`

**문제:**

- `normalize_shell_command`가 따옴표만 교정
- Unix 명령어(`ls`, `grep`)를 Windows 명령어로 변환하지 않음
- Windows 경로의 백슬래시 이스케이프 미처리

---

## 3. 관련 코드 구조 및 동작 방식 Summary

### 3.1 파일 Import 흐름 (Birdeye View)

```
[사용자 DnD]
    ↓
[Tauri DnD Handler]
    → paths: ["C:\Users\user\file.txt"]
    ↓
[WorkspaceFilesPanel.handleWorkspaceFileDrop]
    → srcPath parsing (문제 발생!)
    → fileName = srcPath.split('/').pop()
    → destRelPath = `${rootPath}/${fileName}`
    ↓
[callBuiltinTool('workspace', 'import_file')]
    → { src_abs_path: "C:\...", dest_rel_path: "C:\..." } (잘못된 dest!)
    ↓
[Rust Backend: handle_import_file]
    → canonicalize(src_abs_path) ✅
    → copy_file_from_external(src, dest)
        ↓
    [SecureFileManager.copy_file_from_external]
        → validate_path(dest_rel_path) ❌ 드라이브 문자 거부!
        ↓
    [SecurityValidator.validate_path]
        → Windows drive check: ':' 감지 → Error!
```

### 3.2 주요 컴포넌트 관계도

```
Frontend:
  WorkspaceFilesPanel.tsx
    ├── handleWorkspaceFileDrop() - 경로 파싱 (수정 필요)
    └── callBuiltinTool() - 백엔드 호출

Backend:
  file_operations.rs
    ├── handle_import_file() - 엔트리포인트 (에러 개선 필요)
    └── validate_path_with_error() - 검증 래퍼

  secure_file_manager.rs
    └── copy_file_from_external() - 실제 복사 로직
        └── validate_path() - dest 검증 (정책 명확화)

  utils.rs (SecurityValidator)
    ├── validate_path() - 쓰기용 (절대경로 금지)
    └── validate_path_for_read() - 읽기용 (절대경로 허용)
```

### 3.3 경로 검증 정책 (설계 의도)

| 함수                     | 용도        | 절대경로 | 드라이브 문자 | 상대경로 |
| ------------------------ | ----------- | -------- | ------------- | -------- |
| `validate_path`          | 쓰기/목적지 | ❌ 거부  | ❌ 거부       | ✅ 허용  |
| `validate_path_for_read` | 읽기/소스   | ✅ 허용  | ✅ 허용       | ✅ 허용  |

**현재 문제:** `validate_path`를 여러 곳에서 무차별 사용 → 용도별 구분 필요

---

## 4. 변경 이후의 상태 / 해결 판정 기준

### 4.1 성공 판정 기준

#### 기능적 요구사항

- [ ] Windows에서 파일 DnD import 성공률 100%
- [ ] Linux/macOS 기존 동작 유지 (regression 없음)
- [ ] 혼합 구분자 경로 (`C:\path/to\file`) 정상 처리
- [ ] ZIP export 시 경로 구조 정확성 유지

#### 비기능적 요구사항

- [ ] 에러 메시지에 입력 경로 표시 및 플랫폼별 힌트 제공
- [ ] 로그에 경로 정규화 전/후 기록
- [ ] 코드 리뷰 통과 (2명 이상 approve)

### 4.2 테스트 시나리오

#### 시나리오 1: Windows 파일 Import (Critical)

```
Given: Windows 환경, 파일 "C:\Users\user\Downloads\test.pdf" 준비
When: 파일을 Workspace Files Panel에 DnD
Then:
  - rootPath "./" 기준으로 "test.pdf" 생성
  - 채팅에 성공 메시지 표시
  - 파일 트리 자동 갱신
```

#### 시나리오 2: Linux 파일 Import (Regression 방지)

```
Given: Linux 환경, 파일 "/home/user/Downloads/test.pdf" 준비
When: 파일을 Workspace Files Panel에 DnD
Then:
  - 기존과 동일하게 동작
  - "test.pdf" 생성 성공
```

#### 시나리오 3: 절대경로 에러 메시지 (UX 개선)

```
Given: dest_rel_path에 절대경로 실수로 전달
When: import_file 호출
Then:
  - 에러 메시지: "Destination path must be relative to workspace. Got: 'C:\...' (absolute path not allowed)"
  - 로그에 입력값 전체 기록
```

#### 시나리오 4: ZIP Export 경로 정규화

```
Given: Windows에서 혼합 구분자 경로 파일들
When: export_zip 호출
Then:
  - ZIP 내부 경로가 모두 "/" 사용
  - 압축 해제 시 디렉토리 구조 정확
```

### 4.3 성능 기준

- 파일 import 시간: 이전 대비 +10% 이내 (경로 정규화 오버헤드)
- 메모리 사용량: 변화 없음

---

## 5. 수정이 필요한 코드 및 수정 부분 코드 스니펫

### 5.1 프론트엔드: 경로 파싱 수정 (P0 - Critical)

**파일:** `src/features/chat/components/WorkspaceFilesPanel.tsx`

**수정 위치:** 라인 256

**현재 코드:**

```typescript
const fileName = srcPath.split('/').pop() || 'unknown';
```

**수정 후 코드:**

```typescript
// OS-agnostic path parsing: support both / and \ separators
const fileName = srcPath.split(/[/\\]/).pop() || 'unknown';
```

**추가 개선 (선택):**

```typescript
// Alternative: normalize path first, then parse
const normalizedPath = srcPath.replace(/\\/g, '/');
const fileName = normalizedPath.split('/').pop() || 'unknown';
```

**영향 범위:**

- `handleWorkspaceFileDrop` 함수 내부
- Windows/Linux/macOS 모두 정상 동작

---

### 5.2 백엔드: 에러 메시지 개선 (P0 - Critical)

**파일:** `src-tauri/src/mcp/builtin/workspace/file_operations.rs`

**수정 위치:** 라인 651-661

**현재 코드:**

```rust
let src_path = match std::path::Path::new(src_path_str).canonicalize() {
    Ok(path) => path,
    Err(e) => {
        error!("Invalid source path {}: {}", src_path_str, e);
        return Self::error_response(
            request_id,
            -32603,
            &format!("Invalid source path: {e}"),
        );
    }
};
```

**수정 후 코드:**

```rust
let src_path = match std::path::Path::new(src_path_str).canonicalize() {
    Ok(path) => path,
    Err(e) => {
        error!("Failed to canonicalize source path '{}': {}", src_path_str, e);
        return Self::error_response(
            request_id,
            -32603,
            &format!(
                "Invalid source path: '{}'. {}. \
                 Please ensure the file exists and the path is correct. \
                 On Windows, use absolute paths like 'C:\\Users\\...'",
                src_path_str,
                e
            ),
        );
    }
};
```

**추가 로깅:**

```rust
tracing::debug!(
    "import_file called: src='{}', dest='{}'",
    src_path_str,
    dest_rel_path
);
```

---

### 5.3 백엔드: validate_path 용도 명확화 (P1 - High)

**파일:** `src-tauri/src/mcp/builtin/workspace/file_operations.rs`

**가이드라인:**

- **읽기 작업** (`handle_read_file`, `handle_grep`): `validate_path_for_read` 사용
- **쓰기 작업** (`handle_write_file`, `handle_replace_lines_in_file`): `validate_path` 사용
- **디렉토리 작업** (`handle_list_directory`, `handle_search_files`): 상황에 따라 선택

**수정 예시 (handle_grep, 라인 564):**

**현재 코드:**

```rust
match file_manager
    .get_security_validator()
    .validate_path(path_str)
{
    Ok(safe_path) => match tokio::fs::read_to_string(safe_path).await {
        // ...
    }
}
```

**수정 후 코드:**

```rust
match file_manager
    .get_security_validator()
    .validate_path_for_read(path_str)  // 읽기 전용이므로 변경
{
    Ok(safe_path) => match tokio::fs::read_to_string(safe_path).await {
        // ...
    }
}
```

**체크리스트:**

- [ ] handle_read_file (라인 66) - validate_path_for_read 적용 검토
- [ ] handle_grep (라인 564) - validate_path_for_read 적용
- [ ] handle_list_directory (라인 214) - 현재 상태 유지 (디렉토리는 워크스페이스 내부만)
- [ ] handle_search_files (라인 310) - 현재 상태 유지

---

### 5.4 백엔드: 경로 정규화 유틸리티 추가 (P1 - High)

**파일:** `src-tauri/src/mcp/builtin/workspace/utils.rs` (새로운 함수 추가)

**추가 코드:**

```rust
impl SecurityValidator {
    /// Normalize path separators to forward slashes for cross-platform compatibility.
    /// This is useful for storing paths in databases or ZIP archives.
    pub fn normalize_path_separators(path: &str) -> String {
        path.replace('\\', "/")
    }

    /// Extract filename from a path, supporting both / and \ separators.
    pub fn extract_filename(path: &str) -> Option<String> {
        let normalized = Self::normalize_path_separators(path);
        normalized.split('/').last().map(|s| s.to_string())
    }
}
```

**사용 예시:**

```rust
// In export_operations.rs:160
let archive_path = SecurityValidator::normalize_path_separators(&file_path);

// In terminal_manager.rs (if needed)
let filename = SecurityValidator::extract_filename(&stdout_path)
    .unwrap_or_else(|| "output".to_string());
```

---

### 5.5 백엔드: export_operations.rs 경로 정규화 (P2 - Medium)

**파일:** `src-tauri/src/mcp/builtin/workspace/export_operations.rs`

**수정 위치:** 라인 160

**현재 코드:**

```rust
let archive_path = file_path.replace("\\", "/");
```

**수정 후 코드:**

```rust
use crate::mcp::builtin::utils::SecurityValidator;

let archive_path = SecurityValidator::normalize_path_separators(file_path);
```

**또는 (Path API 사용):**

```rust
let archive_path = std::path::Path::new(file_path)
    .components()
    .filter_map(|c| match c {
        std::path::Component::Normal(s) => s.to_str(),
        _ => None,
    })
    .collect::<Vec<_>>()
    .join("/");
```

---

### 5.6 백엔드: SecurityError 메시지 개선 (P2 - Medium)

**파일:** `src-tauri/src/mcp/builtin/utils.rs`

**수정 위치:** 라인 95-98

**현재 코드:**

```rust
if user_path.len() >= 2 && user_path.chars().nth(1) == Some(':') {
    return Err(SecurityError::PathTraversal(format!(
        "Windows drive paths not allowed: '{user_path}'"
    )));
}
```

**수정 후 코드:**

```rust
if user_path.len() >= 2 && user_path.chars().nth(1) == Some(':') {
    return Err(SecurityError::PathTraversal(format!(
        "Absolute paths with drive letters are not allowed for destination paths: '{}'. \
         Please use relative paths like 'folder/file.txt'. \
         The file will be placed inside the workspace directory.",
        user_path
    )));
}
```

---

## 6. 재사용 가능한 연관 코드

### 6.1 경로 정규화 유틸리티

**위치:** `src-tauri/src/mcp/builtin/utils.rs`

**주요 기능:**

- `normalize_path_separators(path: &str) -> String` - 백슬래시를 슬래시로 변환
- `extract_filename(path: &str) -> Option<String>` - 플랫폼 무관 파일명 추출

**사용 예시:**

```rust
use crate::mcp::builtin::utils::SecurityValidator;

// ZIP archive paths
let archive_path = SecurityValidator::normalize_path_separators(&file_path);

// Filename extraction
let filename = SecurityValidator::extract_filename(&full_path)
    .unwrap_or_else(|| "unknown".to_string());
```

### 6.2 경로 검증 래퍼

**위치:** `src-tauri/src/mcp/builtin/workspace/file_operations.rs`

**기존 함수:**

```rust
fn validate_path_with_error(
    &self,
    path_str: &str,
    request_id: &Value,
) -> Result<std::path::PathBuf, Box<MCPResponse>>
```

**용도별 래퍼 추가 권장:**

```rust
fn validate_read_path_with_error(
    &self,
    path_str: &str,
    request_id: &Value,
) -> Result<std::path::PathBuf, Box<MCPResponse>> {
    let file_manager = self.get_file_manager();
    match file_manager
        .get_security_validator()
        .validate_path_for_read(path_str)  // 읽기용
    {
        Ok(path) => Ok(path),
        Err(e) => {
            error!("Read path validation failed: {}", e);
            Err(Box::new(Self::error_response(
                request_id.clone(),
                -32603,
                &format!("Security error: {e}"),
            )))
        }
    }
}
```

### 6.3 프론트엔드 경로 유틸리티 (선택적 추가)

**위치:** `src/lib/path-utils.ts` (신규 파일)

**제안 코드:**

```typescript
/**
 * Extract filename from a path, supporting both Unix and Windows separators.
 * @param path - Full file path
 * @returns Filename without directory path
 */
export function extractFilename(path: string): string {
  return path.split(/[/\\]/).pop() || 'unknown';
}

/**
 * Normalize path separators to forward slashes for cross-platform compatibility.
 * @param path - Path with mixed separators
 * @returns Path with forward slashes only
 */
export function normalizePath(path: string): string {
  return path.replace(/\\/g, '/');
}

/**
 * Check if a path is absolute (Windows or Unix style).
 * @param path - Path to check
 * @returns True if absolute path
 */
export function isAbsolutePath(path: string): boolean {
  // Windows: C:\ or \\server\share
  if (/^[A-Za-z]:[/\\]/.test(path) || /^\\\\/.test(path)) {
    return true;
  }
  // Unix: /path
  return path.startsWith('/');
}
```

**사용 예시:**

```typescript
import { extractFilename, normalizePath } from '@/lib/path-utils';

const fileName = extractFilename(srcPath);
const normalizedSrc = normalizePath(srcPath);
```

---

## 7. Test Code 추가 및 수정 가이드

### 7.1 프론트엔드 테스트

**파일:** `src/features/chat/components/WorkspaceFilesPanel.test.tsx` (신규)

**테스트 케이스:**

```typescript
describe('WorkspaceFilesPanel - Path Handling', () => {
  describe('handleWorkspaceFileDrop', () => {
    it('should extract filename from Windows path', () => {
      const windowsPath = 'C:\\Users\\user\\Downloads\\test.pdf';
      const fileName = windowsPath.split(/[/\\]/).pop();
      expect(fileName).toBe('test.pdf');
    });

    it('should extract filename from Unix path', () => {
      const unixPath = '/home/user/downloads/test.pdf';
      const fileName = unixPath.split(/[/\\]/).pop();
      expect(fileName).toBe('test.pdf');
    });

    it('should extract filename from mixed path', () => {
      const mixedPath = 'C:/Users/user\\Downloads\\test.pdf';
      const fileName = mixedPath.split(/[/\\]/).pop();
      expect(fileName).toBe('test.pdf');
    });

    it('should generate relative dest path correctly', () => {
      const rootPath = './';
      const fileName = 'test.pdf';
      const destPath = `${rootPath}/${fileName}`.replace(/\/+/g, '/');
      const destRelPath = destPath.startsWith('./')
        ? destPath.slice(2)
        : destPath;

      expect(destRelPath).toBe('test.pdf');
    });
  });
});
```

### 7.2 백엔드 테스트

**파일:** `src-tauri/src/mcp/builtin/workspace/file_operations.rs` (테스트 섹션)

**테스트 케이스:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_import_file_windows_absolute_src() {
        // Windows 절대경로 src는 허용되어야 함
        let src_path = "C:\\Users\\user\\test.pdf";
        let result = std::path::Path::new(src_path).is_absolute();
        assert!(result);
    }

    #[test]
    fn test_import_file_relative_dest() {
        // dest는 상대경로만 허용
        let dest_path = "imported/test.pdf";
        assert!(!dest_path.contains(':'));
        assert!(!std::path::Path::new(dest_path).is_absolute());
    }

    #[tokio::test]
    async fn test_validate_path_rejects_absolute_dest() {
        // Windows 절대경로는 dest에서 거부되어야 함
        let validator = SecurityValidator::new();
        let result = validator.validate_path("C:\\Users\\test.pdf");
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_validate_path_for_read_allows_absolute() {
        // 읽기용 검증은 절대경로 허용
        let validator = SecurityValidator::new();
        let result = validator.validate_path_for_read("/tmp/test.pdf");
        assert!(result.is_ok());
    }
}
```

**파일:** `src-tauri/src/mcp/builtin/utils.rs` (테스트 섹션)

**테스트 케이스 추가:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_path_separators() {
        let windows_path = "C:\\Users\\user\\file.txt";
        let normalized = SecurityValidator::normalize_path_separators(windows_path);
        assert_eq!(normalized, "C:/Users/user/file.txt");
    }

    #[test]
    fn test_extract_filename_windows() {
        let path = "C:\\Users\\user\\Downloads\\test.pdf";
        let filename = SecurityValidator::extract_filename(path);
        assert_eq!(filename, Some("test.pdf".to_string()));
    }

    #[test]
    fn test_extract_filename_unix() {
        let path = "/home/user/downloads/test.pdf";
        let filename = SecurityValidator::extract_filename(path);
        assert_eq!(filename, Some("test.pdf".to_string()));
    }

    #[test]
    fn test_extract_filename_mixed() {
        let path = "C:/Users/user\\Downloads\\test.pdf";
        let filename = SecurityValidator::extract_filename(path);
        assert_eq!(filename, Some("test.pdf".to_string()));
    }
}
```

### 7.3 통합 테스트

**파일:** `src-tauri/tests/import_file_integration.rs` (신규)

**테스트 시나리오:**

```rust
#[cfg(test)]
mod import_file_tests {
    use std::fs;
    use std::path::PathBuf;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_import_file_windows_to_workspace() {
        // Setup
        let temp_dir = TempDir::new().unwrap();
        let src_file = temp_dir.path().join("source.txt");
        fs::write(&src_file, "test content").unwrap();

        // Simulate Windows absolute path
        let src_abs = src_file.to_string_lossy().to_string();
        let dest_rel = "imported/source.txt";

        // Execute
        // (Call actual import_file function via MCP tool)

        // Assert
        // - File copied successfully
        // - dest_rel_path is relative
        // - Source file still exists
    }

    #[tokio::test]
    async fn test_import_file_rejects_absolute_dest() {
        // Setup
        let temp_dir = TempDir::new().unwrap();
        let src_file = temp_dir.path().join("source.txt");
        fs::write(&src_file, "test content").unwrap();

        let src_abs = src_file.to_string_lossy().to_string();

        #[cfg(target_os = "windows")]
        let dest_abs = "C:\\workspace\\imported.txt";

        #[cfg(not(target_os = "windows"))]
        let dest_abs = "/workspace/imported.txt";

        // Execute & Assert
        // (Should return error about absolute dest path)
    }
}
```

### 7.4 수동 테스트 체크리스트

#### Windows 환경

- [ ] 파일 DnD (Downloads → Workspace) - 성공
- [ ] 혼합 구분자 경로 처리 - 성공
- [ ] 한글 파일명 처리 - 성공
- [ ] 공백 포함 경로 처리 - 성공
- [ ] 에러 메시지 확인 - 명확함

#### Linux/macOS 환경

- [ ] 파일 DnD (기존 동작) - 성공
- [ ] 심볼릭 링크 처리 - 성공
- [ ] Regression 테스트 - 이상 없음

#### 크로스 플랫폼

- [ ] ZIP export 경로 구조 - 일관성 유지
- [ ] 로그 가독성 - 개선됨
- [ ] 성능 영향 - 허용 범위 내

---

## 8. 작업 우선순위 및 의존성

### Phase 1: Critical Path (P0) - 1일차

**목표:** Windows import 기능 복구

1. **프론트엔드 경로 파싱 수정** (30분)
   - `WorkspaceFilesPanel.tsx:256` 수정
   - 즉시 테스트 가능
   - 의존성: 없음

2. **백엔드 에러 메시지 개선** (1시간)
   - `file_operations.rs:651-661` 수정
   - 로깅 추가
   - 의존성: 없음

3. **수동 테스트 (Windows)** (2시간)
   - 실제 파일 import 시나리오
   - 에러 케이스 확인
   - 의존성: 1, 2 완료

### Phase 2: Path Validation Refactoring (P1) - 2일차

**목표:** 경로 검증 정책 명확화 및 정규화 유틸리티 추가

4. **경로 정규화 유틸리티 추가** (2시간)
   - `utils.rs`에 함수 추가
   - 단위 테스트 작성
   - 의존성: 없음

5. **validate_path 용도별 분리** (3시간)
   - `file_operations.rs` 읽기 작업 수정
   - `validate_read_path_with_error` 추가
   - 의존성: 4 완료

6. **export_operations.rs 경로 정규화** (1시간)
   - 유틸리티 함수 활용
   - 의존성: 4 완료

### Phase 3: Testing & Documentation (P2) - 3일차

**목표:** 테스트 커버리지 및 문서화

7. **단위 테스트 작성** (3시간)
   - 프론트엔드 테스트
   - 백엔드 테스트
   - 의존성: 1-6 완료

8. **통합 테스트 및 회귀 테스트** (2시간)
   - Linux/macOS 검증
   - 의존성: 7 완료

9. **문서 업데이트** (1시간)
   - README 수정
   - API 문서 업데이트
   - 의존성: 8 완료

---

## 9. 추가 분석 과제

### 9.1 경로 관련 추가 조사 필요 사항

1. **Tauri DnD 경로 형식 확인**
   - Tauri의 `FileDrop` 이벤트가 반환하는 경로 형식 검증
   - Windows/Linux/macOS별 실제 반환값 샘플링
   - 문서: `@tauri-apps/api/event` FileDrop 타입

2. **워크스페이스 경로 정책 재검토**
   - 현재 base_dir 설정 방식 (`SecurityValidator::new()`)
   - 세션별 워크스페이스 격리 정책
   - 심볼릭 링크 처리 방침

3. **code_execution 명령어 변환 전략**
   - Unix → Windows 명령어 매핑 테이블 작성
   - PowerShell vs CMD 선택 기준
   - LLM 프롬프트 수정 가능성 검토

### 9.2 성능 영향 분석

1. **경로 정규화 오버헤드 측정**
   - 대량 파일 import 시나리오 (100+ files)
   - 경로 정규화 전/후 시간 측정
   - 병목 지점 식별

2. **메모리 사용량 분석**
   - String 복사 vs 참조 사용
   - PathBuf 변환 최적화 여부

### 9.3 보안 영향 평가

1. **절대경로 허용 시 보안 리스크**
   - `validate_path_for_read`의 절대경로 허용 범위
   - 심볼릭 링크를 통한 경로 탐색 공격 가능성
   - Sandbox 환경에서의 제약사항

2. **경로 정규화 취약점**
   - 정규화 우회 시도 (예: `C:/Users/..\..\..\..\Windows`)
   - Unicode/특수문자 처리

---

## 10. 롤백 계획

### 10.1 롤백 트리거 조건

다음 중 하나라도 발생 시 즉시 롤백:

- [ ] Linux/macOS에서 기존 동작 실패 (regression)
- [ ] Windows 성공률 70% 미만
- [ ] 성능 저하 30% 이상
- [ ] 보안 취약점 발견

### 10.2 롤백 절차

1. **Git revert** (5분)

   ```bash
   git revert <commit-hash>
   git push origin main
   ```

2. **긴급 핫픽스 브랜치** (필요 시)

   ```bash
   git checkout -b hotfix/path-handling-rollback
   # 최소한의 수정으로 긴급 수정
   ```

3. **사용자 공지** (즉시)
   - Discord/Slack 공지
   - GitHub Issue 생성 및 상황 설명

---

## 11. 참고 자료

### 내부 문서

- [Chat Feature Architecture](../architecture/chat-feature-architecture.md)
- [Built-in Tools Documentation](../builtin-tools.md)
- [Tauri Commands API](../api/tauri-commands.md)

### 외부 참조

- [Rust std::path Documentation](https://doc.rust-lang.org/std/path/)
- [Tauri FileDrop Event](https://tauri.app/v1/api/js/event/#filedropevent)
- [Windows Path Formats](https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats)

### 관련 Issue/PR

- (추가 예정: 실제 issue 번호로 교체)
- #XXX - Windows 파일 import 실패 보고
- #YYY - 경로 처리 표준화 제안

---

## 12. 작업자 체크리스트

### 시작 전

- [ ] 프로젝트 빌드 성공 확인 (`pnpm tauri build`)
- [ ] 기존 테스트 통과 확인 (`pnpm test`)
- [ ] Windows 개발 환경 준비 (또는 VM/CI)
- [ ] 작업 브랜치 생성 (`git checkout -b fix/windows-path-handling`)

### 개발 중

- [ ] Phase 1 완료 후 Windows 테스트
- [ ] Phase 2 완료 후 Linux/macOS regression 테스트
- [ ] 각 단계별 커밋 (atomic commits)
- [ ] 로그 메시지 확인 (경로 정규화 전/후)

### 완료 후

- [ ] 모든 테스트 통과 (`pnpm refactor:validate`)
- [ ] 코드 리뷰 요청 (2명 이상)
- [ ] 문서 업데이트 확인
- [ ] CHANGELOG 업데이트
- [ ] 릴리스 노트 작성

---

**작성자:** GitHub Copilot  
**검토자:** (할당 예정)  
**승인자:** (할당 예정)

**변경 이력:**

- 2025-10-12 19:10 - 초안 작성
