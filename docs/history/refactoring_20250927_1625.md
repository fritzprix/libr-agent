# Refactoring Plan: Robust Browser Automation (Shadow DOM + Reliable Interaction)

Date: 2025-09-27 16:25
Author: SynapticFlow Dev Team

---

## 작업의 목적

브라우저 자동화 도구(`Click`, `Input`, `ExtractInteractable`, 기타 DOM 탐색/추출 도구`)의 실패율을 낮추고, 현대 웹앱에서 흔히 사용되는 Shadow DOM, 동적 렌더링(SPA), 오버레이/모달 등으로 인한 상호작용 문제를 해결합니다. 목적은 다음과 같습니다:

- Shadow DOM 내부 요소를 탐색·조작할 수 있도록 지원
- 요소 존재/상호작용 가능 상태를 기다리는(wait-and-retry) 전략 도입
- React/Vue 등 프레임워크와 호환되는 입력 방법(프로토타입 value 세터 사용, 이벤트 디스패치) 적용
- 실패 시 더 풍부한 진단정보 수집
- 백엔드(JS injection)와 프론트(TS tool wrappers) 양쪽에서 일관된 접근 제공

## 현재의 상태 / 문제점

요약:

- 대부분 도구가 `document.querySelector` / `querySelectorAll`에 의존하여 Shadow DOM 내부 요소를 찾지 못함
- 요소가 비동기적으로 렌더링될 때(데이터 로드, 애니메이션) 즉시 실패함 — 재시도/대기 로직 부재
- 텍스트 입력은 `el.value = ...`와 단순 이벤트 디스패치로 처리되어 프레임워크 바인딩을 우회하거나 무시될 가능성 있음
- 클릭은 `el.click()`/`dispatchEvent(new MouseEvent(...))` 위주라서 오버레이/포인터 이벤트 문제를 탐지하지 못함
- JS injection 결과가 성공(ok)으로 마킹되더라도 내부 클릭/입력 시도가 실제로 성공했는지 불명확

구체적 영향:

- 자동화 안정성 저하 (테스트/스크래핑/브라우저 도구에서 반복적 실패)
- 디버깅 난이도 증가(진단 로그가 충분치 않음)

## 관련 코드의 구조 및 동작 방식 (Bird's-eye)

- Frontend tools (TypeScript)
  - `src/features/tools/browser-tools/helpers.ts` — 현재 element state 검사, poll helper, result formatter 포함
  - `src/features/tools/browser-tools/ClickElementTool.ts` — 클릭 로직(상태검사 → `clickElement` backend 호출 → poll 결과)
  - `src/features/tools/browser-tools/InputTextTool.ts` — 입력 로직(상태검사 → `inputText` backend 호출 → poll 결과)
  - `src/features/tools/browser-tools/ExtractInteractableTool.ts` — 상호작용 가능한 요소 추출기
  - `src/features/tools/browser-tools/index.ts` — 도구 내보내기
- Backend (Rust / Tauri)
  - `src-tauri/src/services/interactive_browser_server.rs` — 실제 JS injection을 생성·실행. `click_element`, `input_text`, `execute_script`, `poll_script_result` 등 핵심 함수 포함

(더 자세한 파일 경로는 repo 루트의 `src/features/tools/browser-tools/`와 `src-tauri/src/services/interactive_browser_server.rs` 참조)

## 변경 이후의 상태 / 해결 판정 기준

목표 상태:

- `deepQuerySelector`/`waitForElement`가 모든 도구의 element lookup에 사용됨
- 클릭/입력 스크립트는 Shadow DOM을 탐색하며 요소가 interactable 해질 때까지 대기
- 입력은 프레임워크와 호환되는 방식으로 값이 정상 반영돼야 함(프로토타입 세터 사용)
- 실패 시 `ok:false`와 함께 상세한 `diagnostics`(obscuring element outerHTML, parent outerHTML, rect, pointerEvents, value_preview 등)를 반환

성공 기준 (자동 체크 가능한 기준):

1. Unit tests for `deepQuerySelector` and `waitForElement` pass (Vitest)
2. Integration test (simple SPA pages, and a page with Shadow DOM) where click/input previously failed now succeed >= 90% in CI run
3. No TypeScript or lint errors after changes (`pnpm lint`, `pnpm build` pass)
4. Backend tests for injected scripts return structured diagnostics and accurate success flags

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

아래는 핵심 변경 스니핏과 어느 파일에 적용할지에 대한 지침입니다. 실제 적용 시 기존 helper에 합치고 포맷, 주석에 맞춰 조정하세요.

1. `helpers.ts` — deepQuerySelector, waitForElement 추가

```typescript
// File: src/features/tools/browser-tools/helpers.ts
export function deepQuerySelector(
  selector: string,
  root: Document | ShadowRoot = document,
): Element | null {
  const el = root.querySelector(selector);
  if (el) return el;
  const all = root.querySelectorAll('*');
  for (const node of all) {
    const elNode = node as Element & { shadowRoot?: ShadowRoot };
    if (elNode.shadowRoot) {
      const found = deepQuerySelector(selector, elNode.shadowRoot);
      if (found) return found;
    }
  }
  return null;
}

export function waitForElement(
  selector: string,
  timeout = 5000,
): Promise<Element> {
  const start = Date.now();
  return new Promise((resolve, reject) => {
    const poll = setInterval(() => {
      try {
        const el = deepQuerySelector(selector);
        if (el) {
          const style = window.getComputedStyle(el);
          const rect = el.getBoundingClientRect();
          const visible =
            style.visibility !== 'hidden' &&
            style.display !== 'none' &&
            rect.width > 0 &&
            rect.height > 0;
          const disabled =
            (el as HTMLInputElement).disabled || el.hasAttribute('disabled');
          if (visible && !disabled) {
            clearInterval(poll);
            resolve(el);
            return;
          }
        }
      } catch (e) {
        // swallow and retry until timeout
      }
      if (Date.now() - start > timeout) {
        clearInterval(poll);
        reject(
          new Error(
            `Element "${selector}" not found or not interactable within ${timeout}ms`,
          ),
        );
      }
    }, 100);
  });
}
```

2. `ClickElementTool.ts` — selection과 pre-click 검사 변경 (execute -> backend 호출 전)

```typescript
// File: src/features/tools/browser-tools/ClickElementTool.ts
// ... existing imports ...
import { deepQuerySelector, waitForElement } from './helpers';

// inside execute: replace checkElementState usage or augment it
const el = await executeScript(
  sessionId,
  `(${waitForElement.toString()})(${JSON.stringify(selector)}, 5000)`,
);
// Or better: keep checkElementState but use deepQuerySelector inside its injected script
// Ensure backend click script also uses elementFromPoint to detect obscuring elements
```

> 권장: `checkElementState` 내부의 injected script를 deepQuerySelector 기반으로 교체하면 프론트와 백엔드 양쪽에서 일관성을 유지할 수 있음.

3. `InputTextTool.ts` — 안정적인 값 설정 (프레임워크 호환)

```typescript
// File: src/features/tools/browser-tools/InputTextTool.ts
// When performing the input, use prototype setter in injected JS or from backend
const valueSetter = Object.getOwnPropertyDescriptor(
  window.HTMLInputElement.prototype,
  'value',
)?.set;
if (valueSetter) valueSetter.call(el, inputText);
else el.value = inputText;
el.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
el.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
```

4. `ExtractInteractableTool.ts` — shadow DOM 지원

```typescript
// File: src/features/tools/browser-tools/ExtractInteractableTool.ts
// Replace document.querySelectorAll usage with a traversal using deepQuerySelector or recursive shadow root scanning
```

5. `interactive_browser_server.rs` (Rust) — injected script 변경

- `click_element`와 `input_text` JS 템플릿에서 `document.querySelector` → `deepQuerySelector` 정의 및 사용으로 교체
- `click_element`는 pre-check으로 `document.elementFromPoint(centerX, centerY)`를 사용하여 obscuring 요소를 진단하고, 실패 시 상세 diagnostics 반환
- `input_text` 템플릿은 prototype value setter 사용(브라우저 컨텍스트에서)과 입력 후 `el.value` 확인 로직을 추가

Rust 예시 스니핏 (개념):

```rust
let script = format!(r#"
(async function() {{
  function deepQuerySelector(selector, root) {{
    root = root || document;
    try {{
      const el = root.querySelector(selector);
      if (el) return el;
      const nodes = root.querySelectorAll('*');
      for (let i=0;i<nodes.length;i++){{
        const n = nodes[i];
        if (n.shadowRoot){{
          const found = deepQuerySelector(selector, n.shadowRoot);
          if (found) return found;
        }}
      }}
      return null;
    }} catch(e) {{ return null; }}
  }}

  const el = deepQuerySelector('{}');
  // ... rest of script using el ...
}})();
"#, selector_escaped);
```

> 주의: Rust 소스 내 문자열 이스케이프 및 큰 따옴표 처리에 유의

## 재사용 가능한 연관 코드 (파일 경로, 주요 기능)

- `src/features/tools/browser-tools/helpers.ts` — 공통 helper(추가 예정)
- `src/features/tools/browser-tools/ClickElementTool.ts` — 클릭 툴
- `src/features/tools/browser-tools/InputTextTool.ts` — 입력 툴
- `src/features/tools/browser-tools/ExtractInteractableTool.ts` — 상호작용 요소 추출
- `src-tauri/src/services/interactive_browser_server.rs` — 실제 JS injection 및 실행/응답 수집
- `src/lib/rust-backend-client.ts` — frontend <-> backend 래퍼 함수 (`clickElement`, `inputText`, `pollScriptResult`)

## Test Code 추가 및 수정 필요 부분에 대한 가이드 포함

1. Unit tests (Vitest)

- `helpers.deepQuerySelector()`
  - 정상: nested shadow roots 포함 페이지에서 selector를 찾는지
  - 실패: 없는 셀렉터 시 timeout 발생
- `helpers.waitForElement()`
  - element가 지연 렌더링될 때 resolve 여부
  - visible/disabled 조건 검증

2. Integration tests (lightweight headless or puppeteer-playwright harness)

- 샘플 페이지 A: React SPA에서 버튼 클릭/텍스트 입력 성공 여부
- 샘플 페이지 B: 커스텀 element + shadow root 내부의 입력/버튼
- 샘플 페이지 C: 오버레이가 잠시 나타나는 페이지 — obscured 진단 검증

3. Backend tests

- Rust unit tests for `execute_script` wrapper mocked behavior (if possible)
- Smoke tests calling Tauri commands `click_element`, `input_text` against a controlled test page hosted locally

4. Manual QA checklist

- Test on at least one real-world app (e.g., sample SPA) and capture screenshot/logs on failure
- Validate diagnostics for obscured elements include `outerHTML` snippets

## 파일 규칙

- 제안된 파일은 변경 전 반드시 `git branch`로 분리하여 작업
- 변경 내역은 `docs/history/refactoring_{yyyyMMdd_hhmm}.md` 형식으로 기록(본 파일이 그 목적)

## 수행 일정(예상)

- 분석·설계 (1일): 상세 코드별 영향도 확인 및 테스트 페이지 준비
- 구현 (2~3일): helpers + TS tool 변경, Rust JS template 업데이트
- 테스트·QA (1~2일): unit + integration + manual
- 리뷰·커밋·PR (0.5~1일)

총 예상: 4.5 ~ 7일 (컨텍스트, 리뷰 속도에 따라 변동)

## 위험요인 및 완화책

- Rust에서 긴 JS 템플릿 이스케이프 중 버그 유입 — mitigation: 단계별 로컬 검증, 작은 템플릿으로 나눠서 테스트
- 일부 사이트에서 보안 정책(CSP)으로 인젝션 실패 — mitigation: CSP 관련 캡처 및 대체 전략 문서화
- Synthetic event가 여전히 일부 프레임워크에서 무시될 가능성 — mitigation: per-character keyboard simulation 또는 브라우저 확장/patch 옵션 고려

## 검증 및 요구사항 커버리지

- Build: `pnpm build` — PASS required
- Lint: `pnpm lint` — PASS required
- Unit tests: vitest for helpers — PASS required
- Integration: sample pages script — PASS threshold >= 90%

---

### 체크리스트 (작업자용)

- [ ] 브랜치 생성: `fix/browser-deep-query-<yourname>`
- [ ] `helpers.ts`에 `deepQuerySelector`, `waitForElement` 추가
- [ ] `ClickElementTool.ts`, `InputTextTool.ts`, `ExtractInteractableTool.ts` 변경
- [ ] `src-tauri/src/services/interactive_browser_server.rs`의 click/input JS 템플릿 업데이트
- [ ] Unit tests 작성 및 실행
- [ ] Integration tests 실행 및 로그/스크린샷 확보
- [ ] `pnpm refactor:validate` 실행
- [ ] PR 생성 및 리뷰 요청

---

끝.
