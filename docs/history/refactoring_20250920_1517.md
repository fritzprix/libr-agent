# Refactoring Plan: AI Service Error Handling with User-Friendly Recovery UX

## 작업의 목적

AI 서비스 호출 시 발생하는 다양한 에러(MALFORMED_FUNCTION_CALL, JSON 파싱 오류, 네트워크 오류 등)에 대해 **malformed message가 채팅 히스토리에 추가되는 것을 방지**하고, 대신 **사용자 친화적인 에러 표시 및 재시도 UX**를 제공한다. 에러 정보는 로깅용과 사용자 표시용으로 구분하여 관리한다.

## 현재의 상태 / 문제점

### 1. Malformed Message 생성 문제

- **AI 서비스 에러**: MALFORMED_FUNCTION_CALL, "Incomplete JSON segment", 네트워크 오류 등 다양한 에러 발생
- **현재 처리**: 에러 발생 시에도 빈 content 또는 부분적인 content를 가진 메시지가 생성되어 채팅 히스토리에 추가됨
- **사용자 혼란**: 의미 없는 빈 메시지나 중단된 메시지가 채팅 창에 표시되어 사용자 경험 저하

### 2. 에러 처리 및 복구 기능 부재

- **MessageBubbleRouter**: 에러 메시지 분기 처리 없음
- **ErrorBubble 컴포넌트**: 존재하지 않음
- **Retry 기능**: 구현되지 않음
- **에러 정보 구분**: 로깅용 상세 에러와 사용자 표시용 메시지가 구분되지 않음

### 3. Message 타입 및 상태 관리 한계

```typescript
export interface Message {
  // 에러 상태를 나타내는 필드 없음
  // 사용자 친화적 에러 메시지와 기술적 에러 정보 구분 없음
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: MCPContent[];
  // ... 기타 필드
}
```

### 4. 핵심 문제: 에러 시 히스토리 오염

현재는 에러 발생 시에도 메시지가 생성되어 다음과 같은 문제 발생:

- 빈 assistant 메시지가 채팅 히스토리에 저장됨
- 사용자가 의미 있는 대화 흐름을 파악하기 어려움
- 에러 원인을 알 수 없어 재시도할 방법이 없음

## 관련 코드의 구조 및 동작 방식 Summary

### Birdeye View: 개선된 Message 처리 플로우

```text
useAIService → ChatContext → SessionHistoryContext → IndexedDB
     ↓              ↓              ↓
  Error 발생    Error 감지     Error Message 생성 (히스토리 추가)
     ↓              ↓              ↓
Error 분류     Retry UX 표시   사용자 친화적 에러 표시
     ↓              ↓              ↓
로깅 처리      재시도 실행     성공 시 정상 메시지로 교체
```

### 핵심 컴포넌트 구조

1. **메시지 렌더링 플로우**:

   ```text
   ChatMessages → MessageBubble → MessageBubbleRouter → ErrorBubble (신규)
   ```

2. **데이터 플로우**:

   ```text
   useAIService → ChatContext → SessionHistoryContext → IndexedDB (CRUD)
   ```

3. **상태 관리**:

   ```text
   SWR useSWRInfinite → 낙관적 업데이트 → 롤백 메커니즘
   ```

## 변경 이후의 상태 / 해결 판정 기준

### 1. 핵심 성공 기준

- ✅ **Malformed Message 방지**: 에러 발생 시 빈 content나 부분 메시지가 히스토리에 추가되지 않음
- ✅ **Error Message 표시**: 에러 발생 시 사용자 친화적인 에러 메시지가 포함된 Message 객체 생성
- ✅ **Retry UX 제공**: ErrorBubble을 통한 명확한 재시도 버튼 제공
- ✅ **성공 시 교체**: 재시도 성공 시 에러 메시지를 정상 응답으로 In-place 업데이트
- ✅ **에러 정보 분리**: 로깅용 상세 에러와 사용자 표시용 메시지 구분

### 2. 품질 기준

- **히스토리 무결성**: 의미 있는 메시지만 채팅 히스토리에 저장
- **사용자 경험**: 에러 상황에서도 명확한 가이드와 복구 방법 제공
- **성능 영향 최소화**: 정상 케이스의 성능 저하 없음
- **확장성**: 다양한 에러 타입에 대응 가능한 구조

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Message 타입 확장 (`src/models/chat.ts`)

```typescript
export interface Message {
  id: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: MCPContent[];
  tool_calls?: ToolCall[];
  tool_call_id?: string;
  isStreaming?: boolean;
  thinking?: string;
  thinkingSignature?: string;
  assistantId?: string;
  attachments?: AttachmentReference[];
  tool_use?: { id: string; name: string; input: Record<string, unknown> };
  createdAt?: Date;
  updatedAt?: Date;
  // 새로 추가할 필드
  error?: {
    // 사용자에게 표시될 친화적 메시지
    displayMessage: string;
    // 에러 타입 분류 (NETWORK_ERROR, API_ERROR, PARSING_ERROR 등)
    type: string;
    // 재시도 가능 여부
    recoverable: boolean;
    // 로깅용 상세 정보 (사용자에게 노출되지 않음)
    details?: {
      originalError: unknown;
      errorCode?: string;
      timestamp: string;
      context?: Record<string, unknown>;
    };
  };
}
```

### 2. 에러 분류 및 메시지 생성 유틸리티 (`src/lib/ai-service/error-handler.ts`)

```typescript
export interface ErrorClassification {
  displayMessage: string;
  type: string;
  recoverable: boolean;
  details: {
    originalError: unknown;
    errorCode?: string;
    timestamp: string;
    context?: Record<string, unknown>;
  };
}

export const classifyAIServiceError = (
  error: unknown,
  context?: Record<string, unknown>,
): ErrorClassification => {
  const timestamp = new Date().toISOString();

  // MALFORMED_FUNCTION_CALL 에러
  if (
    error instanceof Error &&
    error.message.includes('MALFORMED_FUNCTION_CALL')
  ) {
    return {
      displayMessage:
        'I encountered an issue while trying to use tools. Let me try again without tools.',
      type: 'MALFORMED_FUNCTION_CALL',
      recoverable: true,
      details: {
        originalError: error,
        errorCode: 'MALFORMED_FUNCTION_CALL',
        timestamp,
        context,
      },
    };
  }

  // JSON 파싱 에러
  if (
    error instanceof Error &&
    error.message.includes('Incomplete JSON segment')
  ) {
    return {
      displayMessage:
        'I had trouble processing the response. Please try again.',
      type: 'JSON_PARSING_ERROR',
      recoverable: true,
      details: {
        originalError: error,
        errorCode: 'INCOMPLETE_JSON',
        timestamp,
        context,
      },
    };
  }

  // 네트워크 에러
  if (
    error instanceof Error &&
    (error.message.includes('network') || error.message.includes('fetch'))
  ) {
    return {
      displayMessage:
        'Network connection issue. Please check your connection and try again.',
      type: 'NETWORK_ERROR',
      recoverable: true,
      details: {
        originalError: error,
        errorCode: 'NETWORK_FAILURE',
        timestamp,
        context,
      },
    };
  }

  // 기타 알 수 없는 에러
  return {
    displayMessage: 'Something went wrong. Please try again.',
    type: 'UNKNOWN_ERROR',
    recoverable: true,
    details: {
      originalError: error,
      errorCode: 'UNKNOWN',
      timestamp,
      context,
    },
  };
};
```

### 3. ErrorBubble 컴포넌트 신설 (`src/features/chat/ErrorBubble.tsx`)

```typescript
interface ErrorBubbleProps {
  message: Message;
  onRetry?: (messageId: string) => Promise<void>;
}

export const ErrorBubble: React.FC<ErrorBubbleProps> = ({ message, onRetry }) => {
  const [retrying, setRetrying] = useState(false);

  const handleRetry = async () => {
    if (!onRetry || !message.error?.recoverable) return;

    setRetrying(true);
    try {
      await onRetry(message.id);
    } finally {
      setRetrying(false);
    }
  };

  const getErrorIcon = (errorType: string) => {
    switch (errorType) {
      case 'NETWORK_ERROR':
        return <Wifi size={16} className="text-amber-600" />;
      case 'MALFORMED_FUNCTION_CALL':
        return <Tool size={16} className="text-blue-600" />;
      case 'JSON_PARSING_ERROR':
        return <FileX size={16} className="text-destructive" />;
      default:
        return <AlertTriangle size={16} className="text-destructive" />;
    }
  };

  const getErrorColor = (errorType: string) => {
    switch (errorType) {
      case 'NETWORK_ERROR':
        return 'border-amber-200 bg-amber-50';
      case 'MALFORMED_FUNCTION_CALL':
        return 'border-blue-200 bg-blue-50';
      case 'JSON_PARSING_ERROR':
        return 'border-destructive/20 bg-destructive/5';
      default:
        return 'border-destructive/20 bg-destructive/5';
    }
  };

  return (
    <BaseBubble
      title="Error"
      icon={getErrorIcon(message.error?.type || 'UNKNOWN_ERROR')}
      badge={
        <span className="px-2 py-1 bg-destructive text-destructive-foreground text-xs rounded-full">
          {message.error?.type}
        </span>
      }
      className={getErrorColor(message.error?.type || 'UNKNOWN_ERROR')}
    >
      <div className="space-y-3">
        <p className="text-muted-foreground">{message.error?.displayMessage}</p>
        {message.error?.recoverable && (
          <Button
            onClick={handleRetry}
            disabled={retrying}
            variant="outline"
            size="sm"
            className="flex items-center gap-2"
          >
            {retrying ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Retrying...
              </>
            ) : (
              <>
                <RefreshCw className="w-4 h-4" />
                Try Again
              </>
            )}
          </Button>
        )}
      </div>
    </BaseBubble>
  );
};
```

          >
            {retrying ? 'Retrying...' : 'Retry'}
          </Button>
        )}
      </div>
    </BaseBubble>

);
};

````

### 3. MessageBubbleRouter 확장 (`src/features/chat/MessageBubbleRouter.tsx`)

```typescript
const MessageBubbleRouter: React.FC<MessageBubbleRouterProps> = ({
  message,
}) => {
  // 에러 메시지 분기 추가
  if (message.error) {
    return <ErrorBubble message={message} onRetry={onRetryMessage} />;
  }

  if (
    message.tool_calls &&
    Array.isArray(message.tool_calls) &&
    message.tool_calls.length > 0 &&
    message.tool_calls.every((tc) => tc && tc.function && tc.function.name)
  ) {
    return <ToolCallBubble tool_calls={message.tool_calls} />;
  }

  if (message.role === 'tool') {
    return <ToolOutputBubble message={message} />;
  }

  return <ContentBubble message={message} />;
};
````

### 4. useAIService 에러 처리 개선 (`src/hooks/use-ai-service.ts`)

```typescript
} catch (err) {
  logger.error('Error in useAIService stream:', err);
  setError(err as Error);

  // 에러 메시지 생성
  const errorMessage: Message = {
    id: currentResponseId,
    content: stringToMCPContentArray(''),
    role: 'assistant',
    sessionId: messages[0]?.sessionId || '',
    isStreaming: false,
    error: {
      code: getErrorCode(err),
      message: getErrorMessage(err),
      recoverable: isRecoverableError(err),
      originalError: err
    }
  };

  setResponse(errorMessage);
  return errorMessage;
}

// 헬퍼 함수들
const getErrorCode = (error: unknown): string => {
  if (error instanceof Error) {
    if (error.message.includes('MALFORMED_FUNCTION_CALL')) return 'MALFORMED_FUNCTION_CALL';
    if (error.message.includes('Incomplete JSON segment')) return 'INCOMPLETE_JSON';
  }
  return 'UNKNOWN_ERROR';
};

const isRecoverableError = (error: unknown): boolean => {
  const code = getErrorCode(error);
  return ['MALFORMED_FUNCTION_CALL', 'INCOMPLETE_JSON'].includes(code);
};
```

### 5. ChatContext에 Retry 로직 추가 (`src/context/ChatContext.tsx`)

```typescript
const retryMessage = useCallback(
  async (messageId: string): Promise<void> => {
    const messageToRetry = messages.find((m) => m.id === messageId);
    if (!messageToRetry?.error) return;

    logger.info('Retrying failed message', { messageId });

    try {
      // 에러 메시지 이전의 메시지들을 찾아서 재전송
      const messageIndex = messages.findIndex((m) => m.id === messageId);
      const previousMessages = messages.slice(0, messageIndex);

      // 도구 없이 재시도 (MALFORMED_FUNCTION_CALL 회피)
      const retryConfig = {
        ...aiServiceConfig,
        tools: [], // 도구 제거하여 재시도
      };

      const response = await triggerAIServiceWithConfig(
        previousMessages,
        buildSystemPrompt,
        retryConfig,
      );

      if (response) {
        // 성공 시 에러 메시지를 정상 메시지로 업데이트
        await updateMessage(messageId, {
          error: undefined,
          content: response.content,
          tool_calls: response.tool_calls,
          thinking: response.thinking,
          isStreaming: false,
        });
      }
    } catch (error) {
      logger.error('Retry failed', { messageId, error });
      // 재시도 실패 시 에러 메시지 업데이트
      await updateMessage(messageId, {
        error: {
          code: 'RETRY_FAILED',
          message: 'Retry attempt failed. Please try again.',
          recoverable: true,
        },
      });
    }
  },
  [messages, triggerAIService, buildSystemPrompt, updateMessage],
);
```

## 재사용 가능한 연관 코드

### 1. 기존 컴포넌트 재사용

- **`BaseBubble`** (`src/components/ui/BaseBubble.tsx`): ErrorBubble의 기본 UI 구조
- **`MessageBubbleRouter`** (`src/features/chat/MessageBubbleRouter.tsx`): 메시지 타입별 라우팅 로직
- **`SessionHistoryContext`** (`src/context/SessionHistoryContext.tsx`): `updateMessage` 함수

### 2. 유틸리티 함수 재사용

- **`stringToMCPContentArray`** (`src/lib/utils.ts`): 에러 메시지 content 변환
- **`createId`** (`@paralleldrive/cuid2`): 고유 ID 생성
- **`getLogger`** (`src/lib/logger.ts`): 로깅

### 3. 스타일링 재사용

- **Tailwind CSS 클래스**: 기존 버블 컴포넌트의 색상/레이아웃 패턴
- **Lucide 아이콘**: `AlertTriangle`, `RefreshCw` 등

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 단위 테스트 (`src/features/chat/__tests__/`)

```typescript
// ErrorBubble.test.tsx
describe('ErrorBubble', () => {
  it('should display error message correctly', () => {
    const message = createMockErrorMessage();
    render(<ErrorBubble message={message} />);
    expect(screen.getByText(message.error.message)).toBeInTheDocument();
  });

  it('should call onRetry when retry button is clicked', async () => {
    const onRetry = jest.fn();
    const message = createMockRecoverableErrorMessage();
    render(<ErrorBubble message={message} onRetry={onRetry} />);

    fireEvent.click(screen.getByText('Retry'));
    expect(onRetry).toHaveBeenCalledWith(message.id);
  });
});

// MessageBubbleRouter.test.tsx
describe('MessageBubbleRouter', () => {
  it('should render ErrorBubble for error messages', () => {
    const errorMessage = createMockErrorMessage();
    render(<MessageBubbleRouter message={errorMessage} />);
    expect(screen.getByText('Error Occurred')).toBeInTheDocument();
  });
});
```

### 2. 통합 테스트 (`src/hooks/__tests__/`)

```typescript
// use-ai-service.test.ts
describe('useAIService error handling', () => {
  it('should create error message when MALFORMED_FUNCTION_CALL occurs', async () => {
    const mockError = new Error('MALFORMED_FUNCTION_CALL detected');
    // AIService 모킹하여 에러 발생 시뮬레이션
    // 에러 메시지 생성 및 반환 검증
  });

  it('should mark error as recoverable for known error types', async () => {
    // 복구 가능한 에러 타입들에 대한 테스트
  });
});
```

### 3. E2E 테스트 시나리오

```typescript
// chat-error-recovery.e2e.ts
describe('Chat Error Recovery', () => {
  it('should show error message and allow retry', async () => {
    // 1. 에러 발생 상황 시뮬레이션
    // 2. ErrorBubble 표시 확인
    // 3. Retry 버튼 클릭
    // 4. 성공 메시지로 교체 확인
    // 5. DB에 정상 메시지 저장 확인
  });
});
```

### 4. 모킹 전략

```typescript
// test-utils/mocks.ts
export const createMockErrorMessage = (): Message => ({
  id: 'error_123',
  role: 'assistant',
  content: [],
  sessionId: 'session_123',
  error: {
    code: 'MALFORMED_FUNCTION_CALL',
    message:
      'The AI model generated an invalid function call. Please try again.',
    recoverable: true,
  },
});

export const mockAIServiceError = () => {
  // Gemini API 에러 시뮬레이션
};
```

## 추가 분석 과제

### 1. 성능 영향 분석

- 에러 메시지 저장/업데이트가 정상 메시지 처리 성능에 미치는 영향
- SWR 캐시 무효화 빈도 분석

### 2. 동시성 이슈 심화 분석

- 스트리밍 중 에러 발생 시 상태 동기화 문제
- 빠른 연속 Retry 요청 시 Race Condition 가능성

### 3. 사용자 경험 최적화

- 에러 메시지 표시 타이밍 및 애니메이션
- 자동 재시도 vs 수동 재시도 정책 결정

### 4. 확장성 고려사항

- 다른 AI 프로바이더의 에러 처리 통합 방안
- 에러 유형별 커스텀 복구 전략 구현

---

**작업 우선순위**: Message 타입 확장 → ErrorBubble 컴포넌트 → MessageBubbleRouter 수정 → useAIService 에러 처리 → ChatContext Retry 로직 → 테스트 코드 추가

**예상 작업 시간**: 2-3일 (설계 1일, 구현 1일, 테스트 1일)
