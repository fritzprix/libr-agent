# WebView Crawler를 Interactive Browser Agent로 확장 리팩토링 계획

## 작업의 목적

현재의 WebView Crawler를 확장하여 Side Drawer에서 실행되는 Interactive Browser Agent를 구현합니다. 이를 통해 AI 에이전트가 단순한 페이지 크롤링을 넘어서 실제 브라우저 상호작용(클릭, 입력, 스크롤 등)을 수행할 수 있도록 합니다.

### 주요 목표

1. **Side Drawer Browser UI**: 사용    /// 브라우저 WebView 생성 (Tauri multiwebview 패턴 사용)
    async fn create_browser_webview(
        &self, 
        session_id: &str, 
        url: &str, 
        title: &str
    ) -> Result<WebviewWindow, String> {
        // 메인 윈도우 가져오기
        let main_window = self.app_handle
            .get_window("main")
            .ok_or("Main window not found")?;

        // WebviewBuilder로 child webview 생성 (GitHub 예제 패턴)
        let webview_builder = tauri::webview::WebviewBuilder::new(
            session_id,
            tauri::WebviewUrl::External(url.parse().map_err(|e| format!("Invalid URL: {}", e))?)
        )
        .auto_resize(); // 자동 리사이징 활성화

        // Side Drawer 영역에 webview 추가 (우측 400px 폭)
        let window_size = main_window.inner_size().map_err(|e| format!("Failed to get window size: {}", e))?;
        let drawer_width = 400.0;
        let drawer_height = window_size.height as f64;

        let webview = main_window.add_child(
            webview_builder,
            tauri::LogicalPosition::new(window_size.width as f64 - drawer_width, 0.0),
            tauri::LogicalSize::new(drawer_width, drawer_height),
        )
        .map_err(|e| format!("Failed to create child webview: {}", e))?;

        // WebviewWindow 래퍼 생성
        let webview_window = WebviewWindow {
            window: main_window,
            webview,
        };

        Ok(webview_window)
    }할 수 있는 인터페이스
2. **DOM Event Generation**: AI가 실제 웹 페이지와 상호작용할 수 있는 도구들
3. **Multi-Session Management**: 여러 브라우저 세션을 동시에 관리
4. **Real-time Interaction**: 실시간으로 브라우저 자동화 과정을 관찰

## 현재의 상태 / 문제점

### 현재 WebView Crawler의 한계

```rust
// src-tauri/src/mcp/builtin/webview_crawler.rs (현재 상태)
pub struct WebViewCrawlerServer {
    app_handle: AppHandle,
    active_crawlers: Arc<Mutex<HashMap<String, CrawlerInstance>>>,
}

// 현재는 단순한 크롤링만 가능
async fn handle_crawl_page(&self, args: Value) -> MCPResponse {
    // 1. 숨겨진 WebView 생성
    // 2. 페이지 로드
    // 3. HTML 추출 후 즉시 종료
    // 4. 상호작용 불가능
}
```

### 주요 문제점

1. **일회성 크롤링**: WebView가 크롤링 후 즉시 종료됨
2. **숨겨진 실행**: 사용자가 크롤링 과정을 볼 수 없음
3. **제한된 상호작용**: HTML 추출만 가능, DOM 조작 불가능
4. **세션 관리 부재**: 연속적인 브라우저 작업 불가능
5. **시각적 피드백 없음**: 자동화 과정을 디버깅하기 어려움

## 변경 이후의 상태 / 해결 판정 기준

### 달성할 목표 상태

#### 1. Interactive Browser Agent 시스템

```rust
// 새로운 구조
pub struct InteractiveBrowserServer {
    app_handle: AppHandle,
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,
    ui_manager: BrowserUIManager,
}

struct BrowserSession {
    webview: WebviewWindow,
    session_id: String,
    url: String,
    event_listeners: Vec<String>,
    automation_queue: VecDeque<AutomationTask>,
    created_at: std::time::Instant,
    last_activity: std::time::Instant,
}
```

#### 2. 새로운 MCP 도구들

- `start_browser_session`: Side Drawer에 브라우저 세션 시작
- `click_element`: CSS 셀렉터로 요소 클릭
- `fill_input`: 입력 필드에 텍스트 입력
- `scroll`: 페이지 스크롤 (up/down/top/bottom)
- `send_keys`: 키보드 이벤트 전송
- `wait_for`: 특정 조건까지 대기
- `take_screenshot`: 현재 페이지 스크린샷
- `extract_data`: 페이지에서 데이터 추출

#### 3. Side Drawer UI 컴포넌트

```typescript
// 새로운 UI 컴포넌트들
- BrowserDrawer: 메인 브라우저 패널
- BrowserPanel: 개별 브라우저 세션
- BrowserToolbar: 네비게이션 및 도구 모음
- SessionTabs: 멀티 세션 관리
- AutomationLog: 자동화 액션 로그
```

### 성공 판정 기준

1. ✅ Side Drawer에서 브라우저 세션이 정상적으로 표시됨
2. ✅ AI 에이전트가 웹 페이지와 상호작용 가능 (클릭, 입력, 스크롤)
3. ✅ 여러 브라우저 세션을 동시에 관리 가능
4. ✅ 사용자가 자동화 과정을 실시간으로 관찰 가능
5. ✅ 기존 크롤링 기능이 그대로 유지됨

## GitHub 예제 참고 사항

### Tauri Multiwebview 공식 예제 분석

**참고 링크**: https://github.com/tauri-apps/tauri/tree/dev/examples/multiwebview

#### 핵심 패턴

1. **메인 윈도우에 자식 WebView 추가**:
   ```rust
   let webview = window.add_child(
       tauri::webview::WebviewBuilder::new("label", WebviewUrl::External(url))
           .auto_resize(),
       LogicalPosition::new(x, y),
       LogicalSize::new(width, height),
   )?;
   ```

2. **위치와 크기 지정**:
   - `LogicalPosition`: WebView의 시작 위치 (x, y)
   - `LogicalSize`: WebView의 크기 (width, height)
   - `auto_resize()`: 부모 윈도우 크기 변경시 자동 조정

3. **다중 WebView 관리**:
   - 각 WebView는 고유한 `label`로 식별
   - 같은 윈도우 내에서 여러 WebView를 격자형으로 배치 가능

### 실제 사용 예시 (GitHub 예제 기반)

```rust
// GitHub 예제에서 영감을 받은 실제 구현
fn setup_interactive_browser(app: &AppHandle) -> Result<(), Box<dyn std::error::Error>> {
    let main_window = app.get_window("main").unwrap();
    let window_size = main_window.inner_size()?;
    
    // Side Drawer 영역 계산 (우측 30% 공간)
    let drawer_width = (window_size.width as f64 * 0.3).max(300.0);
    let drawer_x = window_size.width as f64 - drawer_width;
    
    // 첫 번째 브라우저 세션 생성
    let session1 = main_window.add_child(
        tauri::webview::WebviewBuilder::new(
            "browser-session-1",
            tauri::WebviewUrl::External("https://www.google.com".parse()?)
        )
        .auto_resize(),
        tauri::LogicalPosition::new(drawer_x, 0.0),
        tauri::LogicalSize::new(drawer_width, window_size.height as f64),
    )?;
    
    Ok(())
}
```

### AI 에이전트 워크플로우 예시

```typescript
// AI가 GitHub에서 이슈를 생성하는 자동화 워크플로우
async function automateGitHubIssue() {
    // 1. 브라우저 세션 시작
    const session = await startBrowserSession({
        url: 'https://github.com/myrepo/issues',
        session_name: 'GitHub Issue Creation'
    });
    
    // 2. 로그인 페이지로 이동 (필요시)
    await clickElement({ 
        session_id: session.id, 
        selector: '.header-nav-link[href="/login"]' 
    });
    
    // 3. 새 이슈 생성 버튼 클릭
    await clickElement({ 
        session_id: session.id, 
        selector: 'a[href$="/issues/new"]' 
    });
    
    // 4. 이슈 제목 입력
    await fillInput({ 
        session_id: session.id, 
        selector: '#issue_title', 
        value: 'Bug: WebView integration issue' 
    });
    
    // 5. 이슈 내용 입력
    await fillInput({ 
        session_id: session.id, 
        selector: '#issue_body', 
        value: 'Found an issue with multiwebview implementation...' 
    });
    
    // 6. 라벨 추가
    await clickElement({ 
        session_id: session.id, 
        selector: '.js-issue-labels button' 
    });
    
    // 7. 스크롤하여 submit 버튼 찾기
    await scroll({ 
        session_id: session.id, 
        direction: 'down', 
        amount: 300 
    });
    
    // 8. 이슈 생성
    await clickElement({ 
        session_id: session.id, 
        selector: 'button[type="submit"]' 
    });
    
    // 9. 생성 완료 대기
    await waitFor({ 
        session_id: session.id, 
        condition: 'document.querySelector(".timeline-comment")', 
        timeout: 5000 
    });
}
```


### 1. Backend: Interactive Browser Server 구현

#### 파일: `src-tauri/src/mcp/builtin/interactive_browser.rs` (신규 생성)

```rust
use crate::mcp::{builtin::BuiltinMCPServer, MCPResponse, MCPTool};
use serde_json::{json, Value};
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tauri::{AppHandle, Manager, WebviewWindow};
use tokio::sync::Mutex;
use uuid::Uuid;

pub struct InteractiveBrowserServer {
    app_handle: AppHandle,
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,
}

#[derive(Debug)]
struct BrowserSession {
    webview: WebviewWindow,
    session_id: String,
    url: String,
    automation_queue: VecDeque<AutomationTask>,
    created_at: std::time::Instant,
}

#[derive(Debug)]
struct AutomationTask {
    task_id: String,
    action: BrowserAction,
    timestamp: std::time::Instant,
}

#[derive(Debug)]
enum BrowserAction {
    Click { selector: String },
    FillInput { selector: String, value: String },
    Scroll { direction: String, amount: i32 },
    SendKeys { keys: String, selector: Option<String> },
    Navigate { url: String },
    Screenshot,
}

impl InteractiveBrowserServer {
    pub fn new(app_handle: AppHandle) -> Self {
        Self {
            app_handle,
            browser_sessions: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// 새로운 브라우저 세션 시작
    async fn handle_start_browser_session(&self, args: Value) -> MCPResponse {
        let session_id = Uuid::new_v4().to_string();
        let url = args.get("url").and_then(|v| v.as_str()).unwrap_or("about:blank");
        let session_name = args.get("session_name").and_then(|v| v.as_str())
            .unwrap_or("Browser Session");

        // Side Drawer에 WebView 생성
        match self.create_browser_webview(&session_id, url, session_name).await {
            Ok(webview) => {
                let session = BrowserSession {
                    webview,
                    session_id: session_id.clone(),
                    url: url.to_string(),
                    automation_queue: VecDeque::new(),
                    created_at: std::time::Instant::now(),
                };

                self.browser_sessions.lock().await.insert(session_id.clone(), session);

                MCPResponse::success(json!({
                    "session_id": session_id,
                    "url": url,
                    "status": "started"
                }))
            }
            Err(e) => MCPResponse::error(&format!("Failed to create browser session: {}", e))
        }
    }

    /// DOM 요소 클릭
    async fn handle_click_element(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let selector = args.get("selector").and_then(|v| v.as_str()).unwrap_or_default();

        let script = format!(r#"
            (function() {{
                const element = document.querySelector('{}');
                if (element) {{
                    element.click();
                    return {{
                        success: true,
                        tagName: element.tagName,
                        text: element.textContent?.slice(0, 100) || '',
                        rect: element.getBoundingClientRect()
                    }};
                }}
                return {{ success: false, error: 'Element not found' }};
            }})()
        "#, selector.replace("'", "\\'"));

        self.execute_script(session_id, &script).await
    }

    /// 입력 필드 채우기
    async fn handle_fill_input(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let selector = args.get("selector").and_then(|v| v.as_str()).unwrap_or_default();
        let value = args.get("value").and_then(|v| v.as_str()).unwrap_or_default();

        let script = format!(r#"
            (function() {{
                const input = document.querySelector('{}');
                if (input) {{
                    input.value = '{}';
                    input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                    input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                    return {{
                        success: true,
                        value: input.value,
                        type: input.type || 'text'
                    }};
                }}
                return {{ success: false, error: 'Input element not found' }};
            }})()
        "#, selector.replace("'", "\\'"), value.replace("'", "\\'"));

        self.execute_script(session_id, &script).await
    }

    /// 스크롤 액션
    async fn handle_scroll(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let direction = args.get("direction").and_then(|v| v.as_str()).unwrap_or("down");
        let amount = args.get("amount").and_then(|v| v.as_i64()).unwrap_or(300);

        let script = match direction {
            "up" => format!(
                "window.scrollBy(0, -{}); return {{ scrollY: window.scrollY, direction: 'up' }};",
                amount
            ),
            "down" => format!(
                "window.scrollBy(0, {}); return {{ scrollY: window.scrollY, direction: 'down' }};",
                amount
            ),
            "top" => "window.scrollTo(0, 0); return { scrollY: window.scrollY, direction: 'top' };".to_string(),
            "bottom" => "window.scrollTo(0, document.body.scrollHeight); return { scrollY: window.scrollY, direction: 'bottom' };".to_string(),
            _ => "return { error: 'Invalid direction. Use: up, down, top, bottom' };".to_string(),
        };

        self.execute_script(session_id, &script).await
    }

    /// JavaScript 실행 헬퍼
    async fn execute_script(&self, session_id: &str, script: &str) -> MCPResponse {
        let sessions = self.browser_sessions.lock().await;
        if let Some(session) = sessions.get(session_id) {
            match session.webview.eval(script) {
                Ok(_) => MCPResponse::success(json!({
                    "session_id": session_id,
                    "executed": true
                })),
                Err(e) => MCPResponse::error(&format!("Script execution failed: {}", e))
            }
        } else {
            MCPResponse::error("Session not found")
        }
    }

    /// 브라우저 WebView 생성
    async fn create_browser_webview(
        &self,
        session_id: &str,
        url: &str,
        title: &str
    ) -> Result<WebviewWindow, String> {
        // Side Drawer에 표시될 WebView 생성
        let webview = tauri::WebviewWindowBuilder::new(
            &self.app_handle,
            session_id,
            tauri::WebviewUrl::External(url.parse().map_err(|e| format!("Invalid URL: {}", e))?)
        )
        .title(title)
        .inner_size(400.0, 600.0)
        .build()
        .map_err(|e| format!("Failed to create webview: {}", e))?;

        Ok(webview)
    }
}

#[async_trait::async_trait]
impl BuiltinMCPServer for InteractiveBrowserServer {
    fn name(&self) -> &str {
        "interactive_browser"
    }

    fn description(&self) -> &str {
        "Interactive browser automation with visual feedback in side drawer"
    }

    fn tools(&self) -> Vec<MCPTool> {
        vec![
            MCPTool {
                name: "start_browser_session".to_string(),
                description: "Start a new interactive browser session in side drawer".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "url": {"type": "string", "description": "Initial URL to load"},
                        "session_name": {"type": "string", "description": "Name for this browser session"}
                    },
                    "required": ["url"]
                }),
            },
            MCPTool {
                name: "click_element".to_string(),
                description: "Click on a DOM element using CSS selector".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "selector": {"type": "string", "description": "CSS selector for the element to click"}
                    },
                    "required": ["session_id", "selector"]
                }),
            },
            MCPTool {
                name: "fill_input".to_string(),
                description: "Fill an input field with text".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "selector": {"type": "string", "description": "CSS selector for the input field"},
                        "value": {"type": "string", "description": "Text to enter"}
                    },
                    "required": ["session_id", "selector", "value"]
                }),
            },
            MCPTool {
                name: "scroll".to_string(),
                description: "Scroll the page in various directions".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "direction": {"type": "string", "enum": ["up", "down", "top", "bottom"], "default": "down"},
                        "amount": {"type": "number", "default": 300}
                    },
                    "required": ["session_id"]
                }),
            },
        ]
    }

    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
        match tool_name {
            "start_browser_session" => self.handle_start_browser_session(args).await,
            "click_element" => self.handle_click_element(args).await,
            "fill_input" => self.handle_fill_input(args).await,
            "scroll" => self.handle_scroll(args).await,
            _ => MCPResponse::error(&format!("Unknown tool: {}", tool_name)),
        }
    }
}
```

### 2. Frontend: Browser UI 컴포넌트 구현

#### 파일: `src/features/browser/components/BrowserDrawer.tsx` (신규 생성)

```typescript
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { BrowserPanel } from './BrowserPanel';
import { getLogger } from '@/lib/logger';

const logger = getLogger('BrowserDrawer');

interface BrowserSession {
  sessionId: string;
  name: string;
  url: string;
  status: 'active' | 'loading' | 'error';
  createdAt: Date;
}

interface BrowserDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

export function BrowserDrawer({ isOpen, onClose }: BrowserDrawerProps) {
  const [sessions, setSessions] = useState<BrowserSession[]>([]);
  const [activeSession, setActiveSession] = useState<string | null>(null);

  const createNewSession = async () => {
    try {
      logger.info('Creating new browser session');

      // MCP 도구 호출로 새 세션 시작
      const result = await window.__TAURI__.invoke('call_mcp_tool', {
        server: 'interactive_browser',
        tool: 'start_browser_session',
        args: {
          url: 'https://www.google.com',
          session_name: `Browser ${sessions.length + 1}`
        }
      });

      if (result.success) {
        const newSession: BrowserSession = {
          sessionId: result.data.session_id,
          name: `Browser ${sessions.length + 1}`,
          url: result.data.url,
          status: 'active',
          createdAt: new Date()
        };

        setSessions(prev => [...prev, newSession]);
        setActiveSession(newSession.sessionId);
        logger.info('Browser session created successfully', { sessionId: newSession.sessionId });
      }
    } catch (error) {
      logger.error('Failed to create browser session', error);
    }
  };

  const closeSession = (sessionId: string) => {
    setSessions(prev => prev.filter(s => s.sessionId !== sessionId));
    if (activeSession === sessionId) {
      setActiveSession(sessions[0]?.sessionId || null);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="w-96 bg-background border-l flex flex-col h-full">
      {/* Header */}
      <div className="p-4 border-b">
        <div className="flex items-center justify-between">
          <h3 className="font-semibold text-lg">Browser Sessions</h3>
          <Button variant="ghost" size="sm" onClick={onClose}>
            ✕
          </Button>
        </div>
        <Button
          size="sm"
          className="mt-2 w-full"
          onClick={createNewSession}
        >
          + New Session
        </Button>
      </div>

      {/* Sessions */}
      <div className="flex-1 flex flex-col">
        {sessions.length === 0 ? (
          <div className="flex-1 flex items-center justify-center text-muted-foreground">
            <div className="text-center">
              <p>No browser sessions</p>
              <p className="text-sm">Click "New Session" to start</p>
            </div>
          </div>
        ) : (
          <Tabs value={activeSession || undefined} onValueChange={setActiveSession} className="flex-1 flex flex-col">
            <TabsList className="grid w-full" style={{ gridTemplateColumns: `repeat(${sessions.length}, 1fr)` }}>
              {sessions.map((session) => (
                <TabsTrigger key={session.sessionId} value={session.sessionId} className="relative">
                  <div className="flex items-center gap-1">
                    <span className="truncate max-w-16">{session.name}</span>
                    <Badge variant={session.status === 'active' ? 'default' : 'secondary'} className="text-xs">
                      {session.status}
                    </Badge>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="absolute -top-1 -right-1 h-4 w-4 p-0 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      closeSession(session.sessionId);
                    }}
                  >
                    ✕
                  </Button>
                </TabsTrigger>
              ))}
            </TabsList>

            {sessions.map((session) => (
              <TabsContent key={session.sessionId} value={session.sessionId} className="flex-1">
                <BrowserPanel
                  sessionId={session.sessionId}
                  session={session}
                  onSessionUpdate={(updatedSession) => {
                    setSessions(prev => prev.map(s =>
                      s.sessionId === updatedSession.sessionId ? updatedSession : s
                    ));
                  }}
                />
              </TabsContent>
            ))}
          </Tabs>
        )}
      </div>
    </div>
  );
}
```

#### 파일: `src/features/browser/components/BrowserPanel.tsx` (신규 생성)

```typescript
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { getLogger } from '@/lib/logger';

const logger = getLogger('BrowserPanel');

interface BrowserSession {
  sessionId: string;
  name: string;
  url: string;
  status: 'active' | 'loading' | 'error';
  createdAt: Date;
}

interface BrowserPanelProps {
  sessionId: string;
  session: BrowserSession;
  onSessionUpdate: (session: BrowserSession) => void;
}

interface AutomationAction {
  id: string;
  action: string;
  selector?: string;
  value?: string;
  timestamp: Date;
  result?: any;
}

export function BrowserPanel({ sessionId, session, onSessionUpdate }: BrowserPanelProps) {
  const [automationLog, setAutomationLog] = useState<AutomationAction[]>([]);
  const [testSelector, setTestSelector] = useState('');
  const [testValue, setTestValue] = useState('');

  const executeAction = async (action: string, params: any = {}) => {
    try {
      logger.info('Executing browser action', { action, params, sessionId });

      const actionEntry: AutomationAction = {
        id: Date.now().toString(),
        action,
        selector: params.selector,
        value: params.value,
        timestamp: new Date()
      };

      setAutomationLog(prev => [...prev, actionEntry]);

      const result = await window.__TAURI__.invoke('call_mcp_tool', {
        server: 'interactive_browser',
        tool: action,
        args: {
          session_id: sessionId,
          ...params
        }
      });

      // 결과로 로그 업데이트
      setAutomationLog(prev => prev.map(entry =>
        entry.id === actionEntry.id
          ? { ...entry, result: result.data }
          : entry
      ));

      logger.info('Browser action completed', { action, result });
    } catch (error) {
      logger.error('Browser action failed', { action, error });
    }
  };

  return (
    <div className="p-4 space-y-4 h-full overflow-auto">
      {/* Session Info */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Session Info</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">Status:</span>
            <Badge variant={session.status === 'active' ? 'default' : 'secondary'}>
              {session.status}
            </Badge>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">URL:</span>
            <span className="text-xs truncate max-w-32">{session.url}</span>
          </div>
        </CardContent>
      </Card>

      {/* Quick Actions */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Quick Actions</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          {/* Scroll Actions */}
          <div className="grid grid-cols-2 gap-2">
            <Button
              size="sm"
              variant="outline"
              onClick={() => executeAction('scroll', { direction: 'up' })}
            >
              ↑ Scroll Up
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => executeAction('scroll', { direction: 'down' })}
            >
              ↓ Scroll Down
            </Button>
          </div>

          {/* Test Element Interaction */}
          <div className="space-y-2">
            <Input
              placeholder="CSS Selector (e.g., #myButton)"
              value={testSelector}
              onChange={(e) => setTestSelector(e.target.value)}
              className="text-xs"
            />
            <div className="grid grid-cols-2 gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => executeAction('click_element', { selector: testSelector })}
                disabled={!testSelector}
              >
                Click
              </Button>
              <Button
                size="sm"
                variant="outline"
                onClick={() => executeAction('fill_input', {
                  selector: testSelector,
                  value: testValue
                })}
                disabled={!testSelector}
              >
                Fill
              </Button>
            </div>
            <Input
              placeholder="Text to fill"
              value={testValue}
              onChange={(e) => setTestValue(e.target.value)}
              className="text-xs"
            />
          </div>
        </CardContent>
      </Card>

      {/* Automation Log */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Automation Log</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2 max-h-64 overflow-auto">
            {automationLog.length === 0 ? (
              <p className="text-xs text-muted-foreground">No actions yet</p>
            ) : (
              automationLog.slice(-10).reverse().map((action) => (
                <div key={action.id} className="text-xs p-2 bg-muted rounded">
                  <div className="flex items-center justify-between">
                    <span className="font-mono">{action.action}</span>
                    <span className="text-muted-foreground">
                      {action.timestamp.toLocaleTimeString()}
                    </span>
                  </div>
                  {action.selector && (
                    <div className="text-muted-foreground">
                      Selector: {action.selector}
                    </div>
                  )}
                  {action.result && (
                    <div className="text-green-600">
                      ✓ {JSON.stringify(action.result, null, 2)}
                    </div>
                  )}
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 3. 기존 WebView Crawler 수정

#### 파일: `src-tauri/src/mcp/builtin/webview_crawler.rs` (수정)

```rust
// 기존 코드에 다음 내용 추가

impl WebViewCrawlerServer {
    // 기존 크롤링 기능을 Interactive Browser와 통합
    pub async fn integrate_with_interactive_browser(
        &self,
        interactive_server: &InteractiveBrowserServer
    ) -> Result<(), String> {
        // 필요시 기존 크롤링 결과를 브라우저 세션으로 전환
        Ok(())
    }

    // 기존 도구에 브라우저 세션 지원 추가
    fn create_enhanced_crawl_tool(&self) -> MCPTool {
        MCPTool {
            name: "crawl_with_browser_session".to_string(),
            description: "Crawl page and optionally keep session open for interaction".to_string(),
            input_schema: json!({
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "keep_session": {"type": "boolean", "default": false},
                    "session_name": {"type": "string", "default": "Crawl Session"},
                    "selectors": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "CSS selectors for data extraction"
                    }
                },
                "required": ["url"]
            }),
        }
    }
}
```

### 4. MCP 서버 등록 업데이트

#### 파일: `src-tauri/src/mcp/builtin/mod.rs` (수정)

```rust
// 기존 코드
pub mod webview_crawler;

// 추가할 코드
pub mod interactive_browser;

use interactive_browser::InteractiveBrowserServer;

// 서버 등록 함수에 추가
pub fn register_builtin_servers(app_handle: AppHandle) -> Vec<Box<dyn BuiltinMCPServer + Send + Sync>> {
    vec![
        Box::new(WebViewCrawlerServer::new(app_handle.clone())),
        Box::new(InteractiveBrowserServer::new(app_handle)), // 새로 추가
    ]
}
```

### 5. 메인 UI에 Browser Drawer 통합

#### 파일: `src/app/App.tsx` (수정)

```typescript
// 기존 import에 추가
import { BrowserDrawer } from '@/features/browser/components/BrowserDrawer';

// App 컴포넌트 내부에 state 추가
const [isBrowserDrawerOpen, setIsBrowserDrawerOpen] = useState(false);

// UI에 Browser Drawer 추가
return (
  <div className="flex h-screen">
    {/* 기존 컨텐츠 */}
    <main className="flex-1">
      {/* 기존 메인 컨텐츠 */}
    </main>

    {/* Browser Drawer */}
    <BrowserDrawer
      isOpen={isBrowserDrawerOpen}
      onClose={() => setIsBrowserDrawerOpen(false)}
    />

    {/* Browser Toggle Button */}
    <Button
      className="fixed bottom-4 right-4"
      onClick={() => setIsBrowserDrawerOpen(!isBrowserDrawerOpen)}
    >
      🌐 Browser
    </Button>
  </div>
);
```

## 구현 단계별 순서

### Phase 1: Backend 기반 구축 (1-2일)

1. `InteractiveBrowserServer` 구조체 및 기본 세션 관리 구현
2. `start_browser_session` 도구 구현
3. JavaScript 실행 헬퍼 함수들 구현

### Phase 2: 핵심 상호작용 도구 (2-3일)

1. `click_element`, `fill_input` 도구 구현
2. `scroll`, `send_keys` 도구 구현
3. 에러 처리 및 로깅 강화

### Phase 3: Frontend UI 구현 (2-3일)

1. `BrowserDrawer` 기본 구조 구현
2. `BrowserPanel` 상호작용 인터페이스 구현
3. 세션 관리 및 탭 시스템 구현

### Phase 4: 통합 및 테스트 (1-2일)

1. 기존 크롤러와의 호환성 확인
2. 전체 시스템 통합 테스트
3. 사용자 경험 개선

### Phase 5: 고급 기능 추가 (선택사항)

1. `wait_for` 조건부 대기 구현
2. 스크린샷 및 데이터 추출 강화
3. 자동화 스크립트 녹화/재생 기능

## 예상 효과

### 개발자 관점

- **디버깅 향상**: 브라우저 자동화 과정을 실시간으로 관찰
- **개발 효율성**: 복잡한 웹 워크플로우를 AI가 자동화
- **테스트 자동화**: 웹 애플리케이션 E2E 테스트 지원

### 사용자 관점

- **직관적 인터페이스**: 브라우저 상호작용을 시각적으로 확인
- **멀티태스킹**: 여러 웹사이트를 동시에 자동화
- **안전성**: 샌드박스된 환경에서 안전한 브라우저 자동화

### AI 에이전트 관점

- **확장된 능력**: 단순 크롤링에서 완전한 웹 상호작용으로 진화
- **컨텍스트 유지**: 연속적인 브라우저 세션으로 복잡한 워크플로우 수행
- **실시간 피드백**: 액션 결과를 즉시 확인하여 적응적 행동 가능

## 초보 개발자를 위한 구현 가이드

### 🔰 1단계: 백엔드 이해하기

#### Rust 코드 구조 이해

```rust
// 이 구조체는 브라우저 세션들을 관리하는 매니저입니다
pub struct InteractiveBrowserServer {
    app_handle: AppHandle,  // Tauri 앱에 접근하기 위한 핸들
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,  // 세션들을 안전하게 저장
}

// 각 브라우저 세션의 정보를 담는 구조체
struct BrowserSession {
    webview: WebviewWindow,  // 실제 브라우저 창
    session_id: String,      // 고유 식별자
    url: String,            // 현재 URL
    // ... 기타 정보들
}
```

#### MCP 도구의 작동 원리

1. **도구 정의**: `tools()` 함수에서 AI가 사용할 수 있는 도구들을 정의
2. **도구 실행**: `call_tool()` 함수에서 실제 작업을 수행
3. **결과 반환**: `MCPResponse`로 AI에게 결과를 전달

### 🔰 2단계: 프론트엔드 이해하기

#### React 컴포넌트 구조

```
BrowserDrawer (메인 컨테이너)
├── Header (제목과 새 세션 버튼)
├── SessionTabs (세션 탭들)
└── BrowserPanel (개별 세션 조작 패널)
    ├── Session Info (세션 정보)
    ├── Quick Actions (빠른 액션 버튼들)
    └── Automation Log (자동화 로그)
```

#### State 관리

```typescript
// 브라우저 세션들의 목록
const [sessions, setSessions] = useState<BrowserSession[]>([]);

// 현재 활성화된 세션 ID
const [activeSession, setActiveSession] = useState<string | null>(null);

// 자동화 액션들의 로그
const [automationLog, setAutomationLog] = useState<AutomationAction[]>([]);
```

### 🔰 3단계: 실제 구현 순서

#### 첫 번째: 기본 세션 생성

1. `InteractiveBrowserServer` 구조체 만들기
2. `start_browser_session` 도구 구현하기
3. `BrowserDrawer` 컴포넌트 만들기
4. "New Session" 버튼으로 테스트

#### 두 번째: 간단한 상호작용 추가

1. `click_element` 도구 구현
2. `BrowserPanel`에서 클릭 테스트 UI 만들기
3. 실제 웹페이지에서 버튼 클릭 테스트

#### 세 번째: 고급 기능 추가

1. `fill_input`, `scroll` 도구들 구현
2. UI에 해당 버튼들 추가
3. 자동화 로그 기능 구현

### 🔰 4단계: 디버깅 팁

#### 백엔드 디버깅

```rust
// 로그 추가하기
use log::{info, warn, error};

info!("Creating browser session with URL: {}", url);
error!("Failed to create webview: {}", e);
```

#### 프론트엔드 디버깅

```typescript
// 중앙화된 로거 사용하기
import { getLogger } from '@/lib/logger';
const logger = getLogger('BrowserPanel');

logger.info('Executing browser action', { action, params });
logger.error('Browser action failed', error);
```

### 🔰 5단계: 테스트 방법

1. **개발 환경 실행**: `pnpm tauri dev`
2. **새 세션 생성**: Browser 버튼 클릭 → New Session
3. **기본 테스트**: Google.com에서 검색창 클릭해보기
4. **상호작용 테스트**: 검색어 입력, 버튼 클릭 등

이 가이드를 따라하면 초보 개발자도 단계별로 Interactive Browser Agent를 구현할 수 있습니다. 각 단계에서 문제가 생기면 로그를 확인하고, 작은 부분부터 테스트해가며 진행하세요!

## GitHub 예제 기반 구현 팁

### 1. 윈도우 레이아웃 관리

```rust
// tauri.conf.json에서 메인 윈도우 설정
{
  "windows": [{
    "label": "main",
    "width": 1200,
    "height": 800,
    "resizable": true,
    "fullscreen": false
  }]
}

// 런타임에서 Side Drawer 영역 계산
fn calculate_drawer_bounds(window: &Window) -> (LogicalPosition<f64>, LogicalSize<f64>) {
    let size = window.inner_size().unwrap();
    let drawer_width = 400.0;
    let position = LogicalPosition::new(
        size.width as f64 - drawer_width, 
        0.0
    );
    let size = LogicalSize::new(drawer_width, size.height as f64);
    (position, size)
}
```

### 2. 세션 전환 메커니즘

```rust
impl InteractiveBrowserServer {
    async fn switch_session(&self, from_session: &str, to_session: &str) -> Result<(), String> {
        let mut sessions = self.browser_sessions.lock().await;
        
        // 현재 세션 숨기기
        if let Some(current) = sessions.get(from_session) {
            current.webview.hide().map_err(|e| format!("Failed to hide webview: {}", e))?;
        }
        
        // 새 세션 표시
        if let Some(target) = sessions.get(to_session) {
            target.webview.show().map_err(|e| format!("Failed to show webview: {}", e))?;
            target.webview.set_focus().map_err(|e| format!("Failed to focus webview: {}", e))?;
        }
        
        Ok(())
    }
}
```

### 3. 에러 처리 및 복구

```rust
impl InteractiveBrowserServer {
    async fn handle_webview_error(&self, session_id: &str, error: &str) -> MCPResponse {
        log::error!("WebView error in session {}: {}", session_id, error);
        
        // 세션 재시작 시도
        if let Err(e) = self.restart_session(session_id).await {
            log::error!("Failed to restart session {}: {}", session_id, e);
            return MCPResponse::error(&format!("Session {} failed and could not be restarted", session_id));
        }
        
        MCPResponse::success(json!({
            "session_id": session_id,
            "action": "restarted",
            "reason": error
        }))
    }
}
```

이 리팩토링 계획을 통해 SynapticFlow는 단순한 크롤링 도구에서 **완전한 브라우저 자동화 플랫폼**으로 진화하게 됩니다.
