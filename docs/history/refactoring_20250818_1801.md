# WebView Crawlerë¥¼ Interactive Browser Agentë¡œ í™•ì¥ ë¦¬íŒ©í† ë§ ê³„íš

## ì‘ì—…ì˜ ëª©ì 

í˜„ì¬ì˜ WebView Crawlerë¥¼ í™•ì¥í•˜ì—¬ Side Drawerì—ì„œ ì‹¤í–‰ë˜ëŠ” Interactive Browser Agentë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ AI ì—ì´ì „íŠ¸ê°€ ë‹¨ìˆœí•œ í˜ì´ì§€ í¬ë¡¤ë§ì„ ë„˜ì–´ì„œ ì‹¤ì œ ë¸Œë¼ìš°ì € ìƒí˜¸ì‘ìš©(í´ë¦­, ì…ë ¥, ìŠ¤í¬ë¡¤ ë“±)ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

### ì£¼ìš” ëª©í‘œ

1. **Side Drawer Browser UI**: ì‚¬ìš©    /// ë¸Œë¼ìš°ì € WebView ìƒì„± (Tauri multiwebview íŒ¨í„´ ì‚¬ìš©)
    async fn create_browser_webview(
        &self, 
        session_id: &str, 
        url: &str, 
        title: &str
    ) -> Result<WebviewWindow, String> {
        // ë©”ì¸ ìœˆë„ìš° ê°€ì ¸ì˜¤ê¸°
        let main_window = self.app_handle
            .get_window("main")
            .ok_or("Main window not found")?;

        // WebviewBuilderë¡œ child webview ìƒì„± (GitHub ì˜ˆì œ íŒ¨í„´)
        let webview_builder = tauri::webview::WebviewBuilder::new(
            session_id,
            tauri::WebviewUrl::External(url.parse().map_err(|e| format!("Invalid URL: {}", e))?)
        )
        .auto_resize(); // ìë™ ë¦¬ì‚¬ì´ì§• í™œì„±í™”

        // Side Drawer ì˜ì—­ì— webview ì¶”ê°€ (ìš°ì¸¡ 400px í­)
        let window_size = main_window.inner_size().map_err(|e| format!("Failed to get window size: {}", e))?;
        let drawer_width = 400.0;
        let drawer_height = window_size.height as f64;

        let webview = main_window.add_child(
            webview_builder,
            tauri::LogicalPosition::new(window_size.width as f64 - drawer_width, 0.0),
            tauri::LogicalSize::new(drawer_width, drawer_height),
        )
        .map_err(|e| format!("Failed to create child webview: {}", e))?;

        // WebviewWindow ë˜í¼ ìƒì„±
        let webview_window = WebviewWindow {
            window: main_window,
            webview,
        };

        Ok(webview_window)
    }í•  ìˆ˜ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤
2. **DOM Event Generation**: AIê°€ ì‹¤ì œ ì›¹ í˜ì´ì§€ì™€ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ë„êµ¬ë“¤
3. **Multi-Session Management**: ì—¬ëŸ¬ ë¸Œë¼ìš°ì € ì„¸ì…˜ì„ ë™ì‹œì— ê´€ë¦¬
4. **Real-time Interaction**: ì‹¤ì‹œê°„ìœ¼ë¡œ ë¸Œë¼ìš°ì € ìë™í™” ê³¼ì •ì„ ê´€ì°°

## í˜„ì¬ì˜ ìƒíƒœ / ë¬¸ì œì 

### í˜„ì¬ WebView Crawlerì˜ í•œê³„

```rust
// src-tauri/src/mcp/builtin/webview_crawler.rs (í˜„ì¬ ìƒíƒœ)
pub struct WebViewCrawlerServer {
    app_handle: AppHandle,
    active_crawlers: Arc<Mutex<HashMap<String, CrawlerInstance>>>,
}

// í˜„ì¬ëŠ” ë‹¨ìˆœí•œ í¬ë¡¤ë§ë§Œ ê°€ëŠ¥
async fn handle_crawl_page(&self, args: Value) -> MCPResponse {
    // 1. ìˆ¨ê²¨ì§„ WebView ìƒì„±
    // 2. í˜ì´ì§€ ë¡œë“œ
    // 3. HTML ì¶”ì¶œ í›„ ì¦‰ì‹œ ì¢…ë£Œ
    // 4. ìƒí˜¸ì‘ìš© ë¶ˆê°€ëŠ¥
}
```

### ì£¼ìš” ë¬¸ì œì 

1. **ì¼íšŒì„± í¬ë¡¤ë§**: WebViewê°€ í¬ë¡¤ë§ í›„ ì¦‰ì‹œ ì¢…ë£Œë¨
2. **ìˆ¨ê²¨ì§„ ì‹¤í–‰**: ì‚¬ìš©ìê°€ í¬ë¡¤ë§ ê³¼ì •ì„ ë³¼ ìˆ˜ ì—†ìŒ
3. **ì œí•œëœ ìƒí˜¸ì‘ìš©**: HTML ì¶”ì¶œë§Œ ê°€ëŠ¥, DOM ì¡°ì‘ ë¶ˆê°€ëŠ¥
4. **ì„¸ì…˜ ê´€ë¦¬ ë¶€ì¬**: ì—°ì†ì ì¸ ë¸Œë¼ìš°ì € ì‘ì—… ë¶ˆê°€ëŠ¥
5. **ì‹œê°ì  í”¼ë“œë°± ì—†ìŒ**: ìë™í™” ê³¼ì •ì„ ë””ë²„ê¹…í•˜ê¸° ì–´ë ¤ì›€

## ë³€ê²½ ì´í›„ì˜ ìƒíƒœ / í•´ê²° íŒì • ê¸°ì¤€

### ë‹¬ì„±í•  ëª©í‘œ ìƒíƒœ

#### 1. Interactive Browser Agent ì‹œìŠ¤í…œ

```rust
// ìƒˆë¡œìš´ êµ¬ì¡°
pub struct InteractiveBrowserServer {
    app_handle: AppHandle,
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,
    ui_manager: BrowserUIManager,
}

struct BrowserSession {
    webview: WebviewWindow,
    session_id: String,
    url: String,
    event_listeners: Vec<String>,
    automation_queue: VecDeque<AutomationTask>,
    created_at: std::time::Instant,
    last_activity: std::time::Instant,
}
```

#### 2. ìƒˆë¡œìš´ MCP ë„êµ¬ë“¤

- `start_browser_session`: Side Drawerì— ë¸Œë¼ìš°ì € ì„¸ì…˜ ì‹œì‘
- `click_element`: CSS ì…€ë ‰í„°ë¡œ ìš”ì†Œ í´ë¦­
- `fill_input`: ì…ë ¥ í•„ë“œì— í…ìŠ¤íŠ¸ ì…ë ¥
- `scroll`: í˜ì´ì§€ ìŠ¤í¬ë¡¤ (up/down/top/bottom)
- `send_keys`: í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì „ì†¡
- `wait_for`: íŠ¹ì • ì¡°ê±´ê¹Œì§€ ëŒ€ê¸°
- `take_screenshot`: í˜„ì¬ í˜ì´ì§€ ìŠ¤í¬ë¦°ìƒ·
- `extract_data`: í˜ì´ì§€ì—ì„œ ë°ì´í„° ì¶”ì¶œ

#### 3. Side Drawer UI ì»´í¬ë„ŒíŠ¸

```typescript
// ìƒˆë¡œìš´ UI ì»´í¬ë„ŒíŠ¸ë“¤
- BrowserDrawer: ë©”ì¸ ë¸Œë¼ìš°ì € íŒ¨ë„
- BrowserPanel: ê°œë³„ ë¸Œë¼ìš°ì € ì„¸ì…˜
- BrowserToolbar: ë„¤ë¹„ê²Œì´ì…˜ ë° ë„êµ¬ ëª¨ìŒ
- SessionTabs: ë©€í‹° ì„¸ì…˜ ê´€ë¦¬
- AutomationLog: ìë™í™” ì•¡ì…˜ ë¡œê·¸
```

### ì„±ê³µ íŒì • ê¸°ì¤€

1. âœ… Side Drawerì—ì„œ ë¸Œë¼ìš°ì € ì„¸ì…˜ì´ ì •ìƒì ìœ¼ë¡œ í‘œì‹œë¨
2. âœ… AI ì—ì´ì „íŠ¸ê°€ ì›¹ í˜ì´ì§€ì™€ ìƒí˜¸ì‘ìš© ê°€ëŠ¥ (í´ë¦­, ì…ë ¥, ìŠ¤í¬ë¡¤)
3. âœ… ì—¬ëŸ¬ ë¸Œë¼ìš°ì € ì„¸ì…˜ì„ ë™ì‹œì— ê´€ë¦¬ ê°€ëŠ¥
4. âœ… ì‚¬ìš©ìê°€ ìë™í™” ê³¼ì •ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê´€ì°° ê°€ëŠ¥
5. âœ… ê¸°ì¡´ í¬ë¡¤ë§ ê¸°ëŠ¥ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë¨

## GitHub ì˜ˆì œ ì°¸ê³  ì‚¬í•­

### Tauri Multiwebview ê³µì‹ ì˜ˆì œ ë¶„ì„

**ì°¸ê³  ë§í¬**: https://github.com/tauri-apps/tauri/tree/dev/examples/multiwebview

#### í•µì‹¬ íŒ¨í„´

1. **ë©”ì¸ ìœˆë„ìš°ì— ìì‹ WebView ì¶”ê°€**:
   ```rust
   let webview = window.add_child(
       tauri::webview::WebviewBuilder::new("label", WebviewUrl::External(url))
           .auto_resize(),
       LogicalPosition::new(x, y),
       LogicalSize::new(width, height),
   )?;
   ```

2. **ìœ„ì¹˜ì™€ í¬ê¸° ì§€ì •**:
   - `LogicalPosition`: WebViewì˜ ì‹œì‘ ìœ„ì¹˜ (x, y)
   - `LogicalSize`: WebViewì˜ í¬ê¸° (width, height)
   - `auto_resize()`: ë¶€ëª¨ ìœˆë„ìš° í¬ê¸° ë³€ê²½ì‹œ ìë™ ì¡°ì •

3. **ë‹¤ì¤‘ WebView ê´€ë¦¬**:
   - ê° WebViewëŠ” ê³ ìœ í•œ `label`ë¡œ ì‹ë³„
   - ê°™ì€ ìœˆë„ìš° ë‚´ì—ì„œ ì—¬ëŸ¬ WebViewë¥¼ ê²©ìí˜•ìœ¼ë¡œ ë°°ì¹˜ ê°€ëŠ¥

### ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ (GitHub ì˜ˆì œ ê¸°ë°˜)

```rust
// GitHub ì˜ˆì œì—ì„œ ì˜ê°ì„ ë°›ì€ ì‹¤ì œ êµ¬í˜„
fn setup_interactive_browser(app: &AppHandle) -> Result<(), Box<dyn std::error::Error>> {
    let main_window = app.get_window("main").unwrap();
    let window_size = main_window.inner_size()?;
    
    // Side Drawer ì˜ì—­ ê³„ì‚° (ìš°ì¸¡ 30% ê³µê°„)
    let drawer_width = (window_size.width as f64 * 0.3).max(300.0);
    let drawer_x = window_size.width as f64 - drawer_width;
    
    // ì²« ë²ˆì§¸ ë¸Œë¼ìš°ì € ì„¸ì…˜ ìƒì„±
    let session1 = main_window.add_child(
        tauri::webview::WebviewBuilder::new(
            "browser-session-1",
            tauri::WebviewUrl::External("https://www.google.com".parse()?)
        )
        .auto_resize(),
        tauri::LogicalPosition::new(drawer_x, 0.0),
        tauri::LogicalSize::new(drawer_width, window_size.height as f64),
    )?;
    
    Ok(())
}
```

### AI ì—ì´ì „íŠ¸ ì›Œí¬í”Œë¡œìš° ì˜ˆì‹œ

```typescript
// AIê°€ GitHubì—ì„œ ì´ìŠˆë¥¼ ìƒì„±í•˜ëŠ” ìë™í™” ì›Œí¬í”Œë¡œìš°
async function automateGitHubIssue() {
    // 1. ë¸Œë¼ìš°ì € ì„¸ì…˜ ì‹œì‘
    const session = await startBrowserSession({
        url: 'https://github.com/myrepo/issues',
        session_name: 'GitHub Issue Creation'
    });
    
    // 2. ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™ (í•„ìš”ì‹œ)
    await clickElement({ 
        session_id: session.id, 
        selector: '.header-nav-link[href="/login"]' 
    });
    
    // 3. ìƒˆ ì´ìŠˆ ìƒì„± ë²„íŠ¼ í´ë¦­
    await clickElement({ 
        session_id: session.id, 
        selector: 'a[href$="/issues/new"]' 
    });
    
    // 4. ì´ìŠˆ ì œëª© ì…ë ¥
    await fillInput({ 
        session_id: session.id, 
        selector: '#issue_title', 
        value: 'Bug: WebView integration issue' 
    });
    
    // 5. ì´ìŠˆ ë‚´ìš© ì…ë ¥
    await fillInput({ 
        session_id: session.id, 
        selector: '#issue_body', 
        value: 'Found an issue with multiwebview implementation...' 
    });
    
    // 6. ë¼ë²¨ ì¶”ê°€
    await clickElement({ 
        session_id: session.id, 
        selector: '.js-issue-labels button' 
    });
    
    // 7. ìŠ¤í¬ë¡¤í•˜ì—¬ submit ë²„íŠ¼ ì°¾ê¸°
    await scroll({ 
        session_id: session.id, 
        direction: 'down', 
        amount: 300 
    });
    
    // 8. ì´ìŠˆ ìƒì„±
    await clickElement({ 
        session_id: session.id, 
        selector: 'button[type="submit"]' 
    });
    
    // 9. ìƒì„± ì™„ë£Œ ëŒ€ê¸°
    await waitFor({ 
        session_id: session.id, 
        condition: 'document.querySelector(".timeline-comment")', 
        timeout: 5000 
    });
}
```


### 1. Backend: Interactive Browser Server êµ¬í˜„

#### íŒŒì¼: `src-tauri/src/mcp/builtin/interactive_browser.rs` (ì‹ ê·œ ìƒì„±)

```rust
use crate::mcp::{builtin::BuiltinMCPServer, MCPResponse, MCPTool};
use serde_json::{json, Value};
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tauri::{AppHandle, Manager, WebviewWindow};
use tokio::sync::Mutex;
use uuid::Uuid;

pub struct InteractiveBrowserServer {
    app_handle: AppHandle,
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,
}

#[derive(Debug)]
struct BrowserSession {
    webview: WebviewWindow,
    session_id: String,
    url: String,
    automation_queue: VecDeque<AutomationTask>,
    created_at: std::time::Instant,
}

#[derive(Debug)]
struct AutomationTask {
    task_id: String,
    action: BrowserAction,
    timestamp: std::time::Instant,
}

#[derive(Debug)]
enum BrowserAction {
    Click { selector: String },
    FillInput { selector: String, value: String },
    Scroll { direction: String, amount: i32 },
    SendKeys { keys: String, selector: Option<String> },
    Navigate { url: String },
    Screenshot,
}

impl InteractiveBrowserServer {
    pub fn new(app_handle: AppHandle) -> Self {
        Self {
            app_handle,
            browser_sessions: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// ìƒˆë¡œìš´ ë¸Œë¼ìš°ì € ì„¸ì…˜ ì‹œì‘
    async fn handle_start_browser_session(&self, args: Value) -> MCPResponse {
        let session_id = Uuid::new_v4().to_string();
        let url = args.get("url").and_then(|v| v.as_str()).unwrap_or("about:blank");
        let session_name = args.get("session_name").and_then(|v| v.as_str())
            .unwrap_or("Browser Session");

        // Side Drawerì— WebView ìƒì„±
        match self.create_browser_webview(&session_id, url, session_name).await {
            Ok(webview) => {
                let session = BrowserSession {
                    webview,
                    session_id: session_id.clone(),
                    url: url.to_string(),
                    automation_queue: VecDeque::new(),
                    created_at: std::time::Instant::now(),
                };

                self.browser_sessions.lock().await.insert(session_id.clone(), session);

                MCPResponse::success(json!({
                    "session_id": session_id,
                    "url": url,
                    "status": "started"
                }))
            }
            Err(e) => MCPResponse::error(&format!("Failed to create browser session: {}", e))
        }
    }

    /// DOM ìš”ì†Œ í´ë¦­
    async fn handle_click_element(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let selector = args.get("selector").and_then(|v| v.as_str()).unwrap_or_default();

        let script = format!(r#"
            (function() {{
                const element = document.querySelector('{}');
                if (element) {{
                    element.click();
                    return {{
                        success: true,
                        tagName: element.tagName,
                        text: element.textContent?.slice(0, 100) || '',
                        rect: element.getBoundingClientRect()
                    }};
                }}
                return {{ success: false, error: 'Element not found' }};
            }})()
        "#, selector.replace("'", "\\'"));

        self.execute_script(session_id, &script).await
    }

    /// ì…ë ¥ í•„ë“œ ì±„ìš°ê¸°
    async fn handle_fill_input(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let selector = args.get("selector").and_then(|v| v.as_str()).unwrap_or_default();
        let value = args.get("value").and_then(|v| v.as_str()).unwrap_or_default();

        let script = format!(r#"
            (function() {{
                const input = document.querySelector('{}');
                if (input) {{
                    input.value = '{}';
                    input.dispatchEvent(new Event('input', {{ bubbles: true }}));
                    input.dispatchEvent(new Event('change', {{ bubbles: true }}));
                    return {{
                        success: true,
                        value: input.value,
                        type: input.type || 'text'
                    }};
                }}
                return {{ success: false, error: 'Input element not found' }};
            }})()
        "#, selector.replace("'", "\\'"), value.replace("'", "\\'"));

        self.execute_script(session_id, &script).await
    }

    /// ìŠ¤í¬ë¡¤ ì•¡ì…˜
    async fn handle_scroll(&self, args: Value) -> MCPResponse {
        let session_id = args.get("session_id").and_then(|v| v.as_str()).unwrap_or_default();
        let direction = args.get("direction").and_then(|v| v.as_str()).unwrap_or("down");
        let amount = args.get("amount").and_then(|v| v.as_i64()).unwrap_or(300);

        let script = match direction {
            "up" => format!(
                "window.scrollBy(0, -{}); return {{ scrollY: window.scrollY, direction: 'up' }};",
                amount
            ),
            "down" => format!(
                "window.scrollBy(0, {}); return {{ scrollY: window.scrollY, direction: 'down' }};",
                amount
            ),
            "top" => "window.scrollTo(0, 0); return { scrollY: window.scrollY, direction: 'top' };".to_string(),
            "bottom" => "window.scrollTo(0, document.body.scrollHeight); return { scrollY: window.scrollY, direction: 'bottom' };".to_string(),
            _ => "return { error: 'Invalid direction. Use: up, down, top, bottom' };".to_string(),
        };

        self.execute_script(session_id, &script).await
    }

    /// JavaScript ì‹¤í–‰ í—¬í¼
    async fn execute_script(&self, session_id: &str, script: &str) -> MCPResponse {
        let sessions = self.browser_sessions.lock().await;
        if let Some(session) = sessions.get(session_id) {
            match session.webview.eval(script) {
                Ok(_) => MCPResponse::success(json!({
                    "session_id": session_id,
                    "executed": true
                })),
                Err(e) => MCPResponse::error(&format!("Script execution failed: {}", e))
            }
        } else {
            MCPResponse::error("Session not found")
        }
    }

    /// ë¸Œë¼ìš°ì € WebView ìƒì„±
    async fn create_browser_webview(
        &self,
        session_id: &str,
        url: &str,
        title: &str
    ) -> Result<WebviewWindow, String> {
        // Side Drawerì— í‘œì‹œë  WebView ìƒì„±
        let webview = tauri::WebviewWindowBuilder::new(
            &self.app_handle,
            session_id,
            tauri::WebviewUrl::External(url.parse().map_err(|e| format!("Invalid URL: {}", e))?)
        )
        .title(title)
        .inner_size(400.0, 600.0)
        .build()
        .map_err(|e| format!("Failed to create webview: {}", e))?;

        Ok(webview)
    }
}

#[async_trait::async_trait]
impl BuiltinMCPServer for InteractiveBrowserServer {
    fn name(&self) -> &str {
        "interactive_browser"
    }

    fn description(&self) -> &str {
        "Interactive browser automation with visual feedback in side drawer"
    }

    fn tools(&self) -> Vec<MCPTool> {
        vec![
            MCPTool {
                name: "start_browser_session".to_string(),
                description: "Start a new interactive browser session in side drawer".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "url": {"type": "string", "description": "Initial URL to load"},
                        "session_name": {"type": "string", "description": "Name for this browser session"}
                    },
                    "required": ["url"]
                }),
            },
            MCPTool {
                name: "click_element".to_string(),
                description: "Click on a DOM element using CSS selector".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "selector": {"type": "string", "description": "CSS selector for the element to click"}
                    },
                    "required": ["session_id", "selector"]
                }),
            },
            MCPTool {
                name: "fill_input".to_string(),
                description: "Fill an input field with text".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "selector": {"type": "string", "description": "CSS selector for the input field"},
                        "value": {"type": "string", "description": "Text to enter"}
                    },
                    "required": ["session_id", "selector", "value"]
                }),
            },
            MCPTool {
                name: "scroll".to_string(),
                description: "Scroll the page in various directions".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "session_id": {"type": "string"},
                        "direction": {"type": "string", "enum": ["up", "down", "top", "bottom"], "default": "down"},
                        "amount": {"type": "number", "default": 300}
                    },
                    "required": ["session_id"]
                }),
            },
        ]
    }

    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
        match tool_name {
            "start_browser_session" => self.handle_start_browser_session(args).await,
            "click_element" => self.handle_click_element(args).await,
            "fill_input" => self.handle_fill_input(args).await,
            "scroll" => self.handle_scroll(args).await,
            _ => MCPResponse::error(&format!("Unknown tool: {}", tool_name)),
        }
    }
}
```

### 2. Frontend: Browser UI ì»´í¬ë„ŒíŠ¸ êµ¬í˜„

#### íŒŒì¼: `src/features/browser/components/BrowserDrawer.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { BrowserPanel } from './BrowserPanel';
import { getLogger } from '@/lib/logger';

const logger = getLogger('BrowserDrawer');

interface BrowserSession {
  sessionId: string;
  name: string;
  url: string;
  status: 'active' | 'loading' | 'error';
  createdAt: Date;
}

interface BrowserDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

export function BrowserDrawer({ isOpen, onClose }: BrowserDrawerProps) {
  const [sessions, setSessions] = useState<BrowserSession[]>([]);
  const [activeSession, setActiveSession] = useState<string | null>(null);

  const createNewSession = async () => {
    try {
      logger.info('Creating new browser session');

      // MCP ë„êµ¬ í˜¸ì¶œë¡œ ìƒˆ ì„¸ì…˜ ì‹œì‘
      const result = await window.__TAURI__.invoke('call_mcp_tool', {
        server: 'interactive_browser',
        tool: 'start_browser_session',
        args: {
          url: 'https://www.google.com',
          session_name: `Browser ${sessions.length + 1}`
        }
      });

      if (result.success) {
        const newSession: BrowserSession = {
          sessionId: result.data.session_id,
          name: `Browser ${sessions.length + 1}`,
          url: result.data.url,
          status: 'active',
          createdAt: new Date()
        };

        setSessions(prev => [...prev, newSession]);
        setActiveSession(newSession.sessionId);
        logger.info('Browser session created successfully', { sessionId: newSession.sessionId });
      }
    } catch (error) {
      logger.error('Failed to create browser session', error);
    }
  };

  const closeSession = (sessionId: string) => {
    setSessions(prev => prev.filter(s => s.sessionId !== sessionId));
    if (activeSession === sessionId) {
      setActiveSession(sessions[0]?.sessionId || null);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="w-96 bg-background border-l flex flex-col h-full">
      {/* Header */}
      <div className="p-4 border-b">
        <div className="flex items-center justify-between">
          <h3 className="font-semibold text-lg">Browser Sessions</h3>
          <Button variant="ghost" size="sm" onClick={onClose}>
            âœ•
          </Button>
        </div>
        <Button
          size="sm"
          className="mt-2 w-full"
          onClick={createNewSession}
        >
          + New Session
        </Button>
      </div>

      {/* Sessions */}
      <div className="flex-1 flex flex-col">
        {sessions.length === 0 ? (
          <div className="flex-1 flex items-center justify-center text-muted-foreground">
            <div className="text-center">
              <p>No browser sessions</p>
              <p className="text-sm">Click "New Session" to start</p>
            </div>
          </div>
        ) : (
          <Tabs value={activeSession || undefined} onValueChange={setActiveSession} className="flex-1 flex flex-col">
            <TabsList className="grid w-full" style={{ gridTemplateColumns: `repeat(${sessions.length}, 1fr)` }}>
              {sessions.map((session) => (
                <TabsTrigger key={session.sessionId} value={session.sessionId} className="relative">
                  <div className="flex items-center gap-1">
                    <span className="truncate max-w-16">{session.name}</span>
                    <Badge variant={session.status === 'active' ? 'default' : 'secondary'} className="text-xs">
                      {session.status}
                    </Badge>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="absolute -top-1 -right-1 h-4 w-4 p-0 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      closeSession(session.sessionId);
                    }}
                  >
                    âœ•
                  </Button>
                </TabsTrigger>
              ))}
            </TabsList>

            {sessions.map((session) => (
              <TabsContent key={session.sessionId} value={session.sessionId} className="flex-1">
                <BrowserPanel
                  sessionId={session.sessionId}
                  session={session}
                  onSessionUpdate={(updatedSession) => {
                    setSessions(prev => prev.map(s =>
                      s.sessionId === updatedSession.sessionId ? updatedSession : s
                    ));
                  }}
                />
              </TabsContent>
            ))}
          </Tabs>
        )}
      </div>
    </div>
  );
}
```

#### íŒŒì¼: `src/features/browser/components/BrowserPanel.tsx` (ì‹ ê·œ ìƒì„±)

```typescript
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { getLogger } from '@/lib/logger';

const logger = getLogger('BrowserPanel');

interface BrowserSession {
  sessionId: string;
  name: string;
  url: string;
  status: 'active' | 'loading' | 'error';
  createdAt: Date;
}

interface BrowserPanelProps {
  sessionId: string;
  session: BrowserSession;
  onSessionUpdate: (session: BrowserSession) => void;
}

interface AutomationAction {
  id: string;
  action: string;
  selector?: string;
  value?: string;
  timestamp: Date;
  result?: any;
}

export function BrowserPanel({ sessionId, session, onSessionUpdate }: BrowserPanelProps) {
  const [automationLog, setAutomationLog] = useState<AutomationAction[]>([]);
  const [testSelector, setTestSelector] = useState('');
  const [testValue, setTestValue] = useState('');

  const executeAction = async (action: string, params: any = {}) => {
    try {
      logger.info('Executing browser action', { action, params, sessionId });

      const actionEntry: AutomationAction = {
        id: Date.now().toString(),
        action,
        selector: params.selector,
        value: params.value,
        timestamp: new Date()
      };

      setAutomationLog(prev => [...prev, actionEntry]);

      const result = await window.__TAURI__.invoke('call_mcp_tool', {
        server: 'interactive_browser',
        tool: action,
        args: {
          session_id: sessionId,
          ...params
        }
      });

      // ê²°ê³¼ë¡œ ë¡œê·¸ ì—…ë°ì´íŠ¸
      setAutomationLog(prev => prev.map(entry =>
        entry.id === actionEntry.id
          ? { ...entry, result: result.data }
          : entry
      ));

      logger.info('Browser action completed', { action, result });
    } catch (error) {
      logger.error('Browser action failed', { action, error });
    }
  };

  return (
    <div className="p-4 space-y-4 h-full overflow-auto">
      {/* Session Info */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Session Info</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">Status:</span>
            <Badge variant={session.status === 'active' ? 'default' : 'secondary'}>
              {session.status}
            </Badge>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-sm text-muted-foreground">URL:</span>
            <span className="text-xs truncate max-w-32">{session.url}</span>
          </div>
        </CardContent>
      </Card>

      {/* Quick Actions */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Quick Actions</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          {/* Scroll Actions */}
          <div className="grid grid-cols-2 gap-2">
            <Button
              size="sm"
              variant="outline"
              onClick={() => executeAction('scroll', { direction: 'up' })}
            >
              â†‘ Scroll Up
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => executeAction('scroll', { direction: 'down' })}
            >
              â†“ Scroll Down
            </Button>
          </div>

          {/* Test Element Interaction */}
          <div className="space-y-2">
            <Input
              placeholder="CSS Selector (e.g., #myButton)"
              value={testSelector}
              onChange={(e) => setTestSelector(e.target.value)}
              className="text-xs"
            />
            <div className="grid grid-cols-2 gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => executeAction('click_element', { selector: testSelector })}
                disabled={!testSelector}
              >
                Click
              </Button>
              <Button
                size="sm"
                variant="outline"
                onClick={() => executeAction('fill_input', {
                  selector: testSelector,
                  value: testValue
                })}
                disabled={!testSelector}
              >
                Fill
              </Button>
            </div>
            <Input
              placeholder="Text to fill"
              value={testValue}
              onChange={(e) => setTestValue(e.target.value)}
              className="text-xs"
            />
          </div>
        </CardContent>
      </Card>

      {/* Automation Log */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm">Automation Log</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2 max-h-64 overflow-auto">
            {automationLog.length === 0 ? (
              <p className="text-xs text-muted-foreground">No actions yet</p>
            ) : (
              automationLog.slice(-10).reverse().map((action) => (
                <div key={action.id} className="text-xs p-2 bg-muted rounded">
                  <div className="flex items-center justify-between">
                    <span className="font-mono">{action.action}</span>
                    <span className="text-muted-foreground">
                      {action.timestamp.toLocaleTimeString()}
                    </span>
                  </div>
                  {action.selector && (
                    <div className="text-muted-foreground">
                      Selector: {action.selector}
                    </div>
                  )}
                  {action.result && (
                    <div className="text-green-600">
                      âœ“ {JSON.stringify(action.result, null, 2)}
                    </div>
                  )}
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 3. ê¸°ì¡´ WebView Crawler ìˆ˜ì •

#### íŒŒì¼: `src-tauri/src/mcp/builtin/webview_crawler.rs` (ìˆ˜ì •)

```rust
// ê¸°ì¡´ ì½”ë“œì— ë‹¤ìŒ ë‚´ìš© ì¶”ê°€

impl WebViewCrawlerServer {
    // ê¸°ì¡´ í¬ë¡¤ë§ ê¸°ëŠ¥ì„ Interactive Browserì™€ í†µí•©
    pub async fn integrate_with_interactive_browser(
        &self,
        interactive_server: &InteractiveBrowserServer
    ) -> Result<(), String> {
        // í•„ìš”ì‹œ ê¸°ì¡´ í¬ë¡¤ë§ ê²°ê³¼ë¥¼ ë¸Œë¼ìš°ì € ì„¸ì…˜ìœ¼ë¡œ ì „í™˜
        Ok(())
    }

    // ê¸°ì¡´ ë„êµ¬ì— ë¸Œë¼ìš°ì € ì„¸ì…˜ ì§€ì› ì¶”ê°€
    fn create_enhanced_crawl_tool(&self) -> MCPTool {
        MCPTool {
            name: "crawl_with_browser_session".to_string(),
            description: "Crawl page and optionally keep session open for interaction".to_string(),
            input_schema: json!({
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "keep_session": {"type": "boolean", "default": false},
                    "session_name": {"type": "string", "default": "Crawl Session"},
                    "selectors": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "CSS selectors for data extraction"
                    }
                },
                "required": ["url"]
            }),
        }
    }
}
```

### 4. MCP ì„œë²„ ë“±ë¡ ì—…ë°ì´íŠ¸

#### íŒŒì¼: `src-tauri/src/mcp/builtin/mod.rs` (ìˆ˜ì •)

```rust
// ê¸°ì¡´ ì½”ë“œ
pub mod webview_crawler;

// ì¶”ê°€í•  ì½”ë“œ
pub mod interactive_browser;

use interactive_browser::InteractiveBrowserServer;

// ì„œë²„ ë“±ë¡ í•¨ìˆ˜ì— ì¶”ê°€
pub fn register_builtin_servers(app_handle: AppHandle) -> Vec<Box<dyn BuiltinMCPServer + Send + Sync>> {
    vec![
        Box::new(WebViewCrawlerServer::new(app_handle.clone())),
        Box::new(InteractiveBrowserServer::new(app_handle)), // ìƒˆë¡œ ì¶”ê°€
    ]
}
```

### 5. ë©”ì¸ UIì— Browser Drawer í†µí•©

#### íŒŒì¼: `src/app/App.tsx` (ìˆ˜ì •)

```typescript
// ê¸°ì¡´ importì— ì¶”ê°€
import { BrowserDrawer } from '@/features/browser/components/BrowserDrawer';

// App ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì— state ì¶”ê°€
const [isBrowserDrawerOpen, setIsBrowserDrawerOpen] = useState(false);

// UIì— Browser Drawer ì¶”ê°€
return (
  <div className="flex h-screen">
    {/* ê¸°ì¡´ ì»¨í…ì¸  */}
    <main className="flex-1">
      {/* ê¸°ì¡´ ë©”ì¸ ì»¨í…ì¸  */}
    </main>

    {/* Browser Drawer */}
    <BrowserDrawer
      isOpen={isBrowserDrawerOpen}
      onClose={() => setIsBrowserDrawerOpen(false)}
    />

    {/* Browser Toggle Button */}
    <Button
      className="fixed bottom-4 right-4"
      onClick={() => setIsBrowserDrawerOpen(!isBrowserDrawerOpen)}
    >
      ğŸŒ Browser
    </Button>
  </div>
);
```

## êµ¬í˜„ ë‹¨ê³„ë³„ ìˆœì„œ

### Phase 1: Backend ê¸°ë°˜ êµ¬ì¶• (1-2ì¼)

1. `InteractiveBrowserServer` êµ¬ì¡°ì²´ ë° ê¸°ë³¸ ì„¸ì…˜ ê´€ë¦¬ êµ¬í˜„
2. `start_browser_session` ë„êµ¬ êµ¬í˜„
3. JavaScript ì‹¤í–‰ í—¬í¼ í•¨ìˆ˜ë“¤ êµ¬í˜„

### Phase 2: í•µì‹¬ ìƒí˜¸ì‘ìš© ë„êµ¬ (2-3ì¼)

1. `click_element`, `fill_input` ë„êµ¬ êµ¬í˜„
2. `scroll`, `send_keys` ë„êµ¬ êµ¬í˜„
3. ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹… ê°•í™”

### Phase 3: Frontend UI êµ¬í˜„ (2-3ì¼)

1. `BrowserDrawer` ê¸°ë³¸ êµ¬ì¡° êµ¬í˜„
2. `BrowserPanel` ìƒí˜¸ì‘ìš© ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
3. ì„¸ì…˜ ê´€ë¦¬ ë° íƒ­ ì‹œìŠ¤í…œ êµ¬í˜„

### Phase 4: í†µí•© ë° í…ŒìŠ¤íŠ¸ (1-2ì¼)

1. ê¸°ì¡´ í¬ë¡¤ëŸ¬ì™€ì˜ í˜¸í™˜ì„± í™•ì¸
2. ì „ì²´ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸
3. ì‚¬ìš©ì ê²½í—˜ ê°œì„ 

### Phase 5: ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€ (ì„ íƒì‚¬í•­)

1. `wait_for` ì¡°ê±´ë¶€ ëŒ€ê¸° êµ¬í˜„
2. ìŠ¤í¬ë¦°ìƒ· ë° ë°ì´í„° ì¶”ì¶œ ê°•í™”
3. ìë™í™” ìŠ¤í¬ë¦½íŠ¸ ë…¹í™”/ì¬ìƒ ê¸°ëŠ¥

## ì˜ˆìƒ íš¨ê³¼

### ê°œë°œì ê´€ì 

- **ë””ë²„ê¹… í–¥ìƒ**: ë¸Œë¼ìš°ì € ìë™í™” ê³¼ì •ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê´€ì°°
- **ê°œë°œ íš¨ìœ¨ì„±**: ë³µì¡í•œ ì›¹ ì›Œí¬í”Œë¡œìš°ë¥¼ AIê°€ ìë™í™”
- **í…ŒìŠ¤íŠ¸ ìë™í™”**: ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ E2E í…ŒìŠ¤íŠ¸ ì§€ì›

### ì‚¬ìš©ì ê´€ì 

- **ì§ê´€ì  ì¸í„°í˜ì´ìŠ¤**: ë¸Œë¼ìš°ì € ìƒí˜¸ì‘ìš©ì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸
- **ë©€í‹°íƒœìŠ¤í‚¹**: ì—¬ëŸ¬ ì›¹ì‚¬ì´íŠ¸ë¥¼ ë™ì‹œì— ìë™í™”
- **ì•ˆì „ì„±**: ìƒŒë“œë°•ìŠ¤ëœ í™˜ê²½ì—ì„œ ì•ˆì „í•œ ë¸Œë¼ìš°ì € ìë™í™”

### AI ì—ì´ì „íŠ¸ ê´€ì 

- **í™•ì¥ëœ ëŠ¥ë ¥**: ë‹¨ìˆœ í¬ë¡¤ë§ì—ì„œ ì™„ì „í•œ ì›¹ ìƒí˜¸ì‘ìš©ìœ¼ë¡œ ì§„í™”
- **ì»¨í…ìŠ¤íŠ¸ ìœ ì§€**: ì—°ì†ì ì¸ ë¸Œë¼ìš°ì € ì„¸ì…˜ìœ¼ë¡œ ë³µì¡í•œ ì›Œí¬í”Œë¡œìš° ìˆ˜í–‰
- **ì‹¤ì‹œê°„ í”¼ë“œë°±**: ì•¡ì…˜ ê²°ê³¼ë¥¼ ì¦‰ì‹œ í™•ì¸í•˜ì—¬ ì ì‘ì  í–‰ë™ ê°€ëŠ¥

## ì´ˆë³´ ê°œë°œìë¥¼ ìœ„í•œ êµ¬í˜„ ê°€ì´ë“œ

### ğŸ”° 1ë‹¨ê³„: ë°±ì—”ë“œ ì´í•´í•˜ê¸°

#### Rust ì½”ë“œ êµ¬ì¡° ì´í•´

```rust
// ì´ êµ¬ì¡°ì²´ëŠ” ë¸Œë¼ìš°ì € ì„¸ì…˜ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë§¤ë‹ˆì €ì…ë‹ˆë‹¤
pub struct InteractiveBrowserServer {
    app_handle: AppHandle,  // Tauri ì•±ì— ì ‘ê·¼í•˜ê¸° ìœ„í•œ í•¸ë“¤
    browser_sessions: Arc<Mutex<HashMap<String, BrowserSession>>>,  // ì„¸ì…˜ë“¤ì„ ì•ˆì „í•˜ê²Œ ì €ì¥
}

// ê° ë¸Œë¼ìš°ì € ì„¸ì…˜ì˜ ì •ë³´ë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´
struct BrowserSession {
    webview: WebviewWindow,  // ì‹¤ì œ ë¸Œë¼ìš°ì € ì°½
    session_id: String,      // ê³ ìœ  ì‹ë³„ì
    url: String,            // í˜„ì¬ URL
    // ... ê¸°íƒ€ ì •ë³´ë“¤
}
```

#### MCP ë„êµ¬ì˜ ì‘ë™ ì›ë¦¬

1. **ë„êµ¬ ì •ì˜**: `tools()` í•¨ìˆ˜ì—ì„œ AIê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë„êµ¬ë“¤ì„ ì •ì˜
2. **ë„êµ¬ ì‹¤í–‰**: `call_tool()` í•¨ìˆ˜ì—ì„œ ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰
3. **ê²°ê³¼ ë°˜í™˜**: `MCPResponse`ë¡œ AIì—ê²Œ ê²°ê³¼ë¥¼ ì „ë‹¬

### ğŸ”° 2ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ì´í•´í•˜ê¸°

#### React ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°

```
BrowserDrawer (ë©”ì¸ ì»¨í…Œì´ë„ˆ)
â”œâ”€â”€ Header (ì œëª©ê³¼ ìƒˆ ì„¸ì…˜ ë²„íŠ¼)
â”œâ”€â”€ SessionTabs (ì„¸ì…˜ íƒ­ë“¤)
â””â”€â”€ BrowserPanel (ê°œë³„ ì„¸ì…˜ ì¡°ì‘ íŒ¨ë„)
    â”œâ”€â”€ Session Info (ì„¸ì…˜ ì •ë³´)
    â”œâ”€â”€ Quick Actions (ë¹ ë¥¸ ì•¡ì…˜ ë²„íŠ¼ë“¤)
    â””â”€â”€ Automation Log (ìë™í™” ë¡œê·¸)
```

#### State ê´€ë¦¬

```typescript
// ë¸Œë¼ìš°ì € ì„¸ì…˜ë“¤ì˜ ëª©ë¡
const [sessions, setSessions] = useState<BrowserSession[]>([]);

// í˜„ì¬ í™œì„±í™”ëœ ì„¸ì…˜ ID
const [activeSession, setActiveSession] = useState<string | null>(null);

// ìë™í™” ì•¡ì…˜ë“¤ì˜ ë¡œê·¸
const [automationLog, setAutomationLog] = useState<AutomationAction[]>([]);
```

### ğŸ”° 3ë‹¨ê³„: ì‹¤ì œ êµ¬í˜„ ìˆœì„œ

#### ì²« ë²ˆì§¸: ê¸°ë³¸ ì„¸ì…˜ ìƒì„±

1. `InteractiveBrowserServer` êµ¬ì¡°ì²´ ë§Œë“¤ê¸°
2. `start_browser_session` ë„êµ¬ êµ¬í˜„í•˜ê¸°
3. `BrowserDrawer` ì»´í¬ë„ŒíŠ¸ ë§Œë“¤ê¸°
4. "New Session" ë²„íŠ¼ìœ¼ë¡œ í…ŒìŠ¤íŠ¸

#### ë‘ ë²ˆì§¸: ê°„ë‹¨í•œ ìƒí˜¸ì‘ìš© ì¶”ê°€

1. `click_element` ë„êµ¬ êµ¬í˜„
2. `BrowserPanel`ì—ì„œ í´ë¦­ í…ŒìŠ¤íŠ¸ UI ë§Œë“¤ê¸°
3. ì‹¤ì œ ì›¹í˜ì´ì§€ì—ì„œ ë²„íŠ¼ í´ë¦­ í…ŒìŠ¤íŠ¸

#### ì„¸ ë²ˆì§¸: ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€

1. `fill_input`, `scroll` ë„êµ¬ë“¤ êµ¬í˜„
2. UIì— í•´ë‹¹ ë²„íŠ¼ë“¤ ì¶”ê°€
3. ìë™í™” ë¡œê·¸ ê¸°ëŠ¥ êµ¬í˜„

### ğŸ”° 4ë‹¨ê³„: ë””ë²„ê¹… íŒ

#### ë°±ì—”ë“œ ë””ë²„ê¹…

```rust
// ë¡œê·¸ ì¶”ê°€í•˜ê¸°
use log::{info, warn, error};

info!("Creating browser session with URL: {}", url);
error!("Failed to create webview: {}", e);
```

#### í”„ë¡ íŠ¸ì—”ë“œ ë””ë²„ê¹…

```typescript
// ì¤‘ì•™í™”ëœ ë¡œê±° ì‚¬ìš©í•˜ê¸°
import { getLogger } from '@/lib/logger';
const logger = getLogger('BrowserPanel');

logger.info('Executing browser action', { action, params });
logger.error('Browser action failed', error);
```

### ğŸ”° 5ë‹¨ê³„: í…ŒìŠ¤íŠ¸ ë°©ë²•

1. **ê°œë°œ í™˜ê²½ ì‹¤í–‰**: `pnpm tauri dev`
2. **ìƒˆ ì„¸ì…˜ ìƒì„±**: Browser ë²„íŠ¼ í´ë¦­ â†’ New Session
3. **ê¸°ë³¸ í…ŒìŠ¤íŠ¸**: Google.comì—ì„œ ê²€ìƒ‰ì°½ í´ë¦­í•´ë³´ê¸°
4. **ìƒí˜¸ì‘ìš© í…ŒìŠ¤íŠ¸**: ê²€ìƒ‰ì–´ ì…ë ¥, ë²„íŠ¼ í´ë¦­ ë“±

ì´ ê°€ì´ë“œë¥¼ ë”°ë¼í•˜ë©´ ì´ˆë³´ ê°œë°œìë„ ë‹¨ê³„ë³„ë¡œ Interactive Browser Agentë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ë‹¨ê³„ì—ì„œ ë¬¸ì œê°€ ìƒê¸°ë©´ ë¡œê·¸ë¥¼ í™•ì¸í•˜ê³ , ì‘ì€ ë¶€ë¶„ë¶€í„° í…ŒìŠ¤íŠ¸í•´ê°€ë©° ì§„í–‰í•˜ì„¸ìš”!

## GitHub ì˜ˆì œ ê¸°ë°˜ êµ¬í˜„ íŒ

### 1. ìœˆë„ìš° ë ˆì´ì•„ì›ƒ ê´€ë¦¬

```rust
// tauri.conf.jsonì—ì„œ ë©”ì¸ ìœˆë„ìš° ì„¤ì •
{
  "windows": [{
    "label": "main",
    "width": 1200,
    "height": 800,
    "resizable": true,
    "fullscreen": false
  }]
}

// ëŸ°íƒ€ì„ì—ì„œ Side Drawer ì˜ì—­ ê³„ì‚°
fn calculate_drawer_bounds(window: &Window) -> (LogicalPosition<f64>, LogicalSize<f64>) {
    let size = window.inner_size().unwrap();
    let drawer_width = 400.0;
    let position = LogicalPosition::new(
        size.width as f64 - drawer_width, 
        0.0
    );
    let size = LogicalSize::new(drawer_width, size.height as f64);
    (position, size)
}
```

### 2. ì„¸ì…˜ ì „í™˜ ë©”ì»¤ë‹ˆì¦˜

```rust
impl InteractiveBrowserServer {
    async fn switch_session(&self, from_session: &str, to_session: &str) -> Result<(), String> {
        let mut sessions = self.browser_sessions.lock().await;
        
        // í˜„ì¬ ì„¸ì…˜ ìˆ¨ê¸°ê¸°
        if let Some(current) = sessions.get(from_session) {
            current.webview.hide().map_err(|e| format!("Failed to hide webview: {}", e))?;
        }
        
        // ìƒˆ ì„¸ì…˜ í‘œì‹œ
        if let Some(target) = sessions.get(to_session) {
            target.webview.show().map_err(|e| format!("Failed to show webview: {}", e))?;
            target.webview.set_focus().map_err(|e| format!("Failed to focus webview: {}", e))?;
        }
        
        Ok(())
    }
}
```

### 3. ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

```rust
impl InteractiveBrowserServer {
    async fn handle_webview_error(&self, session_id: &str, error: &str) -> MCPResponse {
        log::error!("WebView error in session {}: {}", session_id, error);
        
        // ì„¸ì…˜ ì¬ì‹œì‘ ì‹œë„
        if let Err(e) = self.restart_session(session_id).await {
            log::error!("Failed to restart session {}: {}", session_id, e);
            return MCPResponse::error(&format!("Session {} failed and could not be restarted", session_id));
        }
        
        MCPResponse::success(json!({
            "session_id": session_id,
            "action": "restarted",
            "reason": error
        }))
    }
}
```

ì´ ë¦¬íŒ©í† ë§ ê³„íšì„ í†µí•´ SynapticFlowëŠ” ë‹¨ìˆœí•œ í¬ë¡¤ë§ ë„êµ¬ì—ì„œ **ì™„ì „í•œ ë¸Œë¼ìš°ì € ìë™í™” í”Œë«í¼**ìœ¼ë¡œ ì§„í™”í•˜ê²Œ ë©ë‹ˆë‹¤.
