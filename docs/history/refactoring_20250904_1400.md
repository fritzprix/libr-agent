# Builtin MCP Server 통합 및 Workspace 도구 개선 Refactoring Plan

## 작업의 목적

현재 분산되어 있는 builtin MCP 서버들(filesystem, sandbox)을 **workspace**라는 통합된 개념으로 재구성하여 사용자 경험을 개선하고 도구 간 연결성을 강화한다.

### 핵심 목표

- **사용자 관점**: 직관적인 "작업공간" 개념으로 통일된 워크플로우 제공
- **개발 관점**: 중복 코드 제거 및 일관된 작업 디렉토리 관리
- **아키텍처 관점**: 도구 간 역할 명확화 및 확장성 확보

## 현재의 상태 / 문제점

### 1. 도구 간 역할 혼재 및 분산

- **filesystem server**: 파일 조작만 담당, SecureFileManager 기반 세션별 workspace 사용
- **sandbox server**: 코드 실행만 담당, 독립적인 `determine_execution_working_dir()` 로직
- **작업 디렉토리 불일치**: filesystem은 SecureFileManager.base_dir(), sandbox는 별도 로직

### 2. 사용자 경험 문제

- **네이밍 혼란**: `filesystem`이라는 기술적 용어로 인한 직관성 부족
- **분절된 워크플로우**: 파일 작업과 코드 실행이 별개 서버로 분리
- **도구 간 연결성 부족**: 파일 편집 → 코드 실행 → 결과 저장의 자연스러운 흐름 부재

### 3. 코드 중복 및 유지보수 문제

- **작업 디렉토리 로직 중복**: SecureFileManager와 sandbox의 별도 구현
- **일관성 부족**: 동일한 세션에서 서로 다른 작업 디렉토리 사용 가능성
- **확장성 제약**: 새로운 도구 추가시 서버별 별도 구현 필요

## 추가 분석 과제

### 1. SecureFileManager 통합 방식 최적화

- 현재 filesystem에서 사용하는 SecureFileManager 패턴을 sandbox 실행에도 적용
- 세션별 workspace 디렉토리의 영구성 및 보안 정책 일관성 확보

### 2. Export 기능 구현 범위 결정

- ZIP 패키지 생성을 위한 라이브러리 의존성 추가 여부
- 브라우저 다운로드 API와 Tauri 연동 방식 선택

### 3. 도구 통합 후 성능 영향 분석

- 단일 서버에서 파일 작업과 코드 실행을 모두 처리할 때의 성능 영향
- 동시 실행 요청 처리 방식 최적화

## 변경 이후의 상태 / 해결 판정 기준

### 1. 통합된 Workspace 서버

- **단일 서버**: `WorkspaceServer`로 파일 작업과 코드 실행 통합
- **일관된 작업 디렉토리**: 모든 도구가 SecureFileManager의 base_dir 사용
- **직관적 네이밍**: `builtin_workspace__*` 형태의 도구명

### 2. 개선된 사용자 워크플로우

```
파일 업로드 → 작업공간 저장 → 편집/분석 → 코드 실행 → 결과 저장 → Export
```

### 3. 판정 기준

- [ ] filesystem과 sandbox 서버 완전 제거
- [ ] 모든 파일 작업과 코드 실행이 SecureFileManager.base_dir()에서 수행
- [ ] 기존 기능 100% 호환성 유지
- [ ] workspace 도구 정상 동작 확인

## 수정이 필요한 코드 및 수정부분

### 1. 새로운 WorkspaceServer 생성

**파일**: `src-tauri/src/mcp/builtin/workspace.rs` (신규)

```rust
use async_trait::async_trait;
use serde_json::{json, Value};
use std::collections::HashMap;
use std::time::Duration;
use tempfile::TempDir;
use tokio::fs;
use tokio::process::Command;
use tokio::time::timeout;
use tracing::{error, info, warn};
use uuid::Uuid;

use super::{
    utils::constants::{DEFAULT_EXECUTION_TIMEOUT, MAX_CODE_SIZE, MAX_EXECUTION_TIMEOUT, MAX_FILE_SIZE},
    BuiltinMCPServer,
};
use crate::mcp::{utils::schema_builder::*, MCPError, MCPResponse, MCPTool};
use crate::services::SecureFileManager;

pub struct WorkspaceServer {
    file_manager: std::sync::Arc<SecureFileManager>,
}

impl WorkspaceServer {
    pub fn new(file_manager: std::sync::Arc<SecureFileManager>) -> Self {
        // workspace 디렉토리 로그
        info!(
            "WorkspaceServer using workspace directory: {:?}",
            file_manager.base_dir()
        );
        Self { file_manager }
    }

    /// SecureFileManager와 동일한 workspace 디렉토리 사용
    fn get_workspace_dir(&self) -> &std::path::Path {
        self.file_manager.base_dir()
    }

    /// Generate a new request ID for MCP responses
    fn generate_request_id() -> Value {
        Value::String(cuid2::create_id())
    }

    /// Create a success response with text content
    fn success_response(request_id: Value, message: &str) -> MCPResponse {
        MCPResponse::success(request_id, json!({ "text": message }))
    }

    /// Create an error response with consistent formatting
    fn error_response(&self, code: i32, message: &str) -> MCPResponse {
        MCPResponse::error(Self::generate_request_id(), code, message)
    }
}

#[async_trait]
impl BuiltinMCPServer for WorkspaceServer {
    fn name(&self) -> &str {
        "workspace"
    }

    fn description(&self) -> &str {
        "Integrated workspace for file operations and code execution"
    }

    fn tools(&self) -> Vec<MCPTool> {
        vec![
            // 파일 작업 도구들 (filesystem에서 이전)
            Self::create_read_file_tool(),
            Self::create_write_file_tool(),
            Self::create_list_directory_tool(),
            Self::create_search_files_tool(),
            Self::create_replace_lines_in_file_tool(),
            Self::create_grep_tool(),

            // 코드 실행 도구들 (sandbox에서 이전)
            Self::create_execute_python_tool(),
            Self::create_execute_typescript_tool(),
            Self::create_execute_shell_tool(),
        ]
    }

    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
        match tool_name {
            // 파일 작업 도구들
            "read_file" => self.handle_read_file(args).await,
            "write_file" => self.handle_write_file(args).await,
            "list_directory" => self.handle_list_directory(args).await,
            "search_files" => self.handle_search_files(args).await,
            "replace_lines_in_file" => self.handle_replace_lines_in_file(args).await,
            "grep" => self.handle_grep(args).await,

            // 코드 실행 도구들
            "execute_python" => self.handle_execute_python(args).await,
            "execute_typescript" => self.handle_execute_typescript(args).await,
            "execute_shell" => self.handle_execute_shell(args).await,

            _ => self.error_response(-32601, &format!("Tool '{}' not found", tool_name))
        }
    }
}

// 파일 작업 구현체들 (filesystem.rs에서 복사)
impl WorkspaceServer {
    // create_read_file_tool, create_write_file_tool 등 도구 생성 메서드들
    // handle_read_file, handle_write_file 등 핸들러 메서드들
    // filesystem.rs의 모든 구현체를 그대로 복사
}

// 코드 실행 구현체들 (sandbox.rs에서 복사 후 수정)
impl WorkspaceServer {
    async fn execute_code_in_sandbox(
        &self,
        command: &str,
        args: &[&str],
        code: &str,
        file_extension: &str,
        timeout_secs: u64,
    ) -> MCPResponse {
        let request_id = Self::generate_request_id();

        // Validate code size
        if code.len() > MAX_CODE_SIZE {
            return self.error_response(-32602, &format!("Code size {} exceeds maximum allowed size {}", code.len(), MAX_CODE_SIZE));
        }

        // Create temporary directory for sandboxed execution
        let temp_dir = match TempDir::new() {
            Ok(dir) => dir,
            Err(e) => return self.error_response(-32603, &format!("Failed to create temporary directory: {}", e)),
        };

        // Write code to temporary file
        let script_path = temp_dir.path().join(format!("script{}", file_extension));
        if let Err(e) = fs::write(&script_path, code).await {
            return self.error_response(-32603, &format!("Failed to write script file: {}", e));
        }

        // Prepare command with arguments
        let mut cmd = Command::new(command);
        for arg in args {
            cmd.arg(arg);
        }
        cmd.arg(&script_path);

        // 핵심 변경: SecureFileManager의 workspace 디렉토리 사용
        let work_dir = self.get_workspace_dir();
        info!("Code execution in workspace: {:?}", work_dir);
        cmd.current_dir(work_dir);

        // Clear environment variables for isolation
        cmd.env_clear();
        cmd.env("PATH", std::env::var("PATH").unwrap_or_default());

        // HOME은 workspace 디렉토리로 설정
        if let Some(workspace_str) = work_dir.to_str() {
            cmd.env("HOME", workspace_str);
            cmd.env("PWD", workspace_str);
        }

        // 임시 관련 변수는 temp_dir로 설정
        if let Some(tmp_str) = temp_dir.path().to_str() {
            cmd.env("TMPDIR", tmp_str);
            cmd.env("TMP", tmp_str);
            cmd.env("TEMP", tmp_str);
        }

        // Execute command with timeout
        let timeout_duration = Duration::from_secs(timeout_secs.min(MAX_EXECUTION_TIMEOUT));
        let execution_result = timeout(timeout_duration, cmd.output()).await;

        // 실행 결과 처리 (sandbox.rs와 동일)
        match execution_result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);

                let result = if output.status.success() {
                    json!({
                        "success": true,
                        "stdout": stdout,
                        "stderr": stderr,
                        "exit_code": output.status.code()
                    })
                } else {
                    json!({
                        "success": false,
                        "stdout": stdout,
                        "stderr": stderr,
                        "exit_code": output.status.code()
                    })
                };

                MCPResponse::success(request_id, result)
            }
            Ok(Err(e)) => self.error_response(-32603, &format!("Failed to execute command: {}", e)),
            Err(_) => self.error_response(-32603, &format!("Command execution timed out after {} seconds", timeout_secs)),
        }
    }

    // handle_execute_python, handle_execute_typescript, handle_execute_shell 등
    // sandbox.rs의 구현체들을 복사하되 작업 디렉토리 부분만 self.get_workspace_dir() 사용
}
```

### 2. 기존 서버 완전 제거

**삭제할 파일들**:

- `src-tauri/src/mcp/builtin/filesystem.rs`
- `src-tauri/src/mcp/builtin/sandbox.rs`

### 3. 모듈 등록 수정

**파일**: `src-tauri/src/mcp/builtin/mod.rs`

```rust
// 기존 imports 제거
// pub mod filesystem;
// pub mod sandbox;

// 새로운 import 추가
pub mod workspace;

// 기존 exports 제거
// pub use filesystem::FilesystemServer;
// pub use sandbox::SandboxServer;

// 새로운 export 추가
pub use workspace::WorkspaceServer;
```

**파일**: `src-tauri/src/mcp/builtin_manager.rs`

```rust
impl BuiltinMCPManager {
    pub fn new(file_manager: Arc<SecureFileManager>) -> Self {
        let mut servers: HashMap<String, Box<dyn BuiltinMCPServer + Send + Sync>> = HashMap::new();

        // workspace 서버만 등록 (기존 filesystem, sandbox 제거)
        servers.insert(
            "workspace".to_string(),
            Box::new(WorkspaceServer::new(file_manager)),
        );

        Self { servers }
    }
}
```

## 재사용 가능한 연관 코드

### 1. 파일 관리 관련

- **파일**: `src-tauri/src/services/secure_file_manager.rs`
- **주요 기능**: 경로 검증, 파일 읽기/쓰기, 디렉토리 나열
- **인터페이스**: `SecureFileManager::validate_path()`, `read_file()`, `write_file()`
- **재사용 방법**: WorkspaceServer에서 file_manager 인스턴스로 직접 활용

### 2. 세션 관리 관련

- **파일**: `src-tauri/src/session/manager.rs`
- **주요 기능**: 세션별 작업 디렉토리 관리
- **인터페이스**: `get_session_workspace_dir()`, 세션 상태 관리
- **재사용 방법**: SecureFileManager 생성시 이미 통합되어 있음

### 3. 스키마 빌더 유틸리티

- **파일**: `src-tauri/src/mcp/utils/schema_builder.rs`
- **주요 기능**: MCP 도구 스키마 생성
- **인터페이스**: `object_schema()`, `string_prop()`, `integer_prop()`
- **재사용 방법**: WorkspaceServer의 도구 정의에서 그대로 사용

### 4. 기존 도구 구현체 (복사 대상)

- **파일**: `src-tauri/src/mcp/builtin/filesystem.rs` - 모든 파일 작업 로직
- **파일**: `src-tauri/src/mcp/builtin/sandbox.rs` - 모든 코드 실행 로직
- **재사용 방법**: 구현체를 WorkspaceServer로 완전 복사 후 작업 디렉토리만 수정

### 5. 상수 및 설정

- **파일**: `src-tauri/src/mcp/builtin/utils/constants.rs`
- **내용**: `MAX_FILE_SIZE`, `DEFAULT_EXECUTION_TIMEOUT`, `MAX_EXECUTION_TIMEOUT`, `MAX_CODE_SIZE`
- **재사용 방법**: WorkspaceServer에서 동일한 상수들 import

### 6. 임시 디렉토리 관리

- **라이브러리**: `tempfile::TempDir`
- **용도**: 코드 실행시 스크립트 파일 임시 저장
- **재사용 방법**: sandbox.rs의 패턴 그대로 적용

## 구현 단계

### Phase 1: WorkspaceServer 구현 (1주)

1. 새로운 workspace.rs 파일 생성
2. filesystem.rs의 모든 구현체 복사
3. sandbox.rs의 모든 구현체 복사 및 작업 디렉토리 수정
4. 기본 동작 테스트

### Phase 2: 서버 교체 및 정리 (3일)

1. builtin_manager.rs에서 서버 등록 변경
2. 기존 filesystem.rs, sandbox.rs 파일 삭제
3. mod.rs 수정으로 모듈 구성 정리
4. 컴파일 및 기능 테스트

### Phase 3: 통합 테스트 및 검증 (2일)

1. 모든 파일 작업 도구 동작 확인
2. 모든 코드 실행 도구 동작 확인
3. 작업 디렉토리 일관성 검증
4. 성능
