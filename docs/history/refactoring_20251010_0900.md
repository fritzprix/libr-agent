# Refactoring Plan: AI Service Tool Use Forcing

## 1. 작업의 목적 (Purpose of the Task)

- **Agent Mode 구현**: AI가 응답 시 반드시 도구를 사용하도록 강제하는 "에이전트 모드"의 기반을 마련합니다.
- **AI Service 기능 확장**: `streamChat` 메소드에 `forceToolUse` 옵션을 추가하여, 각 AI 제공업체(OpenAI, Anthropic, Gemini)의 API에 맞게 도구 사용을 강제하는 기능을 구현합니다.
- **예측 가능한 에이전트 행동**: AI가 특정 작업에 대해 항상 도구를 사용하도록 하여, 보다 예측 가능하고 안정적인 에이전트 워크플로우를 구축합니다.

## 2. 현재의 상태 / 문제점 (Current State / Problems)

- 현재 AI 서비스 계층(`base-service.ts` 및 그 구현체)에는 AI 모델이 도구를 사용하도록 강제하는 기능이 없습니다.
- 모델은 자체적으로 판단하여 도구 사용 여부를 결정하므로(`auto` 모드), 특정 시나리오에서 도구 사용을 보장할 수 없습니다.
- 이로 인해, 도구 사용이 필수적인 에이전트의 안정적인 동작을 구현하기 어렵습니다.

## 3. 관련 코드의 구조 및 동작 방식 Summary (Bird's-eye View)

- **`IAIService` (`src/lib/ai-service/types.ts`)**: 모든 AI 서비스가 구현해야 하는 공통 인터페이스입니다.
- **`BaseAIService` (`src/lib/ai-service/base-service.ts`)**: 공통 로직을 제공하는 추상 클래스입니다. `streamChat` 메소드가 스트리밍 채팅 요청의 진입점 역할을 합니다.
- **Provider-specific Services (`src/lib/ai-service/*.ts`)**: `OpenAIService`, `AnthropicService`, `GeminiService` 등 각 제공업체별 구체적인 구현체입니다. 각 서비스는 `streamChat` 메소드 내에서 제공업체별 SDK를 호출하여 API와 통신합니다.
- **`tool_use_summary.md`**: 각 AI 제공업체별로 도구 사용을 강제하는 구체적인 API 파라미터와 동작 방식이 기술적으로 분석되어 있습니다.
  - **OpenAI**: `tool_choice: "required"`를 사용하여 하나 이상의 도구 사용을 강제합니다.
  - **Anthropic**: `tool_choice: "any"`를 사용하여 제공된 도구 중 하나를 사용하도록 강제합니다.
  - **Gemini**: `function_calling_config.mode: "ANY"`를 설정하여 도구 호출을 강제합니다.

## 4. 변경 이후의 상태 / 해결 판정 기준 (State After Change / Resolution Criteria)

- `BaseAIService`의 `streamChat` 메소드와 그 구현체들은 `forceToolUse: boolean` 옵션을 받게 됩니다.
- `forceToolUse: true`로 호출 시, 각 서비스는 AI 제공업체의 API 명세에 맞게 도구 사용을 강제하는 파라미터를 설정하여 요청을 보냅니다.
- **해결 판정 기준**: `streamChat`을 `forceToolUse: true`와 함께 호출했을 때, AI의 응답이 일반 텍스트가 아닌 반드시 `tool_calls`를 포함하는지 여부로 판정합니다. 이는 단위 테스트 및 통합 테스트를 통해 검증할 수 있습니다.

## 5. 수정이 필요한 코드 및 수정 부분의 코드 스니핏 (Code to be Modified & Snippets)

### `src/lib/ai-service/base-service.ts`

`streamChat` 메소드의 시그니처에 `forceToolUse` 옵션을 추가합니다.

```typescript
  abstract streamChat(
    messages: Message[],
    options?: {
      modelName?: string;
      systemPrompt?: string;
      availableTools?: MCPTool[];
      config?: AIServiceConfig;
      forceToolUse?: boolean; // <--- 추가
    },
  ): AsyncGenerator<string, void, void>;
```

### `src/lib/ai-service/openai.ts`

`streamChat` 내부에서 `tool_choice`를 동적으로 설정합니다.

```typescript
// ... in streamChat method
const completion = await this.withRetry(() =>
  this.openai.chat.completions.create(
    {
      model: modelName,
      messages: openaiMessages,
      max_completion_tokens: config.maxTokens,
      stream: true,
      tools: tools as OpenAIChatCompletionTool[],
      // vvvvvv 수정 vvvvvv
      tool_choice: !options.availableTools?.length
        ? undefined
        : options.forceToolUse
          ? 'required'
          : 'auto',
      // ^^^^^^ 수정 ^^^^^^
    },
    { signal: this.getAbortSignal() },
  ),
);
// ...
```

### `src/lib/ai-service/anthropic.ts`

`streamChat` 내부에서 `tool_choice`를 동적으로 추가합니다.

```typescript
// ... in streamChat method
const stream = this.anthropic.messages.stream(
  {
    model:
      options.modelName || config.defaultModel || 'claude-3-sonnet-20240229',
    max_tokens: config.maxTokens!,
    messages: anthropicMessages,
    ...(shouldEnableThinking && {
      thinking: {
        budget_tokens: 1024,
        type: 'enabled',
      },
    }),
    system: options.systemPrompt,
    tools: tools as AnthropicTool[],
    // vvvvvv 추가 vvvvvv
    ...(options.forceToolUse && { tool_choice: 'any' }),
    // ^^^^^^ 추가 ^^^^^^
  },
  { signal: this.getAbortSignal() },
);
// ...
```

### `src/lib/ai-service/gemini.ts`

`GeminiServiceConfig` 인터페이스를 수정하고, `streamChat`에서 `functionCallingConfig`를 설정합니다.

```typescript
// GeminiServiceConfig 인터페이스 수정
interface GeminiServiceConfig {
  responseMimeType: string;
  tools?: Array<{ functionDeclarations: FunctionDeclaration[] }>;
  systemInstruction?: Array<{ text: string }>;
  maxOutputTokens?: number;
  temperature?: number;
  functionCallingConfig?: { mode: 'AUTO' | 'ANY' | 'NONE' }; // <--- 추가
}

// ... in streamChat method
if (geminiTools) {
  geminiConfig.tools = geminiTools;
  // vvvvvv 추가 vvvvvv
  if (options.forceToolUse) {
    geminiConfig.functionCallingConfig = { mode: 'ANY' };
  }
  // ^^^^^^ 추가 ^^^^^^
}
// ...
```

## 6. 재사용 가능한 연관 코드 (Reusable Related Code)

- **`src/lib/ai-service/tool-converters.ts`**: `convertMCPToolsToProviderTools` 함수는 MCP 표준 도구를 각 AI 제공업체 형식으로 변환하는 데 계속 사용됩니다.
- **`src/lib/ai-service/utils.ts`**: `formatToolCall`과 같은 유틸리티 함수는 응답 포맷팅에 재사용됩니다.

## 7. Test Code 추가 및 수정 필요 부분에 대한 가이드 (Testing Guide)

- 각 서비스(`openai.ts`, `anthropic.ts`, `gemini.ts`)에 대한 단위 테스트를 추가해야 합니다.
- 각 테스트는 제공업체의 API 클라이언트를 모킹(mocking)하고, `streamChat`이 `forceToolUse: true`로 호출될 때 API 요청에 올바른 파라미터가 포함되었는지 확인해야 합니다.
  - **`OpenAIService`**: `tool_choice`가 `'required'`인지 검증합니다.
  - **`AnthropicService`**: `tool_choice`가 `'any'`인지 검증합니다.
  - **`GeminiService`**: `functionCallingConfig.mode`가 `'ANY'`인지 검증합니다.
- `useAIService.ts` 또는 상위 컴포넌트에서 `forceToolUse` 옵션이 서비스 계층까지 올바르게 전달되는지 확인하는 통합 테스트를 고려할 수 있습니다.
