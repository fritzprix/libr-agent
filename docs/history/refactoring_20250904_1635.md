# Workspace Export 경로 불일치 해결 Refactoring Plan

## 작업의 목적

BuiltIn MCP Server(WorkspaceServer)와 Tauri Command 간의 **워크스페이스 디렉토리 불일치 문제**를 해결하여 export 파일 생성과 다운로드가 동일한 위치에서 이루어지도록 한다.

### 핵심 목표

- **워크스페이스 통합**: BuiltIn MCP Server가 세션별 워크스페이스를 사용하도록 수정
- **경로 일치 보장**: 파일 생성 위치와 다운로드 검색 위치를 동일하게 통일
- **세션 관리 연동**: WorkspaceServer가 SessionManager를 통해 현재 활성 세션의 워크스페이스 사용
- **기존 기능 유지**: 파일 읽기/쓰기/실행 등 기존 WorkspaceServer 기능 정상 동작 보장

## 현재의 상태 / 문제점

### 1. 워크스페이스 디렉토리 불일치

**WorkspaceServer (파일 생성 측)**:

```rust
fn get_workspace_dir(&self) -> &std::path::Path {
    self.file_manager.base_dir()  // BuiltIn MCP 전용 워크스페이스
}
```

**Tauri Command (파일 다운로드 측)**:

```rust
let workspace_dir = session_manager.get_session_workspace_dir(); // 사용자 세션 워크스페이스
```

### 2. 에러 발생 시퀀스

1. **ZIP 생성**: `{builtin_mcp_workspace}/exports/packages/file.zip`에 파일 생성
2. **HTML 응답**: 상대 경로 `exports/packages/file.zip`로 다운로드 링크 제공
3. **다운로드 시도**: `{session_workspace}/exports/packages/file.zip`에서 파일 검색
4. **실패**: "File not found" 에러 발생 (다른 디렉토리에 파일 존재)

### 3. 현재 에러 로그 분석

```
[ERROR] [RustBackendClient] invoke failed
{"cmd":"download_workspace_file","err":"File not found: exports/packages/테스트_파일_패키지_20250904_063823.zip"}
```

- ZIP 파일은 생성되었으나 다른 위치에 저장됨
- Tauri Command가 세션 워크스페이스에서 파일을 찾으려 시도
- 경로 불일치로 인한 다운로드 실패

### 4. 아키텍처 상의 문제

- **BuiltIn MCP Server**: SecureFileManager의 고정 워크스페이스 사용
- **사용자 세션**: SessionManager를 통한 동적 워크스페이스 관리
- **분리된 파일 시스템**: 두 시스템이 서로 다른 디렉토리 구조 사용

## 추가 분석 과제

### 1. SessionManager와 BuiltIn MCP Server 연동 방안

- **의존성 주입**: WorkspaceServer 생성 시 SessionManager 참조 전달
- **동적 워크스페이스**: 런타임에 현재 활성 세션의 워크스페이스 동적 참조
- **라이프사이클 관리**: 세션 변경 시 WorkspaceServer의 워크스페이스 자동 업데이트

### 2. SecureFileManager 역할 재정의

- **보안 검증 기능**: 파일 경로 검증 및 접근 제어 기능 유지
- **워크스페이스 관리**: 세션별 워크스페이스를 기반으로 한 보안 정책 적용
- **기존 API 호환성**: 현재 SecureFileManager 인터페이스 유지

### 3. 멀티 세션 환경에서의 BuiltIn MCP Server 동작

- **세션별 격리**: 각 세션의 워크스페이스가 독립적으로 동작
- **동시성 처리**: 여러 세션에서 동시에 BuiltIn MCP Server 사용 시 충돌 방지
- **상태 관리**: 현재 활성 세션 추적 및 워크스페이스 동기화

## 변경 이후의 상태 / 해결 판정 기준

### 1. 통합된 워크스페이스 시스템

- **동일 위치**: 파일 생성과 다운로드가 동일한 세션 워크스페이스에서 실행
- **세션 연동**: WorkspaceServer가 SessionManager를 통해 현재 활성 세션 워크스페이스 사용
- **동적 업데이트**: 세션 변경 시 WorkspaceServer 워크스페이스 자동 전환

### 2. 개선된 에러 처리

- **파일 검색 성공**: export 파일이 정확한 위치에서 찾아짐
- **경로 검증**: 생성된 파일과 다운로드 대상 파일의 경로 일치
- **사용자 피드백**: 정상적인 다운로드 완료 메시지 표시

### 3. 향상된 시스템 일관성

- **통합 아키텍처**: BuiltIn MCP Server와 Tauri Command가 동일한 워크스페이스 참조
- **세션 기반 격리**: 각 사용자 세션별로 독립적인 파일 시스템 관리
- **보안 강화**: SessionManager 기반의 일관된 접근 제어

### 4. 판정 기준

- [ ] WorkspaceServer가 SessionManager를 통해 워크스페이스 디렉토리 참조
- [ ] export 파일 생성과 다운로드가 동일한 디렉토리에서 실행
- [ ] "File not found" 에러 없이 정상적인 파일 다운로드 동작
- [ ] 세션 변경 시 WorkspaceServer 워크스페이스 자동 업데이트
- [ ] 기존 파일 읽기/쓰기/실행 기능 정상 동작 유지
- [ ] 멀티 세션 환경에서 파일 격리 정상 작동

## 수정이 필요한 코드 및 수정부분

### 1. WorkspaceServer 생성자 수정

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
use crate::session::SessionManager;

pub struct WorkspaceServer {
    session_manager: std::sync::Arc<SessionManager>,
}

impl WorkspaceServer {
    pub fn new(session_manager: std::sync::Arc<SessionManager>) -> Self {
        info!(
            "WorkspaceServer using session-based workspace management"
        );
        Self { session_manager }
    }

    /// SessionManager를 통한 현재 활성 세션의 워크스페이스 사용
    fn get_workspace_dir(&self) -> std::path::PathBuf {
        self.session_manager.get_session_workspace_dir()
    }

    /// 동적 파일 매니저 생성 (현재 세션 기반)
    fn get_file_manager(&self) -> std::sync::Arc<crate::services::SecureFileManager> {
        self.session_manager.get_file_manager()
    }

    /// 파일 경로 검증 (세션 워크스페이스 기반)
    fn validate_path_with_error(
        &self,
        path_str: &str,
        request_id: &Value,
    ) -> Result<std::path::PathBuf, Box<MCPResponse>> {
        let file_manager = self.get_file_manager();
        match file_manager
            .get_security_validator()
            .validate_path(path_str)
        {
            Ok(path) => Ok(path),
            Err(e) => {
                error!("Path validation failed: {}", e);
                Err(Box::new(Self::error_response(
                    request_id.clone(),
                    -32603,
                    &format!("Security error: {e}"),
                )))
            }
        }
    }
}
```

### 2. BuiltIn MCP Server Manager 수정

**파일**: `src-tauri/src/mcp/builtin/mod.rs`

```rust
impl BuiltinMCPServerManager {
    pub fn new(session_manager: std::sync::Arc<SessionManager>) -> Self {
        let workspace_server = WorkspaceServer::new(session_manager.clone());
        // 다른 builtin 서버들도 필요시 session_manager 전달

        let mut servers: HashMap<String, Box<dyn BuiltinMCPServer + Send + Sync>> = HashMap::new();
        servers.insert("workspace".to_string(), Box::new(workspace_server));

        Self { servers }
    }
}
```

### 3. 메인 애플리케이션에서 의존성 주입

**파일**: `src-tauri/src/lib.rs`

```rust
// 전역 session manager 활용
fn get_mcp_manager() -> &'static MCPServerManager {
    MCP_MANAGER.get_or_init(|| {
        let session_manager = get_session_manager().expect("SessionManager not initialized");
        MCPServerManager::new_with_session_manager(session_manager)
    })
}

// MCPServerManager 생성자 수정
impl MCPServerManager {
    pub fn new_with_session_manager(session_manager: std::sync::Arc<SessionManager>) -> Self {
        let builtin_manager = BuiltinMCPServerManager::new(session_manager);
        Self {
            builtin_servers: std::sync::Arc::new(builtin_manager),
            external_servers: std::sync::Arc::new(tokio::sync::RwLock::new(HashMap::new())),
        }
    }
}
```

### 4. 파일 작업 메서드 수정

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
impl WorkspaceServer {
    async fn handle_write_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let path_str = match args.get("path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: path",
                );
            }
        };

        let content = match args.get("content").and_then(|v| v.as_str()) {
            Some(content) => content,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: content",
                );
            }
        };

        let mode = args.get("mode").and_then(|v| v.as_str()).unwrap_or("w");

        // 동적으로 현재 세션의 파일 매니저 사용
        let file_manager = self.get_file_manager();
        let result = match mode {
            "w" => file_manager.write_file(path_str, content).await,
            "a" => file_manager.append_file(path_str, content).await,
            _ => Err(format!("Unknown write mode: {}", mode)),
        };

        match result {
            Ok(_) => Self::success_response(request_id, &format!("File written successfully: {}", path_str)),
            Err(e) => Self::error_response(request_id, -32603, &format!("Failed to write file: {}", e)),
        }
    }

    /// Export 디렉토리 초기화 (세션 워크스페이스 기반)
    fn ensure_exports_directory(&self) -> Result<std::path::PathBuf, String> {
        let workspace_dir = self.get_workspace_dir();
        let exports_dir = workspace_dir.join("exports");

        // files 및 packages 하위 디렉토리 생성
        let files_dir = exports_dir.join("files");
        let packages_dir = exports_dir.join("packages");

        for dir in [&exports_dir, &files_dir, &packages_dir] {
            if !dir.exists() {
                std::fs::create_dir_all(dir)
                    .map_err(|e| format!("Failed to create directory {:?}: {}", dir, e))?;
            }
        }

        Ok(exports_dir)
    }
}
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 컴포넌트

**파일**: `src-tauri/src/session/mod.rs`

- **기능**: 세션별 워크스페이스 관리, 파일 매니저 제공
- **인터페이스**: `get_session_workspace_dir()`, `get_file_manager()`
- **재사용**: WorkspaceServer에서 직접 활용

**파일**: `src-tauri/src/services/file_manager.rs`

- **기능**: 보안 파일 접근, 경로 검증
- **인터페이스**: `validate_path()`, `write_file()`, `read_file()`
- **재사용**: 세션별 파일 매니저 인스턴스 동적 생성

**파일**: `src-tauri/src/mcp/builtin/mod.rs`

- **기능**: BuiltIn MCP Server 생명주기 관리
- **재사용**: 의존성 주입 패턴으로 SessionManager 전달

### 확장 필요한 인터페이스

**파일**: `src-tauri/src/mcp/manager.rs`

```rust
impl MCPServerManager {
    // 기존 new() 메서드와 병행 사용
    pub fn new_with_session_manager(
        session_manager: std::sync::Arc<SessionManager>
    ) -> Self {
        // SessionManager 기반 초기화
    }

    // 세션 변경 시 BuiltIn 서버 워크스페이스 업데이트
    pub async fn update_session_workspace(&self) -> Result<(), String> {
        // 현재 활성 세션의 워크스페이스로 업데이트
    }
}
```

**파일**: `src-tauri/src/mcp/builtin/workspace.rs`

```rust
impl BuiltinMCPServer for WorkspaceServer {
    // 기존 인터페이스 유지하면서 내부 구현만 세션 기반으로 변경
    // 호환성 보장을 위한 기존 메서드 시그니처 유지
}
```

이 계획을 통해 BuiltIn MCP Server와 사용자 세션 워크스페이스를 완전히 통합하여 파일 생성과 다운로드가 동일한 위치에서 이루어지도록 보장할 수 있습니다.
