# ChatContext 상태 관리 개선 리팩토링 계획

## 작업의 목적

ChatContext에서 Tool 실행 상태 관리의 타이밍 문제를 해결하여 사용자 경험을 개선한다. 현재 AI 응답 완료와 Tool 실행 시작 사이의 미세한 간격으로 인해 Cancel 버튼이 잠깐 비활성화되는 hiccup을 제거하고, Tool 실행 중에도 사용자가 추가 메시지를 입력할 수 있도록 상태 관리를 개선한다.

## 현재의 상태 / 문제점

### 현재 상태

1. **isLoading 상태 계산**

   ```tsx
   // ChatContext.tsx 라인 251
   const isLoading = aiServiceLoading || isToolExecuting;
   ```

2. **Tool 실행 상태 관리**

   ```tsx
   // ToolCaller에서 execute 함수 내부에서만 상태 변경
   onToolExecutionChange(true);  // tool 실행 시작
   // ... tool 실행 ...
   } finally {
     onToolExecutionChange(false); // tool 실행 완료
   }
   ```

3. **ChatInput의 제한적인 처리**

   ```tsx
   // ChatInput.tsx 라인 47
   if (isLoading) {
     cancel();
     return;
   }
   ```

### 문제점

1. **Cancel 버튼 hiccup**: AI 응답 완료 후 Tool 실행 시작까지의 미세한 간격에서 Cancel 버튼이 잠깐 비활성화됨
   - `aiServiceLoading = false` (AI 응답 완료)
   - `isToolExecuting = false` (아직 Tool 실행 시작 안됨)
   - 결과: `isLoading = false`가 되어 Cancel 버튼 비활성화

2. **사용자 입력 완전 차단**: Tool 실행 중 사용자가 추가 메시지를 입력할 수 없음
   - Recursive tool loop 중 사용자 개입 불가
   - 입력 필드와 Submit 버튼 모두 비활성화

3. **상태 관리의 단순화 문제**: 모든 로딩 상태를 하나의 `isLoading`으로 관리하여 세밀한 제어 어려움

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **자연스러운 Tool 상태 관리**
   - AI 응답에 tool_calls가 있으면 즉시 tool 실행 상태를 `true`로 설정
   - AI 응답에 tool_calls가 없으면 대화 완료로 간주하여 `false`로 설정
   - Gap 없는 연속적인 상태 전환

2. **개선된 사용자 경험**
   - Cancel 버튼의 일관된 활성화 상태 유지
   - Tool 실행 중에도 사용자 메시지 입력 가능 (선택적)

3. **세분화된 상태 관리**
   - AI 응답 로딩과 Tool 실행 상태의 분리된 관리
   - 각 상태에 따른 적절한 UI 제어

### 해결 판정 기준

1. **Cancel 버튼 hiccup 제거**: Tool call이 포함된 AI 응답 후 Cancel 버튼이 중간에 비활성화되지 않음
2. **상태 전환의 자연스러움**: AI 응답 완료와 Tool 실행 시작 사이의 Gap 제거
3. **사용자 입력 개선**: Tool 실행 중 사용자 메시지 입력 가능 (Phase 2)

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ToolCaller useEffect 개선 (ChatContext.tsx)

**현재 코드 (라인 167-184):**

```tsx
useEffect(() => {
  const lastMessage = messages[messages.length - 1];
  if (
    lastMessage &&
    lastMessage.role === 'assistant' &&
    lastMessage.tool_calls &&
    lastMessage.tool_calls.length > 0 &&
    !lastMessage.isStreaming &&
    !loading &&
    lastMessage.id &&
    lastProcessedMessageId.current !== lastMessage.id
  ) {
    lastProcessedMessageId.current = lastMessage.id;
    execute(lastMessage);
  }
}, [messages, execute, loading]);
```

**수정 코드:**

```tsx
useEffect(() => {
  const lastMessage = messages[messages.length - 1];

  if (
    lastMessage &&
    lastMessage.role === 'assistant' &&
    !lastMessage.isStreaming
  ) {
    if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
      // Tool call이 있으면 즉시 tool 실행 상태를 true로 설정
      onToolExecutionChange(true);

      if (
        !loading &&
        lastMessage.id &&
        lastProcessedMessageId.current !== lastMessage.id
      ) {
        lastProcessedMessageId.current = lastMessage.id;
        execute(lastMessage);
      }
    } else {
      // Tool call이 없으면 대화 완료로 간주하여 false로 설정
      onToolExecutionChange(false);
    }
  }
}, [messages, execute, loading, onToolExecutionChange]);
```

### 2. execute 함수 내 상태 관리 조정 (ChatContext.tsx)

**현재 코드 (라인 63):**

```tsx
// Tool 실행 시작을 부모에게 알림
onToolExecutionChange(true);
```

**수정 방향:**

- useEffect에서 이미 `true`로 설정되므로 중복 호출 제거 고려
- 또는 execute 함수 시작 시 확실하게 `true` 보장을 위해 유지

### 3. Phase 2: ChatInput 상태 분리 개선

**현재 코드 (ChatInput.tsx):**

```tsx
const { submit, isLoading, cancel } = useChatContext();

if (isLoading) {
  cancel();
  return;
}
```

**개선 방향:**

```tsx
const { submit, isLoading, isToolExecuting, cancel } = useChatContext();

// Tool 실행 중에는 cancel만 허용하고 새 메시지 입력도 허용
if (isLoading && !isToolExecuting) {
  cancel();
  return;
}

// Tool 실행 중에도 사용자 입력 허용 (큐잉 방식)
```

## 재사용 가능한 연관 코드

### 주요 파일들

1. **`/src/context/ChatContext.tsx`**
   - `ToolCaller` 컴포넌트 (라인 47-184)
   - `ChatProvider` 컴포넌트의 상태 관리 로직
   - `isLoading` 상태 계산 (라인 251)

2. **`/src/features/chat/components/ChatInput.tsx`**
   - `handleSubmit` 함수 (라인 43-85)
   - Submit 버튼 disabled 조건 (라인 164-168)
   - `useChatContext` 훅 사용

3. **관련 훅들**
   - `useAIService`: AI 서비스 로딩 상태 관리
   - `useChatContext`: Chat 상태 및 함수 제공
   - `useAsyncFn`: Tool 실행 비동기 상태 관리

### 주요 인터페이스

```tsx
interface ChatContextValue {
  submit: (messageToAdd?: Message[], agentKey?: string) => Promise<Message>;
  isLoading: boolean;
  messages: Message[];
  cancel: () => void;
}

interface ToolCallerProps {
  onToolExecutionChange: (isExecuting: boolean) => void;
}
```

### 상태 흐름

```
AI 응답 시작 → aiServiceLoading = true → isLoading = true
AI 응답 완료 → aiServiceLoading = false
Tool call 감지 → isToolExecuting = true → isLoading = true (지속)
Tool 실행 완료 → isToolExecuting = false → isLoading = false
```

## 추가 분석 과제

1. **성능 영향 평가**: useEffect 의존성 배열 변경이 렌더링 성능에 미치는 영향 분석

2. **Race Condition 검토**: 빠른 연속 메시지 처리 시 상태 전환의 안정성 확인

3. **Error 시나리오 분석**: Tool 실행 실패 시 상태 복구 메커니즘 검토

4. **사용자 입력 큐잉 방식**: Tool 실행 중 사용자 입력을 어떻게 처리할지에 대한 UX 설계

5. **Cancel 동작 개선**: 현재 다음 submit 시에만 취소가 적용되는 방식의 개선 가능성 검토
