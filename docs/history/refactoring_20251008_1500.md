# Refactoring plan: Terminal session management & async execute\_\* tools

Date: 2025-10-08 15:00 UTC
Author: (automation) refactor plan for feat/terminal-session-management

---

## 1) Purpose

Introduce a Terminal Session Management subsystem and extend the workspace `execute_*` tools so agents can:

- Open and reuse terminal sessions (persistent per-session shells).
- Run commands synchronously or asynchronously through those terminals.
- Poll/read terminal output incrementally (so LLM agents can continue reasoning while long-running commands run).

This enables incremental environment bootstrapping (export, PATH mutation, virtualenv activation) and non-blocking agent workflows.

## 2) Current state / problems

- Current execution model (see `src-tauri/src/mcp/builtin/workspace/code_execution.rs`):
  - `execute_python`, `execute_typescript`, `execute_shell` create a temporary execution context and spawn a single isolated process using `SessionIsolationManager::create_isolated_command`.
  - Execution is synchronous: handler waits for `cmd.output()` (with a timeout). During this wait, the agent cannot poll results incrementally.
  - Temporary scripts are created in a `TempDir` and removed when the call completes.
- Session environment is not preserved between calls:
  - Commands like `export FOO=bar` do not persist in subsequent `execute_*` invocations.
  - This makes stepwise terminal setup (e.g., activate venv, export PATH) impractical.
- No primitives to create, list, read, or close interactive terminals from MCP toolset.

## 3) Birdseye view of relevant code (locations & responsibilities)

- `src-tauri/src/mcp/builtin/workspace/mod.rs` — WorkspaceServer: MCP tool dispatch and service context.
- `src-tauri/src/mcp/builtin/workspace/code_execution.rs` — Execution handlers and normalization (current execute\_\* implementations).
- `src-tauri/src/session_isolation.rs` — SessionIsolationManager and `IsolatedProcessConfig` (creates `tokio::process::Command` with env/working dir and different isolation levels).
- `src-tauri/src/session.rs` — SessionManager and session workspace handling (workspace dir per session, pool management).
- `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs` — MCPTool metadata for execute tools.

## 4) Desired post-change behavior & success criteria

- Features
  - `open_new_terminal(shell?, env?)`: returns `terminal_id` and spawns a persistent terminal process using **pipes-based implementation** (no PTY in Phase 1).
  - `execute_*` **strictly requires** `terminal_id` (no ephemeral/legacy path) and accepts an `async` flag. Commands are routed to the specified terminal.
  - `read_terminal_output(terminal_id, since_index?)` returns incremental output chunks + next index and closed flag.
  - `list_terminals(session_id?)` and `close_terminal(terminal_id)` are available.
  - **No separate `set_terminal_env` tool**: environment changes are made through `execute_*` (e.g., `export FOO=bar` via `execute_shell`).
  - Default isolation level: **Medium**.
  - Security: Terminal processes restricted to **workspace directory and subdirectories only** (no shell allowlist needed).
  - Terminal lifecycle: **No idle timeout**; terminals cleaned up on session context switch or explicit `close_terminal`.
  - Session removal: Terminals are **force-killed** (SIGTERM → SIGKILL) without blocking session deletion.
- Success criteria (automated checks)
  - Unit tests: open/write/read/close round-trip passes.
  - Integration smoke: open terminal → export ENV → execute python via terminal → subsequent execute using the same terminal sees exported env in the same session process (or documented limitation if using strict isolation). Preferably, `export` + `echo $FOO` roundtrip works in terminal mode.
  - APIs are validated to reject calls that omit required `terminal_id` for `execute_*` (negative tests included).
  - No regressions in existing compilation (cargo clippy / fmt) and existing MCP tool contracts.

## 5) Planned code changes (file-level, with snippets)

Overview: add a `TerminalManager` and `TerminalSession` (new file), extend MCP tool metadata and WorkspaceServer handlers, and make `execute_*` terminal-aware and terminal-required.

Files to add & modify:

1.  Add: `src-tauri/src/terminal_manager.rs` (new)
    - Responsibility: manage lifecycle of terminals (open, write, read, close, list). Maintain in-memory map of `terminal_id -> TerminalSession`.
    - Key types & methods (sketch):

```rust
// ...existing code...
pub struct TerminalManager { terminals: tokio::sync::RwLock<HashMap<String, TerminalSession>> }

pub struct TerminalSession {
    pub terminal_id: String,
    pub session_id: Option<String>,
    pub created_at: std::time::Instant,
    pub last_accessed: std::time::Instant,
    pub env: std::collections::HashMap<String,String>,
    // Implementation detail: either PTY master handle or child stdin/stdout pipes
    // plus a background task that drains stdout/stderr into an in-memory buffer
    pub output_buffer: tokio::sync::Mutex<Vec<String>>,
    pub closed: tokio::sync::AtomicBool,
}

impl TerminalManager {
    pub async fn open_new_terminal(&self, session_id: Option<String>, shell: Option<String>, env: Option<HashMap<String,String>>) -> Result<String,String> { ... }
    pub async fn write_to_terminal(&self, terminal_id: &str, input: &str) -> Result<(),String> { ... }
    pub async fn read_terminal_output(&self, terminal_id: &str, since_index: Option<usize>) -> Result<TerminalReadResult,String> { ... }
    pub async fn close_terminal(&self, terminal_id: &str) -> Result<(),String> { ... }
    pub fn list_terminals(&self, session_id: Option<&str>) -> Vec<TerminalSummary> { ... }
}
```

- Implementation notes:
  - Use **pipes-based implementation only** (spawn child with `Command::new(shell).args(&["-i"])` and connect stdin/stdout via tokio pipes). PTY support deferred to future phases.
  - Spawn a background task that reads stdout/stderr and pushes lines/bytes into `output_buffer` with an index. `read_terminal_output` returns new entries since `since_index` and the next index.
  - In-memory buffer cap: **1MB** (configurable); oldest entries dropped when exceeded.
  - **No disk logging/persistence** for terminal output.
  - Working directory restricted to session workspace directory.
  - Environment variables managed through shell commands (`export` in bash/sh, `set` in cmd, etc.) via `execute_*`.
  - **Binary output handling**: Auto-detect UTF-8 validity per chunk. Valid UTF-8 returned as text; invalid bytes base64-encoded. Response includes `encoding` field ("utf8" or "base64").

2.  Modify: `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`
    - Update MCPTool schema for `execute_python`, `execute_typescript`, `execute_shell` to **require** `terminal_id`, include `async` boolean and optional `env` map.
    - Add new tool creators: `create_open_new_terminal_tool()`, `create_read_terminal_output_tool()`, `create_close_terminal_tool()`, `create_list_terminals_tool()` and include them in `tools()`.
    - **Note**: No separate `set_terminal_env` tool; environment changes through `execute_shell` commands.

3.  Modify: `src-tauri/src/mcp/builtin/workspace/mod.rs` (WorkspaceServer)
    - Import terminal manager (e.g., `use crate::terminal_manager::get_terminal_manager;`).
    - Register new tool names in `call_tool` mapping to handlers:
      - `open_new_terminal` => `handle_open_new_terminal` (new)
      - `read_terminal_output` => `handle_read_terminal_output` (new)
      - `close_terminal` => `handle_close_terminal` (new)
      - `list_terminals` => `handle_list_terminals` (new)
    - Keep `get_service_context()` behavior unchanged except optionally exposing active terminal count.

4.  Modify: `src-tauri/src/mcp/builtin/workspace/code_execution.rs`
    - Change signatures so handlers require `terminal_id` and read `async` from `args`.
    - New behavior in each handler (pseudocode):

```rust
// terminal_id is required; API validation ensures presence
let term_id = args.get("terminal_id").and_then(|v| v.as_str()).expect("terminal_id is required");
let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);

// send to terminal
let manager = crate::terminal_manager::get_terminal_manager();
manager.write_to_terminal(term_id, formatted_command).await.map_err(|e| ...)?;

if async_flag {
    return Self::success_response(request_id, &format!("Command sent to terminal {term_id}"));
}

// else: wait for sentinel or timeout: read outputs until sentinel appears or timeout expires
let output = manager.read_terminal_output_until_sentinel(term_id, timeout_secs).await?;
return Self::success_response(request_id, &output);
```

- For Python/TypeScript code, the implementation will create the temporary script in session workspace (not TempDir) when a terminal is used, because TempDir is removed at function end and we want the shell to be able to `python3 script.py` referencing a persisted path during async runs. Alternatively, write the script directly to the terminal's stdin if the interactive REPL approach is chosen; the script-file approach is more robust.

5.  Modify (optional): `src-tauri/src/session_isolation.rs`
    - Add optional `inherit_env: bool` or allow passing `base_env` to `IsolatedProcessConfig` so env merging is explicit when spawning isolated commands vs reusing terminal envs.

## 6) Tests & QA

Add tests under `src-tauri/tests/`:

- `terminal_manager_unit.rs`:
  - open_new_terminal_returns_id
  - write_and_read_roundtrip (echo test)
  - close_terminal_marks_closed
- `workspace_terminal_integration.rs`:
  - open terminal, run `export TEST_TMP=ok`, run `echo $TEST_TMP`, assert output contains `ok`.
  - open terminal, `python -c 'print(1+1)'` -> output `2`.
- API negative tests: calling `execute_*` without `terminal_id` should return a validation error and be covered by unit tests.

Test strategy notes:

- Use pipes fallback for tests to avoid PTY dependency problems in CI; plan separate PTY tests for local runs.
- Use deterministic sentinel markers when waiting for command completion in sync mode, e.g., wrap commands with `; echo __SYN_FLOW_DONE__$?` so reader can detect termination reliably.

## 7) Rollout plan / timeline (suggested)

Phase 1 (POC, 1-2 days)

- Implement `TerminalManager` with **pipes-based sessions only**, minimal API (open/write/read/close/list).
- Wire new MCP tools and handlers. Make `execute_*` **strictly require** `terminal_id` and route to TerminalManager (sync `async=false` only).
- Add unit tests for manager and basic integration tests.
- Binary output: auto-detect UTF-8 and encode to base64 when needed, with `encoding` field in response.

Phase 2 (improvements, 1-2 days)

- Add `async=true` behavior (returns immediately, agent polls via `read_terminal_output`).
- Add buffer caps (1MB default), **context-switch cleanup** (remove terminals on session switch).
- Add `session_id` linkage and ensure session removal **force-kills** associated terminals (SIGTERM → SIGKILL).

Phase 3 (optional future enhancements)

- PTY support using `portable-pty` for better REPL behavior (if needed).
- More integration/edge-case tests.

Total estimate: 2–4 working days for Phase 1-2 (pipes-only implementation).

## 8) Rollback & safety

- API change: `execute_*` now requires `terminal_id`; callers must open a terminal beforehand. This is an intentional breaking change in the MCP tool contract for `execute_*` to enforce session-based execution and avoid accidental ephemeral spawns.
- Feature can be reverted by restoring prior `execute_*` handlers and the previous tool schemas if needed.

## 9) Reusable related code & interfaces (file references)

- `src-tauri/src/mcp/builtin/workspace/code_execution.rs` — execution helpers, normalization utilities (modify here for terminal-aware routing).
- `src-tauri/src/session_isolation.rs` — `IsolatedProcessConfig` and `SessionIsolationManager` (consider env merging).
- `src-tauri/src/session.rs` — session workspace functions (reuse workspace dir when persisting temp scripts for terminals).
- `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs` — tool metadata to update.
- `src-tauri/src/mcp/builtin/workspace/mod.rs` — MCP tool routing (add new handlers).

## 10) Code snippets: exact small edits (suggested diffs)

- Example: parsing `terminal_id` and `async` inside `handle_execute_shell` in `code_execution.rs` (pseudocode):

```rust
let term_id = args.get("terminal_id").and_then(|v| v.as_str()).expect("terminal_id is required");
let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);

// send to terminal
let manager = crate::terminal_manager::get_terminal_manager();
manager.write_to_terminal(term_id, &normalized_command).await.map_err(|e| ...)?;

if async_flag {
    return Self::success_response(request_id, &format!("Sent to terminal {term_id}"));
}

// wait for sentinel or timeout and return output
let output = manager.read_terminal_output_until_sentinel(term_id, timeout_secs).await?;
return Self::success_response(request_id, &output);
```

- Example: Tool metadata change (add params) in `code_tools.rs` — update schemas to mark `terminal_id` required and include `async`, `env`.

## 11) Test & quality gates

Before merge, run:

- `pnpm refactor:validate` as project guide recommends (runs lint/format/build checks and Rust checks).
- `cargo test` for new tests (under `src-tauri/tests/`).
- Manual smoke: start app in dev mode and use MCP client to call `open_new_terminal`, `execute_shell` with `terminal_id`, `read_terminal_output`.

## 12) Additional analysis tasks (if needed)

- ~~Decide and document expected semantics for `env` when mixing terminal sessions and `IsolatedProcessConfig`~~ → **Decided**: Environment managed via `execute_shell` commands; default isolation level is Medium.
- ~~Decide expected isolation semantics for terminal sessions when `isolation_level=high`~~ → **Decided**: Default Medium isolation; workspace directory restrictions apply.
- ~~Evaluate CI compatibility of PTY crate~~ → **Decided**: Phase 1 uses pipes-only; PTY deferred to future optional phase.

## 13) History file rule

This document will be saved under:
`docs/history/refactoring_20251008_1500.md` (this file). When merging, please keep that convention and add a short summary to the PR description.
