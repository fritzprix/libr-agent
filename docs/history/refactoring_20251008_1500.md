# Refactoring plan: Terminal session management & async execute\_\* tools

Date: 2025-10-08 15:00 UTC
Author: (automation) refactor plan for feat/terminal-session-management

---

## 1) Purpose

Introduce a Terminal Session Management subsystem and extend the workspace `execute_*` tools so agents can:

- Open and reuse terminal sessions (persistent per-session shells).
- Run commands synchronously or asynchronously through those terminals.
- Poll/read terminal output incrementally (so LLM agents can continue reasoning while long-running commands run).

This enables incremental environment bootstrapping (export, PATH mutation, virtualenv activation) and non-blocking agent workflows.

## 2) Current state / problems

- Current execution model (see `src-tauri/src/mcp/builtin/workspace/code_execution.rs`):
  - `execute_python`, `execute_typescript`, `execute_shell` create a temporary execution context and spawn a single isolated process using `SessionIsolationManager::create_isolated_command`.
  - Execution is synchronous: handler waits for `cmd.output()` (with a timeout). During this wait, the agent cannot poll results incrementally.
  - Temporary scripts are created in a `TempDir` and removed when the call completes.
- Session environment is not preserved between calls:

  # Refactoring plan: Terminal session management & async execute\_\* tools

  Date: 2025-10-08 15:00 UTC
  Author: (automation) refactor plan for feat/terminal-session-management

  ***

  ## 1) Purpose

  Introduce a Terminal Session Management subsystem and extend the workspace `execute_*` tools so agents can:
  - Open and reuse terminal sessions (persistent per-session shells).
  - Run commands synchronously or asynchronously through those terminals.
  - Poll/read terminal output incrementally (so LLM agents can continue reasoning while long-running commands run).

  This enables incremental environment bootstrapping (export, PATH mutation, virtualenv activation) and non-blocking agent workflows.

  ## 2) Current state / problems
  - Current execution model (see `src-tauri/src/mcp/builtin/workspace/code_execution.rs`):
    - `execute_python`, `execute_typescript`, `execute_shell` create a temporary execution context and spawn a single isolated process using `SessionIsolationManager::create_isolated_command`.
    - Execution is synchronous: handler waits for `cmd.output()` (with a timeout). During this wait, the agent cannot poll results incrementally.
    - Temporary scripts are created in a `TempDir` and removed when the call completes.
  - Session environment is not preserved between calls:
    - Commands like `export FOO=bar` do not persist in subsequent `execute_*` invocations.
    - This makes stepwise terminal setup (e.g., activate venv, export PATH) impractical.
  - No primitives to create, list, read, or close interactive terminals from MCP toolset.

  ## 3) Birdseye view of relevant code (locations & responsibilities)
  - `src-tauri/src/mcp/builtin/workspace/mod.rs` — WorkspaceServer: MCP tool dispatch and service context.
  - `src-tauri/src/mcp/builtin/workspace/code_execution.rs` — Execution handlers and normalization (current execute\_\* implementations).
  - `src-tauri/src/session_isolation.rs` — SessionIsolationManager and `IsolatedProcessConfig` (creates `tokio::process::Command` with env/working dir and different isolation levels).
  - `src-tauri/src/session.rs` — SessionManager and session workspace handling (workspace dir per session, pool management).
  - `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs` — MCPTool metadata for execute tools.

  ## 4) Desired post-change behavior & success criteria
  - Features
    - `open_new_terminal(shell?, env?)`: returns `terminal_id` and spawns a persistent terminal process (PTY preferred; pipes fallback ok).
    - `execute_*` MUST require `terminal_id` and accept an `async` flag. Commands are routed to the specified terminal; calling `execute_*` without `terminal_id` is disallowed by the API.
    - `read_terminal_output(terminal_id, since_index?)` returns incremental output chunks + next index and closed flag.
    - `list_terminals(session_id?)` and `close_terminal(terminal_id)` are available.
  - Success criteria (automated checks)
    - Unit tests: open/write/read/close round-trip passes.
    - Integration smoke: open terminal → export ENV → execute python via terminal → subsequent execute using the same terminal sees exported env in the same session process (or documented limitation if using strict isolation). Preferably, `export` + `echo $FOO` roundtrip works in terminal mode.
    - APIs are validated to reject calls that omit required `terminal_id` for `execute_*` (negative tests included).
    - No regressions in existing compilation (cargo clippy / fmt) and existing MCP tool contracts.

  ## 5) Planned code changes (file-level, with snippets)

  Overview: add a `TerminalManager` and `TerminalSession` (new file), extend MCP tool metadata and WorkspaceServer handlers, and make `execute_*` terminal-aware and terminal-required.

  Files to add & modify:
  1.  Add: `src-tauri/src/terminal_manager.rs` (new)
      - Responsibility: manage lifecycle of terminals (open, write, read, close, list). Maintain in-memory map of `terminal_id -> TerminalSession`.
      - Key types & methods (sketch):

  ```rust
  // ...existing code...
  pub struct TerminalManager { terminals: tokio::sync::RwLock<HashMap<String, TerminalSession>> }

  pub struct TerminalSession {
      pub terminal_id: String,
      pub session_id: Option<String>,
      pub created_at: std::time::Instant,
      pub last_accessed: std::time::Instant,
      pub env: std::collections::HashMap<String,String>,
      // Implementation detail: either PTY master handle or child stdin/stdout pipes
      // plus a background task that drains stdout/stderr into an in-memory buffer
      pub output_buffer: tokio::sync::Mutex<Vec<String>>,
      pub closed: tokio::sync::AtomicBool,
  }

  impl TerminalManager {
      pub async fn open_new_terminal(&self, session_id: Option<String>, shell: Option<String>, env: Option<HashMap<String,String>>) -> Result<String,String> { ... }
      pub async fn write_to_terminal(&self, terminal_id: &str, input: &str) -> Result<(),String> { ... }
      pub async fn read_terminal_output(&self, terminal_id: &str, since_index: Option<usize>) -> Result<TerminalReadResult,String> { ... }
      pub async fn close_terminal(&self, terminal_id: &str) -> Result<(),String> { ... }
      pub fn list_terminals(&self, session_id: Option<&str>) -> Vec<TerminalSummary> { ... }
  }
  ```

  - Implementation notes:
    - Start with a pipes-based fallback (spawn child with `Command::new(shell).args(&["-i"])` and connect stdin/stdout via tokio pipes). This is simpler and portable. Add PTY implementation (using `portable-pty`) in a separate step for better interactivity.
    - Spawn a background task that reads stdout/stderr and pushes lines/bytes into `output_buffer` with an index. `read_terminal_output` returns new entries since `since_index` and the next index.
    - Keep a configurable output buffer cap; oldest entries are dropped when exceeded.
  2.  Modify: `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`
      - Update MCPTool schema for `execute_python`, `execute_typescript`, `execute_shell` to require `terminal_id`, include `async` boolean and optional `env` map.
      - Add new tool creators: `create_open_new_terminal_tool()`, `create_read_terminal_output_tool()`, `create_close_terminal_tool()`, `create_list_terminals_tool()` and include them in `tools()`.

  3.  Modify: `src-tauri/src/mcp/builtin/workspace/mod.rs` (WorkspaceServer)
      - Import terminal manager (e.g., `use crate::terminal_manager::get_terminal_manager;`).
      - Register new tool names in `call_tool` mapping to handlers:
        - `open_new_terminal` => `handle_open_new_terminal` (new)
        - `read_terminal_output` => `handle_read_terminal_output` (new)
        - `close_terminal` => `handle_close_terminal` (new)
        - `list_terminals` => `handle_list_terminals` (new)
      - Keep `get_service_context()` behavior unchanged except optionally exposing active terminal count.

  4.  Modify: `src-tauri/src/mcp/builtin/workspace/code_execution.rs`
      - Change signatures so handlers require `terminal_id` and read `async` from `args`.
      - New behavior in each handler (pseudocode):

  ```rust
  // terminal_id is required; API validation ensures presence
  let term_id = args.get("terminal_id").and_then(|v| v.as_str()).expect("terminal_id is required");
  let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);

  // send to terminal
  let manager = crate::terminal_manager::get_terminal_manager();
  manager.write_to_terminal(term_id, formatted_command).await.map_err(|e| ...)?;

  if async_flag {
      return Self::success_response(request_id, &format!("Command sent to terminal {term_id}"));
  }

  // else: wait for sentinel or timeout: read outputs until sentinel appears or timeout expires
  let output = manager.read_terminal_output_until_sentinel(term_id, timeout_secs).await?;
  return Self::success_response(request_id, &output);
  ```

  - For Python/TypeScript code, the implementation will create the temporary script in session workspace (not TempDir) when a terminal is used, because TempDir is removed at function end and we want the shell to be able to `python3 script.py` referencing a persisted path during async runs. Alternatively, write the script directly to the terminal's stdin if the interactive REPL approach is chosen; the script-file approach is more robust.
  5.  Modify (optional): `src-tauri/src/session_isolation.rs`
      - Add optional `inherit_env: bool` or allow passing `base_env` to `IsolatedProcessConfig` so env merging is explicit when spawning isolated commands vs reusing terminal envs.

  ## 6) Tests & QA

  Add tests under `src-tauri/tests/`:
  - `terminal_manager_unit.rs`:
    - open_new_terminal_returns_id
    - write_and_read_roundtrip (echo test)
    - close_terminal_marks_closed
  - `workspace_terminal_integration.rs`:
    - open terminal, run `export TEST_TMP=ok`, run `echo $TEST_TMP`, assert output contains `ok`.
    - open terminal, `python -c 'print(1+1)'` -> output `2`.
  - API negative tests: calling `execute_*` without `terminal_id` should return a validation error and be covered by unit tests.

  Test strategy notes:
  - Use pipes fallback for tests to avoid PTY dependency problems in CI; plan separate PTY tests for local runs.
  - Use deterministic sentinel markers when waiting for command completion in sync mode, e.g., wrap commands with `; echo __SYN_FLOW_DONE__$?` so reader can detect termination reliably.

  ## 7) Rollout plan / timeline (suggested)

  Phase 1 (POC, 1-2 days)
  - Implement `TerminalManager` with pipes-based sessions, minimal API (open/write/read/close/list).
  - Wire new MCP tools and handlers. Make `execute_*` require `terminal_id` and route to TerminalManager (sync `async=false` only).
  - Add unit tests for manager and basic integration tests.

  Phase 2 (improvements, 1-2 days)
  - Add `async=true` behavior (returns immediately, agent polls via `read_terminal_output`).
  - Add buffer caps, idle timeouts, cleanup tasks.
  - Add `session_id` linkage and ensure `SessionManager` cleanup closes associated terminals.

  Phase 3 (stabilize, 1-2 days)
  - Replace pipes fallback with PTY (`portable-pty`) for better REPL behavior (optional dependency).
  - Add more integration/edge-case tests, e.g., long-running commands, binary output handling.

  Total estimate: 3–6 working days depending on PTY adoption and test coverage.

  ## 8) Rollback & safety
  - API change: `execute_*` now requires `terminal_id`; callers must open a terminal beforehand. This is an intentional breaking change in the MCP tool contract for `execute_*` to enforce session-based execution and avoid accidental ephemeral spawns.
  - Feature can be reverted by restoring prior `execute_*` handlers and the previous tool schemas if needed.

  ## 9) Reusable related code & interfaces (file references)
  - `src-tauri/src/mcp/builtin/workspace/code_execution.rs` — execution helpers, normalization utilities (modify here for terminal-aware routing).
  - `src-tauri/src/session_isolation.rs` — `IsolatedProcessConfig` and `SessionIsolationManager` (consider env merging).
  - `src-tauri/src/session.rs` — session workspace functions (reuse workspace dir when persisting temp scripts for terminals).
  - `src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs` — tool metadata to update.
  - `src-tauri/src/mcp/builtin/workspace/mod.rs` — MCP tool routing (add new handlers).

  ## 10) Code snippets: exact small edits (suggested diffs)
  - Example: parsing `terminal_id` and `async` inside `handle_execute_shell` in `code_execution.rs` (pseudocode):

  ```rust
  let term_id = args.get("terminal_id").and_then(|v| v.as_str()).expect("terminal_id is required");
  let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);

  // send to terminal
  let manager = crate::terminal_manager::get_terminal_manager();
  manager.write_to_terminal(term_id, &normalized_command).await.map_err(|e| ...)?;

  if async_flag {
      return Self::success_response(request_id, &format!("Sent to terminal {term_id}"));
  }

  // wait for sentinel or timeout and return output
  let output = manager.read_terminal_output_until_sentinel(term_id, timeout_secs).await?;
  return Self::success_response(request_id, &output);
  ```

  - Example: Tool metadata change (add params) in `code_tools.rs` — update schemas to mark `terminal_id` required and include `async`, `env`.

  ## 11) Test & quality gates

  Before merge, run:
  - `pnpm refactor:validate` as project guide recommends (runs lint/format/build checks and Rust checks).
  - `cargo test` for new tests (under `src-tauri/tests/`).
  - Manual smoke: start app in dev mode and use MCP client to call `open_new_terminal`, `execute_shell` with `terminal_id`, `read_terminal_output`.

  ## 12) Additional analysis tasks (if needed)
  - Decide and document expected semantics for `env` when mixing terminal sessions and `IsolatedProcessConfig` (should isolated spawn inherit terminal env?).
  - Decide expected isolation semantics for terminal sessions when `isolation_level=high` (can we spawn a PTY inside unshare sandbox reliably?).
  - Evaluate CI compatibility of PTY crate (`portable-pty`) and provide fallback for headless CI environments.

  ## 13) History file rule

  This document will be saved under:
  `docs/history/refactoring_20251008_1500.md` (this file). When merging, please keep that convention and add a short summary to the PR description.
