# Refactoring Plan: Large File Modularization and Code Duplication Removal

## 작업의 목적

SynapticFlow 프로젝트의 대형 파일들을 모듈화하고 코드 중복을 제거하여 유지보수성과 확장성을 향상시키는 것. 특히 BrowserToolProvider.tsx, Chat.tsx, filesystem.rs, db.ts, mcp.rs 등 5개 대형 파일을 대상으로 기능별 서브모듈 분리와 공통 헬퍼 함수 도입을 통해 코드 복잡성을 줄이고, 타입 안전성과 코딩 규약 준수를 보장한다.

## 현재의 상태 / 문제점

### 주요 문제 파일들

- `src/features/tools/BrowserToolProvider.tsx` (961줄): 20개 이상 브라우저 도구의 inputSchema/execute 반복, 단일 파일 집중
- `src/features/chat/Chat.tsx` (939줄): UI/비즈니스/상태 관리 혼재, 다중 책임
- `src-tauri/src/mcp/builtin/filesystem.rs` (842줄): JSONSchema 생성 코드 중복, 각 MCPTool 생성 함수 반복
- `src/lib/db.ts` (841줄): 타입/CRUD/DB 클래스 혼재, 버전 관리 로직 포함
- `src-tauri/src/mcp.rs` (834줄): MCP 타입/구조체/핸들러/유틸리티 혼재

### 공통 문제점

- 코드 중복: inputSchema/JSONSchema 생성, CRUD 인터페이스, MCPTool 등록 패턴 반복
- 단일 책임 위반: 각 파일이 다중 책임 담당
- 타입 안전성 부족: inline import 타입, any 사용 가능성
- 코딩 규약 위반: 중앙 로거 미사용, 들여쓰기 불일치

## 재사용 가능한 연관 코드

### 1. rust-backend-client.ts 브라우저 관련 함수들

**파일 경로**: `src/lib/rust-backend-client.ts`

**주요 기능**:

- `createBrowserSession(params: {url: string, title?: string | null}): Promise<string>`
- `closeBrowserSession(sessionId: string): Promise<void>`
- `listBrowserSessions(): Promise<BrowserSession[]>`
- `clickElement(sessionId: string, selector: string): Promise<string>`
- `inputText(sessionId: string, selector: string, text: string): Promise<string>`
- `pollScriptResult(requestId: string): Promise<string | null>`
- `navigateToUrl(sessionId: string, url: string): Promise<string>`

**특징**:

- 모든 함수가 `safeInvoke`를 통해 Tauri 명령을 안전하게 래핑
- 일관된 에러 핸들링 및 로깅 제공
- 타입 안전성 보장
- BrowserToolProvider.tsx에서 이미 import하여 사용 중

### 2. BrowserToolProvider.tsx 내 공통 함수들

**파일 경로**: `src/features/tools/BrowserToolProvider.tsx`

**주요 기능**:

- `formatBrowserResult(raw: unknown): string` - JSON 결과 포맷팅 및 진단 정보 표시
- `executeScript` (useBrowserInvoker에서 제공) - 브라우저 스크립트 실행

### 3. Rust Backend 서비스들

**파일 경로**: `src-tauri/src/services/interactive_browser_server.rs`

**주요 기능**:

- `create_browser_session()` - 브라우저 세션 생성
- `execute_script()` - JavaScript 실행 및 결과 폴링
- `click_element()`, `input_text()` 등 - 구체적인 브라우저 조작 함수들

## 추가 분석 과제

1. **Worker 호환성 검증**: 모듈 분할 후 동적 import 경로 변경이 Vite 번들러에 미치는 영향 분석
2. **성능 영향 측정**: 모듈 분할 전후 초기 로딩 시간 및 번들 크기 변화 측정
3. **의존성 그래프 분석**: 각 파일의 참조 관계를 파악하여 순환 의존성 방지
4. **테스트 커버리지 평가**: 분할 후 각 서브모듈의 단위 테스트 필요성 및 범위 결정

## 변경 이후의 상태 / 해결 판정 기준

### 성공 판정 기준

1. **빌드/테스트 통과**: `pnpm lint && pnpm format && pnpm build` 성공
2. **코드 중복 제거**: JSONSchema/CRUD/MCPTool 생성 코드 70% 이상 감소
3. **모듈 분리 완료**: 각 파일의 책임이 단일하게 분리, 서브모듈 5개 이상 생성
4. **타입 안전성 보장**: 모든 파일에서 `any` 제거, strict 모드 준수
5. **코딩 규약 준수**: 중앙 로거 사용, 2-space 들여쓰기, 파일 상단 import 정리
6. **기능 유지**: 기존 MCP 툴 호출, UI 동작, DB 작업 정상 동작

### 변경 후 파일 구조

```
src/features/tools/
├── BrowserToolProvider.tsx      # 도구 등록/해제 담당
└── browser-tools/               # 도구별 서브모듈
    ├── CreateSessionTool.tsx
    ├── CloseSessionTool.tsx
    └── ...

src/features/chat/
├── Chat.tsx                     # 메인 컨테이너
├── components/                  # 서브컴포넌트
│   ├── SessionFilesPopover.tsx
│   └── ...
└── hooks/                       # 커스텀 훅
    ├── useChatState.ts
    └── ...

src-tauri/src/mcp/
├── builtin/
│   └── filesystem.rs            # 간결화된 MCPTool 생성
└── utils/
    └── schema_builder.rs        # JSONSchema 헬퍼

src/lib/
├── db/
│   ├── types.ts                 # 타입 정의
│   ├── crud.ts                  # CRUD 인터페이스
│   └── service.ts               # DB 서비스
└── mcp/
    ├── types.rs                 # MCP 타입/구조체
    ├── server.rs                # 서버 관리
    └── utils.rs                 # 유틸리티
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. BrowserToolProvider.tsx 모듈화

**현재 문제**: 961줄의 단일 파일에 20개 이상 도구가 모두 정의됨

```typescript
// 변경 전: BrowserToolProvider.tsx (현재)
const browserTools: LocalMCPTool[] = [
  {
    name: 'createSession',
    description: 'Creates a new interactive browser session...',
    inputSchema: {
      type: 'object',
      properties: {
        url: { type: 'string', description: 'The URL to navigate...' },
        title: { type: 'string', description: 'Optional title...' },
      },
      required: ['url'],
    },
    execute: async (args: Record<string, unknown>) => {
      const { url, title } = args as { url: string; title?: string };
      logger.debug('Executing browser_createSession', { url, title });
      const sessionId = await createBrowserSession({
        url,
        title: title || null,
      });
      return `Browser session created successfully: ${sessionId}`;
    },
  },
  // ... 19개 도구 더 정의됨
];
```

```typescript
// 변경 후: BrowserToolProvider.tsx (리팩토링 후)
import { createSessionTool } from './browser-tools/CreateSessionTool';
import { closeSessionTool } from './browser-tools/CloseSessionTool';
import { clickElementTool } from './browser-tools/ClickElementTool';
// ... 다른 도구들 import

const browserTools: LocalMCPTool[] = [
  createSessionTool,
  closeSessionTool,
  clickElementTool,
  // ... 다른 도구들 (15개 서브모듈에서 import)
];
```

### 2. Chat.tsx 컴포넌트 분해

**현재 문제**: 939줄의 단일 파일에 UI/비즈니스/상태 로직 혼재

```typescript
// 변경 전: Chat.tsx (현재 - 939줄)
function Chat({ children }: ChatProps) {
  const [showToolsDetail, setShowToolsDetail] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  // ... 100줄 이상의 상태 관리 로직
  // ... 200줄 이상의 UI 렌더링 로직
  // ... 100줄 이상의 이벤트 핸들러
}
```

```typescript
// 변경 후: Chat.tsx (리팩토링 후)
import { useChatState } from './hooks/useChatState';
import { SessionFilesPopover } from './components/SessionFilesPopover';
import { ChatInput } from './components/ChatInput';

function Chat({ children }: ChatProps) {
  const { showToolsDetail, setShowToolsDetail, selectedFiles } = useChatState();
  // 간결화된 UI 로직만 유지 (약 200줄로 축소)
}
```

### 3. filesystem.rs 스키마 빌더 활용

**현재 문제**: 각 MCPTool 생성 함수에서 JSONSchema를 반복 생성

```rust
// 변경 전: filesystem.rs (현재)
fn create_read_file_tool() -> MCPTool {
    MCPTool {
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert("path".to_string(), JSONSchema {
                        schema_type: JSONSchemaType::String {
                            min_length: Some(1),
                            max_length: Some(1000),
                            description: Some("Path to file".to_string()),
                        },
                        required: true,
                    });
                    // ... 20줄 이상 반복
                    props
                }),
                required: Some(vec!["path".to_string()]),
            },
        },
        // ...
    }
}
```

```rust
// 변경 후: filesystem.rs (리팩토링 후)
fn create_read_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert("path".to_string(), string_prop(Some(1), Some(1000), Some("Path to file")));
    props.insert("start_line".to_string(), integer_prop(Some(1), None, Some("Start line")));

    MCPTool {
        input_schema: object_schema(props, vec!["path".to_string()]),
        // 간결화된 코드 (기존 30줄 → 5줄)
    }
}
```

### 4. db.ts 계층 분리

**현재 문제**: 타입/CRUD/DB 클래스가 한 파일에 혼재

```typescript
// 변경 전: db.ts (현재 - 841줄)
export interface DatabaseService {
  assistants: CRUD<Assistant>;
  // ... 다른 인터페이스들
}

class LocalDatabase extends Dexie {
  // ... 100줄 이상의 DB 로직
  // ... CRUD 인터페이스 구현
  // ... 버전 관리 로직
}
```

```typescript
// 변경 후: 분리된 파일들
// types.ts
export interface DatabaseService {
  assistants: CRUD<Assistant>;
  // ... 다른 인터페이스들
}

// service.ts
import { DatabaseService } from './types';
export class LocalDatabase extends Dexie implements DatabaseService {
  // 간결화된 DB 로직만 (기존 841줄 → 200줄)
}
```

### 5. mcp.rs 구조체 분리

**현재 문제**: MCP 타입/구조체/핸들러/유틸리티가 한 파일에 혼재

```rust
// 변경 전: mcp.rs (현재 - 834줄)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// ... 핸들러 함수들
// ... 유틸리티 함수들
```

```rust
// 변경 후: 분리된 파일들
// types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

// schema.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// server.rs
// ... 서버 관리 로직만

// utils.rs
// ... 유틸리티 함수들만
```

## 작업 단계

### Phase 1: 준비 및 분석 (1일)

1. 각 파일의 의존성 그래프 분석
2. Worker 호환성 테스트 케이스 작성
3. 빌드/테스트 환경 검증

### Phase 2: BrowserToolProvider.tsx 리팩터링 (2일)

#### 2.1 현재 구조 분석 및 재사용 가능한 코드 식별

**재사용 가능한 코드들 (rust-backend-client.ts):**

- `createBrowserSession(params: {url: string, title?: string})`
- `closeBrowserSession(sessionId: string)`
- `listBrowserSessions(): Promise<BrowserSession[]>`
- `clickElement(sessionId: string, selector: string)`
- `inputText(sessionId: string, selector: string, text: string)`
- `pollScriptResult(requestId: string): Promise<string | null>`
- `navigateToUrl(sessionId: string, url: string)`

**공통 헬퍼 함수들 (BrowserToolProvider.tsx 내):**

- `formatBrowserResult(raw: unknown): string` - JSON 결과 포맷팅
- Element state 체크 스크립트 (clickElement, inputText에서 중복)
- Polling 로직 (30회, 100ms 간격)

**현재 중복 패턴:**

1. 각 도구별 inputSchema 직접 정의
2. Element 존재성/상태 체크 스크립트 반복
3. Polling + timeout 로직 반복
4. Error handling + logging 패턴 반복

#### 2.2 리팩토링 단계별 계획

##### 단계 2.2.1: 공통 헬퍼 모듈 생성 (4시간)

```typescript
// src/features/tools/browser-tools/helpers.ts

// 공통 스키마 정의
export const BROWSER_TOOL_SCHEMAS = {
  sessionId: { type: 'string' as const, description: 'Browser session ID' },
  selector: { type: 'string' as const, description: 'CSS selector' },
  url: { type: 'string' as const, description: 'URL to navigate to' },
  text: { type: 'string' as const, description: 'Text content' },
};

// 공통 Element 상태 체크 함수 (rust-backend-client 활용)
export async function checkElementState(
  executeScript: Function,
  sessionId: string,
  selector: string,
  action: 'click' | 'input',
): Promise<{ exists: boolean; valid: boolean; diagnostics?: any }> {
  const script = `(function() {
    const el = document.querySelector('${selector}');
    if (!el) return JSON.stringify({exists: false});
    
    const rect = el.getBoundingClientRect();
    const style = window.getComputedStyle(el);
    const visible = rect.width > 0 && rect.height > 0 && 
                   style.display !== 'none' && style.visibility !== 'hidden';
    
    if (action === 'input') {
      const disabled = el.disabled || el.readOnly;
      return JSON.stringify({exists: true, valid: visible && !disabled, rect, style});
    } else {
      const clickable = visible && style.pointerEvents !== 'none' && !el.disabled;
      return JSON.stringify({exists: true, valid: clickable, rect, style});
    }
  })()`;

  const result = await executeScript(sessionId, script);
  return JSON.parse(result);
}

// 공통 Polling 함수
export async function pollWithTimeout(
  pollFn: () => Promise<string | null>,
  maxAttempts = 30,
  interval = 100,
): Promise<string | null> {
  for (let attempts = 0; attempts < maxAttempts; attempts++) {
    const result = await pollFn();
    if (result !== null) return result;
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  return null;
}
```

##### 단계 2.2.2: 간단한 도구들 서브모듈화 (4시간)

```typescript
// src/features/tools/browser-tools/CreateSessionTool.ts
import { createBrowserSession } from '@/lib/rust-backend-client';
import { BROWSER_TOOL_SCHEMAS } from './helpers';

export const createSessionTool = {
  name: 'createSession',
  description:
    'Creates a new interactive browser session in a separate window.',
  inputSchema: {
    type: 'object',
    properties: {
      url: BROWSER_TOOL_SCHEMAS.url,
      title: {
        type: 'string',
        description: 'Optional title for the browser session window.',
      },
    },
    required: ['url'],
  },
  execute: async (args: Record<string, unknown>) => {
    const { url, title } = args as { url: string; title?: string };
    // rust-backend-client의 함수 직접 활용
    const sessionId = await createBrowserSession({ url, title: title || null });
    return `Browser session created successfully: ${sessionId}`;
  },
};
```

##### 단계 2.2.3: 복잡한 도구들 리팩토링 (4시간)

```typescript
// src/features/tools/browser-tools/ClickElementTool.ts
import { clickElement, pollScriptResult } from '@/lib/rust-backend-client';
import {
  checkElementState,
  pollWithTimeout,
  BROWSER_TOOL_SCHEMAS,
} from './helpers';
import { formatBrowserResult } from '../BrowserToolProvider';

export const clickElementTool = {
  name: 'clickElement',
  description: 'Clicks on a DOM element using CSS selector.',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: BROWSER_TOOL_SCHEMAS.sessionId,
      selector: BROWSER_TOOL_SCHEMAS.selector,
    },
    required: ['sessionId', 'selector'],
  },
  execute: async (
    args: Record<string, unknown>,
    executeScript: (sessionId: string, script: string) => Promise<string>,
  ) => {
    const { sessionId, selector } = args as {
      sessionId: string;
      selector: string;
    };

    // 공통 헬퍼로 상태 체크 (기존 30줄 → 3줄)
    const state = await checkElementState(
      executeScript,
      sessionId,
      selector,
      'click',
    );
    if (!state.exists) {
      return formatBrowserResult(
        JSON.stringify({
          ok: false,
          action: 'click',
          reason: 'element_not_found',
          selector,
        }),
      );
    }
    if (!state.valid) {
      return formatBrowserResult(
        JSON.stringify({
          ok: false,
          action: 'click',
          reason: 'element_not_clickable',
          selector,
          diagnostics: state.diagnostics,
        }),
      );
    }

    // rust-backend-client의 clickElement 함수 활용
    const requestId = await clickElement(sessionId, selector);

    // 공통 헬퍼로 폴링 (기존 15줄 → 3줄)
    const result = await pollWithTimeout(() => pollScriptResult(requestId));
    return result ? formatBrowserResult(result) : 'Click operation timed out';
  },
};
```

##### 단계 2.2.4: 메인 Provider 리팩토링 (4시간)

```typescript
// BrowserToolProvider.tsx (리팩토링 후)
import { createSessionTool } from './browser-tools/CreateSessionTool';
import { closeSessionTool } from './browser-tools/CloseSessionTool';
import { clickElementTool } from './browser-tools/ClickElementTool';
// ... 다른 도구들 import

export function BrowserToolProvider() {
  const { executeScript } = useBrowserInvoker();

  useEffect(() => {
    const browserTools = [
      createSessionTool,
      closeSessionTool,
      {
        ...clickElementTool,
        execute: (args) => clickElementTool.execute(args, executeScript),
      },
      // ... 다른 도구들
    ];

    // 기존 400줄의 도구 정의 → 50줄로 축소
    const service = {
      /* 간결화된 서비스 정의 */
    };

    register('browser', service);
    return () => unregister('browser');
  }, [executeScript]);

  return null;
}
```

#### 2.3 예상 효과 및 메트릭

**코드 중복 감소:**

- inputSchema 정의: ~70% 감소 (공통 스키마 재사용)
- Element 체크 로직: ~80% 감소 (공통 헬퍼)
- Polling 로직: ~90% 감소 (공통 헬퍼)
- Error handling: ~60% 감소 (표준화)

**파일 구조 개선:**

- BrowserToolProvider.tsx: 961줄 → ~200줄 (79% 감소)
- 신규 서브모듈: 15개 파일 생성
- 각 도구별 책임 분리로 유지보수성 향상

**테스트 용이성:**

- 각 도구별 독립적 단위 테스트 가능
- 공통 헬퍼 함수별 테스트 가능
- Mock 주입으로 의존성 격리 용이

#### 2.4 위험 관리 및 검증

**주요 리스크:**

1. **executeScript 의존성 주입**: 각 도구에서 executeScript를 사용해야 하는 경우 파라미터로 전달
2. **타입 안전성**: 공통 스키마 사용 시 타입 정의 일관성 유지
3. **성능 영향**: 모듈 분할로 인한 초기 로딩 시간 증가 가능성

**완화 전략:**

1. **점진적 마이그레이션**: 한 도구씩 서브모듈로 분리하며 테스트
2. **타입 검증**: TypeScript strict 모드로 컴파일 에러 방지
3. **번들 분석**: Webpack Bundle Analyzer로 청크 크기 모니터링

**검증 기준:**

- 모든 브라우저 도구 정상 동작
- 빌드 성공 및 린트 통과
- 번들 크기 증가 10% 이내
- 각 서브모듈별 단위 테스트 커버리지 80% 이상

### Phase 3: Chat.tsx 리팩터링 (2일)

#### Phase 3 작업의 목적

`Chat.tsx`의 대형 단일 컴포넌트(939줄)를 기능별로 분리하여 유지보수성과 확장성을 높인다. UI, 상태 관리, 비즈니스 로직, 파일 첨부 등 각 역할별로 서브컴포넌트/커스텀 훅으로 분리한다. 파일 첨부 및 드래그앤드롭, 세션 파일 관리 등 복잡한 로직을 별도 모듈로 분리하여 테스트 용이성과 코드 재사용성을 강화한다. 타입 안전성, 중앙 로거 사용, 2-space 들여쓰기 등 프로젝트 코딩 규약을 엄격히 준수한다.

#### Phase 3 현재의 상태 / 문제점

- **단일 책임 원칙 위반**: UI, 상태 관리, 파일 첨부, 메시지 렌더링, 도구 상태 등 모든 로직이 하나의 파일에 혼재.
- **파일 첨부 로직 복잡**: 드래그앤드롭, MIME 타입 판별, Rust backend 연동, Blob URL 관리, 에러 핸들링 등 100줄 이상이 한 곳에 집중.
- **테스트 어려움**: 각 기능별로 분리되어 있지 않아 단위 테스트 및 Mock 주입이 어렵다.
- **코드 중복**: 파일 첨부, 메시지 렌더링, 도구 상태 표시 등 유사 패턴 반복.
- **타입 안전성 부족**: 일부 타입 추론에 의존, 인터페이스 분리 미흡.
- **코딩 규약 미흡**: 일부 로깅에 console 사용, 들여쓰기 불일치 가능성.

#### Phase 3 추가 분석 과제

- 파일 첨부 로직 분리 시, Blob URL 및 cleanup 관리가 ResourceAttachmentContext에서 일관되게 처리되는지 검증.
- 드래그앤드롭 이벤트와 Tauri Webview 연동 시, 커스텀 훅으로 분리해도 이벤트 누락/중복 발생 여부 테스트.
- 세션 파일과 첨부 파일의 구분이 명확히 유지되는지, UI/비즈니스 로직 분리 후에도 기능이 동일하게 동작하는지 확인.
- 각 서브컴포넌트/훅 분리 후, 기존 props/context 의존성 순환 참조 발생 가능성 분석.

#### Phase 3 변경 이후의 상태 / 해결 판정 기준

- **빌드/테스트 통과**: `pnpm lint && pnpm format && pnpm build` 성공.
- **모듈 분리 완료**: `Chat.tsx`가 200줄 이하로 축소, 주요 기능별 서브컴포넌트/커스텀 훅 5개 이상 생성.
- **파일 첨부 로직 분리**: 드래그앤드롭, MIME 판별, Rust backend 연동, Blob 관리 등 별도 훅/모듈로 이동.
- **타입 안전성 보장**: 모든 파일에서 `any` 제거, 인터페이스/타입 분리, strict 모드 준수.
- **코딩 규약 준수**: 중앙 로거 사용, 2-space 들여쓰기, 파일 상단 import 정리.
- **기능 유지**: 기존 메시지 전송, 파일 첨부, 세션 파일 관리, 도구 상태 표시 등 UI/비즈니스 로직 정상 동작.

#### Phase 3 수정이 필요한 코드 및 수정부분의 코드 스니핏

##### 1. 커스텀 훅 분리 (예시: useChatState, useFileAttachment)

```typescript
// src/features/chat/hooks/useChatState.ts
import { useState } from 'react';

export function useChatState() {
  const [showToolsDetail, setShowToolsDetail] = useState(false);
  // ... 기타 상태 관리
  return { showToolsDetail, setShowToolsDetail /* ... */ };
}
```

```typescript
// src/features/chat/hooks/useFileAttachment.ts
import { useResourceAttachment } from '@/context/ResourceAttachmentContext';
import { getLogger } from '@/lib/logger';

const logger = getLogger('FileAttachment');

export function useFileAttachment() {
  const {
    pendingFiles,
    addPendingFiles,
    commitPendingFiles,
    removeFile,
    clearPendingFiles,
    isLoading: isAttachmentLoading,
  } = useResourceAttachment();

  // MIME 타입 판별, Blob 관리, Rust backend 연동 등 분리
  // ...
  return {
    pendingFiles,
    addPendingFiles,
    commitPendingFiles,
    removeFile,
    clearPendingFiles,
    isAttachmentLoading,
    // ... 기타 헬퍼 함수
  };
}
```

##### 2. 서브컴포넌트 분리 (예시: SessionFilesPopover, ChatInput)

```typescript
// src/features/chat/components/SessionFilesPopover.tsx
import { useResourceAttachment } from '@/context/ResourceAttachmentContext';
import { getLogger } from '@/lib/logger';

const logger = getLogger('SessionFilesPopover');

export function SessionFilesPopover({ storeId }: { storeId: string }) {
  // 기존 파일 목록, 상세보기, 로딩, 에러 핸들링 등 분리
  // ...
}
```

```typescript
// src/features/chat/components/ChatInput.tsx
import { useFileAttachment } from '../hooks/useFileAttachment';

export function ChatInput() {
  const {
    pendingFiles,
    addPendingFiles,
    commitPendingFiles,
    removeFile,
    clearPendingFiles,
    isAttachmentLoading,
    // ... 기타 헬퍼
  } = useFileAttachment();

  // 기존 드래그앤드롭, 파일 첨부, 메시지 전송 로직 분리
  // ...
}
```

##### 3. Chat.tsx 메인 컴포넌트 간소화

```typescript
// src/features/chat/Chat.tsx (리팩토링 후)
import { useChatState } from './hooks/useChatState';
import { SessionFilesPopover } from './components/SessionFilesPopover';
import { ChatInput } from './components/ChatInput';
// ... 기타 컴포넌트 import

function Chat({ children }: ChatProps) {
  const { showToolsDetail, setShowToolsDetail } = useChatState();
  // 주요 UI만 유지, 상태/비즈니스 로직 분리
  return (
    <ChatProvider>
      <TimeLocationSystemPrompt />
      <div className="h-full w-full font-mono flex flex-col rounded-lg overflow-hidden shadow-2xl">
        <Chat.Header />
        <Chat.Messages />
        <Chat.Bottom />
        {children}
      </div>
    </ChatProvider>
  );
}
```

##### 4. 파일 첨부 로직 분리 및 타입 안전성 강화

- `useFileAttachment` 훅에서 MIME 타입 판별, Blob URL 관리, Rust backend 연동, 에러 핸들링 등 모두 분리.
- `AttachmentReference` 등 타입을 별도 파일로 분리(`src/models/chat.ts` 등).
- 모든 로깅은 `getLogger`로 통일.

##### 5. 테스트 코드 예시

```typescript
// src/features/chat/hooks/__tests__/useFileAttachment.test.ts
import { renderHook, act } from '@testing-library/react-hooks';
import { useFileAttachment } from '../useFileAttachment';

test('should add and remove pending files safely', () => {
  const { result } = renderHook(() => useFileAttachment());
  act(() => {
    result.current.addPendingFiles([
      { url: 'blob:xxx', filename: 'test.txt', mimeType: 'text/plain' },
    ]);
  });
  expect(result.current.pendingFiles.length).toBe(1);
  act(() => {
    result.current.removeFile(result.current.pendingFiles[0]);
  });
  expect(result.current.pendingFiles.length).toBe(0);
});
```

#### Phase 3 재사용 가능한 연관 코드

- **ResourceAttachmentContext** (`src/context/ResourceAttachmentContext.tsx`): 파일 첨부/삭제/커밋/상태 관리 핵심 로직.
- **getLogger** (`src/lib/logger.ts`): 모든 로깅은 중앙 로거로 통일.
- **Message, AttachmentReference 타입** (`src/models/chat.ts`): 메시지/첨부파일 타입 정의.
- **Rust backend 연동** (`src/hooks/use-rust-backend.ts`): 파일 읽기, Blob 변환 등.

#### Phase 3 변경 후 파일 구조

```
src/features/chat/
├── Chat.tsx
├── hooks/
│   ├── useChatState.ts
│   ├── useFileAttachment.ts
│   └── ...
├── components/
│   ├── SessionFilesPopover.tsx
│   ├── ChatInput.tsx
│   ├── ChatHeader.tsx
│   ├── ChatMessages.tsx
│   └── ...
```

### Phase 4: Rust Backend 리팩터링 (filesystem.rs, mcp.rs) (3일)

#### Phase 4 작업의 목적

`filesystem.rs`와 `mcp.rs`의 대형 단일 파일을 기능별로 모듈화하여 코드 중복을 제거하고 유지보수성을 향상시키는 것. JSONSchema 생성, 파일 I/O 보안 검증, MCPTool 등록/관리, 서버 연결/샘플링/도구 호출 등 각 기능을 별도 모듈로 분리하여 재사용성과 테스트 용이성을 강화한다. Rust 코딩 규약 준수 및 타입 안전성을 보장한다.

#### Phase 4 현재의 상태 / 문제점

- **단일 책임 위반**: 각 파일이 다중 책임 담당 (타입 정의, 도구 생성, 서버 관리, 유틸리티 등 혼재)
- **코드 중복**: JSONSchema 생성 패턴 반복, 파일 경로 검증 로직 중복, MCPTool 등록 패턴 반복
- **유지보수 어려움**: 800줄 이상의 대형 파일로 기능 추가/수정이 어려움
- **테스트 어려움**: 단일 파일로 인한 단위 테스트 및 Mock 주입 어려움
- **타입 안전성 부족**: 일부 타입 추론에 의존, 인터페이스 분리 미흡

#### Phase 4 추가 분석 과제

- 모듈 분리 후 의존성 순환 참조 발생 가능성 분석
- 기존 MCPTool 인터페이스 호환성 유지 여부 검증
- 파일 I/O 보안 검증 로직의 일관성 유지 방법 분석
- Rust 빌드 및 컴파일 시간 영향 측정

#### Phase 4 변경 이후의 상태 / 해결 판정 기준

- **빌드/테스트 통과**: `cargo build && cargo test` 성공
- **모듈 분리 완료**: 각 파일의 책임이 단일하게 분리, 서브모듈 5개 이상 생성
- **코드 중복 제거**: JSONSchema/파일 검증/MCPTool 생성 코드 70% 이상 감소
- **타입 안전성 보장**: 모든 파일에서 타입 추론 최소화, 명시적 타입 정의
- **기능 유지**: 기존 MCP 서버 연결, 도구 호출, 파일 I/O 정상 동작

#### Phase 4 수정이 필요한 코드 및 수정부분의 코드 스니핏

##### 1. filesystem.rs MCPTool 생성 함수 분리

```rust
// 변경 전: filesystem.rs (현재 - 842줄)
fn create_read_file_tool() -> MCPTool {
    MCPTool {
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert("path".to_string(), JSONSchema {
                        schema_type: JSONSchemaType::String {
                            min_length: Some(1),
                            max_length: Some(1000),
                            description: Some("Path to file".to_string()),
                        },
                        required: true,
                    });
                    // ... 20줄 이상 반복
                    props
                }),
                required: Some(vec!["path".to_string()]),
            },
        },
        // ...
    }
}
```

```rust
// 변경 후: filesystem.rs (리팩토링 후)
use crate::mcp::utils::schema_builder::{string_prop, integer_prop, object_schema};

fn create_read_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert("path".to_string(), string_prop(Some(1), Some(1000), Some("Path to file")));
    props.insert("start_line".to_string(), integer_prop(Some(1), None, Some("Start line")));

    MCPTool {
        input_schema: object_schema(props, vec!["path".to_string()]),
        // 간결화된 코드 (기존 30줄 → 5줄)
    }
}
```

##### 2. mcp.rs 타입/서버/유틸리티 분리

```rust
// 변경 전: mcp.rs (현재 - 834줄)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// ... 서버 관리 함수들
// ... 유틸리티 함수들
```

```rust
// 변경 후: 분리된 파일들
// types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

// schema.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// server.rs
pub struct MCPServerManager {
    // 서버 관리 로직만
}

// utils.rs
// 유틸리티 함수들만
```

#### Phase 4 재사용 가능한 연관 코드

##### 1. schema_builder.rs (JSONSchema 생성 헬퍼)

**파일 경로**: `src-tauri/src/mcp/utils/schema_builder.rs`

**주요 기능**:

- `string_prop(min_len, max_len, description)`: 문자열 속성 생성
- `integer_prop(min, max, description)`: 정수 속성 생성
- `object_schema(properties, required)`: 객체 스키마 생성
- `array_schema(items, description)`: 배열 스키마 생성

**특징**:

- JSONSchema 생성 코드 중복 제거
- 타입 안전성 보장
- 재사용성 높음

##### 2. secure_file_manager.rs (파일 I/O 및 보안)

**파일 경로**: `src-tauri/src/services/secure_file_manager.rs`

**주요 기능**:

- `validate_path(path)`: 파일 경로 보안 검증
- `write_file_string(path, content)`: 안전한 파일 쓰기
- `read_file_string(path)`: 안전한 파일 읽기
- `SecurityValidator`: 보안 검증 인터페이스

**특징**:

- 파일 시스템 보안 보장
- 크로스 플랫폼 호환성
- 에러 처리 표준화

##### 3. utils.rs (상수 및 보안 검증)

**파일 경로**: `src-tauri/src/mcp/builtin/utils.rs`

**주요 기능**:

- `MAX_FILE_SIZE`: 최대 파일 크기 상수
- `SecurityValidator`: 보안 검증 구현
- 파일 타입 검증 헬퍼

**특징**:

- 중앙화된 상수 관리
- 재사용 가능한 보안 검증 로직

##### 4. MCPServerManager 및 관련 타입

**파일 경로**: `src-tauri/src/mcp.rs`

**주요 기능**:

- `MCPServerManager`: 서버 연결/관리
- `MCPTool`, `MCPResponse`: MCP 프로토콜 타입
- `start_server()`, `call_tool()`: 서버 조작 함수

**특징**:

- MCP 프로토콜 표준 준수
- 비동기 처리 지원
- 에러 처리 체계화

#### Phase 4 변경 후 파일 구조

```bash
src-tauri/src/mcp/
├── types.rs                 # MCPServerConfig, MCPTool 등 타입 정의
├── schema.rs                # JSONSchemaType, JSONSchema 등 스키마 타입
├── server.rs                # MCPServerManager, 서버 관리 로직
├── utils.rs                 # 유틸리티 함수들
└── builtin/
    ├── filesystem.rs        # 간결화된 파일 시스템 도구 (schema_builder 활용)
    └── mod.rs

src-tauri/src/services/
└── secure_file_manager.rs   # 파일 I/O 보안 서비스

src-tauri/src/mcp/utils/
└── schema_builder.rs        # JSONSchema 생성 헬퍼
```

### Phase 5: db.ts 리팩터링 (2일) ✅ **COMPLETED**

**작업 완료 내용:**

1. **타입 정의 분리** (`src/lib/db/types.ts`) - 모든 인터페이스 및 타입 정의를 별도 파일로 분리
2. **CRUD 인터페이스 분리** (`src/lib/db/crud.ts`) - 각 테이블별 CRUD 구현을 모듈화
3. **DB 서비스 분리** (`src/lib/db/service.ts`) - LocalDatabase 클래스와 dbUtils 유틸리티 분리
4. **인덱스 파일 생성** (`src/lib/db/index.ts`) - 통합 export 제공
5. **기존 호환성 유지** (`src/lib/db.ts`) - 기존 import 경로 유지를 위한 re-export

**결과:**

- 기존 841줄의 단일 파일을 4개 모듈로 분리 (평균 200줄 내외)
- 타입 정의, CRUD 로직, DB 서비스가 각각 단일 책임으로 분리됨
- 모든 기존 import (`from '@/lib/db'`)가 변경 없이 동작
- `pnpm lint && pnpm format && pnpm build` 모두 통과
- 코드 중복 제거 및 유지보수성 향상

### Phase 6: 통합 테스트 및 검증 (2일)

1. 전체 빌드 및 린트 검증
2. Worker 호환성 테스트
3. 성능 및 기능 검증

## 위험 관리

### 주요 리스크

1. **Worker 동적 로딩 실패**: 모듈 분할로 인한 import 경로 변경
2. **API 호환성 깨짐**: MCP 툴 인터페이스 변경
3. **빌드 실패**: 의존성 순환 참조 발생

### 완화 전략

1. **점진적 적용**: 각 Phase별 PR 생성 및 검증
2. **호환성 유지**: default export 및 툴 인터페이스 변경 최소화
3. **자동화 테스트**: Worker 로딩 및 기본 기능 smoke test
4. **롤백 계획**: 각 Phase별 revert 가능한 commit 단위 유지

---

**작업자 유연성**: 위 계획은 상위 레벨 가이드이며, 실제 작업 과정에서 발견되는 이슈에 따라 세부 구현을 조정할 수 있음. 각 Phase 완료 시점에 추가 분석 결과를 반영하여 계획을 업데이트할 것.
