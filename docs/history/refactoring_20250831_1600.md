# Refactoring Plan: Large File Modularization and Code Duplication Removal

## 작업의 목적

SynapticFlow 프로젝트의 대형 파일들을 모듈화하고 코드 중복을 제거하여 유지보수성과 확장성을 향상시키는 것. 특히 BrowserToolProvider.tsx, Chat.tsx, filesystem.rs, db.ts, mcp.rs 등 5개 대형 파일을 대상으로 기능별 서브모듈 분리와 공통 헬퍼 함수 도입을 통해 코드 복잡성을 줄이고, 타입 안전성과 코딩 규약 준수를 보장한다.

## 현재의 상태 / 문제점

### 주요 문제 파일들

- `src/features/tools/BrowserToolProvider.tsx` (961줄): 20개 이상 브라우저 도구의 inputSchema/execute 반복, 단일 파일 집중
- `src/features/chat/Chat.tsx` (939줄): UI/비즈니스/상태 관리 혼재, 다중 책임
- `src-tauri/src/mcp/builtin/filesystem.rs` (842줄): JSONSchema 생성 코드 중복, 각 MCPTool 생성 함수 반복
- `src/lib/db.ts` (841줄): 타입/CRUD/DB 클래스 혼재, 버전 관리 로직 포함
- `src-tauri/src/mcp.rs` (834줄): MCP 타입/구조체/핸들러/유틸리티 혼재

### 공통 문제점

- 코드 중복: inputSchema/JSONSchema 생성, CRUD 인터페이스, MCPTool 등록 패턴 반복
- 단일 책임 위반: 각 파일이 다중 책임 담당
- 타입 안전성 부족: inline import 타입, any 사용 가능성
- 코딩 규약 위반: 중앙 로거 미사용, 들여쓰기 불일치

## 재사용 가능한 연관 코드

### 1. rust-backend-client.ts 브라우저 관련 함수들

**파일 경로**: `src/lib/rust-backend-client.ts`

**주요 기능**:

- `createBrowserSession(params: {url: string, title?: string | null}): Promise<string>`
- `closeBrowserSession(sessionId: string): Promise<void>`
- `listBrowserSessions(): Promise<BrowserSession[]>`
- `clickElement(sessionId: string, selector: string): Promise<string>`
- `inputText(sessionId: string, selector: string, text: string): Promise<string>`
- `pollScriptResult(requestId: string): Promise<string | null>`
- `navigateToUrl(sessionId: string, url: string): Promise<string>`

**특징**:

- 모든 함수가 `safeInvoke`를 통해 Tauri 명령을 안전하게 래핑
- 일관된 에러 핸들링 및 로깅 제공
- 타입 안전성 보장
- BrowserToolProvider.tsx에서 이미 import하여 사용 중

### 2. BrowserToolProvider.tsx 내 공통 함수들

**파일 경로**: `src/features/tools/BrowserToolProvider.tsx`

**주요 기능**:

- `formatBrowserResult(raw: unknown): string` - JSON 결과 포맷팅 및 진단 정보 표시
- `executeScript` (useBrowserInvoker에서 제공) - 브라우저 스크립트 실행

### 3. Rust Backend 서비스들

**파일 경로**: `src-tauri/src/services/interactive_browser_server.rs`

**주요 기능**:

- `create_browser_session()` - 브라우저 세션 생성
- `execute_script()` - JavaScript 실행 및 결과 폴링
- `click_element()`, `input_text()` 등 - 구체적인 브라우저 조작 함수들

## 추가 분석 과제

1. **Worker 호환성 검증**: 모듈 분할 후 동적 import 경로 변경이 Vite 번들러에 미치는 영향 분석
2. **성능 영향 측정**: 모듈 분할 전후 초기 로딩 시간 및 번들 크기 변화 측정
3. **의존성 그래프 분석**: 각 파일의 참조 관계를 파악하여 순환 의존성 방지
4. **테스트 커버리지 평가**: 분할 후 각 서브모듈의 단위 테스트 필요성 및 범위 결정

## 변경 이후의 상태 / 해결 판정 기준

### 성공 판정 기준

1. **빌드/테스트 통과**: `pnpm lint && pnpm format && pnpm build` 성공
2. **코드 중복 제거**: JSONSchema/CRUD/MCPTool 생성 코드 70% 이상 감소
3. **모듈 분리 완료**: 각 파일의 책임이 단일하게 분리, 서브모듈 5개 이상 생성
4. **타입 안전성 보장**: 모든 파일에서 `any` 제거, strict 모드 준수
5. **코딩 규약 준수**: 중앙 로거 사용, 2-space 들여쓰기, 파일 상단 import 정리
6. **기능 유지**: 기존 MCP 툴 호출, UI 동작, DB 작업 정상 동작

### 변경 후 파일 구조

```
src/features/tools/
├── BrowserToolProvider.tsx      # 도구 등록/해제 담당
└── browser-tools/               # 도구별 서브모듈
    ├── CreateSessionTool.tsx
    ├── CloseSessionTool.tsx
    └── ...

src/features/chat/
├── Chat.tsx                     # 메인 컨테이너
├── components/                  # 서브컴포넌트
│   ├── SessionFilesPopover.tsx
│   └── ...
└── hooks/                       # 커스텀 훅
    ├── useChatState.ts
    └── ...

src-tauri/src/mcp/
├── builtin/
│   └── filesystem.rs            # 간결화된 MCPTool 생성
└── utils/
    └── schema_builder.rs        # JSONSchema 헬퍼

src/lib/
├── db/
│   ├── types.ts                 # 타입 정의
│   ├── crud.ts                  # CRUD 인터페이스
│   └── service.ts               # DB 서비스
└── mcp/
    ├── types.rs                 # MCP 타입/구조체
    ├── server.rs                # 서버 관리
    └── utils.rs                 # 유틸리티
```

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. BrowserToolProvider.tsx 모듈화

**현재 문제**: 961줄의 단일 파일에 20개 이상 도구가 모두 정의됨

```typescript
// 변경 전: BrowserToolProvider.tsx (현재)
const browserTools: LocalMCPTool[] = [
  {
    name: 'createSession',
    description: 'Creates a new interactive browser session...',
    inputSchema: {
      type: 'object',
      properties: {
        url: { type: 'string', description: 'The URL to navigate...' },
        title: { type: 'string', description: 'Optional title...' },
      },
      required: ['url'],
    },
    execute: async (args: Record<string, unknown>) => {
      const { url, title } = args as { url: string; title?: string };
      logger.debug('Executing browser_createSession', { url, title });
      const sessionId = await createBrowserSession({
        url,
        title: title || null,
      });
      return `Browser session created successfully: ${sessionId}`;
    },
  },
  // ... 19개 도구 더 정의됨
];
```

```typescript
// 변경 후: BrowserToolProvider.tsx (리팩토링 후)
import { createSessionTool } from './browser-tools/CreateSessionTool';
import { closeSessionTool } from './browser-tools/CloseSessionTool';
import { clickElementTool } from './browser-tools/ClickElementTool';
// ... 다른 도구들 import

const browserTools: LocalMCPTool[] = [
  createSessionTool,
  closeSessionTool,
  clickElementTool,
  // ... 다른 도구들 (15개 서브모듈에서 import)
];
```

### 2. Chat.tsx 컴포넌트 분해

**현재 문제**: 939줄의 단일 파일에 UI/비즈니스/상태 로직 혼재

```typescript
// 변경 전: Chat.tsx (현재 - 939줄)
function Chat({ children }: ChatProps) {
  const [showToolsDetail, setShowToolsDetail] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  // ... 100줄 이상의 상태 관리 로직
  // ... 200줄 이상의 UI 렌더링 로직
  // ... 100줄 이상의 이벤트 핸들러
}
```

```typescript
// 변경 후: Chat.tsx (리팩토링 후)
import { useChatState } from './hooks/useChatState';
import { SessionFilesPopover } from './components/SessionFilesPopover';
import { ChatInput } from './components/ChatInput';

function Chat({ children }: ChatProps) {
  const { showToolsDetail, setShowToolsDetail, selectedFiles } = useChatState();
  // 간결화된 UI 로직만 유지 (약 200줄로 축소)
}
```

### 3. filesystem.rs 스키마 빌더 활용

**현재 문제**: 각 MCPTool 생성 함수에서 JSONSchema를 반복 생성

```rust
// 변경 전: filesystem.rs (현재)
fn create_read_file_tool() -> MCPTool {
    MCPTool {
        input_schema: JSONSchema {
            schema_type: JSONSchemaType::Object {
                properties: Some({
                    let mut props = HashMap::new();
                    props.insert("path".to_string(), JSONSchema {
                        schema_type: JSONSchemaType::String {
                            min_length: Some(1),
                            max_length: Some(1000),
                            description: Some("Path to file".to_string()),
                        },
                        required: true,
                    });
                    // ... 20줄 이상 반복
                    props
                }),
                required: Some(vec!["path".to_string()]),
            },
        },
        // ...
    }
}
```

```rust
// 변경 후: filesystem.rs (리팩토링 후)
fn create_read_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert("path".to_string(), string_prop(Some(1), Some(1000), Some("Path to file")));
    props.insert("start_line".to_string(), integer_prop(Some(1), None, Some("Start line")));

    MCPTool {
        input_schema: object_schema(props, vec!["path".to_string()]),
        // 간결화된 코드 (기존 30줄 → 5줄)
    }
}
```

### 4. db.ts 계층 분리

**현재 문제**: 타입/CRUD/DB 클래스가 한 파일에 혼재

```typescript
// 변경 전: db.ts (현재 - 841줄)
export interface DatabaseService {
  assistants: CRUD<Assistant>;
  // ... 다른 인터페이스들
}

class LocalDatabase extends Dexie {
  // ... 100줄 이상의 DB 로직
  // ... CRUD 인터페이스 구현
  // ... 버전 관리 로직
}
```

```typescript
// 변경 후: 분리된 파일들
// types.ts
export interface DatabaseService {
  assistants: CRUD<Assistant>;
  // ... 다른 인터페이스들
}

// service.ts
import { DatabaseService } from './types';
export class LocalDatabase extends Dexie implements DatabaseService {
  // 간결화된 DB 로직만 (기존 841줄 → 200줄)
}
```

### 5. mcp.rs 구조체 분리

**현재 문제**: MCP 타입/구조체/핸들러/유틸리티가 한 파일에 혼재

```rust
// 변경 전: mcp.rs (현재 - 834줄)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// ... 핸들러 함수들
// ... 유틸리티 함수들
```

```rust
// 변경 후: 분리된 파일들
// types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPServerConfig { ... }

// schema.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JSONSchemaType { ... }

// server.rs
// ... 서버 관리 로직만

// utils.rs
// ... 유틸리티 함수들만
```

## 작업 단계

### Phase 1: 준비 및 분석 (1일)

1. 각 파일의 의존성 그래프 분석
2. Worker 호환성 테스트 케이스 작성
3. 빌드/테스트 환경 검증

### Phase 2: BrowserToolProvider.tsx 리팩터링 (2일)

#### 2.1 현재 구조 분석 및 재사용 가능한 코드 식별

**재사용 가능한 코드들 (rust-backend-client.ts):**

- `createBrowserSession(params: {url: string, title?: string})`
- `closeBrowserSession(sessionId: string)`
- `listBrowserSessions(): Promise<BrowserSession[]>`
- `clickElement(sessionId: string, selector: string)`
- `inputText(sessionId: string, selector: string, text: string)`
- `pollScriptResult(requestId: string): Promise<string | null>`
- `navigateToUrl(sessionId: string, url: string)`

**공통 헬퍼 함수들 (BrowserToolProvider.tsx 내):**

- `formatBrowserResult(raw: unknown): string` - JSON 결과 포맷팅
- Element state 체크 스크립트 (clickElement, inputText에서 중복)
- Polling 로직 (30회, 100ms 간격)

**현재 중복 패턴:**

1. 각 도구별 inputSchema 직접 정의
2. Element 존재성/상태 체크 스크립트 반복
3. Polling + timeout 로직 반복
4. Error handling + logging 패턴 반복

#### 2.2 리팩토링 단계별 계획

##### 단계 2.2.1: 공통 헬퍼 모듈 생성 (4시간)

```typescript
// src/features/tools/browser-tools/helpers.ts

// 공통 스키마 정의
export const BROWSER_TOOL_SCHEMAS = {
  sessionId: { type: 'string' as const, description: 'Browser session ID' },
  selector: { type: 'string' as const, description: 'CSS selector' },
  url: { type: 'string' as const, description: 'URL to navigate to' },
  text: { type: 'string' as const, description: 'Text content' },
};

// 공통 Element 상태 체크 함수 (rust-backend-client 활용)
export async function checkElementState(
  executeScript: Function,
  sessionId: string,
  selector: string,
  action: 'click' | 'input',
): Promise<{ exists: boolean; valid: boolean; diagnostics?: any }> {
  const script = `(function() {
    const el = document.querySelector('${selector}');
    if (!el) return JSON.stringify({exists: false});
    
    const rect = el.getBoundingClientRect();
    const style = window.getComputedStyle(el);
    const visible = rect.width > 0 && rect.height > 0 && 
                   style.display !== 'none' && style.visibility !== 'hidden';
    
    if (action === 'input') {
      const disabled = el.disabled || el.readOnly;
      return JSON.stringify({exists: true, valid: visible && !disabled, rect, style});
    } else {
      const clickable = visible && style.pointerEvents !== 'none' && !el.disabled;
      return JSON.stringify({exists: true, valid: clickable, rect, style});
    }
  })()`;

  const result = await executeScript(sessionId, script);
  return JSON.parse(result);
}

// 공통 Polling 함수
export async function pollWithTimeout(
  pollFn: () => Promise<string | null>,
  maxAttempts = 30,
  interval = 100,
): Promise<string | null> {
  for (let attempts = 0; attempts < maxAttempts; attempts++) {
    const result = await pollFn();
    if (result !== null) return result;
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  return null;
}
```

##### 단계 2.2.2: 간단한 도구들 서브모듈화 (4시간)

```typescript
// src/features/tools/browser-tools/CreateSessionTool.ts
import { createBrowserSession } from '@/lib/rust-backend-client';
import { BROWSER_TOOL_SCHEMAS } from './helpers';

export const createSessionTool = {
  name: 'createSession',
  description:
    'Creates a new interactive browser session in a separate window.',
  inputSchema: {
    type: 'object',
    properties: {
      url: BROWSER_TOOL_SCHEMAS.url,
      title: {
        type: 'string',
        description: 'Optional title for the browser session window.',
      },
    },
    required: ['url'],
  },
  execute: async (args: Record<string, unknown>) => {
    const { url, title } = args as { url: string; title?: string };
    // rust-backend-client의 함수 직접 활용
    const sessionId = await createBrowserSession({ url, title: title || null });
    return `Browser session created successfully: ${sessionId}`;
  },
};
```

##### 단계 2.2.3: 복잡한 도구들 리팩토링 (4시간)

```typescript
// src/features/tools/browser-tools/ClickElementTool.ts
import { clickElement, pollScriptResult } from '@/lib/rust-backend-client';
import {
  checkElementState,
  pollWithTimeout,
  BROWSER_TOOL_SCHEMAS,
} from './helpers';
import { formatBrowserResult } from '../BrowserToolProvider';

export const clickElementTool = {
  name: 'clickElement',
  description: 'Clicks on a DOM element using CSS selector.',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: BROWSER_TOOL_SCHEMAS.sessionId,
      selector: BROWSER_TOOL_SCHEMAS.selector,
    },
    required: ['sessionId', 'selector'],
  },
  execute: async (
    args: Record<string, unknown>,
    executeScript: (sessionId: string, script: string) => Promise<string>,
  ) => {
    const { sessionId, selector } = args as {
      sessionId: string;
      selector: string;
    };

    // 공통 헬퍼로 상태 체크 (기존 30줄 → 3줄)
    const state = await checkElementState(
      executeScript,
      sessionId,
      selector,
      'click',
    );
    if (!state.exists) {
      return formatBrowserResult(
        JSON.stringify({
          ok: false,
          action: 'click',
          reason: 'element_not_found',
          selector,
        }),
      );
    }
    if (!state.valid) {
      return formatBrowserResult(
        JSON.stringify({
          ok: false,
          action: 'click',
          reason: 'element_not_clickable',
          selector,
          diagnostics: state.diagnostics,
        }),
      );
    }

    // rust-backend-client의 clickElement 함수 활용
    const requestId = await clickElement(sessionId, selector);

    // 공통 헬퍼로 폴링 (기존 15줄 → 3줄)
    const result = await pollWithTimeout(() => pollScriptResult(requestId));
    return result ? formatBrowserResult(result) : 'Click operation timed out';
  },
};
```

##### 단계 2.2.4: 메인 Provider 리팩토링 (4시간)

```typescript
// BrowserToolProvider.tsx (리팩토링 후)
import { createSessionTool } from './browser-tools/CreateSessionTool';
import { closeSessionTool } from './browser-tools/CloseSessionTool';
import { clickElementTool } from './browser-tools/ClickElementTool';
// ... 다른 도구들 import

export function BrowserToolProvider() {
  const { executeScript } = useBrowserInvoker();

  useEffect(() => {
    const browserTools = [
      createSessionTool,
      closeSessionTool,
      {
        ...clickElementTool,
        execute: (args) => clickElementTool.execute(args, executeScript),
      },
      // ... 다른 도구들
    ];

    // 기존 400줄의 도구 정의 → 50줄로 축소
    const service = {
      /* 간결화된 서비스 정의 */
    };

    register('browser', service);
    return () => unregister('browser');
  }, [executeScript]);

  return null;
}
```

#### 2.3 예상 효과 및 메트릭

**코드 중복 감소:**

- inputSchema 정의: ~70% 감소 (공통 스키마 재사용)
- Element 체크 로직: ~80% 감소 (공통 헬퍼)
- Polling 로직: ~90% 감소 (공통 헬퍼)
- Error handling: ~60% 감소 (표준화)

**파일 구조 개선:**

- BrowserToolProvider.tsx: 961줄 → ~200줄 (79% 감소)
- 신규 서브모듈: 15개 파일 생성
- 각 도구별 책임 분리로 유지보수성 향상

**테스트 용이성:**

- 각 도구별 독립적 단위 테스트 가능
- 공통 헬퍼 함수별 테스트 가능
- Mock 주입으로 의존성 격리 용이

#### 2.4 위험 관리 및 검증

**주요 리스크:**

1. **executeScript 의존성 주입**: 각 도구에서 executeScript를 사용해야 하는 경우 파라미터로 전달
2. **타입 안전성**: 공통 스키마 사용 시 타입 정의 일관성 유지
3. **성능 영향**: 모듈 분할로 인한 초기 로딩 시간 증가 가능성

**완화 전략:**

1. **점진적 마이그레이션**: 한 도구씩 서브모듈로 분리하며 테스트
2. **타입 검증**: TypeScript strict 모드로 컴파일 에러 방지
3. **번들 분석**: Webpack Bundle Analyzer로 청크 크기 모니터링

**검증 기준:**

- 모든 브라우저 도구 정상 동작
- 빌드 성공 및 린트 통과
- 번들 크기 증가 10% 이내
- 각 서브모듈별 단위 테스트 커버리지 80% 이상

### Phase 3: Chat.tsx 리팩터링 (2일)

1. 커스텀 훅 생성 (`hooks/` 폴더)
2. 서브컴포넌트 분리 (`components/` 폴더)
3. 상태 관리 로직 이동

### Phase 4: Rust 파일들 리팩터링 (3일)

1. `filesystem.rs`: schema_builder.rs 헬퍼 활용
2. `mcp.rs`: 타입/서버/유틸리티 모듈 분리
3. Rust 빌드 및 테스트 검증

### Phase 5: db.ts 리팩터링 (2일)

1. 타입 정의 분리 (`types.ts`)
2. CRUD 인터페이스 분리 (`crud.ts`)
3. DB 서비스 분리 (`service.ts`)

### Phase 6: 통합 테스트 및 검증 (2일)

1. 전체 빌드 및 린트 검증
2. Worker 호환성 테스트
3. 성능 및 기능 검증

## 위험 관리

### 주요 리스크

1. **Worker 동적 로딩 실패**: 모듈 분할로 인한 import 경로 변경
2. **API 호환성 깨짐**: MCP 툴 인터페이스 변경
3. **빌드 실패**: 의존성 순환 참조 발생

### 완화 전략

1. **점진적 적용**: 각 Phase별 PR 생성 및 검증
2. **호환성 유지**: default export 및 툴 인터페이스 변경 최소화
3. **자동화 테스트**: Worker 로딩 및 기본 기능 smoke test
4. **롤백 계획**: 각 Phase별 revert 가능한 commit 단위 유지

---

**작업자 유연성**: 위 계획은 상위 레벨 가이드이며, 실제 작업 과정에서 발견되는 이슈에 따라 세부 구현을 조정할 수 있음. 각 Phase 완료 시점에 추가 분석 결과를 반영하여 계획을 업데이트할 것.
