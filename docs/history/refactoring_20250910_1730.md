# ExtractContentTool Raw HTML 파일 저장 기능 개선 리팩터링 계획

**일시**: 2025년 9월 10일 17:30  
**대상 파일**: `src/features/tools/browser-tools/ExtractContentTool.ts`

## 작업의 목적

ExtractContentTool의 `saveRawHtml` 옵션이 활성화될 때, raw HTML 콘텐츠를 메모리에 직접 포함하여 반환하는 대신, workspace 내 파일로 저장하고 해당 파일의 경로를 반환하도록 개선합니다.

이를 통해 대용량 HTML 콘텐츠로 인한 응답 크기 문제를 해결하고, 파일 기반의 보다 효율적인 콘텐츠 관리를 가능하게 합니다.

## 현재의 상태 / 문제점

### Raw HTML 처리 방식의 문제점

- **메모리 과부하**: `saveRawHtml=true`일 때 raw HTML이 응답 객체에 직접 포함되어 응답 크기가 과도하게 커짐
- **비효율적 전송**: 대용량 HTML 콘텐츠가 JSON 응답에 포함되어 네트워크 전송 비효율성 발생
- **임시 저장**: raw HTML이 메모리에만 존재하여 재사용이나 후속 처리가 어려움

### 현재 코드 구조 (라인 353-356)

```typescript
// Raw HTML 저장 요청 처리
if (saveRawHtml) {
  result.raw_html_content = rawHtml;
  result.save_html_requested = true;
}
```

현재는 `raw_html_content` 필드에 HTML 문자열을 직접 포함하여 반환합니다.

## 추가 분석 과제

1. **파일명 충돌 방지**: 동일한 sessionId와 timestamp로 인한 파일명 중복 가능성 검토
2. **디렉토리 자동 생성**: `extracted-content` 디렉토리가 존재하지 않을 때의 자동 생성 동작 확인
3. **파일 정리 정책**: 저장된 HTML 파일들의 자동 정리 또는 보관 기간 설정 필요성 검토
4. **에러 처리 개선**: 파일 저장 실패 시 fallback 메커니즘 고려

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **파일 저장**: `saveRawHtml=true`일 때 raw HTML이 workspace 내 파일로 저장됨
2. **경로 반환**: 응답에 `raw_html_path` 필드로 저장된 파일의 상대 경로가 포함됨
3. **응답 크기 감소**: `raw_html_content` 필드가 제거되어 응답 크기가 대폭 감소함
4. **에러 처리**: 파일 저장 실패 시 적절한 에러 메시지가 `save_html_error` 필드에 포함됨

### 검증 방법

- ExtractContentTool 실행 후 workspace에 HTML 파일이 생성되는지 확인
- 응답 객체에 `raw_html_path`가 올바른 경로로 포함되는지 확인
- 저장된 파일이 `downloadWorkspaceFile` API로 접근 가능한지 확인
- 파일 저장 실패 시 에러 처리가 적절히 동작하는지 확인

## 수정이 필요한 코드 및 수정부분

### 1. Import 문 추가

**파일**: `src/features/tools/browser-tools/ExtractContentTool.ts`  
**위치**: 파일 상단 import 섹션

**추가할 import**:

```typescript
import { writeFile } from '@/lib/rust-backend-client';
```

### 2. Raw HTML 저장 로직 수정

**파일**: `src/features/tools/browser-tools/ExtractContentTool.ts`  
**위치**: 라인 353-356

**변경 전**:

```typescript
// Raw HTML 저장 요청 처리
if (saveRawHtml) {
  result.raw_html_content = rawHtml;
  result.save_html_requested = true;
}
```

**변경 후**:

```typescript
// Raw HTML 저장 요청 처리
if (saveRawHtml) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const fileName = `extracted-${sessionId}-${timestamp}.html`;
  const relativePath = `extracted-content/${fileName}`;

  try {
    // 문자열을 바이트 배열로 변환
    const encoder = new TextEncoder();
    const contentBytes = Array.from(encoder.encode(rawHtml));

    // 기존 writeFile 인터페이스 사용
    await writeFile(relativePath, contentBytes);

    result.raw_html_path = relativePath;
    result.save_html_requested = true;
  } catch (error) {
    logger.error('Failed to save raw HTML file', { error, path: relativePath });
    result.save_html_error = `Failed to save raw HTML: ${error instanceof Error ? error.message : String(error)}`;
  }
}
```

## 재사용 가능한 연관 코드

### 주요 인터페이스

**파일**: `src/lib/rust-backend-client.ts`

- `writeFile(filePath: string, content: number[]): Promise<void>` - 바이트 배열을 파일로 저장
- `downloadWorkspaceFile(filePath: string): Promise<string>` - workspace 파일 다운로드 URL 생성

### 관련 Rust 백엔드 구현

**파일**: `src-tauri/src/mcp/builtin/workspace/file_operations.rs`

- `handle_write_file()` - 실제 파일 쓰기 처리
- workspace 경로 검증 및 보안 확인

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/file_tools.rs`

- `create_write_file_tool()` - write_file MCP 도구 정의

### 파일 경로 패턴

- **저장 위치**: `workspace/extracted-content/`
- **파일명 형식**: `extracted-{sessionId}-{timestamp}.html`
- **timestamp 형식**: ISO 8601에서 특수문자 제거 (예: `2025-09-10T17-30-00-000Z`)

### 에러 처리 패턴

- 파일 저장 성공: `result.raw_html_path` 설정
- 파일 저장 실패: `result.save_html_error` 설정
- 로깅: `logger.error()` 사용하여 디버깅 정보 기록

## 기대 효과

1. **성능 개선**: 대용량 HTML 콘텐츠의 직접 전송 제거로 응답 시간 단축
2. **메모리 효율성**: 메모리 사용량 감소 및 가비지 컬렉션 부담 완화
3. **확장성**: 저장된 파일을 통한 후속 처리 및 분석 가능
4. **사용자 경험**: 필요시 파일 다운로드를 통한 유연한 콘텐츠 접근
