# Refactoring Plan: Built-in MCP Server Context Implementation

## 작업의 목적

Built-in MCP 서버들이 현재 상태와 환경 정보를 텍스트 형태로 제공할 수 있도록 `get_service_context` 기능을 구현한다. 이를 통해 AI 모델이 작업 환경을 정확히 파악하고 적절한 도구를 선택할 수 있도록 돕는다.

## 현재의 상태 / 문제점

### 1. get_service_context 미구현

- **Tauri Command**: `get_service_context`가 placeholder 형태로만 구현됨
- **Built-in MCP 서버**: 현재 상태나 환경 정보를 제공하는 메서드 없음
- **Frontend 요구사항**: content-store와 같은 텍스트 기반 컨텍스트 정보 필요

### 2. 서버 상태 정보 부재

- AI 모델이 현재 작업 디렉토리, 사용 가능한 환경 등을 알 수 없음
- Built-in 서버의 활성 상태나 연결 정보를 확인할 방법 없음
- 외부 MCP 서버와 built-in 서버 간 일관성 있는 컨텍스트 제공 부족

### 3. BuiltinMCPServer 트레이트 한계

```rust
#[async_trait]
pub trait BuiltinMCPServer: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn version(&self) -> &str { "1.0.0" }
    fn tools(&self) -> Vec<MCPTool>;
    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse;
    // get_service_context 메서드 없음
}
```

## 관련 코드의 구조 및 동작 방식 Summary

### Birdeye View: Built-in MCP Server 구조

```text
MCPServerManager (전역, get_mcp_manager()로 접근)
    ├── BuiltinServerRegistry (내부에서 관리)
    │   ├── HashMap<String, Box<dyn BuiltinMCPServer>>
    │   ├── workspace::WorkspaceServer (등록됨)
    │   └── 향후 추가될 다른 서버들
    └── 외부 MCP 서버 연결 관리

BuiltinMCPServer Trait
    ├── name() -> &str
    ├── description() -> &str
    ├── tools() -> Vec<MCPTool>
    ├── call_tool() -> MCPResponse
    └── get_service_context() -> String (추가 필요)

Tauri Commands
    ├── get_service_context (get_mcp_manager() 사용)
    ├── call_tool_unified (기존)
    └── 기타 MCP 관련 commands
```

### 핵심 컴포넌트

1. **BuiltinServerRegistry**: 서버 등록 및 관리 (MCPServerManager 내부에서 관리)
2. **workspace::WorkspaceServer**: 유일하게 등록된 built-in 서버
3. **MCPServerManager**: 전역 매니저로 `get_mcp_manager()`를 통해 접근
4. **content-store 패턴**: 텍스트 기반 컨텍스트 반환 참고 구현

## 변경 이후의 상태 / 해결 판정 기준

### 1. 성공 기준

- ✅ `BuiltinMCPServer` 트레이트에 `get_service_context` 메서드 추가
- ✅ `WorkspaceServer`에서 현재 작업 디렉토리와 directory tree 제공
- ✅ `BuiltinServerRegistry`에서 서버별 컨텍스트 조회 가능
- ✅ `get_service_context` Tauri command가 실제 정보 반환
- ✅ content-store와 일관성 있는 텍스트 형식 반환

### 2. 품질 기준

- **실용성**: AI가 작업 환경을 파악할 수 있는 핵심 정보 제공
- **간소성**: 도구 설명 제외, 현재 상태 중심 정보만 포함
- **확장성**: 새로운 built-in 서버 추가 시 기본 구현으로 즉시 동작
- **일관성**: 기존 registry 패턴과 호환

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. BuiltinMCPServer 트레이트 확장 (`src-tauri/src/mcp/builtin/mod.rs`)

```rust
#[async_trait]
pub trait BuiltinMCPServer: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn version(&self) -> &str { "1.0.0" }
    fn tools(&self) -> Vec<MCPTool>;
    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse;

    /// Returns current server status and environment context as markdown text
    fn get_service_context(&self, _options: Option<&Value>) -> String {
        format!(
            "# {} Server Status\n\
            **Server**: {}\n\
            **Status**: Active\n\
            **Tools Available**: {}",
            self.name(),
            self.name(),
            self.tools().len()
        )
    }
}
```

### 2. BuiltinServerRegistry 메서드 추가 (`src-tauri/src/mcp/builtin/mod.rs`)

```rust
impl BuiltinServerRegistry {
    // 기존 메서드들...

    pub fn get_server_context(&self, server_name: &str, options: Option<Value>) -> Result<String, String> {
        // Remove "builtin." prefix if present (기존 로직 재사용)
        let normalized_server_name = if let Some(stripped) = server_name.strip_prefix("builtin.") {
            stripped
        } else {
            server_name
        };

        if let Some(server) = self.get_server(normalized_server_name) {
            Ok(server.get_service_context(options.as_ref()))
        } else {
            Err(format!("Built-in server '{}' not found", server_name))
        }
    }
}
```

### 3. WorkspaceServer 구체적 구현 (`src-tauri/src/mcp/builtin/workspace/mod.rs`)

````rust
impl BuiltinMCPServer for WorkspaceServer {
    // 기존 메서드들...

    fn get_service_context(&self, _options: Option<&Value>) -> String {
        // 현재 작업 디렉토리 가져오기
        let current_dir = std::env::current_dir()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // 작업 디렉토리 tree 구조 (2단계 깊이)
        let tree_output = self.get_workspace_tree(&current_dir, 2);

        format!(
            "# Workspace Server Status\n\
            **Server**: workspace\n\
            **Status**: Active\n\
            **Working Directory**: {}\n\
            **Available Tools**: {} tools\n\
            \n\
            ## Current Directory Structure\n\
            ```\n\
            {}\n\
            ```",
            current_dir,
            self.tools().len(),
            tree_output
        )
    }
}

impl WorkspaceServer {
    fn get_workspace_tree(&self, path: &str, max_depth: usize) -> String {
        use std::fs;

        fn build_tree(dir: &std::path::Path, prefix: &str, depth: usize, max_depth: usize) -> String {
            if depth >= max_depth {
                return String::new();
            }

            let mut result = String::new();
            if let Ok(entries) = fs::read_dir(dir) {
                let mut entries: Vec<_> = entries.filter_map(|e| e.ok()).collect();
                entries.sort_by_key(|e| e.file_name());

                for (i, entry) in entries.iter().take(10).enumerate() { // 최대 10개만
                    let is_last = i == entries.len() - 1;
                    let connector = if is_last { "└── " } else { "├── " };
                    let name = entry.file_name().to_string_lossy();

                    result.push_str(&format!("{}{}{}\n", prefix, connector, name));

                    if entry.path().is_dir() && depth + 1 < max_depth {
                        let new_prefix = format!("{}{}    ", prefix, if is_last { " " } else { "│" });
                        result.push_str(&build_tree(&entry.path(), &new_prefix, depth + 1, max_depth));
                    }
                }
            }
            result
        }

        build_tree(std::path::Path::new(path), "", 0, max_depth)
    }
}
````

### 4. MCPServerManager에 get_service_context 메서드 추가 (`src-tauri/src/mcp/server.rs`)

```rust
impl MCPServerManager {
    // 기존 메서드들...

    pub async fn get_service_context(&self, server_name: &str) -> Result<String, String> {
        // Built-in 서버 먼저 확인
        if let Some(registry) = &self.builtin_registry {
            if let Ok(context) = registry.get_server_context(server_name, None) {
                return Ok(context);
            }
        }

        // 외부 MCP 서버 확인 (향후 구현)
        Ok(format!(
            "# MCP Server Context\nServer ID: {server_name}\nStatus: Active"
        ))
    }
}
```

### 5. Tauri Command 실제 구현 (`src-tauri/src/lib.rs`)

```rust
#[tauri::command]
async fn get_service_context(server_id: String) -> Result<String, String> {
    get_mcp_manager()
        .get_service_context(&server_id)
        .await
}
```

### 6. Tauri Handler 등록 (`src-tauri/src/lib.rs`)

```rust
// main function에서 handler 등록
.invoke_handler(tauri::generate_handler![
    // 기존 handlers...
    get_service_context,
    // ...
])
```

## 재사용 가능한 연관 코드

### 1. 기존 패턴 재사용

- **`list_tools_for_server` 로직**: prefix 제거 및 서버 이름 정규화
- **`get_server` 메서드**: 서버 조회 패턴
- **content-store의 `getServiceContext`**: 텍스트 반환 형식 참고

### 2. 파일 경로 및 주요 기능

- `src-tauri/src/mcp/builtin/mod.rs`: 트레이트 및 registry 구현
- `src-tauri/src/mcp/builtin/workspace/mod.rs`: WorkspaceServer 구현
- `src-tauri/src/mcp/server.rs`: MCPServerManager에 get_service_context 메서드 추가
- `src-tauri/src/lib.rs`: Tauri command 구현 및 handler 등록
- `src/lib/web-mcp/modules/content-store/server.ts`: 참고 구현

### 3. 활용 가능한 유틸리티

- `std::env::current_dir()`: 현재 디렉토리 조회
- `std::fs::read_dir()`: 디렉토리 목록 조회
- 기존 error handling 패턴: `MCPResponse` 구조

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 단위 테스트 (`src-tauri/src/mcp/builtin/tests.rs`)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_service_context_default() {
        // 기본 구현 테스트
        struct MockServer;
        impl BuiltinMCPServer for MockServer {
            fn name(&self) -> &str { "test" }
            fn description(&self) -> &str { "Test server" }
            fn tools(&self) -> Vec<MCPTool> { vec![] }
            async fn call_tool(&self, _: &str, _: Value) -> MCPResponse { todo!() }
        }

        let server = MockServer;
        let context = server.get_service_context(None);
        assert!(context.contains("test"));
        assert!(context.contains("Active"));
    }

    #[test]
    fn test_registry_get_server_context() {
        // Registry 컨텍스트 조회 테스트
        let mut registry = BuiltinServerRegistry::new();

        // 존재하지 않는 서버
        assert!(registry.get_server_context("nonexistent", None).is_err());

        // builtin. prefix 제거 테스트
        // (실제 서버 등록 후 테스트)
    }
}
```

### 2. 통합 테스트 (`src-tauri/src/lib.rs`)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_get_service_context_builtin() {
        // Built-in 서버 컨텍스트 조회 테스트
        let context = get_service_context("workspace".to_string()).await;

        assert!(context.is_ok());
        let content = context.unwrap();
        assert!(content.contains("Workspace Server Status"));
        assert!(content.contains("Working Directory"));
    }

    #[tokio::test]
    async fn test_get_service_context_external() {
        // 외부 MCP 서버 폴백 테스트
        let context = get_service_context("external-server".to_string()).await;

        assert!(context.is_ok());
        assert!(context.unwrap().contains("external-server"));
    }
}
```

### 3. E2E 테스트 시나리오

```typescript
// Frontend에서 get_service_context 호출 테스트
describe('MCP Service Context', () => {
  it('should get workspace server context', async () => {
    const context = await invoke('get_service_context', {
      serverId: 'workspace',
    });

    expect(context).toContain('Workspace Server Status');
    expect(context).toContain('Working Directory');
    expect(context).toContain('Directory Structure');
  });

  it('should handle builtin prefix', async () => {
    const context = await invoke('get_service_context', {
      serverId: 'builtin.workspace',
    });

    expect(context).toContain('Workspace Server Status');
  });
});
```

## 추가 분석 과제

### 1. 성능 최적화

- directory tree 생성 시 대용량 디렉토리 처리 방안
- 컨텍스트 생성 빈도 및 캐싱 필요성 검토

### 2. 보안 고려사항

- 작업 디렉토리 노출 수준 결정
- 민감한 파일/디렉토리 필터링 방안

### 3. 확장성 검토

- 향후 추가될 built-in 서버들의 컨텍스트 요구사항 조사
- 동적 컨텍스트 정보 (예: 실시간 상태) 지원 방안

### 4. UI/UX 개선

- Frontend에서 컨텍스트 정보 활용 방안
- 디버깅용 서버 상태 표시 기능 고려

---

**작업 우선순위**: 트레이트 확장 → Registry 메서드 추가 → WorkspaceServer 구현 → MCPServerManager 메서드 추가 → Tauri Command 구현 → Handler 등록 → 테스트 코드 추가

**예상 작업 시간**: 1-2일 (설계 0.5일, 구현 1일, 테스트 0.5일)
