# Refactoring Plan: App Performance & Responsiveness Optimization

**Date:** 2025-11-01  
**Author:** GitHub Copilot  
**Related Branch:** feat/on-board  
**Priority:** High

---

## 1. 작업의 목적

LibrAgent 애플리케이션의 응답성과 사용자 경험을 개선하기 위해 App.tsx 및 하위 컴포넌트들의 성능 최적화를 수행한다.

**목표:**

- UI 응답성 30% 이상 개선
- 불필요한 리렌더링 최소화
- 이벤트 처리 최적화 (스크롤, 타이핑 등)
- 메모리 사용량 감소

---

## 2. 현재의 상태 / 문제점

### 2.1 Context Provider 과도한 중첩 (Critical)

**현황:**

```
App.tsx에 11단계 Context Provider 중첩
├─ SettingsProvider
├─ MCPServerRegistryProvider
├─ MCPServerProvider
├─ SystemPromptProvider
├─ AssistantContextProvider
├─ SessionContextProvider
├─ BuiltInToolProvider
├─ SessionHistoryProvider
├─ ResourceAttachmentProvider
├─ ModelOptionsProvider
└─ SidebarProvider
```

**문제점:**

- 한 Provider의 상태 변경 시 전체 트리 재평가 가능성
- Context 간 의존성 불명확
- 불필요한 리렌더링 체인 발생
- 초기 로딩 성능 저하

**영향 파일:**

- `src/app/App.tsx` (11개 Provider 중첩)

---

### 2.2 AssistantContext 비효율적 상태 관리 (High)

**문제 코드 위치:** `src/context/AssistantContext.tsx`

#### Issue 1: 불필요한 Toast 알림

```tsx
// Line 183-187
useEffect(() => {
  if (currentAssistant) {
    toast(`Assistant switched: ${currentAssistant.name}`);
  }
}, [currentAssistant]);
```

- 초기 로드, 리로드 시에도 토스트 표시
- 사용자가 명시적으로 전환하지 않아도 알림 발생

#### Issue 2: 중복 에러 처리

```tsx
// Line 270-280
useEffect(() => {
  if (saveError) setError(saveError);
  else if (deleteError) setError(deleteError);
  else if (loadError) setError(loadError);
}, [saveError, deleteError, loadError]);
```

- 3개의 useEffect로 분산된 에러 처리
- 매번 새로운 useEffect 실행

#### Issue 3: MCP 서버 즉시 연결

```tsx
// Line 306-313
useEffect(() => {
  if (currentAssistant && activeServers.length > 0) {
    connectServersFromAssistant(currentAssistant);
  }
}, [currentAssistant, activeServers, connectServersFromAssistant]);
```

- Assistant 전환 시 즉시 서버 재연결 (네트워크 오버헤드)
- Debounce 없이 실행

**영향:**

- Assistant 전환 시 UI 지연
- 불필요한 네트워크 요청
- 사용자 경험 저하

---

### 2.3 SessionContext 비효율적 데이터 구조 (High)

**문제 코드 위치:** `src/context/SessionContext.tsx`

#### Issue 1: 매번 flatMap 실행

```tsx
// Line 153-155
useEffect(() => {
  sessionsRef.current = sessions.flatMap((page) => page.items);
}, [sessions]);
```

- SWR 데이터 변경 시마다 전체 배열 재생성
- O(n) 연산이 매 렌더링마다 실행

#### Issue 2: 불필요한 useMemo 체이닝

```tsx
// Line 136
const sessions = useMemo(() => data ?? [], [data]);

// Line 138-141
const hasNextPage = useMemo(
  () => !(sessions.length > 0 && !sessions[sessions.length - 1].hasNextPage),
  [sessions],
);
```

- sessions → hasNextPage로 이어지는 메모 체인
- 중간 값 변경 시 전체 체인 재계산

**영향:**

- 세션 목록이 많을 경우 성능 저하
- 메모리 사용량 증가

---

### 2.4 ChatMessages 스크롤 이벤트 미최적화 (High)

**문제 코드 위치:** `src/features/chat/components/ChatMessages.tsx`

```tsx
// Line 30-41
useEffect(() => {
  const container = scrollContainerRef.current;
  if (!container) return;

  const handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = container;
    const atBottom = scrollHeight - scrollTop - clientHeight < 10;
    setAutoScrollEnabled(atBottom); // 매 스크롤마다 setState!
  };

  container.addEventListener('scroll', handleScroll);
  return () => container.removeEventListener('scroll', handleScroll);
}, []);
```

**문제점:**

- Throttle/Debounce 없이 스크롤 이벤트 처리
- 초당 수백 번의 `setState` 호출
- 메시지가 많을 경우 심각한 성능 저하

**영향:**

- 스크롤 시 UI 버벅임
- CPU 사용률 증가

---

### 2.5 SessionList 검색 미최적화 (Medium)

**문제 코드 위치:** `src/features/session/SessionList.tsx`

```tsx
// Line 23-42
const filteredSessions = useMemo(() => {
  if (!searchQuery.trim()) {
    return sessions;
  }

  const query = searchQuery.toLowerCase();
  return sessions.filter((session) => {
    const name = session.name?.toLowerCase() || '';
    const description = session.description?.toLowerCase() || '';
    const assistantNames = session.assistants
      .map((a) => a.name.toLowerCase())
      .join(' ');

    return (
      name.includes(query) ||
      description.includes(query) ||
      assistantNames.includes(query)
    );
  });
}, [sessions, searchQuery]);
```

**문제점:**

- 타이핑 중 Debounce 없이 즉시 필터링
- `searchQuery` 변경 시마다 전체 배열 순회
- 세션이 많을 경우 타이핑 지연 발생

---

### 2.6 ChatInput 이벤트 핸들러 (Medium)

**문제 코드 위치:** `src/features/chat/components/ChatInput.tsx`

```tsx
// Line 99-103
const handleAgentInputChange = React.useCallback(
  (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(e.target.value);
  },
  [],
);
```

**문제점:**

- 의존성 배열이 비어있어 불필요한 리렌더링 방지는 되지만, 최적화 여지 존재
- Drag & Drop 이벤트 처리가 복잡하게 구성됨

---

## 3. 관련 코드 구조 및 동작 방식 (Bird's Eye View)

### 3.1 Context 의존성 그래프

```
Settings (독립)
    ↓
MCPServerRegistry → MCPServer
    ↓                    ↓
SystemPrompt      Assistant → BuiltInTool
    ↓                    ↓
Session ← SessionHistory
    ↓
ResourceAttachment
    ↓
ModelOptions
    ↓
Sidebar (UI Layer)
```

**의존성 분석:**

- **Settings**: 모든 Context의 기반 (API Keys, Window Size 등)
- **MCP 관련**: MCPServerRegistry ← MCPServer ← Assistant
- **세션 관련**: Session ← SessionHistory ← ResourceAttachment
- **UI 관련**: Sidebar, DnD (독립적)

### 3.2 주요 컴포넌트 렌더링 플로우

```
App.tsx (11 Providers)
    ↓
AppSidebar (SessionList)
    ↓
ChatContainer (WebMCP Providers)
    ↓
Chat (ChatProvider)
    ├─ ChatMessages (스크롤 이벤트)
    └─ ChatInput (타이핑 이벤트)
```

---

## 4. 변경 이후의 상태 / 해결 판정 기준

### 4.1 성능 지표

| 항목                | 현재 (예상) | 목표   | 측정 방법               |
| ------------------- | ----------- | ------ | ----------------------- |
| Context Provider 수 | 11개        | 4-5개  | 코드 리뷰               |
| Assistant 전환 시간 | ~500ms      | <200ms | React DevTools Profiler |
| 스크롤 FPS          | ~30fps      | 60fps  | Chrome Performance Tab  |
| 검색 타이핑 지연    | ~300ms      | <50ms  | User Input Latency      |
| 초기 로딩 시간      | ~2s         | <1.5s  | Lighthouse Performance  |

### 4.2 해결 판정 기준

- [ ] Provider 수가 6개 이하로 감소
- [ ] AssistantContext의 useEffect가 5개 이하로 감소
- [ ] 스크롤 이벤트에 Throttle 적용 (100ms)
- [ ] 검색 입력에 Debounce 적용 (300ms)
- [ ] SessionContext의 불필요한 flatMap 제거
- [ ] React DevTools Profiler에서 리렌더링 경고 50% 감소

---

## 5. 수정이 필요한 코드 및 수정 부분

### 5.1 Context Provider 통합

#### 파일: `src/context/CoreContext.tsx` (신규 생성)

**목적:** Settings, MCP, SystemPrompt을 하나의 Provider로 통합

```tsx
import React, { createContext, useContext, useMemo } from 'react';
import { SettingsProvider, useSettings } from './SettingsContext';
import {
  MCPServerRegistryProvider,
  useMCPServerRegistry,
} from './MCPServerRegistryContext';
import { MCPServerProvider, useMCPServer } from './MCPServerContext';
import { SystemPromptProvider, useSystemPrompt } from './SystemPromptContext';

interface CoreContextValue {
  settings: ReturnType<typeof useSettings>;
  mcpRegistry: ReturnType<typeof useMCPServerRegistry>;
  mcpServer: ReturnType<typeof useMCPServer>;
  systemPrompt: ReturnType<typeof useSystemPrompt>;
}

const CoreContext = createContext<CoreContextValue | undefined>(undefined);

export function CoreProvider({ children }: { children: React.ReactNode }) {
  return (
    <SettingsProvider>
      <MCPServerRegistryProvider>
        <MCPServerProvider>
          <SystemPromptProvider>
            <CoreContextInner>{children}</CoreContextInner>
          </SystemPromptProvider>
        </MCPServerProvider>
      </MCPServerRegistryProvider>
    </SettingsProvider>
  );
}

function CoreContextInner({ children }: { children: React.ReactNode }) {
  const settings = useSettings();
  const mcpRegistry = useMCPServerRegistry();
  const mcpServer = useMCPServer();
  const systemPrompt = useSystemPrompt();

  const value = useMemo<CoreContextValue>(
    () => ({
      settings,
      mcpRegistry,
      mcpServer,
      systemPrompt,
    }),
    [settings, mcpRegistry, mcpServer, systemPrompt],
  );

  return <CoreContext.Provider value={value}>{children}</CoreContext.Provider>;
}

export function useCoreContext() {
  const context = useContext(CoreContext);
  if (!context) {
    throw new Error('useCoreContext must be used within CoreProvider');
  }
  return context;
}

// Backward compatibility hooks
export function useSettings() {
  return useCoreContext().settings;
}

export function useMCPServerRegistry() {
  return useCoreContext().mcpRegistry;
}

export function useMCPServer() {
  return useCoreContext().mcpServer;
}

export function useSystemPrompt() {
  return useCoreContext().systemPrompt;
}
```

#### 파일: `src/app/App.tsx` (수정)

**변경 전:**

```tsx
<SettingsProvider>
  <MCPServerRegistryProvider>
    <MCPServerProvider>
      <SystemPromptProvider>
        <AssistantContextProvider>{/* ... */}</AssistantContextProvider>
      </SystemPromptProvider>
    </MCPServerProvider>
  </MCPServerRegistryProvider>
</SettingsProvider>
```

**변경 후:**

```tsx
import { CoreProvider } from '../context/CoreContext';

<CoreProvider>
  <AssistantContextProvider>{/* ... */}</AssistantContextProvider>
</CoreProvider>;
```

---

### 5.2 AssistantContext 최적화

#### 파일: `src/context/AssistantContext.tsx`

**수정 1: Toast 알림 개선 (Line 183-187)**

```tsx
// 변경 전
useEffect(() => {
  if (currentAssistant) {
    toast(`Assistant switched: ${currentAssistant.name}`);
  }
}, [currentAssistant]);

// 변경 후
const prevAssistantIdRef = useRef<string | null>(null);

useEffect(() => {
  if (currentAssistant?.id) {
    // 초기 로드 시 (null → assistant) 제외
    if (
      prevAssistantIdRef.current !== null &&
      prevAssistantIdRef.current !== currentAssistant.id
    ) {
      toast(`Assistant switched: ${currentAssistant.name}`);
    }
    prevAssistantIdRef.current = currentAssistant.id;
  }
}, [currentAssistant?.id, currentAssistant?.name]);
```

**수정 2: 에러 처리 통합 (Line 270-280)**

```tsx
// 변경 전
const [error, setError] = useState<Error | null>(null);

useEffect(() => {
  if (saveError) setError(saveError);
  else if (deleteError) setError(deleteError);
  else if (loadError) setError(loadError);
}, [saveError, deleteError, loadError]);

// 변경 후
const error = useMemo<Error | null>(() => {
  return saveError || deleteError || loadError || null;
}, [saveError, deleteError, loadError]);

// setError 호출 제거 (자동으로 계산됨)
```

**수정 3: MCP 서버 연결 Debounce (Line 306-313)**

```tsx
// 파일 상단에 import 추가
import { useMemo, useEffect, useCallback, useRef } from 'react';

// 변경 전
useEffect(() => {
  if (currentAssistant && activeServers.length > 0) {
    connectServersFromAssistant(currentAssistant);
  }
}, [currentAssistant, activeServers, connectServersFromAssistant]);

// 변경 후
const debouncedConnectRef = useRef<NodeJS.Timeout | null>(null);

useEffect(() => {
  // 이전 타이머 취소
  if (debouncedConnectRef.current) {
    clearTimeout(debouncedConnectRef.current);
  }

  if (currentAssistant && activeServers.length > 0) {
    // 500ms 후 연결 시도
    debouncedConnectRef.current = setTimeout(() => {
      connectServersFromAssistant(currentAssistant);
    }, 500);
  }

  return () => {
    if (debouncedConnectRef.current) {
      clearTimeout(debouncedConnectRef.current);
    }
  };
}, [currentAssistant, activeServers, connectServersFromAssistant]);
```

---

### 5.3 SessionContext 최적화

#### 파일: `src/context/SessionContext.tsx`

**수정 1: flatMap 제거 (Line 153-155)**

```tsx
// 변경 전
const sessions = useMemo(() => data ?? [], [data]);

useEffect(() => {
  sessionsRef.current = sessions.flatMap((page) => page.items);
}, [sessions]);

// 변경 후
const sessions = useMemo(() => data ?? [], [data]);

const flatSessions = useMemo(
  () => sessions.flatMap((page) => page.items),
  [sessions],
);

useEffect(() => {
  sessionsRef.current = flatSessions;
}, [flatSessions]);

// 또는 ref 업데이트를 제거하고 직접 useMemo 값 사용
const handleGetSessions = useCallback(() => {
  return flatSessions;
}, [flatSessions]);
```

**수정 2: hasNextPage 계산 최적화 (Line 138-141)**

```tsx
// 변경 전
const hasNextPage = useMemo(
  () => !(sessions.length > 0 && !sessions[sessions.length - 1].hasNextPage),
  [sessions],
);

// 변경 후
const hasNextPage = useMemo(() => {
  if (sessions.length === 0) return false;
  const lastPage = sessions[sessions.length - 1];
  return lastPage.hasNextPage;
}, [sessions]);
```

---

### 5.4 ChatMessages 스크롤 최적화

#### 파일: `src/features/chat/components/ChatMessages.tsx`

**의존성 추가:**

```bash
pnpm add lodash-es
pnpm add -D @types/lodash-es
```

**코드 수정 (Line 30-41):**

```tsx
// 파일 상단 import 추가
import { throttle } from 'lodash-es';

// 변경 전
useEffect(() => {
  const container = scrollContainerRef.current;
  if (!container) return;

  const handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = container;
    const atBottom = scrollHeight - scrollTop - clientHeight < 10;
    setAutoScrollEnabled(atBottom);
  };

  container.addEventListener('scroll', handleScroll);
  return () => container.removeEventListener('scroll', handleScroll);
}, []);

// 변경 후
const handleScroll = useMemo(
  () =>
    throttle(() => {
      const container = scrollContainerRef.current;
      if (!container) return;

      const { scrollTop, scrollHeight, clientHeight } = container;
      const atBottom = scrollHeight - scrollTop - clientHeight < 10;
      setAutoScrollEnabled(atBottom);
    }, 100), // 100ms throttle
  [],
);

useEffect(() => {
  const container = scrollContainerRef.current;
  if (!container) return;

  container.addEventListener('scroll', handleScroll, { passive: true });

  return () => {
    handleScroll.cancel(); // lodash throttle cleanup
    container.removeEventListener('scroll', handleScroll);
  };
}, [handleScroll]);
```

---

### 5.5 SessionList 검색 최적화

#### 파일: `src/features/session/SessionList.tsx`

**방법 1: React 18 내장 useDeferredValue 사용**

```tsx
// 파일 상단 import 추가
import { useMemo, useState, useDeferredValue } from 'react';

// Line 19-20 수정
const [searchQuery, setSearchQuery] = useState('');
const deferredQuery = useDeferredValue(searchQuery);

// Line 23 수정
const filteredSessions = useMemo(() => {
  if (!deferredQuery.trim()) {
    return sessions;
  }

  const query = deferredQuery.toLowerCase();
  return sessions.filter((session) => {
    const name = session.name?.toLowerCase() || '';
    const description = session.description?.toLowerCase() || '';
    const assistantNames = session.assistants
      .map((a) => a.name.toLowerCase())
      .join(' ');

    return (
      name.includes(query) ||
      description.includes(query) ||
      assistantNames.includes(query)
    );
  });
}, [sessions, deferredQuery]); // searchQuery → deferredQuery
```

**방법 2: lodash debounce 사용 (더 정밀한 제어)**

```tsx
// 의존성 추가
// pnpm add lodash-es

import { debounce } from 'lodash-es';
import { useMemo, useState, useCallback } from 'react';

const [searchQuery, setSearchQuery] = useState('');
const [debouncedQuery, setDebouncedQuery] = useState('');

const updateDebouncedQuery = useMemo(
  () =>
    debounce((value: string) => {
      setDebouncedQuery(value);
    }, 300),
  [],
);

const handleSearchChange = useCallback(
  (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setSearchQuery(value); // 즉시 input 값 업데이트 (UX)
    updateDebouncedQuery(value); // debounced 필터링
  },
  [updateDebouncedQuery],
);

// cleanup
useEffect(() => {
  return () => {
    updateDebouncedQuery.cancel();
  };
}, [updateDebouncedQuery]);

// filteredSessions는 debouncedQuery 사용
const filteredSessions = useMemo(() => {
  // ... (debouncedQuery 사용)
}, [sessions, debouncedQuery]);
```

---

## 6. 재사용 가능한 연관 코드

### 6.1 공통 Hooks 생성

#### 파일: `src/hooks/use-throttle.ts` (신규 생성)

```typescript
import { useCallback, useEffect, useRef } from 'react';

/**
 * Throttle hook for event handlers
 * @param callback - Function to throttle
 * @param delay - Delay in milliseconds
 * @returns Throttled callback
 */
export function useThrottle<T extends (...args: unknown[]) => void>(
  callback: T,
  delay: number,
): T {
  const lastRun = useRef(Date.now());
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const throttledCallback = useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();
      const timeSinceLastRun = now - lastRun.current;

      if (timeSinceLastRun >= delay) {
        callback(...args);
        lastRun.current = now;
      } else {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
          callback(...args);
          lastRun.current = Date.now();
        }, delay - timeSinceLastRun);
      }
    },
    [callback, delay],
  ) as T;

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return throttledCallback;
}
```

#### 파일: `src/hooks/use-debounce.ts` (신규 생성)

```typescript
import { useEffect, useState } from 'react';

/**
 * Debounce hook for values
 * @param value - Value to debounce
 * @param delay - Delay in milliseconds
 * @returns Debounced value
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

### 6.2 Context 통합 패턴

#### 파일: `src/context/SessionManagementContext.tsx` (신규 생성)

**목적:** Session, SessionHistory, ResourceAttachment 통합

```typescript
import React, { createContext, useContext, useMemo } from 'react';
import { SessionContextProvider, useSessionContext } from './SessionContext';
import { SessionHistoryProvider, useSessionHistory } from './SessionHistoryContext';
import { ResourceAttachmentProvider, useResourceAttachment } from './ResourceAttachmentContext';

interface SessionManagementContextValue {
  session: ReturnType<typeof useSessionContext>;
  history: ReturnType<typeof useSessionHistory>;
  attachment: ReturnType<typeof useResourceAttachment>;
}

const SessionManagementContext = createContext<SessionManagementContextValue | undefined>(
  undefined
);

export function SessionManagementProvider({ children }: { children: React.ReactNode }) {
  return (
    <SessionContextProvider>
      <SessionHistoryProvider>
        <ResourceAttachmentProvider>
          <SessionManagementInner>{children}</SessionManagementInner>
        </ResourceAttachmentProvider>
      </SessionHistoryProvider>
    </SessionContextProvider>
  );
}

function SessionManagementInner({ children }: { children: React.ReactNode }) {
  const session = useSessionContext();
  const history = useSessionHistory();
  const attachment = useResourceAttachment();

  const value = useMemo<SessionManagementContextValue>(
    () => ({
      session,
      history,
      attachment,
    }),
    [session, history, attachment]
  );

  return (
    <SessionManagementContext.Provider value={value}>
      {children}
    </SessionManagementContext.Provider>
  );
}

export function useSessionManagement() {
  const context = useContext(SessionManagementContext);
  if (!context) {
    throw new Error('useSessionManagement must be used within SessionManagementProvider');
  }
  return context;
}

// Backward compatibility
export function useSessionContext() {
  return useSessionManagement().session;
}

export function useSessionHistory() {
  return useSessionManagement().history;
}

export function useResourceAttachment() {
  return useSessionManagement().attachment;
}
```

---

## 7. Test Code 추가 및 수정 가이드

### 7.1 Context 통합 테스트

#### 파일: `src/context/__tests__/CoreContext.test.tsx` (신규)

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { CoreProvider, useCoreContext } from '../CoreContext';

describe('CoreContext', () => {
  it('should provide all core contexts', () => {
    const { result } = renderHook(() => useCoreContext(), {
      wrapper: CoreProvider,
    });

    expect(result.current.settings).toBeDefined();
    expect(result.current.mcpRegistry).toBeDefined();
    expect(result.current.mcpServer).toBeDefined();
    expect(result.current.systemPrompt).toBeDefined();
  });

  it('should throw error when used outside provider', () => {
    expect(() => {
      renderHook(() => useCoreContext());
    }).toThrow('useCoreContext must be used within CoreProvider');
  });
});
```

### 7.2 Throttle Hook 테스트

#### 파일: `src/hooks/__tests__/use-throttle.test.ts` (신규)

```typescript
import { renderHook, act } from '@testing-library/react';
import { useThrottle } from '../use-throttle';

describe('useThrottle', () => {
  jest.useFakeTimers();

  it('should throttle function calls', () => {
    const callback = jest.fn();
    const { result } = renderHook(() => useThrottle(callback, 100));

    act(() => {
      result.current();
      result.current();
      result.current();
    });

    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      jest.advanceTimersByTime(100);
    });

    act(() => {
      result.current();
    });

    expect(callback).toHaveBeenCalledTimes(2);
  });
});
```

### 7.3 AssistantContext 리렌더링 테스트

#### 파일: `src/context/__tests__/AssistantContext.performance.test.tsx` (신규)

```typescript
import { renderHook } from '@testing-library/react';
import {
  AssistantContextProvider,
  useAssistantContext,
} from '../AssistantContext';

describe('AssistantContext Performance', () => {
  it('should not trigger toast on initial load', async () => {
    const toastSpy = jest.spyOn(require('sonner'), 'toast');

    renderHook(() => useAssistantContext(), {
      wrapper: AssistantContextProvider,
    });

    // Initial load should not trigger toast
    expect(toastSpy).not.toHaveBeenCalled();
  });

  it('should debounce MCP server connections', async () => {
    const connectSpy = jest.fn();
    jest.mock('@/hooks/use-mcp-server', () => ({
      useMCPServer: () => ({
        connectServersFromAssistant: connectSpy,
        availableTools: [],
      }),
    }));

    const { result, rerender } = renderHook(() => useAssistantContext(), {
      wrapper: AssistantContextProvider,
    });

    // Multiple rapid changes should only trigger one connection
    act(() => {
      // Simulate multiple assistant changes
    });

    // Should only connect once after debounce period
    await waitFor(() => {
      expect(connectSpy).toHaveBeenCalledTimes(1);
    });
  });
});
```

---

## 8. 추가 분석 과제

### 8.1 Virtual Scrolling 검토

**목적:** 메시지가 100개 이상일 때 스크롤 성능 개선

**검토 항목:**

- `@tanstack/react-virtual` 라이브러리 도입 검토
- 메시지 높이 동적 계산 방식
- 이미지/첨부파일이 포함된 메시지 처리

**예상 파일:**

- `src/features/chat/components/ChatMessages.tsx`

**분석 방법:**

```bash
# 성능 프로파일링
pnpm tauri dev
# Chrome DevTools → Performance → Record 후 스크롤 테스트
```

---

### 8.2 Bundle Size 분석

**목적:** 초기 로딩 성능 개선

**분석 도구:**

```bash
pnpm add -D rollup-plugin-visualizer
```

**vite.config.ts 수정:**

```typescript
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    // ... existing plugins
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
});
```

**검토 항목:**

- 큰 번들 크기를 차지하는 라이브러리 식별
- Tree-shaking이 제대로 동작하는지 확인
- Lazy loading 추가 적용 가능성

---

### 8.3 React DevTools Profiler 분석

**목적:** 실제 리렌더링 패턴 파악

**분석 단계:**

1. 개발 환경 실행: `pnpm tauri dev`
2. React DevTools Profiler 활성화
3. 다음 시나리오 기록:
   - Assistant 전환
   - 세션 생성 및 전환
   - 메시지 입력 및 전송
   - 설정 변경
4. Flame Graph에서 렌더링 시간 분석
5. 불필요한 리렌더링 식별

**문서화:**

- 스크린샷 캡처
- 병목 지점 식별
- 개선 전후 비교 데이터

---

## 9. 작업 단계 및 순서

### Phase 1: 즉시 적용 가능한 최적화 (1-2일)

**우선순위: High, 난이도: Low**

1. ✅ **ChatMessages 스크롤 Throttle** (1시간)
   - 파일: `ChatMessages.tsx`
   - lodash-es 의존성 추가
   - 즉각적인 UX 개선 효과

2. ✅ **SessionList 검색 Debounce** (30분)
   - 파일: `SessionList.tsx`
   - `useDeferredValue` 또는 lodash debounce 적용
   - 타이핑 지연 해소

3. ✅ **AssistantContext Toast 개선** (30분)
   - 파일: `AssistantContext.tsx`
   - prevRef 패턴 적용
   - 사용자 불편 해소

### Phase 2: Context 최적화 (2-3일)

**우선순위: High, 난이도: Medium**

4. ✅ **AssistantContext 에러 처리 통합** (1시간)
   - useEffect → useMemo 변경
   - 불필요한 리렌더링 제거

5. ✅ **AssistantContext MCP Debounce** (1-2시간)
   - 500ms debounce 적용
   - 네트워크 요청 최적화

6. ✅ **SessionContext flatMap 최적화** (2시간)
   - useMemo 체인 개선
   - 메모리 사용량 감소

### Phase 3: Context Provider 통합 (3-4일)

**우선순위: Medium, 난이도: High**

7. ✅ **CoreContext 생성** (4시간)
   - Settings, MCP, SystemPrompt 통합
   - 신규 파일 생성 및 테스트

8. ✅ **SessionManagementContext 생성** (4시간)
   - Session, History, Attachment 통합
   - Backward compatibility 보장

9. ✅ **App.tsx 리팩토링** (2시간)
   - Provider 구조 단순화
   - 전체 통합 테스트

### Phase 4: 검증 및 문서화 (1-2일)

10. ✅ **성능 측정** (2시간)
    - React DevTools Profiler
    - Chrome Performance Tab
    - 개선 전후 비교

11. ✅ **테스트 코드 작성** (4시간)
    - Unit tests for hooks
    - Integration tests for contexts
    - Performance regression tests

12. ✅ **문서 업데이트** (1시간)
    - 변경 사항 README 업데이트
    - Migration guide 작성

---

## 10. Rollback Plan

각 Phase마다 Git branch 생성으로 롤백 가능성 확보:

```bash
# Phase 1
git checkout -b perf/phase1-event-optimization

# Phase 2
git checkout -b perf/phase2-context-optimization

# Phase 3
git checkout -b perf/phase3-provider-integration
```

**Rollback 기준:**

- 빌드 실패
- 기존 기능 동작 불가
- 성능 지표 악화
- 테스트 실패율 10% 이상 증가

---

## 11. Clarification Q-List

### Q1: Context Provider 통합 범위

**질문:** AssistantContextProvider와 BuiltInToolProvider도 통합해야 하는가?

**고려사항:**

- 현재 AssistantContext는 BuiltInTool을 사용
- 순환 의존성 가능성
- 독립성 유지 vs 통합의 trade-off

**제안:**

- Phase 3에서 성능 측정 후 결정
- 우선 CoreContext와 SessionManagementContext만 통합
- 추가 통합은 성능 이득이 확인된 후 진행

---

### Q2: Virtual Scrolling 도입 시점

**질문:** 메시지 목록에 Virtual Scrolling을 지금 도입할 것인가?

**고려사항:**

- 구현 복잡도 증가
- 기존 스크롤 동작 변경
- 이미지/첨부파일 높이 동적 계산 필요

**제안:**

- Phase 1에서 Throttle 적용 후 성능 재측정
- 여전히 성능 이슈가 있다면 Phase 4에서 도입
- 메시지 100개 이상 시나리오로 테스트

---

### Q3: lodash-es vs 자체 구현

**질문:** Throttle/Debounce를 lodash-es로 할지, 자체 hook으로 구현할지?

**Trade-off:**

- **lodash-es 장점:** 검증된 라이브러리, 다양한 옵션
- **lodash-es 단점:** 번들 크기 증가 (~24KB)
- **자체 구현 장점:** 번들 크기 최소화, 커스터마이징 용이
- **자체 구현 단점:** 버그 가능성, 유지보수 부담

**제안:**

- Phase 1에서는 lodash-es 사용 (빠른 검증)
- Phase 4에서 번들 분석 후, 필요시 자체 hook으로 교체
- Tree-shaking이 제대로 동작하는지 확인

---

### Q4: Backward Compatibility 유지 범위

**질문:** Context 통합 시 기존 hook 이름을 모두 유지해야 하는가?

**현황:**

- 현재 `useSettings()`, `useMCPServer()` 등 개별 hook 사용
- 통합 후 `useCoreContext().settings` 형태로 변경 가능

**제안:**

- 기존 hook 이름 유지 (re-export)
- 점진적 마이그레이션 지원
- Deprecation warning 추가
- 2-3개 버전 후 제거

```typescript
/**
 * @deprecated Use useCoreContext().settings instead
 * This hook will be removed in v2.0.0
 */
export function useSettings() {
  console.warn('useSettings is deprecated, use useCoreContext().settings');
  return useCoreContext().settings;
}
```

---

## 12. 참고 자료

### 12.1 관련 문서

- [React 18 Performance Optimization](https://react.dev/learn/render-and-commit)
- [React Context Performance](https://github.com/facebook/react/issues/15156)
- [Tauri Performance Best Practices](https://tauri.app/v1/guides/debugging/performance/)

### 12.2 관련 라이브러리

- [lodash-es](https://www.npmjs.com/package/lodash-es)
- [@tanstack/react-virtual](https://tanstack.com/virtual/latest)
- [use-debounce](https://www.npmjs.com/package/use-debounce)

### 12.3 성능 측정 도구

- React DevTools Profiler
- Chrome Performance Tab
- Lighthouse
- Bundle Analyzer

---

## 13. 성공 지표

### 13.1 정량적 지표

| 항목                       | 현재 (추정) | 목표     | 측정 완료 |
| -------------------------- | ----------- | -------- | --------- |
| Context Provider 수        | 11개        | 4-5개    | [ ]       |
| AssistantContext useEffect | 8개         | 5개 이하 | [ ]       |
| 스크롤 FPS                 | ~30fps      | 60fps    | [ ]       |
| 검색 응답 시간             | ~300ms      | <50ms    | [ ]       |
| 번들 크기                  | TBD         | -10%     | [ ]       |
| 초기 로딩                  | ~2s         | <1.5s    | [ ]       |

### 13.2 정성적 지표

- [ ] 사용자가 느끼는 UI 반응성 개선
- [ ] 스크롤 시 버벅임 없음
- [ ] 타이핑 지연 없음
- [ ] Assistant 전환 즉각 반응
- [ ] 메모리 누수 없음

---

**Document Version:** 1.0  
**Last Updated:** 2025-11-01  
**Review Required:** After Phase 2 completion
