# Refactoring Plan: MCP Builtin Servers 작업 디렉터리 표준화

## 작업의 목적

MCP 내장 서버들(FilesystemServer, SandboxServer)의 작업 디렉터리를 시스템 임시 디렉터리로 통일하여 다음 문제들을 해결:

1. **일관성 부족**: 현재 FilesystemServer와 SandboxServer가 서로 다른 기준으로 작업 디렉터리를 결정
2. **예측 불가능한 실행 위치**: 실행 환경(개발/배포)에 따라 작업 디렉터리가 달라짐
3. **보안 격리 부족**: 프로덕션 환경에서 시스템 파일에 직접 접근할 수 있는 위험
4. **권한 문제**: 다양한 시스템에서 쓰기 권한 문제 발생 가능성

## 현재의 상태 / 문제점

### FilesystemServer

- `SecurityValidator::new()`에서 `std::env::current_dir()`를 기본 base_dir로 사용
- 실행 시점의 CWD가 `src-tauri` 디렉터리가 되어 프로젝트 루트가 아닌 곳에서 동작
- 로그에서 확인된 문제: Cargo.toml, tauri.conf.json 등 src-tauri 내 파일들만 리스트됨

### SandboxServer

- `cmd.current_dir(temp_dir.path())`로 임시 디렉터리를 작업 디렉터리로 설정
- `cmd.env("HOME", temp_dir.path())`로 HOME을 임시 디렉터리로 설정
- FilesystemServer와 다른 기준으로 동작하여 일관성 부족

### 실제 문제 상황

```log
[2025-08-18][06:13:18] Directory listing for ./:
[
  {"name": "capabilities", "type": "directory"},
  {"name": "gen", "type": "directory"},
  {"name": "src", "type": "directory"},
  {"name": "target", "type": "directory"},
  {"name": "Cargo.toml", "size": 1216, "type": "file"}
]
```

→ 프로젝트 루트가 아닌 src-tauri 디렉터리의 내용이 리스트됨

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **통일된 작업 디렉터리**: 모든 MCP 내장 서버가 시스템 임시 디렉터리를 기본으로 사용
2. **환경변수 지원**: `SYNAPTICFLOW_PROJECT_ROOT`로 명시적 프로젝트 루트 지정 가능
3. **보안 격리**: 기본적으로 시스템 임시 디렉터리에서 격리된 환경 제공
4. **일관된 로깅**: 모든 서버에서 사용 중인 작업 디렉터리를 명확히 로깅

### 해결 판정 기준

- [ ] FilesystemServer와 SandboxServer가 동일한 작업 디렉터리 결정 로직 사용
- [ ] 기본 실행 시 시스템 임시 디렉터리(`std::env::temp_dir()`) 사용 확인
- [ ] 환경변수 `SYNAPTICFLOW_PROJECT_ROOT` 설정 시 해당 디렉터리 사용 확인
- [ ] 로그에서 작업 디렉터리가 명확히 출력되는지 확인
- [ ] 개발 환경에서 `export SYNAPTICFLOW_PROJECT_ROOT=/Users/1111108/my_work/synaptic-flow && pnpm tauri dev` 실행 시 프로젝트 루트 사용 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. SecurityValidator 수정 (`src-tauri/src/mcp/builtin/utils.rs`)

**현재 코드:**

```rust
impl SecurityValidator {
    pub fn new() -> Self {
        let cwd = std::env::current_dir().unwrap_or_default();

        Self {
            base_dir: cwd,
            // ...other fields...
        }
    }
}
```

**수정 후 코드:**

```rust
impl SecurityValidator {
    pub fn new() -> Self {
        use std::path::PathBuf;

        let base_dir = if let Ok(root) = std::env::var("SYNAPTICFLOW_PROJECT_ROOT") {
            // 1. 명시적 프로젝트 루트 환경변수
            PathBuf::from(root)
        } else {
            // 2. 기본값: 시스템 임시 디렉터리 사용
            let tmp = std::env::temp_dir();
            tracing::info!("Using default system temp dir for SecurityValidator base: {:?}", tmp);
            tmp
        };

        tracing::info!("SecurityValidator base_dir = {:?}", base_dir);

        Self {
            base_dir,
            // ...other fields...
        }
    }
}
```

### 2. FilesystemServer 수정 (`src-tauri/src/mcp/builtin/filesystem.rs`)

**현재 코드:**

```rust
impl FilesystemServer {
    pub fn new() -> Self {
        Self {
            security: SecurityValidator::default(),
        }
    }
}
```

**수정 후 코드:**

```rust
impl FilesystemServer {
    pub fn new() -> Self {
        // 현재 작업 디렉터리 로그 (확인용)
        match std::env::current_dir() {
            Ok(dir) => info!("FilesystemServer starting with CWD = {:?}", dir),
            Err(e) => error!("Failed to read current_dir: {}", e),
        }

        Self {
            security: SecurityValidator::new(),
        }
    }
}
```

### 3. SandboxServer 수정 (`src-tauri/src/mcp/builtin/sandbox.rs`)

**현재 코드:**

```rust
async fn execute_code_in_sandbox(
    &self,
    command: &str,
    args: &[&str],
    code: &str,
    file_extension: &str,
    timeout_secs: u64,
) -> MCPResponse {
    // ...existing code...

    // Set working directory to temp directory
    cmd.current_dir(temp_dir.path());

    // Clear environment variables for isolation
    cmd.env_clear();
    cmd.env("PATH", std::env::var("PATH").unwrap_or_default());
    cmd.env("HOME", temp_dir.path());
    cmd.env("TMPDIR", temp_dir.path());
    cmd.env("TEMP", temp_dir.path());

    // ...existing code...
}
```

**수정 후 코드:**

```rust
impl SandboxServer {
    /// 작업 디렉터리 결정 (FilesystemServer와 동일한 로직)
    fn determine_execution_working_dir() -> std::path::PathBuf {
        use std::path::PathBuf;

        if let Ok(root) = std::env::var("SYNAPTICFLOW_PROJECT_ROOT") {
            PathBuf::from(root)
        } else {
            let tmp = std::env::temp_dir();
            info!("Using system temp dir for sandbox execution: {:?}", tmp);
            tmp
        }
    }
}

async fn execute_code_in_sandbox(
    &self,
    command: &str,
    args: &[&str],
    code: &str,
    file_extension: &str,
    timeout_secs: u64,
) -> MCPResponse {
    // ...existing code...

    // 결정된 작업 디렉터리 사용 (FilesystemServer와 동일한 규칙)
    let work_dir = Self::determine_execution_working_dir();
    info!("Sandbox execution working dir: {:?}", work_dir);
    cmd.current_dir(&work_dir);

    // Clear environment variables for isolation
    cmd.env_clear();
    cmd.env("PATH", std::env::var("PATH").unwrap_or_default());

    // HOME은 작업 디렉터리로 설정
    if let Some(home_str) = work_dir.to_str() {
        cmd.env("HOME", home_str);
    }

    // 임시 관련 변수는 temp_dir로 설정 (실제 임시 파일은 여기에)
    if let Some(tmp_str) = temp_dir.path().to_str() {
        cmd.env("TMPDIR", tmp_str);
        cmd.env("TEMP", tmp_str);
    }

    // ...existing code...
}
```

## 테스트 시나리오

### 시나리오 1: 기본 실행 (시스템 임시 디렉터리)

```bash
pnpm tauri dev
```

**예상 결과**: 로그에서 시스템 임시 디렉터리 경로 출력

### 시나리오 2: 프로젝트 루트 지정

```bash
export SYNAPTICFLOW_PROJECT_ROOT=/Users/1111108/my_work/synaptic-flow
pnpm tauri dev
```

**예상 결과**: 로그에서 지정된 프로젝트 루트 경로 출력

### 시나리오 3: FilesystemServer 디렉터리 리스트

- 시스템 임시 디렉터리에서 실행 시 임시 디렉터리 내용 리스트
- 프로젝트 루트 지정 시 프로젝트 루트 내용 리스트

## 리스크 및 고려사항

### 리스크

1. **기존 사용자 워크플로우 영향**: 기존에 현재 디렉터리를 기준으로 파일 작업을 하던 사용자들에게 영향
2. **임시 디렉터리 권한**: 일부 시스템에서 임시 디렉터리 접근 권한 문제 가능성

### 고려사항

1. **하위 호환성**: 환경변수를 통해 기존 동작 방식 지원
2. **문서화**: 변경사항에 대한 사용자 가이드 업데이트 필요
3. **로깅**: 충분한 로그를 통해 문제 발생 시 디버깅 가능하도록 구성

## 구현 순서

1. `SecurityValidator::new()` 수정
2. `FilesystemServer::new()` 로깅 추가
3. `SandboxServer` 작업 디렉터리 로직 수정
4. 테스트 실행 및 검증
5. 문서 업데이트
