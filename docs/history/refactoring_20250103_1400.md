# Refactoring Plan: lib.rs 모듈화 및 구조 개선

**작성일**: 2025-10-03  
**작업 브랜치**: fix/mcp-ui  
**담당자**: AI Agent + User Review

---

## 1. 작업의 목적

`src-tauri/src/lib.rs` 파일이 1154줄로 비대해져 유지보수성과 가독성이 저하되었습니다. 이를 기능별 모듈로 분리하여:

- **유지보수성 향상**: 기능별로 독립된 파일에서 코드 수정 및 확장 용이
- **가독성 개선**: 각 모듈의 책임과 역할이 명확하게 분리
- **협업 효율성**: 여러 개발자가 동시에 다른 기능 영역 작업 가능
- **테스트 용이성**: 모듈 단위 테스트 작성 및 검증 가능

---

## 2. 현재의 상태 / 문제점

### 현재 lib.rs 구조 (1154 lines)

```text
lib.rs
├── Global State (Lines 1-50)
│   ├── OnceLock<MCPServerManager> (MCP_MANAGER)
│   ├── OnceLock<String> (SQLITE_DB_URL)
│   └── Initialization helpers
│
├── Workspace Commands (Lines 51-150)
│   ├── get_app_data_dir
│   ├── resolve_path
│   └── get_isolation_capabilities
│
├── Session Commands (Lines 151-250)
│   ├── get_workspace_path
│   ├── delete_workspace
│   └── Related session operations
│
├── MCP Commands (Lines 251-400)
│   ├── list_mcp_servers
│   ├── get_mcp_server_status
│   ├── install_mcp_server
│   └── Other MCP operations
│
├── Content Store Commands (Lines 401-500)
│   ├── delete_content_store (Line 406)
│   └── Related content operations
│
├── Browser Commands (Lines 501-700)
│   ├── launch_browser
│   ├── close_browser
│   └── Browser automation operations
│
├── Log Commands (Lines 701-800)
│   ├── get_recent_logs
│   ├── clear_logs
│   └── Log management
│
├── File Operations (Lines 801-900)
│   ├── secure_read_file
│   ├── secure_write_file
│   └── File system operations
│
├── Initialization Logic (Lines 901-1000)
│   ├── setup_logging
│   ├── initialize_sqlite_db
│   └── register_mcp_builtin_servers
│
└── Tauri Builder Setup (Lines 1001-1154)
    ├── invoke_handler with 50+ commands
    ├── Plugin registrations
    └── App lifecycle hooks
```

### 주요 문제점

1. **단일 책임 원칙 위반**: 한 파일에 너무 많은 책임이 혼재 (workspace, session, MCP, browser, logs, content-store, file operations)
2. **높은 결합도**: 모든 명령이 한 곳에 정의되어 있어 변경 시 파일 전체 영향
3. **낮은 응집도**: 관련 없는 기능들이 물리적으로 인접해 있음
4. **테스트 어려움**: 모듈 단위 테스트 불가능, 전체 lib.rs를 빌드해야만 테스트 가능
5. **Merge Conflict 위험**: 여러 작업자가 동시 수정 시 충돌 가능성 높음
6. **코드 네비게이션 불편**: 특정 명령 찾기 위해 1000줄 이상 스크롤 필요

---

## 3. 관련 코드의 구조 및 동작 방식 Summary

### Tauri Command 시스템

```rust
// 1. 명령 정의 (with #[tauri::command] attribute)
#[tauri::command]
async fn my_command(param: String) -> Result<String, String> {
    // Implementation
}

// 2. generate_handler! 매크로에 등록
fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            my_command,
            other_command,
            // ... more commands
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### Global State 관리

- `OnceLock<T>`: Thread-safe lazy initialization
- `MCP_MANAGER`: MCP 서버 생명주기 관리
- `SQLITE_DB_URL`: 데이터베이스 연결 문자열

### 의존성 관계

```text
lib.rs
  ├─> commands/session_commands.rs (import)
  ├─> commands/browser_commands.rs (import)
  ├─> commands/mcp_commands.rs (import)
  ├─> services/browser_server.rs
  ├─> services/secure_file_manager.rs
  ├─> session/mod.rs
  └─> mcp/manager.rs
```

---

## 4. 변경 이후의 상태 / 해결 판정 기준

### 목표 파일 구조

```text
src-tauri/src/
├── lib.rs (150-200 lines)  ← Main entry point only
│   ├── Global state declarations
│   ├── Builder setup
│   └── Command registration
│
├── commands/
│   ├── mod.rs  ← Re-export all commands
│   ├── workspace_commands.rs  ← get_app_data_dir, resolve_path
│   ├── session_commands.rs  ← Already exists, enhance
│   ├── mcp_commands.rs  ← Already exists, enhance
│   ├── browser_commands.rs  ← Already exists, enhance
│   ├── content_store_commands.rs  ← delete_content_store, etc.
│   ├── log_commands.rs  ← get_recent_logs, clear_logs
│   └── file_commands.rs  ← secure_read_file, secure_write_file
│
└── init/
    ├── mod.rs  ← Re-export initialization functions
    ├── logging.rs  ← setup_logging
    ├── database.rs  ← initialize_sqlite_db
    └── mcp_init.rs  ← register_mcp_builtin_servers
```

### 성공 판정 기준

1. **빌드 성공**: `pnpm rust:check` 및 `cargo build` 통과
2. **기능 검증**: 기존 모든 Tauri 명령이 정상 작동
3. **코드 크기**: lib.rs가 200줄 이하로 감소
4. **모듈 독립성**: 각 명령 모듈이 독립적으로 테스트 가능
5. **Lint 통과**: `cargo clippy` 및 `cargo fmt` 검증 통과
6. **문서화**: 각 모듈에 README 또는 모듈 수준 docstring 존재

---

## 5. 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 5.1. lib.rs - Before (Simplified)

```rust
// src-tauri/src/lib.rs (Current: 1154 lines)

use std::sync::OnceLock;
use tauri::Manager;

static MCP_MANAGER: OnceLock<MCPServerManager> = OnceLock::new();
static SQLITE_DB_URL: OnceLock<String> = OnceLock::new();

#[tauri::command]
async fn get_app_data_dir(app: tauri::AppHandle) -> Result<String, String> {
    // 50 lines of implementation
}

#[tauri::command]
async fn delete_content_store(session_id: String) -> Result<(), String> {
    // 40 lines of implementation
}

#[tauri::command]
async fn get_recent_logs() -> Result<Vec<LogEntry>, String> {
    // 30 lines of implementation
}

// ... 50+ more commands

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            get_app_data_dir,
            delete_content_store,
            get_recent_logs,
            // ... 50+ more commands
        ])
        .setup(|app| {
            setup_logging()?;
            initialize_sqlite_db(app)?;
            register_mcp_builtin_servers()?;
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 5.2. lib.rs - After (Target)

```rust
// src-tauri/src/lib.rs (Target: ~150 lines)

use std::sync::OnceLock;
use tauri::Manager;

mod commands;
mod init;

// Re-export for global access
pub use commands::*;
pub use init::*;

// Global state
static MCP_MANAGER: OnceLock<MCPServerManager> = OnceLock::new();
static SQLITE_DB_URL: OnceLock<String> = OnceLock::new();

pub fn get_mcp_manager() -> &'static MCPServerManager {
    MCP_MANAGER.get().expect("MCP_MANAGER not initialized")
}

pub fn get_sqlite_db_url() -> &'static String {
    SQLITE_DB_URL.get().expect("SQLITE_DB_URL not initialized")
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            // Workspace commands
            commands::workspace::get_app_data_dir,
            commands::workspace::resolve_path,
            commands::workspace::get_isolation_capabilities,

            // Session commands
            commands::session::get_workspace_path,
            commands::session::delete_workspace,

            // Content store commands
            commands::content_store::delete_content_store,

            // Log commands
            commands::log::get_recent_logs,
            commands::log::clear_logs,

            // ... organized by module
        ])
        .setup(|app| {
            init::setup_logging()?;
            init::initialize_sqlite_db(app)?;
            init::register_mcp_builtin_servers()?;
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 5.3. commands/content_store_commands.rs - New File

```rust
// src-tauri/src/commands/content_store_commands.rs

use crate::{get_sqlite_db_url, session::SessionManager};
use sqlx::SqlitePool;
use std::path::PathBuf;

/// Delete content store for a specific session
///
/// This command removes:
/// - All SQLite records (chunks, contents, stores)
/// - Search index directory (content_store_search/{session_id})
///
/// # Arguments
/// * `session_id` - The unique session identifier
///
/// # Returns
/// * `Ok(())` - Successfully deleted
/// * `Err(String)` - Error message if deletion fails
#[tauri::command]
pub async fn delete_content_store(session_id: String) -> Result<(), String> {
    let db_url = get_sqlite_db_url();
    let pool = SqlitePool::connect(db_url)
        .await
        .map_err(|e| format!("Failed to connect to database: {}", e))?;

    // Delete from chunks table
    sqlx::query("DELETE FROM chunks WHERE store_id IN (SELECT id FROM stores WHERE session_id = ?)")
        .bind(&session_id)
        .execute(&pool)
        .await
        .map_err(|e| format!("Failed to delete chunks: {}", e))?;

    // Delete from contents table
    sqlx::query("DELETE FROM contents WHERE store_id IN (SELECT id FROM stores WHERE session_id = ?)")
        .bind(&session_id)
        .execute(&pool)
        .await
        .map_err(|e| format!("Failed to delete contents: {}", e))?;

    // Delete from stores table
    sqlx::query("DELETE FROM stores WHERE session_id = ?")
        .bind(&session_id)
        .execute(&pool)
        .await
        .map_err(|e| format!("Failed to delete stores: {}", e))?;

    // Delete search index directory
    let search_index_path = SessionManager::get_app_data_dir()
        .map_err(|e| format!("Failed to get app data dir: {}", e))?
        .join("content_store_search")
        .join(&session_id);

    if search_index_path.exists() {
        std::fs::remove_dir_all(&search_index_path)
            .map_err(|e| format!("Failed to remove search index: {}", e))?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_delete_content_store() {
        // TODO: Add integration test with test database
    }
}
```

### 5.4. commands/mod.rs - New File

```rust
// src-tauri/src/commands/mod.rs

pub mod workspace;
pub mod content_store;
pub mod log;
pub mod file;

// Re-export existing command modules
pub use crate::commands::session_commands;
pub use crate::commands::browser_commands;
pub use crate::commands::mcp_commands;
```

### 5.5. init/mod.rs - New File

```rust
// src-tauri/src/init/mod.rs

mod logging;
mod database;
mod mcp_init;

pub use logging::setup_logging;
pub use database::initialize_sqlite_db;
pub use mcp_init::register_mcp_builtin_servers;
```

---

## 6. 재사용 가능한 연관 코드

### 기존 모듈 (이미 분리되어 있음)

1. **`src-tauri/src/commands/session_commands.rs`**
   - 주요 기능: Session 생성, 삭제, 조회
   - 인터페이스: `create_session`, `remove_session`, `list_sessions`
   - 재사용: 그대로 유지, lib.rs에서 import만 변경

2. **`src-tauri/src/commands/browser_commands.rs`**
   - 주요 기능: Browser automation (launch, close, navigate)
   - 인터페이스: `launch_browser`, `close_browser`, `browser_navigate`
   - 재사용: 그대로 유지

3. **`src-tauri/src/commands/mcp_commands.rs`**
   - 주요 기능: MCP server 관리 (install, list, start, stop)
   - 인터페이스: `list_mcp_servers`, `install_mcp_server`, `get_mcp_server_status`
   - 재사용: 그대로 유지

### 공통 유틸리티

```rust
// src-tauri/src/utils/error.rs (New)

/// Standard error type for Tauri commands
pub type CommandResult<T> = Result<T, String>;

/// Convert any error to String for Tauri command results
pub fn to_command_error<E: std::fmt::Display>(error: E) -> String {
    format!("{}", error)
}
```

### 글로벌 상태 접근 헬퍼

```rust
// src-tauri/src/state.rs (New)

use std::sync::OnceLock;
use crate::mcp::manager::MCPServerManager;

static MCP_MANAGER: OnceLock<MCPServerManager> = OnceLock::new();
static SQLITE_DB_URL: OnceLock<String> = OnceLock::new();

pub fn get_mcp_manager() -> &'static MCPServerManager {
    MCP_MANAGER.get().expect("MCP_MANAGER not initialized")
}

pub fn set_mcp_manager(manager: MCPServerManager) {
    MCP_MANAGER.set(manager).expect("MCP_MANAGER already initialized");
}

pub fn get_sqlite_db_url() -> &'static String {
    SQLITE_DB_URL.get().expect("SQLITE_DB_URL not initialized")
}

pub fn set_sqlite_db_url(url: String) {
    SQLITE_DB_URL.set(url).expect("SQLITE_DB_URL already initialized");
}
```

---

## 7. Test Code 추가 및 수정 필요 부분에 대한 가이드

### 7.1. 단위 테스트 추가

각 명령 모듈에 `#[cfg(test)]` 블록 추가:

```rust
// src-tauri/src/commands/content_store_commands.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_delete_content_store_success() {
        // Given: Test database with sample data
        // When: Call delete_content_store
        // Then: Verify all data is deleted
    }

    #[tokio::test]
    async fn test_delete_content_store_nonexistent_session() {
        // Given: Non-existent session_id
        // When: Call delete_content_store
        // Then: Should not error (idempotent)
    }
}
```

### 7.2. 통합 테스트 추가

```rust
// src-tauri/tests/integration_test.rs (New)

use tauri::test::{mock_builder, mock_context};

#[test]
fn test_all_commands_registered() {
    let app = mock_builder()
        .invoke_handler(tauri::generate_handler![
            // All commands should be listed here
        ])
        .build(mock_context())
        .unwrap();

    // Verify app builds successfully
}
```

### 7.3. 테스트 실행 가이드

```bash
# 단위 테스트
cargo test --package synaptic-flow --lib

# 통합 테스트
cargo test --package synaptic-flow --test integration_test

# 전체 테스트
cargo test

# 특정 모듈만 테스트
cargo test commands::content_store
```

---

## 8. 마이그레이션 단계 (Step-by-Step)

### Phase 1: 준비 단계 (Low Risk)

1. **새 디렉토리 생성**

   ```bash
   mkdir -p src-tauri/src/commands
   mkdir -p src-tauri/src/init
   ```

2. **state.rs 분리**
   - Global state를 별도 파일로 추출
   - lib.rs에서 import하여 사용

### Phase 2: 명령 분리 (Medium Risk)

#### Content Store Commands 분리 (우선순위 1)

- `delete_content_store` → `commands/content_store_commands.rs`
- lib.rs에서 import 및 테스트

#### Log Commands 분리 (우선순위 2)

- `get_recent_logs`, `clear_logs` → `commands/log_commands.rs`

#### File Commands 분리 (우선순위 3)

- `secure_read_file`, `secure_write_file` → `commands/file_commands.rs`

#### Workspace Commands 분리 (우선순위 4)

- `get_app_data_dir`, `resolve_path` → `commands/workspace_commands.rs`

### Phase 3: 초기화 로직 분리 (Low Risk)

#### Initialization 모듈 분리

- `setup_logging` → `init/logging.rs`
- `initialize_sqlite_db` → `init/database.rs`
- `register_mcp_builtin_servers` → `init/mcp_init.rs`

### Phase 4: 검증 및 정리 (Critical)

#### 전체 빌드 및 테스트

```bash
pnpm rust:fmt
pnpm rust:clippy
pnpm rust:check
cargo test
pnpm build
```

#### 문서 업데이트

- `docs/architecture/overview.md` 업데이트
- 각 모듈에 docstring 추가

#### 코드 리뷰 및 병합

    - Pull Request 생성
    - 팀 리뷰 및 승인
    - main 브랜치 병합

---

## 9. 위험 요소 및 완화 전략

### 위험 요소

1. **빌드 실패 위험**: 모듈 분리 시 import 경로 오류
   - **완화**: 각 단계마다 `cargo check` 실행

2. **명령 누락 위험**: generate_handler! 매크로에서 명령 누락
   - **완화**: 마이그레이션 전후 명령 목록 비교 스크립트 작성

3. **Global State 접근 오류**: OnceLock 초기화 타이밍 문제
   - **완화**: state.rs에서 명확한 getter/setter 제공

4. **테스트 부재**: 리팩토링 후 기능 검증 어려움
   - **완화**: Phase 2에서 각 모듈마다 최소 1개 이상 테스트 추가

### 롤백 계획

- Git 브랜치 전략: `refactor/lib-rs-modularization` 브랜치에서 작업
- 각 Phase별로 커밋 분리
- 문제 발생 시 이전 Phase로 즉시 되돌리기 가능

---

## 10. 추가 분석 과제

### 분석 필요 사항

1. **명령 간 의존성 분석**
   - 어떤 명령이 다른 명령을 내부적으로 호출하는가?
   - 순환 의존성 가능성 확인

2. **Global State 사용 패턴**
   - MCP_MANAGER와 SQLITE_DB_URL을 사용하는 모든 위치 파악
   - Thread-safety 검증

3. **Error Handling 일관성**
   - 현재 `Result<T, String>` 패턴 사용 중
   - 더 나은 에러 타입 정의 필요성 검토

4. **성능 영향 분석**
   - 모듈 분리로 인한 컴파일 시간 변화 측정
   - 런타임 성능 영향 없음 확인

### 분석 가이드

```bash
# 명령 간 호출 관계 분석
rg "invoke\(" src-tauri/src/lib.rs

# Global state 사용 위치 확인
rg "MCP_MANAGER|SQLITE_DB_URL" src-tauri/src/

# 에러 처리 패턴 확인
rg "Result<.*,.*String>" src-tauri/src/lib.rs
```

---

## 11. 예상 결과

### 정량적 목표

- lib.rs: 1154줄 → ~150줄 (87% 감소)
- 명령 모듈: 0개 → 7개 (workspace, session, browser, mcp, content_store, log, file)
- 초기화 모듈: 0개 → 3개 (logging, database, mcp_init)
- 테스트 커버리지: 0% → 60%+

### 정성적 목표

- 새로운 명령 추가 시 해당 모듈만 수정
- 모듈별 책임 명확화로 코드 이해도 향상
- Merge conflict 빈도 감소
- 온보딩 시간 단축 (새 개발자가 코드 구조 파악 용이)

---

## 12. 참고 자료

- [Tauri Command Documentation](https://tauri.app/v1/guides/features/command)
- [Rust Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
- [Project Coding Standards](docs/contributing/coding-standards.md)
- [Architecture Overview](docs/architecture/overview.md)

---

## 체크리스트

- [ ] Phase 1: 새 디렉토리 및 state.rs 생성
- [ ] Phase 2-1: Content Store Commands 분리
- [ ] Phase 2-2: Log Commands 분리
- [ ] Phase 2-3: File Commands 분리
- [ ] Phase 2-4: Workspace Commands 분리
- [ ] Phase 3: Initialization 모듈 분리
- [ ] Phase 4-1: 전체 빌드 및 테스트
- [ ] Phase 4-2: 문서 업데이트
- [ ] Phase 4-3: 코드 리뷰 및 병합
- [ ] 최종 검증: `pnpm refactor:validate` 통과

---

**작성자 노트**: 이 계획은 점진적 마이그레이션을 통해 위험을 최소화하면서 코드 품질을 향상시키는 것을 목표로 합니다. 각 Phase를 독립적으로 검증하며 진행하세요.
