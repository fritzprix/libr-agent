# Refactoring Plan: SQLx를 Repository Pattern으로 추상화

## 작업의 목적

현재 Commands 레이어에 분산되어 있는 SQLx 직접 호출 및 `db::` 모듈을 Repository Pattern으로 추상화하여 다음을 달성:

1. **관심사의 분리**: Commands는 비즈니스 로직, Repository는 데이터 접근 로직으로 명확히 분리
2. **테스트 용이성**: Repository를 Mock으로 대체 가능하도록 하여 유닛 테스트 작성 지원
3. **재사용성 향상**: 동일한 쿼리 로직을 여러 Commands에서 재사용 가능
4. **타입 안전성**: 구조화된 에러 타입(`DbError`)으로 에러 처리 개선
5. **유지보수성**: DB 쿼리 로직을 중앙 집중화하여 변경 시 영향 범위 최소화

---

## 현재의 상태 / 문제점

### 1. 현재 구조

```
commands/
├── messages_commands.rs
│   ├── pub mod db { ... }      # SQLx 직접 호출 (9개 함수)
│   └── Tauri commands          # db:: 모듈 호출
├── content_store_commands.rs   # SQLx 직접 호출
└── session_commands.rs         # SQLx 직접 호출

lib.rs                          # db::create_messages_table() 호출
search/background_worker.rs     # db::is_index_dirty(), update_index_meta() 호출
```

### 2. 주요 문제점

#### **A. 관심사 미분리**

- Commands 파일 내부에 `pub mod db { ... }` 형태로 데이터 접근 로직이 혼재
- `content_store_commands.rs`와 `session_commands.rs`는 함수 내에서 직접 `sqlx::query()` 호출

#### **B. 테스트 어려움**

- DB 로직을 Mock으로 대체할 수 없어 통합 테스트만 가능
- 유닛 테스트 작성 불가

#### **C. 코드 중복 및 재사용 불가**

- 동일한 쿼리 패턴을 여러 곳에서 반복 작성
- 예: `content_store_commands.rs`에서 매번 `SqlitePool::connect()` 수행

#### **D. 에러 처리 일관성 부족**

- 모든 에러를 `String`으로 반환하여 타입 안전성 저하
- 에러 종류 구분 불가 (NotFound vs QueryFailed 등)

#### **E. 의존성 결합도 높음**

- Commands가 SQLx에 직접 의존
- 나중에 다른 DB로 변경 시 Commands 전체 수정 필요

---

## 관련 코드의 구조 및 동작 방식 Summary

### 현재 SQLx 사용 패턴

```
┌─────────────────────────────────────────┐
│         Tauri Commands                   │
│  - messages_get_page()                   │
│  - messages_upsert()                     │
│  - delete_content_store()                │
│  - remove_session()                      │
└─────────────────┬───────────────────────┘
                  │ (직접 호출)
                  ▼
┌─────────────────────────────────────────┐
│      db:: 모듈 또는 인라인 코드          │
│  - sqlx::query(...)                      │
│  - SqlitePool::connect()                 │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│         sqlx::SqlitePool                 │
│  (Low-level database access)             │
└─────────────────────────────────────────┘
```

### SQLx 사용 위치 (총 3개 파일)

#### 1. `commands/messages_commands.rs`

- **`pub mod db`**: 9개 함수
  - `create_messages_table()` - 테이블 초기화
  - `get_messages_page()` - 페이지네이션 조회
  - `upsert_message()` - 단일 메시지 저장
  - `upsert_messages()` - 다중 메시지 저장 (트랜잭션)
  - `delete_message()` - 메시지 삭제
  - `delete_all_for_session()` - 세션 전체 삭제
  - `update_index_meta()` - 인덱스 메타데이터 업데이트
  - `get_last_indexed_at()` - 마지막 인덱싱 시간 조회
  - `is_index_dirty()` - 인덱스 갱신 필요 여부 확인

- **Tauri Commands**: 5개 함수가 `db::` 호출
- **내부 함수**: `get_or_build_index()`가 `db::` 호출

#### 2. `commands/content_store_commands.rs`

- `delete_content_store()` 함수 내에서 직접 SQLx 호출
  - `SqlitePool::connect()` - DB 연결
  - `sqlx::query("DELETE FROM chunks ...")` - 3개 테이블 삭제

#### 3. `commands/session_commands.rs`

- `remove_session()` 함수 내에서 직접 SQLx 호출
  - `sqlx::query("DELETE FROM message_index_meta ...")`

### 외부 호출 지점

#### 1. `lib.rs`

```rust
commands::messages_commands::db::create_messages_table(&pool).await
```

#### 2. `search/background_worker.rs`

```rust
use crate::commands::messages_commands::db::{is_index_dirty, update_index_meta};
```

---

## 변경 이후의 상태 / 해결 판정 기준

### 목표 아키텍처

```
┌─────────────────────────────────────────┐
│         Tauri Commands                   │
│  (Business logic only)                   │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│      Repository Layer                    │
│  - MessageRepository trait               │
│  - SqliteMessageRepository               │
│  - ContentStoreRepository trait          │
│  - SqliteContentStoreRepository          │
│  - SessionRepository trait               │
│  - SqliteSessionRepository               │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│         sqlx::SqlitePool                 │
└─────────────────────────────────────────┘
```

### 변경 후 파일 구조

```
src-tauri/src/
├── repositories/
│   ├── mod.rs                          [수정] - 모듈 export
│   ├── error.rs                        [수정] - DbError 타입
│   ├── message_repository.rs           [수정] - Trait + Impl
│   ├── content_store_repository.rs     [수정] - Trait + Impl
│   └── session_repository.rs           [수정] - Trait + Impl
│
├── commands/
│   ├── messages_commands.rs            [수정] - db:: 모듈 제거, Repository 사용
│   ├── content_store_commands.rs       [수정] - Repository 사용
│   └── session_commands.rs             [수정] - Repository 사용
│
├── lib.rs                              [수정] - Repository 사용
└── search/background_worker.rs         [수정] - Repository 사용
```

### 해결 판정 기준

#### ✅ 필수 조건

1. `pub mod db` 모듈이 완전히 제거됨
2. 모든 Commands에서 Repository를 통해 DB 접근
3. `cargo check` 및 `cargo clippy` 통과
4. 기존 통합 테스트 모두 통과
5. 에러 타입이 `DbError`로 통일 (Commands는 String 변환)

#### ✅ 선택 조건

1. Repository 유닛 테스트 추가 (Mock 기반)
2. 성능 테스트 (Repository 추상화 오버헤드 확인)

---

## 수정이 필요한 코드 및 수정부분 코드 스니핏

### 1. repositories/error.rs

#### 현재 상태

```rust
// 빈 파일
```

#### 수정 후

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DbError {
    #[error("Database query failed: {0}")]
    QueryFailed(#[from] sqlx::Error),

    #[error("Record not found: {0}")]
    NotFound(String),

    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),
}

// Tauri commands 호환성을 위한 String 변환
impl From<DbError> for String {
    fn from(err: DbError) -> String {
        err.to_string()
    }
}
```

---

### 2. repositories/message_repository.rs

#### 현재 상태

```rust
// 빈 파일
```

#### 수정 후 (핵심 구조)

```rust
use async_trait::async_trait;
use sqlx::{Row, SqlitePool};
use crate::commands::messages_commands::{Message, Page};
use super::error::DbError;

/// Message repository trait for abstraction
#[async_trait]
pub trait MessageRepository: Send + Sync {
    async fn create_table(&self) -> Result<(), DbError>;
    async fn get_page(&self, session_id: &str, page: usize, page_size: usize) -> Result<Page<Message>, DbError>;
    async fn insert(&self, message: &Message) -> Result<(), DbError>;
    async fn insert_many(&self, messages: Vec<Message>) -> Result<(), DbError>;
    async fn delete_by_id(&self, message_id: &str) -> Result<(), DbError>;
    async fn delete_by_session(&self, session_id: &str) -> Result<(), DbError>;
    async fn update_index_meta(&self, session_id: &str, index_path: &str, doc_count: usize, rebuild_duration_ms: i64) -> Result<(), DbError>;
    async fn get_last_indexed_at(&self, session_id: &str) -> Result<i64, DbError>;
    async fn is_index_dirty(&self, session_id: &str) -> Result<bool, DbError>;
}

/// SQLite implementation of MessageRepository
pub struct SqliteMessageRepository {
    pool: SqlitePool,
}

impl SqliteMessageRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl MessageRepository for SqliteMessageRepository {
    async fn create_table(&self) -> Result<(), DbError> {
        // db::create_messages_table() 로직 이동
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS messages (
                id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL CHECK(session_id <> ''),
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                tool_calls TEXT,
                tool_call_id TEXT,
                is_streaming INTEGER,
                thinking TEXT,
                thinking_signature TEXT,
                assistant_id TEXT,
                attachments TEXT,
                tool_use TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                source TEXT,
                error TEXT
            );

            CREATE INDEX IF NOT EXISTS idx_messages_session_created
            ON messages(session_id, created_at);

            CREATE INDEX IF NOT EXISTS idx_messages_session_id
            ON messages(session_id);

            CREATE TABLE IF NOT EXISTS message_index_meta (
                session_id TEXT PRIMARY KEY,
                index_path TEXT,
                last_indexed_at INTEGER DEFAULT 0,
                doc_count INTEGER DEFAULT 0,
                index_version INTEGER DEFAULT 1,
                last_rebuild_duration_ms INTEGER
            );
            "#,
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn get_page(&self, session_id: &str, page: usize, page_size: usize) -> Result<Page<Message>, DbError> {
        // db::get_messages_page() 로직 이동
        if page_size == 0 {
            return Err(DbError::InvalidInput("page_size must be > 0".into()));
        }

        let offset = (page.saturating_sub(1)) as i64 * page_size as i64;

        let row = sqlx::query("SELECT COUNT(1) as count FROM messages WHERE session_id = ?")
            .bind(session_id)
            .fetch_one(&self.pool)
            .await?;
        let total: i64 = row.get("count");

        let rows = sqlx::query(
            r#"
            SELECT
                id, session_id, role, content, tool_calls, tool_call_id,
                is_streaming, thinking, thinking_signature, assistant_id,
                attachments, tool_use, created_at, updated_at, source, error
            FROM messages
            WHERE session_id = ?
            ORDER BY created_at ASC
            LIMIT ? OFFSET ?
            "#,
        )
        .bind(session_id)
        .bind(page_size as i64)
        .bind(offset)
        .fetch_all(&self.pool)
        .await?;

        let messages: Vec<Message> = rows
            .into_iter()
            .map(|row| Message {
                id: row.get("id"),
                session_id: row.get("session_id"),
                role: row.get("role"),
                content: row.get("content"),
                tool_calls: row.get("tool_calls"),
                tool_call_id: row.get("tool_call_id"),
                is_streaming: row.get("is_streaming"),
                thinking: row.get("thinking"),
                thinking_signature: row.get("thinking_signature"),
                assistant_id: row.get("assistant_id"),
                attachments: row.get("attachments"),
                tool_use: row.get("tool_use"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
                source: row.get("source"),
                error: row.get("error"),
            })
            .collect();

        let total_usize = total as usize;
        let has_prev = page > 1;
        let has_next = page * page_size < total_usize;

        Ok(Page {
            items: messages,
            page,
            page_size,
            total_items: total_usize,
            has_next_page: has_next,
            has_previous_page: has_prev,
        })
    }

    async fn insert(&self, message: &Message) -> Result<(), DbError> {
        // db::upsert_message() 로직 이동
        sqlx::query(
            r#"
            INSERT INTO messages (
                id, session_id, role, content, tool_calls, tool_call_id,
                is_streaming, thinking, thinking_signature, assistant_id,
                attachments, tool_use, created_at, updated_at, source, error
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(id) DO UPDATE SET
                session_id = excluded.session_id,
                role = excluded.role,
                content = excluded.content,
                tool_calls = excluded.tool_calls,
                tool_call_id = excluded.tool_call_id,
                is_streaming = excluded.is_streaming,
                thinking = excluded.thinking,
                thinking_signature = excluded.thinking_signature,
                assistant_id = excluded.assistant_id,
                attachments = excluded.attachments,
                tool_use = excluded.tool_use,
                updated_at = excluded.updated_at,
                source = excluded.source,
                error = excluded.error
            "#,
        )
        .bind(&message.id)
        .bind(&message.session_id)
        .bind(&message.role)
        .bind(&message.content)
        .bind(&message.tool_calls)
        .bind(&message.tool_call_id)
        .bind(message.is_streaming)
        .bind(&message.thinking)
        .bind(&message.thinking_signature)
        .bind(&message.assistant_id)
        .bind(&message.attachments)
        .bind(&message.tool_use)
        .bind(message.created_at)
        .bind(message.updated_at)
        .bind(&message.source)
        .bind(&message.error)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn insert_many(&self, messages: Vec<Message>) -> Result<(), DbError> {
        // db::upsert_messages() 로직 이동 (트랜잭션 포함)
        let mut tx = self.pool.begin().await?;

        for message in messages {
            sqlx::query(
                r#"
                INSERT INTO messages (
                    id, session_id, role, content, tool_calls, tool_call_id,
                    is_streaming, thinking, thinking_signature, assistant_id,
                    attachments, tool_use, created_at, updated_at, source, error
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(id) DO UPDATE SET
                    session_id = excluded.session_id,
                    role = excluded.role,
                    content = excluded.content,
                    tool_calls = excluded.tool_calls,
                    tool_call_id = excluded.tool_call_id,
                    is_streaming = excluded.is_streaming,
                    thinking = excluded.thinking,
                    thinking_signature = excluded.thinking_signature,
                    assistant_id = excluded.assistant_id,
                    attachments = excluded.attachments,
                    tool_use = excluded.tool_use,
                    updated_at = excluded.updated_at,
                    source = excluded.source,
                    error = excluded.error
                "#,
            )
            .bind(&message.id)
            .bind(&message.session_id)
            .bind(&message.role)
            .bind(&message.content)
            .bind(&message.tool_calls)
            .bind(&message.tool_call_id)
            .bind(message.is_streaming)
            .bind(&message.thinking)
            .bind(&message.thinking_signature)
            .bind(&message.assistant_id)
            .bind(&message.attachments)
            .bind(&message.tool_use)
            .bind(message.created_at)
            .bind(message.updated_at)
            .bind(&message.source)
            .bind(&message.error)
            .execute(&mut *tx)
            .await?;
        }

        tx.commit().await.map_err(|e| DbError::TransactionFailed(e.to_string()))?;
        Ok(())
    }

    async fn delete_by_id(&self, message_id: &str) -> Result<(), DbError> {
        // db::delete_message() 로직 이동
        sqlx::query("DELETE FROM messages WHERE id = ?")
            .bind(message_id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }

    async fn delete_by_session(&self, session_id: &str) -> Result<(), DbError> {
        // db::delete_all_for_session() 로직 이동
        sqlx::query("DELETE FROM messages WHERE session_id = ?")
            .bind(session_id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }

    async fn update_index_meta(
        &self,
        session_id: &str,
        index_path: &str,
        doc_count: usize,
        rebuild_duration_ms: i64,
    ) -> Result<(), DbError> {
        // db::update_index_meta() 로직 이동
        let now = chrono::Utc::now().timestamp_millis();

        sqlx::query(
            r#"
            INSERT INTO message_index_meta (session_id, index_path, last_indexed_at, doc_count, last_rebuild_duration_ms)
            VALUES (?, ?, ?, ?, ?)
            ON CONFLICT(session_id) DO UPDATE SET
                index_path = excluded.index_path,
                last_indexed_at = excluded.last_indexed_at,
                doc_count = excluded.doc_count,
                last_rebuild_duration_ms = excluded.last_rebuild_duration_ms
            "#,
        )
        .bind(session_id)
        .bind(index_path)
        .bind(now)
        .bind(doc_count as i64)
        .bind(rebuild_duration_ms)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn get_last_indexed_at(&self, session_id: &str) -> Result<i64, DbError> {
        // db::get_last_indexed_at() 로직 이동
        let result = sqlx::query("SELECT last_indexed_at FROM message_index_meta WHERE session_id = ?")
            .bind(session_id)
            .fetch_optional(&self.pool)
            .await?;

        Ok(result.map(|row| row.get("last_indexed_at")).unwrap_or(0))
    }

    async fn is_index_dirty(&self, session_id: &str) -> Result<bool, DbError> {
        // db::is_index_dirty() 로직 이동
        let last_indexed_at = self.get_last_indexed_at(session_id).await?;

        let row = sqlx::query("SELECT MAX(created_at) as max_created FROM messages WHERE session_id = ?")
            .bind(session_id)
            .fetch_one(&self.pool)
            .await?;

        let max_created: Option<i64> = row.get("max_created");
        Ok(max_created.map(|t| t > last_indexed_at).unwrap_or(false))
    }
}
```

---

### 3. repositories/content_store_repository.rs

#### 현재 상태

```rust
// 빈 파일
```

#### 수정 후

```rust
use async_trait::async_trait;
use sqlx::SqlitePool;
use super::error::DbError;

#[async_trait]
pub trait ContentStoreRepository: Send + Sync {
    async fn delete_by_session(&self, session_id: &str) -> Result<(), DbError>;
}

pub struct SqliteContentStoreRepository {
    pool: SqlitePool,
}

impl SqliteContentStoreRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl ContentStoreRepository for SqliteContentStoreRepository {
    async fn delete_by_session(&self, session_id: &str) -> Result<(), DbError> {
        // delete_content_store() 함수의 SQLx 로직 이동
        sqlx::query(
            "DELETE FROM chunks WHERE content_id IN (SELECT id FROM contents WHERE session_id = ?)",
        )
        .bind(session_id)
        .execute(&self.pool)
        .await?;

        sqlx::query("DELETE FROM contents WHERE session_id = ?")
            .bind(session_id)
            .execute(&self.pool)
            .await?;

        sqlx::query("DELETE FROM stores WHERE session_id = ?")
            .bind(session_id)
            .execute(&self.pool)
            .await?;

        Ok(())
    }
}
```

---

### 4. repositories/session_repository.rs

#### 현재 상태

```rust
// 빈 파일
```

#### 수정 후

```rust
use async_trait::async_trait;
use sqlx::SqlitePool;
use super::error::DbError;

#[async_trait]
pub trait SessionRepository: Send + Sync {
    async fn delete_index_metadata(&self, session_id: &str) -> Result<(), DbError>;
}

pub struct SqliteSessionRepository {
    pool: SqlitePool,
}

impl SqliteSessionRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl SessionRepository for SqliteSessionRepository {
    async fn delete_index_metadata(&self, session_id: &str) -> Result<(), DbError> {
        sqlx::query("DELETE FROM message_index_meta WHERE session_id = ?")
            .bind(session_id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}
```

---

### 5. repositories/mod.rs

#### 현재 상태

```rust
// 빈 파일
```

#### 수정 후

```rust
pub mod error;
pub mod message_repository;
pub mod content_store_repository;
pub mod session_repository;

pub use error::DbError;
pub use message_repository::{MessageRepository, SqliteMessageRepository};
pub use content_store_repository::{ContentStoreRepository, SqliteContentStoreRepository};
pub use session_repository::{SessionRepository, SqliteSessionRepository};
```

---

### 6. commands/messages_commands.rs

#### 수정 전 (주요 부분)

```rust
use crate::state::get_sqlite_pool;

pub mod db {
    // ... 330줄의 db 로직 ...
}

#[command]
pub async fn messages_get_page(
    session_id: String,
    page: usize,
    page_size: usize,
) -> Result<Page<Message>, String> {
    let pool = get_sqlite_pool();
    db::get_messages_page(pool, &session_id, page, page_size).await
}

async fn get_or_build_index(session_id: &str) -> Result<MessageSearchEngine, String> {
    let pool = get_sqlite_pool();
    let is_dirty = db::is_index_dirty(pool, session_id).await?;
    // ...
    db::update_index_meta(pool, session_id, &index_path, doc_count, duration_ms).await?;
    // ...
}
```

#### 수정 후

```rust
use crate::state::get_sqlite_pool;
use crate::repositories::message_repository::{MessageRepository, SqliteMessageRepository};

// pub mod db { ... } 완전히 제거

#[command]
pub async fn messages_get_page(
    session_id: String,
    page: usize,
    page_size: usize,
) -> Result<Page<Message>, String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    repo.get_page(&session_id, page, page_size)
        .await
        .map_err(|e| e.to_string())
}

#[command]
pub async fn messages_upsert_many(messages: Vec<Message>) -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    repo.insert_many(messages)
        .await
        .map_err(|e| e.to_string())
}

#[command]
pub async fn messages_upsert(message: Message) -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    repo.insert(&message)
        .await
        .map_err(|e| e.to_string())
}

#[command]
pub async fn messages_delete(message_id: String) -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    repo.delete_by_id(&message_id)
        .await
        .map_err(|e| e.to_string())
}

#[command]
pub async fn messages_delete_all_for_session(session_id: String) -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    repo.delete_by_session(&session_id)
        .await
        .map_err(|e| e.to_string())
}

async fn get_or_build_index(session_id: &str) -> Result<MessageSearchEngine, String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    let is_dirty = repo.is_index_dirty(session_id).await.map_err(|e| e.to_string())?;
    // ...
    repo.update_index_meta(session_id, &index_path, doc_count, duration_ms)
        .await
        .map_err(|e| e.to_string())?;
    // ...
}
```

---

### 7. lib.rs

#### 수정 전

```rust
commands::messages_commands::db::create_messages_table(&pool)
    .await
    .expect("Failed to create messages table");
```

#### 수정 후

```rust
use crate::repositories::message_repository::{MessageRepository, SqliteMessageRepository};

let repo = SqliteMessageRepository::new(pool.clone());
repo.create_table()
    .await
    .expect("Failed to create messages table");
```

---

### 8. search/background_worker.rs

#### 수정 전

```rust
use crate::commands::messages_commands::db::{is_index_dirty, update_index_meta};

async fn reindex_dirty_sessions() -> Result<(), String> {
    // ...
    let is_dirty = is_index_dirty(pool, &session_id).await?;
    // ...
}

async fn rebuild_session_index(session_id: &str) -> Result<(), String> {
    // ...
    update_index_meta(pool, session_id, &index_path, doc_count, duration_ms).await?;
    // ...
}
```

#### 수정 후

```rust
use crate::repositories::message_repository::{MessageRepository, SqliteMessageRepository};

async fn reindex_dirty_sessions() -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    // ...
    let is_dirty = repo.is_index_dirty(&session_id).await.map_err(|e| e.to_string())?;
    // ...
}

async fn rebuild_session_index(session_id: &str) -> Result<(), String> {
    let pool = get_sqlite_pool();
    let repo = SqliteMessageRepository::new(pool.clone());
    // ...
    repo.update_index_meta(session_id, &index_path, doc_count, duration_ms)
        .await
        .map_err(|e| e.to_string())?;
    // ...
}
```

---

### 9. commands/content_store_commands.rs

#### 수정 전

```rust
#[tauri::command]
pub async fn delete_content_store(session_id: String) -> Result<(), String> {
    if let Some(db_url) = get_sqlite_db_url() {
        let db_path = if let Some(p) = db_url.strip_prefix("sqlite://") {
            p.to_string()
        } else {
            db_url.clone()
        };

        let pool = SqlitePool::connect(&db_path).await.map_err(...)?;

        sqlx::query("DELETE FROM chunks WHERE content_id IN ...").bind(&session_id).execute(&pool).await?;
        sqlx::query("DELETE FROM contents WHERE session_id = ?").bind(&session_id).execute(&pool).await?;
        sqlx::query("DELETE FROM stores WHERE session_id = ?").bind(&session_id).execute(&pool).await?;
    }
    // ... 파일 시스템 정리 ...
}
```

#### 수정 후

```rust
use crate::repositories::content_store_repository::{ContentStoreRepository, SqliteContentStoreRepository};
use crate::state::get_sqlite_pool;

#[tauri::command]
pub async fn delete_content_store(session_id: String) -> Result<(), String> {
    if get_sqlite_db_url().is_some() {
        let pool = get_sqlite_pool();
        let repo = SqliteContentStoreRepository::new(pool.clone());
        repo.delete_by_session(&session_id)
            .await
            .map_err(|e| e.to_string())?;
    }

    // 파일 시스템 정리는 그대로 유지
    let session_manager = get_session_manager()?;
    let search_index_dir = session_manager
        .get_session_workspace_dir()
        .join("content_store_search");

    if search_index_dir.exists() {
        tokio_fs::remove_dir_all(&search_index_dir).await?;
    }

    Ok(())
}
```

---

### 10. commands/session_commands.rs

#### 수정 전

```rust
pub async fn remove_session(session_id: String) -> Result<(), String> {
    // ...
    let pool = get_sqlite_pool();
    if let Err(e) = sqlx::query("DELETE FROM message_index_meta WHERE session_id = ?")
        .bind(&session_id)
        .execute(pool)
        .await
    {
        error!("Failed to delete index metadata: {e}");
    }
    // ...
}
```

#### 수정 후

```rust
use crate::repositories::session_repository::{SessionRepository, SqliteSessionRepository};

pub async fn remove_session(session_id: String) -> Result<(), String> {
    // ...
    let pool = get_sqlite_pool();
    let repo = SqliteSessionRepository::new(pool.clone());

    if let Err(e) = repo.delete_index_metadata(&session_id).await {
        error!("Failed to delete index metadata: {e}");
    }
    // ...
}
```

---

## 재사용 가능한 연관 코드

### 1. 타입 정의 (그대로 사용)

- `commands/messages_commands.rs`의 `Message`, `Page<T>` 타입
- Repository에서 import하여 사용

### 2. State 관리 함수 (그대로 사용)

- `state::get_sqlite_pool()` - 전역 pool 가져오기
- `state::get_sqlite_db_url()` - DB URL 가져오기

### 3. 기존 쿼리 로직 (100% 재사용)

- `db::` 모듈의 모든 쿼리 로직을 Repository로 복사-붙여넣기
- SQL 문, bind 로직, 결과 매핑 로직 모두 동일

### 4. 에러 변환 패턴

```rust
// 표준 패턴
repo.method(...)
    .await
    .map_err(|e| e.to_string())
```

---

## Test Code 추가 및 수정 가이드

### 1. Repository 유닛 테스트 (신규 추가)

#### 테스트 파일 위치

```
src-tauri/src/repositories/
├── message_repository.rs
└── tests/
    ├── mod.rs
    └── message_repository_test.rs
```

#### 테스트 시나리오

**A. Mock을 사용한 유닛 테스트**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::mock;

    // Mock Repository 정의
    mock! {
        pub MessageRepository {}

        #[async_trait]
        impl MessageRepository for MessageRepository {
            async fn get_page(&self, session_id: &str, page: usize, page_size: usize)
                -> Result<Page<Message>, DbError>;
            // ... 나머지 메서드
        }
    }

    #[tokio::test]
    async fn test_get_page_returns_correct_pagination() {
        let mut mock_repo = MockMessageRepository::new();
        mock_repo
            .expect_get_page()
            .with(eq("session-1"), eq(1), eq(10))
            .times(1)
            .returning(|_, _, _| {
                Ok(Page {
                    items: vec![],
                    page: 1,
                    page_size: 10,
                    total_items: 0,
                    has_next_page: false,
                    has_previous_page: false,
                })
            });

        let result = mock_repo.get_page("session-1", 1, 10).await;
        assert!(result.is_ok());
    }
}
```

**B. 실제 DB를 사용한 통합 테스트**

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use sqlx::SqlitePool;

    async fn setup_test_db() -> SqlitePool {
        let pool = SqlitePool::connect("sqlite::memory:").await.unwrap();
        let repo = SqliteMessageRepository::new(pool.clone());
        repo.create_table().await.unwrap();
        pool
    }

    #[tokio::test]
    async fn test_insert_and_get_message() {
        let pool = setup_test_db().await;
        let repo = SqliteMessageRepository::new(pool);

        let message = Message {
            id: "msg-1".to_string(),
            session_id: "session-1".to_string(),
            role: "user".to_string(),
            content: "Hello".to_string(),
            // ... 나머지 필드
        };

        // Insert
        repo.insert(&message).await.unwrap();

        // Get
        let page = repo.get_page("session-1", 1, 10).await.unwrap();
        assert_eq!(page.items.len(), 1);
        assert_eq!(page.items[0].id, "msg-1");
    }
}
```

### 2. 기존 통합 테스트 수정

기존 Commands 통합 테스트는 **수정 불필요**합니다. 이유:

- Commands의 public API (Tauri command 시그니처)는 변경 없음
- 내부 구현만 변경되었으므로 기존 테스트가 그대로 동작

단, 테스트가 실패하면 다음을 확인:

1. DB 초기화 로직이 올바르게 변경되었는지 (`create_table()` 호출)
2. 에러 메시지 형식이 변경되었는지 (DbError → String 변환)

### 3. 성능 테스트 (선택 사항)

```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;

    #[tokio::test]
    async fn test_repository_overhead() {
        let pool = setup_test_db().await;
        let repo = SqliteMessageRepository::new(pool.clone());

        // 1000개 메시지 삽입 시간 측정
        let start = Instant::now();
        for i in 0..1000 {
            let message = create_test_message(i);
            repo.insert(&message).await.unwrap();
        }
        let duration = start.elapsed();

        println!("Repository insert 1000 messages: {:?}", duration);
        assert!(duration.as_secs() < 5); // 5초 이내
    }
}
```

---

## 추가 분석 과제

### 1. Pool Clone 성능 영향 분석

**현상:**

```rust
let repo = SqliteMessageRepository::new(pool.clone());
```

매 호출마다 `pool.clone()`이 발생합니다.

**분석 필요 사항:**

- `SqlitePool`은 내부적으로 `Arc<PoolInner>`이므로 clone이 cheap함
- 하지만 실제 성능 영향을 벤치마크로 측정 필요
- 대안: Tauri State로 Repository를 관리하여 clone 제거

**측정 방법:**

```rust
// 벤치마크 코드
let iterations = 10000;

// Pattern 1: 매번 clone
let start = Instant::now();
for _ in 0..iterations {
    let repo = SqliteMessageRepository::new(pool.clone());
    // use repo
}
let clone_duration = start.elapsed();

// Pattern 2: 한 번만 생성
let start = Instant::now();
let repo = SqliteMessageRepository::new(pool.clone());
for _ in 0..iterations {
    // use same repo
}
let reuse_duration = start.elapsed();

println!("Clone: {:?}, Reuse: {:?}", clone_duration, reuse_duration);
```

### 2. Trait vs Struct 직접 사용

**현재 설계:**

```rust
pub trait MessageRepository { ... }
pub struct SqliteMessageRepository { ... }
```

**분석 필요 사항:**

- Trait을 정의하는 이유: Mock 테스트, 다중 구현체 지원
- 단점: `dyn` 사용 시 dynamic dispatch 오버헤드
- 현재는 Trait을 정의하지만 Commands에서는 concrete type 사용

**대안 검토:**

1. Trait 제거하고 Struct만 사용 (간단함, Mock 어려움)
2. Trait + Struct 유지 (현재 방식, 유연성 높음)
3. Generic + Trait bound (복잡도 증가)

**권장:** Trait + Struct 유지 (테스트 용이성이 더 중요)

### 3. 트랜잭션 처리 개선

**현재 구조:**

```rust
async fn insert_many(&self, messages: Vec<Message>) -> Result<(), DbError> {
    let mut tx = self.pool.begin().await?;
    // ... 여러 쿼리 ...
    tx.commit().await?;
}
```

**분석 필요 사항:**

- 모든 트랜잭션이 Repository 내부에 캡슐화됨
- 만약 여러 Repository 호출을 하나의 트랜잭션으로 묶으려면?
  - 예: MessageRepository + ContentStoreRepository 동시 업데이트

**대안:**

```rust
// Transaction-aware Repository
pub struct SqliteMessageRepository<'a> {
    executor: &'a dyn Executor<'a, Database = Sqlite>,
}

// Pool 또는 Transaction 모두 받을 수 있음
let repo = SqliteMessageRepository::new(&pool);
let repo = SqliteMessageRepository::new(&mut tx);
```

**권장:** 현재는 단순하게 유지, 나중에 필요시 개선

### 4. 에러 타입 세분화

**현재 DbError:**

```rust
pub enum DbError {
    QueryFailed(sqlx::Error),
    NotFound(String),
    InvalidInput(String),
    TransactionFailed(String),
}
```

**분석 필요 사항:**

- `QueryFailed`가 너무 포괄적
- sqlx::Error를 그대로 노출하면 Repository 추상화 목적에 어긋남

**개선 방안:**

```rust
pub enum DbError {
    // 구체적인 에러 타입
    ConnectionFailed(String),
    UniqueConstraintViolation { field: String },
    ForeignKeyViolation { table: String, key: String },
    QueryTimeout,
    NotFound(String),
    InvalidInput(String),
    TransactionFailed(String),
    Unknown(String),
}

impl From<sqlx::Error> for DbError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => DbError::NotFound("Record not found".into()),
            sqlx::Error::Database(db_err) => {
                // SQLite 에러 코드 파싱하여 세분화
                // ...
            }
            _ => DbError::Unknown(err.to_string()),
        }
    }
}
```

**권장:** 일단 현재대로 진행, 실제 사용하면서 필요한 에러 타입 추가

---

## 작업 순서 및 체크리스트

### Phase 1: Repository 기반 작성

- [ ] `repositories/error.rs` - DbError 타입 정의
- [ ] `repositories/mod.rs` - 모듈 export
- [ ] `repositories/message_repository.rs` - Trait + Impl
- [ ] `repositories/content_store_repository.rs` - Trait + Impl
- [ ] `repositories/session_repository.rs` - Trait + Impl
- [ ] `cargo check` 통과 확인

### Phase 2: Commands 레이어 수정

- [ ] `commands/messages_commands.rs` - db:: 모듈 제거, Repository 사용
  - [ ] Tauri commands 5개 수정
  - [ ] `get_or_build_index()` 내부 로직 수정
- [ ] `commands/content_store_commands.rs` - Repository 사용
- [ ] `commands/session_commands.rs` - Repository 사용
- [ ] `cargo check` 통과 확인

### Phase 3: 외부 호출 지점 수정

- [ ] `lib.rs` - Repository 사용
- [ ] `search/background_worker.rs` - Repository 사용
- [ ] `cargo check` 통과 확인

### Phase 4: 테스트 및 검증

- [ ] `cargo clippy` 통과
- [ ] `pnpm refactor:validate` 통과
- [ ] 기존 통합 테스트 실행
- [ ] Repository 유닛 테스트 추가 (선택)
- [ ] 성능 테스트 (선택)

### Phase 5: 문서화

- [ ] Repository 사용 가이드 작성 (README)
- [ ] API 문서 업데이트 (rustdoc)
- [ ] 아키텍처 다이어그램 업데이트

---

## 예상 소요 시간

| Phase    | 작업                | 예상 시간 |
| -------- | ------------------- | --------- |
| Phase 1  | Repository 구현     | 1시간     |
| Phase 2  | Commands 수정       | 1시간     |
| Phase 3  | 외부 호출 지점 수정 | 30분      |
| Phase 4  | 테스트 및 검증      | 1시간     |
| Phase 5  | 문서화              | 30분      |
| **총계** | **전체 작업**       | **4시간** |

---

## 리스크 및 대응 방안

### 리스크 1: 트랜잭션 처리 누락

- **영향도**: 높음 (데이터 일관성 문제)
- **대응**: `insert_many()` 구현 시 트랜잭션 확인 철저히
- **검증**: 다중 메시지 저장 테스트 추가

### 리스크 2: 에러 변환 누락

- **영향도**: 중간 (컴파일 에러 발생)
- **대응**: `.map_err(|e| e.to_string())` 패턴 일관되게 적용
- **검증**: `cargo check`로 확인

### 리스크 3: Pool Clone 성능 저하

- **영향도**: 낮음 (SqlitePool은 Arc 기반)
- **대응**: 벤치마크로 측정, 문제 시 Tauri State로 변경
- **검증**: 성능 테스트 추가

### 리스크 4: 기존 테스트 실패

- **영향도**: 중간
- **대응**: 테스트 실패 시 디버깅하여 원인 파악
- **검증**: 모든 테스트 실행

---

## 참고 자료

### Rust Repository Pattern

- https://www.lpalmieri.com/posts/2020-08-09-zero-to-production-3-5-html-forms-databases-integration-tests/
- https://github.com/actix/actix-web/tree/master/examples

### SQLx Best Practices

- https://github.com/launchbadge/sqlx/blob/main/FAQ.md
- https://docs.rs/sqlx/latest/sqlx/

### Tauri State Management

- https://tauri.app/v1/guides/features/command/#accessing-managed-state
- https://docs.rs/tauri/latest/tauri/struct.State.html

### Async Trait

- https://docs.rs/async-trait/latest/async_trait/
- https://rust-lang.github.io/async-book/

---

## 결론

이 리팩토링은 **난이도 3/10의 낮은 복잡도**로 **약 4시간 내**에 완료 가능하며, 다음과 같은 이점을 제공합니다:

1. ✅ **명확한 레이어 분리**: Commands ↔ Repository ↔ SQLx
2. ✅ **테스트 용이성**: Mock을 통한 유닛 테스트 가능
3. ✅ **유지보수성 향상**: DB 로직 중앙 집중화
4. ✅ **타입 안전성**: 구조화된 에러 타입
5. ✅ **확장성**: 다른 DB 추가 시 Repository만 구현

작업자는 이 문서를 참고하여 단계별로 진행하되, 상황에 따라 유연하게 조정할 수 있습니다.
