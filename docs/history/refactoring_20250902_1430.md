# Built-in Tools Prefix 안전성 개선 Refactoring Plan

## 작업의 목적

Built-in Tools의 prefix 처리 방식을 `builtin.`에서 `builtin_`로 변경하고, substring 대체 방식의 안전성 문제를 해결하여 tool name 처리의 신뢰성을 향상시킨다.

## 현재의 상태 / 문제점

### 1. Prefix 관련 문제

- **현재 prefix**: `builtin.` (dot 포함)
- **현재 제거 방식**: `replace(BUILTIN_PREFIX, '')` 사용
- **문제**: tool name 중간이나 끝에 `builtin.` 문자열이 있으면 의도하지 않게 제거됨
- **예시**: `some_builtin.tool_name` → `some_tool_name` (잘못된 결과)

### 2. 코드 위치별 문제

```tsx
// 1. 상수 정의 (라인 38)
const BUILTIN_PREFIX = 'builtin.';

// 2. Tool 이름 생성 (라인 96) - 안전함
name: `${BUILTIN_PREFIX}${alias}__${t.name}`,

// 3. Tool 실행 시 prefix 제거 (라인 188) - 문제 있음
strippedToolName = toolcall.function.name.replace(BUILTIN_PREFIX, '');

// 4. 사용자 안내 메시지 (라인 239) - 업데이트 필요
"builtin.file_read" 예시 사용
```

### 3. 구체적 위험 시나리오

- Tool name에 `builtin.`이 포함된 경우 (예: `custom_builtin.helper`)
- 중복 prefix 처리 시 예상치 못한 결과 발생
- AI 서비스별 tool name 규칙 준수 문제

## 추가 분석 과제

1. **AI 서비스 호환성 검증**
   - 각 AI 서비스(OpenAI, Anthropic 등)의 tool name 규칙 확인
   - `builtin_` prefix 사용 시 제약사항 조사

2. **기존 데이터 마이그레이션**
   - 현재 사용 중인 tool call 로그나 설정에서 `builtin.` 사용 여부 확인
   - 하위 호환성 필요 여부 판단

3. **연관 컴포넌트 영향도 분석**
   - Tool call을 사용하는 다른 컴포넌트에서의 prefix 의존성 조사
   - System prompt 생성 로직의 영향 범위 확인

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **Prefix 통일**: 모든 builtin tool이 `builtin_` prefix 사용
2. **안전한 제거**: `startsWith()` + `slice()` 방식으로 정확한 prefix 제거
3. **일관성**: 코드, 문서, 사용자 안내 메시지 모두 일관된 prefix 사용

### 해결 판정 기준

- [ ] `replace()` 방식 완전 제거
- [ ] `startsWith()` + `slice()` 방식으로 변경 완료
- [ ] 모든 관련 문서/메시지에서 `builtin_` 사용
- [ ] Tool name 중간에 동일 문자열 포함 시에도 정상 동작
- [ ] 기존 기능 유지 (regression 없음)

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 상수 정의 변경

**파일**: `src/features/tools/index.tsx:38`

```tsx
// 현재
const BUILTIN_PREFIX = 'builtin.';

// 변경 후
const BUILTIN_PREFIX = 'builtin_';
```

### 2. Tool 실행 로직 개선

**파일**: `src/features/tools/index.tsx:182-189`

```tsx
// 현재 (문제 있음)
const executeTool = useCallback(async (toolcall: ToolCall) => {
  let strippedToolName;
  if (!toolcall.function.name.startsWith(BUILTIN_PREFIX)) {
    strippedToolName = toolcall.function.name;
    logger.warn('tool call does not have builtin prefix', { toolcall });
  } else {
    strippedToolName = toolcall.function.name.replace(BUILTIN_PREFIX, '');
  }

// 변경 후 (안전함)
const executeTool = useCallback(async (toolcall: ToolCall) => {
  let strippedToolName;
  if (!toolcall.function.name.startsWith(BUILTIN_PREFIX)) {
    strippedToolName = toolcall.function.name;
    logger.warn('tool call does not have builtin prefix', { toolcall });
  } else {
    strippedToolName = toolcall.function.name.slice(BUILTIN_PREFIX.length);
  }
```

### 3. 사용자 안내 메시지 업데이트

**파일**: `src/features/tools/index.tsx:239`

```tsx
// 현재
**Important Instruction:** When calling built-in tools, you MUST use the tool name exactly as it appears in the available tools list. Do not add or remove the "builtin." prefix - use it "as is" (e.g., if the tool name is "builtin.file_read", call it as "builtin.file_read", not "file_read" or "builtin.builtin.file_read").

// 변경 후
**Important Instruction:** When calling built-in tools, you MUST use the tool name exactly as it appears in the available tools list. Do not add or remove the "builtin_" prefix - use it "as is" (e.g., if the tool name is "builtin_file_read", call it as "builtin_file_read", not "file_read" or "builtin_builtin_file_read").
```

## 재사용 가능한 연관 코드

### 주요 파일 및 기능

1. **`src/features/tools/index.tsx`**
   - Built-in Tool Provider 메인 로직
   - Tool 등록/해제, 실행, 프롬프트 생성
   - 인터페이스: `BuiltInToolContextType`, `BuiltInService`

2. **`src/lib/mcp-types.ts`**
   - MCP Tool 타입 정의
   - `MCPTool`, `MCPResponse` 인터페이스

3. **`src/models/chat.ts`**
   - Tool Call 모델 정의
   - `ToolCall` 인터페이스

4. **`src/lib/utils.ts`**
   - `toValidJsName()` 함수 (alias 생성용)

### 관련 Hook 및 Context

- `useSystemPrompt()`: System prompt 등록/해제
- `useSessionContext()`: 현재 세션 정보 제공
- `useBuiltInTool()`: Built-in tool 사용 hook

### 테스트 고려사항

- Tool name 생성 로직 테스트
- Prefix 제거 로직 단위 테스트
- Integration 테스트 (전체 tool call 플로우)

## 작업 순서 제안

1. **Phase 1**: 상수 및 핵심 로직 변경
   - `BUILTIN_PREFIX` 값 변경
   - `replace()` → `slice()` 로직 변경

2. **Phase 2**: 문서 및 메시지 업데이트
   - 사용자 안내 메시지 수정
   - 관련 문서 업데이트

3. **Phase 3**: 검증 및 테스트
   - 기능 테스트 수행
   - Edge case 검증
   - 성능 영향 확인
