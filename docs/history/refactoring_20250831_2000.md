# Refactoring Plan: Filesystem 도구 개선

## 작업의 목적

`builtin.filesystem` 모듈의 도구들을 개선하여 사용자 경험과 기능성을 향상시키는 것. 구체적으로:

1. `replace_lines_in_file` 도구에 범위 교체 기능 추가 (`start_line`, `end_line` 지원)
2. `write_file` 도구에 파일 쓰기 모드 지원 추가 (덮어쓰기/추가 모드)
3. 도구 사용의 직관성과 효율성 향상

## 현재의 상태 / 문제점

### 1. `replace_lines_in_file` 도구의 제한적 파라미터 지원

- 현재: `line_number`만 지원하여 단일 줄 교체만 가능
- 문제: 범위 교체(여러 줄)를 위해서는 별도의 로직 필요
- 영향: 사용자 혼동 및 비효율적 사용

### 2. `write_file` 도구의 기능 부족

- 현재: 파일 덮어쓰기만 지원
- 문제: 파일 끝에 내용 추가(append) 기능 부재
- 영향: append 작업 시 전체 파일 읽기-수정-쓰기 우회 필요

### 3. 도구 명세와 실제 구현 불일치 가능성

- 외부 문서나 커뮤니티에서 잘못된 파라미터 설명 유포 가능성
- 사용자 혼동 및 오류 발생

## 추가 분석 과제

- 기존 사용자 코드와의 호환성 검토 (breaking change 방지)
- 성능 영향 분석 (범위 교체 시 메모리 사용량)
- 보안 검토 (새로운 파라미터의 입력 검증)

## 변경 이후의 상태 / 해결 판정 기준

### 성공 판정 기준

1. `replace_lines_in_file`이 `start_line`, `end_line` 파라미터를 지원
2. `write_file`이 `mode` 파라미터로 append 기능 지원
3. 기존 `line_number` 방식과의 호환성 유지
4. 도구 설명과 구현이 일치
5. 단위 테스트 통과 및 통합 테스트 성공

### 변경 후 상태

- `replace_lines_in_file`: 범위 및 단일 줄 교체 모두 지원
- `write_file`: overwrite/append 모드 선택 가능
- API 일관성 향상 및 사용자 경험 개선

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. `filesystem.rs` - 도구 스키마 및 핸들러 수정

#### `create_replace_lines_in_file_tool()` 수정

```rust
fn create_replace_lines_in_file_tool() -> MCPTool {
    let mut item_props = HashMap::new();
    item_props.insert("start_line".to_string(), integer_prop(Some(1), None, Some("Starting line number (1-based)")));
    item_props.insert("end_line".to_string(), integer_prop(Some(1), None, Some("Ending line number (1-based, optional). If not provided, equals start_line")));
    item_props.insert("content".to_string(), string_prop(None, None, Some("The new content for the line range")));

    // 기존 line_number 지원을 위한 backward compatibility
    item_props.insert("line_number".to_string(), integer_prop(Some(1), None, Some("The 1-based line number to replace (deprecated, use start_line)")));

    let replacement_item_schema = object_schema(item_props, vec!["start_line".to_string(), "content".to_string()]);
    // ... 나머지 동일
}
```

#### `handle_replace_lines_in_file()` 수정

```rust
for rep in replacements {
    let start_line = match rep.get("start_line").and_then(|v| v.as_u64()) {
        Some(num) => num as usize,
        None => {
            // backward compatibility: line_number fallback
            match rep.get("line_number").and_then(|v| v.as_u64()) {
                Some(num) => num as usize,
                None => return MCPResponse::error(request_id, -32602, "Missing start_line or line_number"),
            }
        }
    };

    let end_line = rep.get("end_line")
        .and_then(|v| v.as_u64())
        .map(|n| n as usize)
        .unwrap_or(start_line); // 기본값: start_line과 동일

    // 범위 검증
    if start_line > end_line {
        return MCPResponse::error(request_id, -32602, "start_line must be <= end_line");
    }

    // 범위 교체 로직 구현
    // ... (기존 단일 줄 교체 로직 확장)
}
```

#### `create_write_file_tool()` 수정

```rust
fn create_write_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert("path".to_string(), string_prop(Some(1), Some(1000), Some("Path to the file to write")));
    props.insert("content".to_string(), string_prop(None, Some(MAX_FILE_SIZE as u32), Some("Content to write to the file")));
    props.insert("mode".to_string(), string_prop(None, None, Some("Write mode: 'w' for overwrite (default), 'a' for append")));

    MCPTool {
        name: "write_file".to_string(),
        title: Some("Write File".to_string()),
        description: "Write content to a file with optional append mode".to_string(),
        input_schema: object_schema(props, vec!["path".to_string(), "content".to_string()]),
        output_schema: None,
        annotations: None,
    }
}
```

#### `handle_write_file()` 수정

```rust
let mode = args.get("mode")
    .and_then(|v| v.as_str())
    .unwrap_or("w");

match mode {
    "w" => {
        // 기존 덮어쓰기 로직
        self.file_manager.write_file_string(path_str, content).await
    },
    "a" => {
        // 새로 구현할 append 로직
        self.append_to_file(path_str, content).await
    },
    _ => {
        return MCPResponse::error(request_id, -32602, "Invalid mode. Use 'w' or 'a'");
    }
}
```

### 2. `secure_file_manager.rs` - append 기능 추가

#### 새 메서드 추가

```rust
pub async fn append_file_string(&self, path: &str, content: &str) -> Result<(), String> {
    let safe_path = self
        .security
        .validate_path(path)
        .map_err(|e| format!("Security error: {e}"))?;

    // 파일이 존재하지 않으면 생성
    if !safe_path.exists() {
        return self.write_file_string(path, content);
    }

    // 기존 파일 열기 및 내용 추가
    use tokio::io::AsyncWriteExt;
    let mut file = tokio::fs::OpenOptions::new()
        .append(true)
        .open(&safe_path)
        .await
        .map_err(|e| format!("Failed to open file for append: {e}"))?;

    file.write_all(content.as_bytes())
        .await
        .map_err(|e| format!("Failed to append to file: {e}"))?;

    info!("Successfully appended to file: {:?}", safe_path);
    Ok(())
}
```

## 재사용 가능한 연관 코드

### 파일 경로

- `src-tauri/src/mcp/builtin/filesystem.rs` - 메인 도구 구현
- `src-tauri/src/services/secure_file_manager.rs` - 파일 I/O 로직
- `src-tauri/src/mcp/builtin/utils/` - 스키마 빌더 유틸리티

### 주요 기능

- `FilesystemServer::create_*_tool()` - 도구 스키마 생성
- `FilesystemServer::handle_*()` - 도구 실행 핸들러
- `SecureFileManager::*` - 안전한 파일 I/O

### 인터페이스

- `MCPTool` 구조체 - 도구 정의
- `MCPResponse` - 응답 포맷
- `BuiltinMCPServer` 트레이트 - 서버 인터페이스

## 구현 순서

1. `secure_file_manager.rs`에 append 기능 추가
2. `filesystem.rs`의 `write_file` 도구에 mode 파라미터 지원
3. `filesystem.rs`의 `replace_lines_in_file` 도구에 범위 지원
4. 단위 테스트 작성 및 검증
5. 통합 테스트 수행
6. 문서 업데이트

## 위험 요소 및 완화 방안

- **호환성 문제**: 기존 `line_number` 방식 유지로 완화
- **성능 저하**: 범위 교체 시 메모리 사용량 모니터링
- **보안**: 입력 검증 강화

## 예상 완료 시간

- 개발: 4-6시간
- 테스트: 2-3시간
- 검토: 1-2시간

총: 7-11시간
