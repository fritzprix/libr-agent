# CSS Selector 생성 개선 및 DOM 파싱 최적화 리팩토링 계획

## 작업의 목적

HTML 파싱 시스템에서 **정확하고 고유한 CSS selector 생성**과 **노드 누락 최소화**를 통해 브라우저 자동화 도구들의 신뢰성을 향상시킵니다. 현재 단순한 selector 생성 방식으로 인한 요소 식별 실패와 중복 selector 문제를 해결하여, 브라우저 도구들이 정확한 DOM 요소에 접근할 수 있도록 합니다.

## 현재의 상태 / 문제점

### 1. CSS Selector 생성의 한계

- **단순한 selector 구성**: ID → 첫 번째 유효한 클래스 → 태그명 순서로만 생성
- **형제 요소 구분 불가**: `div:nth-child(3)` 같은 인덱스 정보 없음
- **계층 구조 무시**: `body > main > section > div` 같은 전체 경로 누락
- **중복 가능성**: 동일한 클래스/태그를 가진 요소들이 같은 selector를 가짐

### 2. ParsedElement와 DOMMapNode 간 기능 차이

- **ParsedElement**: selector 필드 없음 → CSS selector 구성 불가
- **DOMMapNode**: selector 필드 있음 → 브라우저 도구에 적합
- **목적과 사용 형태 불일치**: 콘텐츠 분석용과 DOM 조작용이 혼재

### 3. 노드 누락 요인들

- **제외 태그/클래스 필터링**: 일부 중요한 요소들이 제외될 가능성
- **깊이/자식 수 제한**: maxDepth(5-10), maxChildren(20) 제한으로 하위 노드 누락
- **유효성 검증 로직**: 텍스트나 자식이 없는 요소들이 필터링됨

### 4. 브라우저 도구와의 연동 문제

- 브라우저 도구들이 `document.querySelector(selector)` 직접 사용
- 부정확한 selector로 인한 요소 찾기 실패 또는 잘못된 요소 선택

## 추가 분석 과제

### 1. Selector 정확도 벤치마킹

- 현재 `generateSelector` 함수의 고유성 테스트
- 실제 웹페이지에서 중복 selector 발생 빈도 측정
- 계층적 selector vs 단순 selector 성능 비교

### 2. 필터링 로직 영향 분석

- 현재 제외 규칙들이 실제로 필요한 요소를 누락시키는지 검증
- Interactive 요소 판별 로직의 정확성 검증
- maxDepth, maxChildren 제한의 적절성 평가

### 3. 브라우저 도구 사용 패턴 분석

- 각 브라우저 도구에서 실제로 사용하는 selector 패턴 조사
- 실패하는 selector 케이스들의 공통 특징 분석

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **고유성 보장**: 동일한 웹페이지 내에서 생성되는 모든 selector가 고유함
2. **정확성 향상**: `querySelector(selector)`로 의도한 요소를 정확히 찾을 수 있음
3. **노드 누락 최소화**: 중요한 Interactive 요소들이 누락되지 않음
4. **브라우저 도구 성공률 향상**: FindElement, ClickElement 등의 성공률 개선

### 측정 가능한 지표

- Selector 고유성: 중복 selector 발생률 < 1%
- 요소 찾기 정확도: querySelector 성공률 > 95%
- 성능: Selector 생성 시간 증가 < 50ms
- 브라우저 도구 성공률: 기존 대비 20% 이상 향상

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. CSS Selector 생성 함수 개선

**파일**: `src/lib/html-parser.ts` (라인 459-474)

**현재 코드**:

```typescript
function generateSelector(element: Element): string {
  const id = element.getAttribute('id');
  if (id && isValidCSSIdentifier(id)) {
    return '#' + id;
  }

  const className = element.getAttribute('class');
  if (className?.trim()) {
    const classes = className.trim().split(/\s+/);
    const validClass = classes.find((cls) => isValidCSSIdentifier(cls));
    if (validClass) {
      return '.' + validClass;
    }
  }

  return element.tagName.toLowerCase();
}
```

**수정 방향**:

```typescript
// 계층적 selector 생성 함수 추가
function generateFullSelector(element: Element, doc: Document): string;
function generateElementSelectorWithIndex(element: Element): string;
function ensureSelectorUniqueness(
  selector: string,
  element: Element,
  doc: Document,
): string;
```

### 2. ParsedElement에 selector 필드 추가

**파일**: `src/lib/html-parser.ts` (라인 6-15)

**현재 코드**:

```typescript
export interface ParsedElement {
  tag: string;
  text?: string;
  id?: string;
  class?: string;
  href?: string;
  src?: string;
  alt?: string;
  title?: string;
  children: ParsedElement[];
}
```

**수정 방향**:

```typescript
export interface ParsedElement {
  tag: string;
  selector: string; // 추가
  fullPath?: string; // 선택적 추가
  siblingIndex?: number; // 선택적 추가
  // ... 기존 필드들
}
```

### 3. StructuredParsePipeline 업데이트

**파일**: `src/lib/html-parser.ts` (라인 537-544)

**현재 코드**:

```typescript
createBaseResult(element: Element): ParsedElement {
  return {
    tag: element.tagName.toLowerCase(),
    children: [],
  };
}
```

**수정 방향**:

```typescript
createBaseResult(element: Element): ParsedElement {
  return {
    tag: element.tagName.toLowerCase(),
    selector: this.generateSelector(element, this.document), // 추가
    children: [],
  };
}
```

## 재사용 가능한 연관 코드

### 핵심 파일들

- **`src/lib/html-parser.ts`**: 메인 파싱 로직, 인터페이스 정의
- **`src/features/tools/browser-tools/helpers.ts`**: 브라우저 도구 공통 헬퍼 함수들
- **`src/features/tools/browser-tools/FindElementTool.ts`**: 요소 찾기 도구
- **`src/features/tools/browser-tools/ClickElementTool.ts`**: 요소 클릭 도구

### 주요 기능 및 인터페이스

```typescript
// 현재 사용 중인 주요 인터페이스들
interface ParsePipeline<T, O> {
  createBaseResult(element: Element): T;
  extractAttributes(context: ParseContext<T, O>): void;
}

// 브라우저 도구에서 사용하는 패턴
const elementState = await checkElementState(
  executeScript,
  sessionId,
  selector,
  action,
);
const el = document.querySelector(selector);
```

### 유틸리티 함수들

- **`isValidCSSIdentifier(str: string)`**: CSS 식별자 유효성 검증
- **`ElementValidator.validateForParsing()`**: 요소 파싱 유효성 검증
- **`extractTextContent()`**: 텍스트 추출 로직
- **`ChildElementProcessor.getFilteredChildElements()`**: 자식 요소 필터링

### 설정 상수들

```typescript
const DEFAULT_PARSE_OPTIONS: Required<ParseOptions>;
const DEFAULT_DOM_MAP_OPTIONS: Required<DOMMapOptions>;
const EXCLUDE_TAGS, EXCLUDE_CLASSES, INTERACTIVE_TAGS, MEANINGFUL_ELEMENTS;
```

### 브라우저 도구 스키마

```typescript
// src/features/tools/browser-tools/helpers.ts
const BROWSER_TOOL_SCHEMAS = {
  sessionId: { type: 'string', description: 'Browser session ID' },
  selector: { type: 'string', description: 'CSS selector for target element' },
};
```

## 구현 순서 권장사항

1. **CSS Selector 생성 로직 개선** (우선순위: 높음)
2. **ParsedElement 인터페이스 확장** (우선순위: 높음)
3. **파싱 파이프라인 업데이트** (우선순위: 중간)
4. **필터링 로직 최적화** (우선순위: 중간)
5. **성능 테스트 및 벤치마킹** (우선순위: 낮음)

## 호환성 고려사항

- 기존 ParsedElement를 사용하는 코드들과의 하위 호환성 유지
- DOMMapNode와 ParsedElement 간의 일관성 확보
- 브라우저 도구들의 기존 동작 방식 보존
