# Refactoring Plan: Wait UI Tools (극단적 단순화)

**Date**: 2025-10-11 17:00  
**Author**: AI Agent  
**Version**: 1.0

## 작업의 목적

오래 걸리는 비동기 작업(예: shell command 실행) 실행 시 사용자에게
대기 애니메이션과 "계속" 버튼을 제공하여, 사용자가 명시적으로
버튼을 눌러 작업을 재개할 수 있도록 한다.

**핵심 원칙**:

- 극단적 단순성: waitId, 세션 관리, action 구분 없음
- 상태 비저장: 모든 정보는 UIResource에 embedded
- Non-blocking: UIResource 포함 메시지는 자동 submit 안 됨
- 2개 도구만: `wait_for_user_resume`, `resume_from_wait`

## 현재의 상태 / 문제점

### 현재 ui-tools.ts 구조

- 3개 도구 제공: `prompt_user`, `reply_prompt`, `visualize_data`
- 모든 도구는 즉각적인 사용자 입력/시각화 목적
- **부재**: 긴 작업 대기 중 사용자 확인 UI 없음

### 문제점

1. 긴 작업 실행 시 사용자는 응답 없는 상태로 대기
2. 작업 진행 상태가 불명확
3. 사용자가 작업 흐름을 제어할 수 없음

## 관련 코드의 구조 및 동작 방식 Summary

### ui-tools.ts 아키텍처

```text
WebMCPServer 'ui'
├── tools: MCPTool[] (3개 도구)
├── callTool(name, args) → MCPResponse
│   ├── 입력 검증
│   ├── HTML 생성 (build*Html)
│   ├── UIResource 생성 (createUiResourceFromHtml)
│   └── multipart 응답
└── activePrompts: Map<string, PromptState>
```

### 핵심 패턴

- HTML 생성: `build*Html()` → escaped HTML string
- UIResource 생성: `createUiResourceFromHtml(html, uri)`
- postMessage 통신: UI → parent → tool 호출
- 응답 형식: text + uiResource (multipart)

### 재사용 가능한 코드

- `escapeHtml(s: string)`: XSS 방지
- `createUiResourceFromHtml(html, uri)`: UIResource + serviceInfo
- `createMCPStructuredMultipartResponse()`: multipart 응답
- `nextMessageId`: 유니크 ID 생성

### ChatContext와의 통합

- UIResource 포함 메시지는 **자동 submit되지 않음**
- postMessage → tool 호출 → 응답은 별도 경로로 처리
- 따라서 별도 wait/blocking 로직 불필요

## 변경 이후의 상태 / 해결 판정 기준

### 변경 후 상태

- 2개 새 도구 추가: `wait_for_user_resume`, `resume_from_wait`
- 사용자는 spinner + "계속" 버튼이 있는 UI 확인
- 버튼 클릭 → `resume_from_wait` 호출 → agent가 컨텍스트 받음

### 해결 판정 기준

1. **기능**: 두 도구가 정상 동작
2. **UI**: spinner, 메시지, "계속" 버튼 표시
3. **컨텍스트**: agent가 재개 시 충분한 정보 수신
4. **테스트**: 도구 lifecycle, HTML 생성, postMessage 테스트 통과

## 수정이 필요한 코드 및 수정 부분

### 1. 타입 정의 추가 (파일 상단)

```typescript
// Wait context type (구조화된 정보)
interface WaitContext {
  startedAt: string; // ISO 8601 timestamp (서버가 자동 생성)
  reason: string; // 대기 이유
  command: string; // 실행 중인 명령/작업
  nextAction: string; // 재개 후 수행할 동작
}
```

### 2. Helper 함수 추가

```typescript
/**
 * Format duration in human-readable format
 */
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) return `${hours}h ${minutes % 60}m`;
  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
  return `${seconds}s`;
}

/**
 * Generate HTML for wait UI
 */
function buildWaitHtml(message: string, context: WaitContext): string {
  const escapedMessage = escapeHtml(message);
  const escapedContext = escapeHtml(JSON.stringify(context));

  return `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 16px;
      background: #f9fafb;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    .wait-container {
      max-width: 500px;
      background: white;
      border-radius: 8px;
      padding: 32px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      text-align: center;
    }
    .spinner {
      font-size: 48px;
      margin-bottom: 16px;
      animation: spin 2s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @media (prefers-reduced-motion: reduce) {
      .spinner { animation: none; }
    }
    .message {
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 24px;
    }
    .btn-continue {
      padding: 12px 24px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-continue:hover {
      background: #2563eb;
    }
    .btn-continue:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
    }
  </style>
</head>
<body>
  <div class="wait-container" role="dialog" aria-modal="true"
       aria-labelledby="wait-message">
    <div class="spinner" aria-hidden="true">⏳</div>
    <div id="wait-message" class="message">${escapedMessage}</div>
    <button class="btn-continue" onclick="handleContinue()" autofocus>
      계속
    </button>
  </div>
  <script>
    const context = ${escapedContext};

    function handleContinue() {
      window.parent.postMessage({
        type: 'tool',
        payload: {
          toolName: 'resume_from_wait',
          params: { context }
        }
      }, '*');
    }

    // Keyboard support
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        handleContinue();
      }
    });
  </script>
</body>
</html>`;
}
```

### 3. 도구 정의 추가 (tools 배열)

```typescript
const tools: MCPTool[] = [
  // ... 기존 도구들 ...

  {
    name: 'wait_for_user_resume',
    description: 'Display wait UI with continue button for long operations',
    inputSchema: {
      type: 'object',
      properties: {
        message: {
          type: 'string',
          description: 'Message to display to user',
        },
        context: {
          type: 'object',
          properties: {
            reason: {
              type: 'string',
              description: 'Why waiting (for agent context)',
            },
            command: {
              type: 'string',
              description: 'Command or task being executed',
            },
            nextAction: {
              type: 'string',
              description: 'What to do after resume',
            },
          },
          required: ['reason', 'command', 'nextAction'],
        },
      },
      required: ['message', 'context'],
    },
  },

  {
    name: 'resume_from_wait',
    description: 'Resume from wait (called by UI button click)',
    inputSchema: {
      type: 'object',
      properties: {
        context: {
          type: 'object',
          properties: {
            startedAt: { type: 'string' },
            reason: { type: 'string' },
            command: { type: 'string' },
            nextAction: { type: 'string' },
          },
          required: ['startedAt', 'reason', 'command', 'nextAction'],
        },
        sessionId: {
          type: 'string',
          description: 'Optional session ID for validation',
        },
      },
      required: ['context'],
    },
  },
];
```

### 4. callTool 핸들러 추가 (switch문에 case 추가)

```typescript
async callTool(name: string, args: unknown): Promise<MCPResponse<unknown>> {
  const a = (args || {}) as Record<string, unknown>;

  try {
    switch (name) {
      // ... 기존 케이스들 ...

      case 'wait_for_user_resume': {
        const message = String(a.message || '');
        const contextInput = a.context as Omit<WaitContext, 'startedAt'>;

        if (!message) {
          return createMCPTextResponse('Message is required');
        }

        if (!contextInput || !contextInput.reason ||
            !contextInput.command || !contextInput.nextAction) {
          return createMCPTextResponse(
            'Context with reason, command, nextAction required'
          );
        }

        // Add startedAt timestamp
        const context: WaitContext = {
          ...contextInput,
          startedAt: new Date().toISOString()
        };

        // Generate HTML
        const html = buildWaitHtml(message, context);
        const uri = `ui://wait/${Date.now()}` as `ui://${string}`;
        const uiResource = createUiResourceFromHtml(html, uri);

        // Text content
        const textContent: MCPContent = {
          type: 'text',
          text: `⏳ Waiting: ${message}\nReason: ${context.reason}`
        } as MCPContent;

        // Return multipart
        return createMCPStructuredMultipartResponse(
          [textContent, uiResource],
          { waiting: true, context }
        );
      }

      case 'resume_from_wait': {
        const context = a.context as WaitContext;

        if (!context || !context.startedAt) {
          return createMCPTextResponse('Valid context required');
        }

        // Calculate duration
        const startedAt = new Date(context.startedAt);
        const resumedAt = new Date();
        const duration = formatDuration(
          resumedAt.getTime() - startedAt.getTime()
        );

        // Build agent-friendly text response
        const text = [
          `✅ User resumed after waiting ${duration}`,
          '',
          `What was waiting: ${context.reason}`,
          `Command/Task: ${context.command}`,
          `Started: ${context.startedAt}`,
          `Ended: ${resumedAt.toISOString()}`,
          '',
          `Next action: ${context.nextAction}`
        ].join('\n');

        return createMCPStructuredResponse(text, {
          resumed: true,
          duration,
          ...context,
          resumedAt: resumedAt.toISOString()
        });
      }

      default:
        return createMCPTextResponse(`Unknown tool: ${name}`);
    }
  } catch (err) {
    return createMCPTextResponse(
      `Error in ui-tools: ${err instanceof Error ? err.message : String(err)}`
    );
  }
}
```

## 재사용 가능한 연관 코드

### 기존 ui-tools.ts 패턴

- **파일**: `src/lib/web-mcp/modules/ui-tools.ts`
- **패턴**:
  - `escapeHtml`: XSS 방지
  - `createUiResourceFromHtml`: UIResource 생성
  - postMessage 통신 패턴
  - multipart 응답 생성
- **인터페이스**:
  - `MCPTool`, `MCPResponse`, `MCPContent`, `UIResource`
  - `WebMCPServer`

### MCP 응답 유틸리티

- **파일**: `src/lib/mcp-response-utils.ts`
- **함수**:
  - `createMCPTextResponse(text)`
  - `createMCPStructuredResponse(text, data)`
  - `createMCPStructuredMultipartResponse(contents, data)`

### @mcp-ui/server

- **패키지**: `@mcp-ui/server`
- **함수**: `createUIResource({ uri, content, encoding })`

## Test Code 추가 및 수정 필요 부분

### 1. Unit Tests: 도구 기본 동작

**파일**: `src/lib/web-mcp/modules/__tests__/ui-tools.test.ts`

**테스트 케이스**:

```typescript
describe('wait_for_user_resume tool', () => {
  test('returns multipart response with text and uiResource', async () => {
    const response = await uiTools.callTool('wait_for_user_resume', {
      message: 'Testing wait',
      context: {
        reason: 'Test reason',
        command: 'test command',
        nextAction: 'test next',
      },
    });

    expect(response.content).toHaveLength(2);
    expect(response.content[0].type).toBe('text');
    expect(response.content[1].type).toBe('resource');
  });

  test('automatically adds startedAt timestamp', async () => {
    const before = new Date().toISOString();
    const response = await uiTools.callTool('wait_for_user_resume', {
      message: 'Test',
      context: {
        reason: 'Test',
        command: 'test',
        nextAction: 'test',
      },
    });
    const after = new Date().toISOString();

    const metadata = response.metadata as { context: WaitContext };
    expect(metadata.context.startedAt).toBeDefined();
    expect(metadata.context.startedAt >= before).toBe(true);
    expect(metadata.context.startedAt <= after).toBe(true);
  });

  test('rejects invalid context', async () => {
    const response = await uiTools.callTool('wait_for_user_resume', {
      message: 'Test',
      context: { reason: 'Test' }, // incomplete
    });

    expect(response.content[0].text).toContain('required');
  });
});

describe('resume_from_wait tool', () => {
  test('returns formatted agent message', async () => {
    const context = {
      startedAt: '2025-10-11T17:00:00Z',
      reason: 'Test wait',
      command: 'npm install',
      nextAction: 'Continue deployment',
    };

    const response = await uiTools.callTool('resume_from_wait', {
      context,
    });

    expect(response.content[0].text).toContain('✅ User resumed');
    expect(response.content[0].text).toContain('Test wait');
    expect(response.content[0].text).toContain('npm install');
    expect(response.content[0].text).toContain('Continue deployment');
  });

  test('calculates duration correctly', async () => {
    const startedAt = new Date(Date.now() - 65000).toISOString();
    const response = await uiTools.callTool('resume_from_wait', {
      context: {
        startedAt,
        reason: 'Test',
        command: 'test',
        nextAction: 'test',
      },
    });

    expect(response.content[0].text).toMatch(/1m \d+s/);
  });
});
```

### 2. Integration Tests: HTML 생성

```typescript
test('buildWaitHtml generates valid HTML', () => {
  const html = buildWaitHtml('Test message', {
    startedAt: '2025-10-11T17:00:00Z',
    reason: 'Test',
    command: 'test cmd',
    nextAction: 'next',
  });

  expect(html).toContain('<!doctype html>');
  expect(html).toContain('Test message');
  expect(html).toContain('role="dialog"');
  expect(html).toContain('resume_from_wait');
  expect(html).toContain('postMessage');
});

test('HTML includes accessibility attributes', () => {
  const html = buildWaitHtml('Test', mockContext);

  expect(html).toContain('aria-modal="true"');
  expect(html).toContain('autofocus');
  expect(html).toContain('aria-labelledby');
});
```

### 3. E2E Tests: postMessage 시뮬레이션

```typescript
test('UI button triggers correct postMessage', () => {
  // JSDOM 또는 Playwright로 HTML 렌더링
  const messages: unknown[] = [];
  window.addEventListener('message', (e) => messages.push(e.data));

  // Simulate button click
  const button = document.querySelector('.btn-continue');
  button?.click();

  expect(messages).toHaveLength(1);
  expect(messages[0]).toMatchObject({
    type: 'tool',
    payload: {
      toolName: 'resume_from_wait',
      params: { context: expect.any(Object) },
    },
  });
});
```

## 추가 분석 과제

### 1. 보안: postMessage origin 검증

- 현재: `postMessage` origin '\*' 사용
- **분석**: origin 제한 또는 nonce 검증 필요성
- **제안**: context에 nonce 추가하여 서버 검증

### 2. Timeout 정책

- 현재: timeout 처리 없음
- **분석**: 사용자가 장시간 버튼 안 누르는 경우
- **제안**: 옵션으로 timeout 파라미터 추가 고려

### 3. 여러 대기 동시 발생

- 현재: 상태 비저장 방식
- **분석**: 동일 세션에서 여러 wait 동시 발생 시나리오
- **제안**: sessionId 검증으로 충돌 방지

### 4. 사용자가 창 닫는 경우

- 현재: 처리 없음
- **분석**: onbeforeunload 처리 필요성
- **제안**: UI에서 페이지 이탈 시 cancel 신호 전송

## 요약

- **새 도구 2개**: `wait_for_user_resume`, `resume_from_wait`
- **핵심**: 극단적 단순화 — waitId, 세션 관리, action 구분 없음
- **상태**: UIResource에 모든 context embedded
- **UI**: spinner + 메시지 + "계속" 버튼
- **agent 메시지**: 재개 시 충분한 컨텍스트 제공 (간결)
- **테스트**: 도구 lifecycle, HTML, postMessage, duration 계산

---

**다음 단계**: 이 계획에 따라 `ui-tools.ts` 수정 및 테스트 작성 진행.
