# LLM JSON 이스케이핑 문제 해결 및 MCP 도구 입력 정규화 Refactoring Plan

## 작업의 목적

LLM이 MCP 도구 호출 시 발생하는 JSON 이스케이핑 문제를 해결하여 도구 실행의 안정성과 신뢰성을 확보합니다. 특히 Shell 명령어, Python 코드, TypeScript 코드 실행 시 발생하는 따옴표 관련 파싱 오류를 자동으로 보정하는 메커니즘을 구축합니다.

### 핵심 목표

- LLM이 생성한 부정확한 JSON 이스케이핑을 자동으로 보정
- 도구 실행 시 빈 응답이나 예상치 못한 오류 최소화
- 사용자 경험 개선 및 도구 신뢰성 향상

## 현재의 상태 / 문제점

### 1. 확인된 문제 사례

**Shell 명령어 실행 (`builtin_workspace__execute_shell`)**

```json
// 잘못된 LLM 생성 JSON
{
  "command": "echo "Shell is working!""  // 이스케이핑 누락
}

// 올바른 형식
{
  "command": "echo \"Shell is working!\""  // 제대로 이스케이핑됨
}
```

**결과**: 명령어가 불완전하게 파싱되어 Shell이 따옴표 매칭을 기다리는 상태에서 멈춤 (`dquote>` 프롬프트)

### 2. 현재 코드의 취약점

#### 입력 검증 부족

```rust
// src-tauri/src/mcp/builtin/workspace/code_execution.rs:307
let command_str = match args.get("command").and_then(|v| v.as_str()) {
    Some(cmd) => cmd,  // 그대로 사용, 검증/보정 없음
    None => return Self::error_response(...)
};
```

#### 동일한 패턴이 반복됨

- `handle_execute_python`: 코드 문자열 직접 사용
- `handle_execute_typescript`: 코드 문자열 직접 사용
- `handle_execute_shell`: 명령어 문자열 직접 사용

### 3. 영향 범위

- **Workspace MCP Server**: 모든 코드 실행 도구
- **사용자 경험**: 예상치 못한 빈 응답으로 인한 혼란
- **디버깅 복잡성**: 시각적으로 구분하기 어려운 따옴표 문제

## 추가 분석 과제

### 1. LLM별 이스케이핑 패턴 분석

- 다양한 LLM 모델에서 발생하는 공통적인 이스케이핑 실수 패턴 조사
- 언어별(Python, TypeScript, Shell) 특수 문자 처리 방식 차이점 분석

### 2. Frontend JSON 직렬화 검토

- `src/lib/mcp-types.ts`의 `normalizeToolResult` 함수 검토
- Web Worker와 Tauri 간 JSON 전달 과정에서의 추가적인 이스케이핑 문제 가능성

### 3. 다른 도구들의 입력 검증 현황

- 파일 조작 도구들(`read_file`, `write_file` 등)의 경로 문자열 처리
- 검색 도구들(`grep`, `search_files`)의 패턴 문자열 처리

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **자동 보정 기능 작동**

   ```bash
   # 테스트 케이스: 잘못된 이스케이핑
   echo "Shell is working!""  # 이전: 실패
   echo "Shell is working!"   # 이후: 자동 보정되어 성공
   ```

2. **로그 메시지 확인**
   - 보정이 발생했을 때 적절한 정보성 로그 출력
   - 원본과 보정된 명령어/코드의 차이점 기록

3. **기존 기능 무손상**
   - 올바른 형식의 입력은 그대로 처리
   - 기존 테스트 케이스들 모두 통과

### 검증 방법

````bash
# 1. Shell 명령어 테스트
builtin_workspace__execute_shell: {"command": "echo "test""}
builtin_workspace__execute_shell: {"command": "ls -la"}

# 2. Python 코드 테스트
builtin_workspace__execute_python: {"code": "print("hello")"}
builtin_workspace__execute_python: {"code": "print('hello')"}

# 3. TypeScript 코드 테스트
builtin_workspace__execute_typescript: {"code": "console.log("test")"}
```## 수정이 필요한 코드 및 수정부분의 코드 스니핏### 1. 입력 정규화 함수 추가

**파일**: `src-tauri/src/mcp/builtin/workspace/code_execution.rs`

```rust
impl WorkspaceServer {
    /// LLM이 생성한 Shell 명령어의 따옴표 문제를 자동으로 보정
    fn normalize_shell_command(raw_command: &str) -> String {
        let mut normalized = raw_command.to_string();

        // 1. 불완전한 따옴표 쌍 감지 및 보정
        let double_quote_count = normalized.chars().filter(|&c| c == '"').count();
        let single_quote_count = normalized.chars().filter(|&c| c == '\'').count();

        // 2. 홀수 개의 따옴표가 있으면 마지막에 추가
        if double_quote_count % 2 != 0 {
            normalized.push('"');
            info!("Shell command: Added missing double quote");
        }
        if single_quote_count % 2 != 0 {
            normalized.push('\'');
            info!("Shell command: Added missing single quote");
        }

        // 3. 연속된 따옴표 보정 패턴들
        // "echo "hello"" -> "echo \"hello\""
        if normalized.contains("\"\"") {
            // 문맥에 따른 스마트 보정 로직
            normalized = Self::fix_consecutive_quotes(&normalized);
        }

        normalized
    }

    /// Python/TypeScript 코드의 문자열 문제를 보정
    fn normalize_code_string(raw_code: &str, language: &str) -> String {
        // 언어별 특수 처리 로직
        // 공통 패턴: 불완전한 문자열 리터럴 보정
    }
}
````

### 2. 핸들러 함수 수정

#### Shell 명령어 핸들러

```rust
pub async fn handle_execute_shell(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let raw_command = match args.get("command").and_then(|v| v.as_str()) {
        Some(cmd) => cmd,
        None => return Self::error_response(request_id, -32602, "Missing required parameter: command"),
    };

    // LLM 입력 정규화
    let command_str = Self::normalize_shell_command(raw_command);

    // 보정이 발생한 경우 로그 출력
    if command_str != raw_command {
        info!("Shell command normalized: '{}' -> '{}'", raw_command, command_str);
    }

    // 기존 실행 로직...
}
```

#### Python 핸들러

```rust
pub async fn handle_execute_python(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    let raw_code = match args.get("code").and_then(|v| v.as_str()) {
        Some(code) => code,
        None => return Self::error_response(request_id, -32602, "Missing required parameter: code"),
    };

    let normalized_code = Self::normalize_code_string(raw_code, "python");

    if normalized_code != raw_code {
        info!("Python code normalized for execution");
    }

    self.execute_code_in_sandbox("python3", &[], &normalized_code, ".py", timeout_secs).await
}
```

### 3. 공통 유틸리티 함수

**파일**: `src-tauri/src/mcp/builtin/workspace/utils.rs`

```rust
/// 문자열에서 따옴표 균형 검사 및 보정
pub fn balance_quotes(input: &str) -> String {
    // 복잡한 따옴표 균형 로직
}

/// JSON 이스케이핑 패턴 감지 및 보정
pub fn fix_json_escaping_patterns(input: &str) -> String {
    // 일반적인 LLM 실수 패턴들 보정
}
```

## 재사용 가능한 연관 코드

### 파일 경로 및 주요 기능

1. **`src-tauri/src/mcp/builtin/workspace/code_execution.rs`**
   - 핵심 수정 대상
   - 기능: Python, TypeScript, Shell 코드 실행
   - 인터페이스: `handle_execute_*` 함수들

2. **`src-tauri/src/mcp/builtin/workspace/utils.rs`**
   - 공통 유틸리티 함수 추가 위치
   - 기능: 요청 ID 생성, 응답 생성, 입력 검증
   - 기존 함수: `validate_timeout`, `create_success_response`

3. **`src-tauri/src/mcp/builtin/workspace/tools/code_tools.rs`**
   - 도구 스키마 정의
   - 수정 가능성: 입력 스키마에 정규화 관련 설명 추가

4. **`src/lib/mcp-types.ts`**
   - Frontend 측 타입 정의 및 정규화 로직
   - 검토 대상: `normalizeToolResult` 함수

### 주요 인터페이스

```rust
// 기존 인터페이스 (유지)
pub async fn handle_execute_shell(&self, args: Value) -> MCPResponse
pub async fn handle_execute_python(&self, args: Value) -> MCPResponse
pub async fn handle_execute_typescript(&self, args: Value) -> MCPResponse

// 새로 추가될 내부 함수들
fn normalize_shell_command(raw_command: &str) -> String
fn normalize_code_string(raw_code: &str, language: &str) -> String
fn fix_consecutive_quotes(input: &str) -> String
```

### 참고할 기존 패턴

1. **입력 검증**: `utils::validate_timeout` 함수 패턴
2. **에러 응답**: `Self::error_response` 사용 패턴
3. **성공 응답**: `Self::success_response` 사용 패턴
4. **로깅**: `tracing::{info, warn, error}` 사용 패턴

이 계획은 상위 레벨의 구조와 방향성을 제시하면서도, 작업자가 구현 과정에서 유연하게 대응할 수 있도록 세부 구현은 가이드라인 수준으로 제시했습니다.
