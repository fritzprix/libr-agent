# WorkspaceFilesPanel 파일 가져오기 기능 구현 계획

## 작업의 목적

WorkspaceFilesPanel에서 외부 파일을 드래그 앤 드롭으로 워크스페이스에 가져오는 기능을 구현하여, 사용자가 직관적으로 파일을 워크스페이스에 추가하고 AI와의 대화에서 활용할 수 있도록 한다.

## 현재의 상태 / 문제점

### 현재 상태

1. **DnD 인프라 존재**: `DnDContext`를 통한 드래그 앤 드롭 이벤트 처리 시스템이 구현되어 있음
2. **기본 이벤트 처리**: WorkspaceFilesPanel.tsx:177-192에서 파일 드롭 이벤트를 받지만 단순 알림만 표시
3. **MCP 도구 인프라**: workspace MCP 서버가 존재하며 파일 조작 도구들이 구현됨
4. **채팅 통합**: `useChatContext`의 submit 메서드로 도구 사용을 메시지화할 수 있음

### 문제점

1. **기능 미완성**: 현재 `handleWorkspaceFileDrop`에서 `alert()`만 호출하고 실제 파일 가져오기는 미구현
2. **도구 부재**: workspace MCP 서버에 `import_file` 도구가 존재하지 않음
3. **백엔드 연동 부재**: 파일 복사/이동을 수행하는 Tauri 명령이 없음
4. **메시지 통합 부재**: 파일 가져오기 작업이 채팅 세션에 기록되지 않음

## 추가 분석 과제

1. **파일 충돌 처리**: 동일한 이름의 파일이 이미 존재할 때의 처리 방식 결정
2. **대용량 파일 처리**: 파일 크기 제한 및 진행률 표시 방식 검토
3. **권한 검증**: 외부 파일 접근 시 보안 검증 방식 확인
4. **에러 처리**: 파일 가져오기 실패 시 사용자 피드백 방식 정의

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **기능적 완성**: 외부 파일을 드래그 앤 드롭으로 워크스페이스에 복사 가능
2. **UI 피드백**: 드롭 영역 시각적 피드백 및 진행 상태 표시
3. **채팅 통합**: 파일 가져오기 작업이 채팅 메시지로 기록됨
4. **에러 처리**: 실패 시 적절한 에러 메시지 표시
5. **보안 준수**: SecureFileManager를 통한 경로 검증

### 검증 방법

- 외부 파일을 WorkspaceFilesPanel로 드래그하여 워크스페이스에 복사되는지 확인
- 채팅 히스토리에 import_file 도구 사용 기록이 남는지 확인
- 파일 충돌, 권한 오류 등의 예외 상황에서 적절한 피드백이 표시되는지 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. Workspace MCP 서버에 import_file 도구 추가

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/file_tools.rs`

```rust
// 추가할 함수
pub fn create_import_file_tool() -> MCPTool {
    let mut props = HashMap::new();
    props.insert(
        "src_abs_path".to_string(),
        string_prop(Some(1), Some(1000), Some("Absolute path of source file to import")),
    );
    props.insert(
        "dest_rel_path".to_string(),
        string_prop(Some(1), Some(1000), Some("Relative path in workspace where file will be imported")),
    );

    MCPTool {
        name: "import_file".to_string(),
        title: Some("Import File".to_string()),
        description: "Import an external file into the workspace".to_string(),
        input_schema: object_schema(props, vec!["src_abs_path".to_string(), "dest_rel_path".to_string()]),
        output_schema: None,
        annotations: None,
    }
}
```

**파일**: `src-tauri/src/mcp/builtin/workspace/tools/mod.rs`

```rust
// 수정할 부분: line 9-17
pub fn file_tools() -> Vec<MCPTool> {
    vec![
        file_tools::create_read_file_tool(),
        file_tools::create_write_file_tool(),
        file_tools::create_list_directory_tool(),
        file_tools::create_search_files_tool(),
        file_tools::create_replace_lines_in_file_tool(),
        file_tools::create_grep_tool(),
        file_tools::create_import_file_tool(), // 추가
    ]
}
```

### 2. import_file 도구 핸들러 구현

**파일**: `src-tauri/src/mcp/builtin/workspace/file_operations.rs`

```rust
// 추가할 메서드
impl WorkspaceServer {
    pub async fn handle_import_file(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let src_path_str = match args.get("src_abs_path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => return Self::error_response(request_id, -32602, "Missing src_abs_path"),
        };

        let dest_rel_path = match args.get("dest_rel_path").and_then(|v| v.as_str()) {
            Some(path) => path,
            None => return Self::error_response(request_id, -32602, "Missing dest_rel_path"),
        };

        let src_path = match std::path::Path::new(src_path_str).canonicalize() {
            Ok(path) => path,
            Err(e) => return Self::error_response(request_id, -32603, &format!("Invalid source path: {e}")),
        };

        let workspace_dir = self.get_workspace_dir();
        let dest_path = workspace_dir.join(dest_rel_path);

        // 대상 디렉토리 생성
        if let Some(parent) = dest_path.parent() {
            if let Err(e) = fs::create_dir_all(parent).await {
                return Self::error_response(request_id, -32603, &format!("Failed to create directory: {e}"));
            }
        }

        // 파일 복사
        match fs::copy(&src_path, &dest_path).await {
            Ok(bytes_copied) => {
                let message = format!("Successfully imported {} ({} bytes) to {}",
                    src_path.display(), bytes_copied, dest_rel_path);
                Self::success_response(request_id, &message)
            }
            Err(e) => Self::error_response(request_id, -32603, &format!("Failed to copy file: {e}")),
        }
    }
}
```

**파일**: `src-tauri/src/mcp/builtin/workspace/mod.rs`

```rust
// 수정할 부분: line 70-91에 추가
async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
    match tool_name {
        // 기존 도구들...
        "import_file" => self.handle_import_file(args).await, // 추가
        // 나머지 도구들...
    }
}
```

### 3. WorkspaceFilesPanel 드롭 핸들러 개선

**파일**: `src/features/chat/components/WorkspaceFilesPanel.tsx`

```tsx
// 수정할 부분: line 177-192
const handleWorkspaceFileDrop = useCallback(
  async (paths: string[]) => {
    if (!session?.id) return;

    logger.info('External files dropped on workspace', {
      fileCount: paths.length,
      targetPath: rootPath,
    });

    try {
      for (const srcPath of paths) {
        const fileName = srcPath.split('/').pop() || 'unknown';
        const destPath = `${rootPath}/${fileName}`.replace(/\/+/g, '/');

        // Call builtin workspace tool
        const response = await callBuiltinTool('workspace', 'import_file', {
          src_abs_path: srcPath,
          dest_rel_path: destPath.startsWith('./')
            ? destPath.slice(2)
            : destPath,
        });

        // Create tool messages for chat history
        const toolRequestMessage: Message = {
          id: createId(),
          role: 'assistant',
          content: [
            {
              type: 'tool_use',
              id: createId(),
              name: 'import_file',
              input: { src_abs_path: srcPath, dest_rel_path: destPath },
            },
          ],
          sessionId: session.id,
        };

        const toolResponseMessage: Message = {
          id: createId(),
          role: 'tool',
          content: [
            {
              type: 'tool_result',
              tool_use_id: toolRequestMessage.content[0].id,
              content:
                typeof response.result === 'string'
                  ? response.result
                  : JSON.stringify(response.result),
            },
          ],
          sessionId: session.id,
        };

        await submit([toolRequestMessage, toolResponseMessage]);
      }

      // Refresh directory after import
      await loadDirectory(rootPath);
    } catch (error) {
      logger.error('File import failed', error);
      // TODO: Show user-friendly error message
    }
  },
  [callBuiltinTool, submit, session, rootPath, loadDirectory],
);
```

필요한 import 추가:

```tsx
import { useSessionContext } from '@/context/SessionContext';
import { useChatContext } from '@/context/ChatContext';
import { createId } from '@paralleldrive/cuid2';
import type { Message } from '@/models/chat';
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 구조

1. **DnDContext**: `src/context/DnDContext.tsx` - 드래그 앤 드롭 이벤트 처리
2. **SecureFileManager**: `src-tauri/src/services/secure_file_manager.rs` - 파일 경로 보안 검증
3. **useRustBackend**: `src/hooks/use-rust-backend.ts` - Tauri 백엔드 통신
4. **useChatContext**: `src/context/ChatContext.tsx` - 채팅 메시지 관리
5. **Message 모델**: `src/models/chat.ts` - 메시지 타입 정의

### 참고할 유사 기능

1. **FileAttachment**: `src/features/chat/hooks/useFileAttachment.ts` - 파일 첨부 로직
2. **기존 workspace 도구들**: `src-tauri/src/mcp/builtin/workspace/tools/` - 도구 구현 패턴

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트

1. **Rust 테스트**: `src-tauri/src/mcp/builtin/workspace/` 내에 테스트 추가
   - `handle_import_file` 메서드의 정상/오류 케이스 테스트
   - 파일 경로 검증 로직 테스트
   - 파일 복사 실패 시나리오 테스트

2. **TypeScript 테스트**: WorkspaceFilesPanel 컴포넌트 테스트
   - 드롭 이벤트 처리 로직 테스트
   - 메시지 생성 및 제출 로직 테스트
   - 에러 처리 로직 테스트

### 통합 테스트

1. **E2E 테스트**: 전체 드래그 앤 드롭 플로우
   - 외부 파일을 패널로 드래그하여 워크스페이스에 추가되는지 확인
   - 채팅 히스토리에 올바른 메시지가 기록되는지 확인
   - 파일 충돌 시나리오 테스트

### 테스트 케이스

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_import_file_success() {
        // 정상적인 파일 가져오기 테스트
    }

    #[tokio::test]
    async fn test_import_file_invalid_source() {
        // 존재하지 않는 소스 파일 테스트
    }

    #[tokio::test]
    async fn test_import_file_permission_denied() {
        // 권한 없는 디렉토리 접근 테스트
    }
}
```

## 구현 순서

1. **백엔드 구현**: Rust MCP 도구 및 핸들러 구현
2. **프론트엔드 연동**: WorkspaceFilesPanel 드롭 핸들러 개선
3. **에러 처리**: 사용자 친화적 에러 메시지 및 피드백 추가
4. **테스트**: 단위 테스트 및 통합 테스트 작성
5. **최적화**: 대용량 파일 처리 및 성능 개선

이 계획에 따라 구현하면 사용자가 직관적으로 파일을 워크스페이스에 가져올 수 있고, 모든 작업이 채팅 히스토리에 기록되어 AI와의 협업에 활용할 수 있게 됩니다.
