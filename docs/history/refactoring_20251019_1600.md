# Thread-Based Message Grouping Implementation Plan

**Created**: 2025-10-19 16:00
**Author**: Claude Code
**Status**: Ready for Implementation
**Type**: Fresh Implementation (Not Refactoring)

---

## 1. Purpose of the Task

Support multiple independent conversation contexts (Threads) within a Session, allowing users to manage multiple conversation topics in parallel within a single session.

### Core Objectives

- Sessions can contain multiple Threads (1:N relationship)
- Each Thread has an independent message history
- Threads exist in parallel without switching
- Backend manages state via (sessionId, threadId) tuples
- threadId is explicitly passed during tool execution

---

## 2. Current State / Problems

### 2.1 Current Structure

```typescript
// Current Message Model
interface Message {
  id: string;
  sessionId: string; // ✅ 있음
  threadId?: string; // ❌ 없음
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  // ...
}

// Current Session Model
interface Session {
  id: string;
  type: 'single' | 'group';
  assistants: Assistant[];
  name?: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
  // ❌ thread 관련 필드 없음
}
```

### 2.2 문제점

1. **메시지 그룹핑 불가**
   - 모든 메시지가 session 레벨에서만 관리됨
   - 다중 대화 맥락 지원 불가

2. **Tool Context 격리 불가**
   - Tool 실행 결과가 전체 session에 영향
   - 독립적인 작업 맥락 유지 어려움

3. **확장성 제한**
   - Multi-agent orchestration 시 agent별 thread 분리 불가
   - 복잡한 워크플로우 구성 어려움

---

## 3. 관련 코드의 구조 및 동작 방식 Summary

### 3.1 Bird's Eye View

```text
Frontend (React)
├── SessionContext
│   ├── current: Session | null       // 현재 선택된 세션
│   ├── select(sessionId): void       // 세션 전환
│   └── start(...): Promise<void>     // 새 세션 생성
│
├── SessionHistoryContext
│   ├── messages: Page<Message>[]     // 메시지 페이지네이션
│   ├── addMessages(messages): void   // 메시지 추가
│   └── SWR Key: [sessionId, 'messages', page]
│
└── ChatContext
    ├── sendMessage(content): void    // 메시지 전송
    └── Tool Execution Flow

Backend (Rust + Tauri)
├── messages_get_page(sessionId, page, pageSize)
├── messages_upsert(messages[])
└── State: Dexie (IndexedDB)
    ├── sessions: &id
    └── messages: &id, sessionId, createdAt
```

### 3.2 현재 데이터 흐름

```text
1. User sends message
   ↓
2. ChatContext.sendMessage()
   ↓
3. SessionHistoryContext.addMessages([message])
   ↓
4. Backend: messages_upsert({ sessionId, content, ... })
   ↓
5. Dexie: messages.add({ sessionId, ... })
   ↓
6. SWR revalidation: [sessionId, 'messages', page]
```

### 3.3 주요 파일 및 책임

| 파일                                    | 책임                                        |
| --------------------------------------- | ------------------------------------------- |
| `src/models/chat.ts`                    | 데이터 모델 정의 (Session, Message, Thread) |
| `src/context/SessionContext.tsx`        | 세션 생명주기 관리                          |
| `src/context/SessionHistoryContext.tsx` | 메시지 CRUD 및 페이지네이션                 |
| `src/features/tools/index.tsx`          | ServiceContextOptions 정의                  |
| `src/hooks/use-unified-mcp.ts`          | Tool 실행 로직                              |
| `src/lib/rust-backend-client.ts`        | Tauri 백엔드 API 클라이언트                 |
| `src/lib/db/service.ts`                 | Dexie 스키마 및 마이그레이션                |

---

## 4. 변경 이후의 상태 / 해결 판정 기준

### 4.1 목표 구조

```typescript
// New Message Model
interface Message {
  id: string;
  sessionId: string;
  threadId: string; // ✅ 필수 필드
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  // ...
}

// New Session Model
interface Session {
  id: string;
  type: 'single' | 'group';
  assistants: Assistant[];
  name?: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
  sessionThread: Thread; // ✅ Top-level thread metadata
}

// New Thread Model
interface Thread {
  /** Unique thread identifier */
  id: string;

  /** Parent session ID */
  sessionId: string;

  /** Assistant ID for this thread (optional) */
  assistantId?: string;

  /** Initial query or context for this thread (optional) */
  initialQuery?: string;

  /** Thread creation timestamp */
  createdAt: Date;
}
```

### 4.2 목표 데이터 흐름

```text
1. User sends message to specific thread
   ↓
2. ChatContext.sendMessage(content, threadId)  // ✅ threadId 명시
   ↓
3. SessionHistoryContext.addMessages([message], threadId)
   ↓
4. Backend: messages_upsert({ sessionId, threadId, content, ... })
   ↓
5. Dexie: messages.add({ sessionId, threadId, ... })
   ↓
6. SWR revalidation: [sessionId, threadId, 'messages', page]  // ✅ threadId 포함
```

### 4.3 해결 판정 기준

- [ ] Session 생성 시 자동으로 top thread (id === sessionId) 생성됨
- [ ] Message에 threadId 필드가 필수로 포함됨
- [ ] 같은 session 내 여러 threadId로 메시지 저장 가능
- [ ] SWR key에 threadId 포함되어 thread별 독립적인 캐싱
- [ ] Tool 실행 시 ServiceContextOptions에 threadId 전달됨
- [ ] Backend API가 (sessionId, threadId) 튜플로 데이터 조회
- [ ] 기존 데이터는 threadId = sessionId로 자동 마이그레이션
- [ ] TypeScript 컴파일 에러 없음
- [ ] 기존 테스트 통과 및 새 테스트 추가

---

## 5. 수정이 필요한 코드 및 수정 부분의 코드 스니핏

### 5.1 Data Models (`src/models/chat.ts`)

#### 5.1.1 Thread Interface 추가

**위치**: `AttachmentReference` 인터페이스 다음

```typescript
/**
 * Thread represents a logical conversation thread within a session.
 * - Top thread: id === sessionId (always exists)
 * - Sub threads: id !== sessionId (optional, created by user)
 *
 * All threads exist in parallel (no switching concept).
 * Backend manages state via (sessionId, threadId) tuples.
 */
export interface Thread {
  /** Unique thread identifier */
  id: string;

  /** Parent session ID */
  sessionId: string;

  /** Assistant ID for this thread (optional) */
  assistantId?: string;

  /** Initial query or context for this thread (optional) */
  initialQuery?: string;

  /** Thread creation timestamp */
  createdAt: Date;
}
```

#### 5.1.2 Message Interface Update

**Location**: `Message` interface

```typescript
export interface Message {
  id: string;
  sessionId: string;

  /**
   * Thread ID this message belongs to.
   * REQUIRED: Must always be specified.
   * For top-level thread: threadId === sessionId
   */
  threadId: string; // ✅ string (not optional)

  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  // ... 나머지 필드 유지
}
```

#### 5.1.3 Session Interface 수정

**위치**: `Session` 인터페이스

```typescript
export interface Session {
  id: string;
  type: 'single' | 'group';
  assistants: Assistant[];
  name?: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;

  /**
   * Session's top-level thread metadata.
   * This is the only Thread object stored in Session.
   * - id === sessionId (identifies this as the top thread)
   *
   * Other threads exist only in backend state.
   */
  sessionThread: Thread;
}
```

### 5.2 SessionContext (`src/context/SessionContext.tsx`)

#### 5.2.1 Context Type 수정

```typescript
interface SessionContextType {
  // Existing fields (unchanged)
  sessions: Page<Session>[] | undefined;
  current: Session | null;
  select: (id?: string) => void;
  start: (
    assistants: Assistant[],
    description?: string,
    name?: string,
  ) => Promise<void>;
  delete: (id: string) => Promise<void>;
  updateSession: (session: Session) => Promise<void>;
  getSessions: () => Promise<void>;
  getCurrentSession: () => Session | null;
  loadMore: () => Promise<void>;
  clearAllSessions: () => Promise<void>;
  isLoading: boolean;
  isValidating: boolean;
  error: Error | null;
  clearError: () => void;
  retryLastOperation: () => Promise<void>;
  hasNextPage: boolean;
  isAgenticMode: boolean;
  toggleAgenticMode: () => void;

  /**
   * NEW: Session's top-level thread metadata (read-only).
   * Derived from current.sessionThread.
   * Returns null if no session is selected.
   */
  sessionThread: Thread | null;
}
```

#### 5.2.2 Provider 구현 - sessionThread 추가

```typescript
function SessionContextProvider({ children }: { children: ReactNode }) {
  // ... existing state ...

  // ✅ Derive sessionThread from current session
  const sessionThread = useMemo(
    () => current?.sessionThread ?? null,
    [current],
  );

  // ... rest of implementation
}
```

#### 5.2.3 start() 메서드 수정 - Top Thread 생성

```typescript
const handleStartNew = useCallback(
  async (assistants: Assistant[], description?: string, name?: string) => {
    const operation = async () => {
      if (!assistants.length) {
        throw new Error(
          'At least one assistant is required to start a session.',
        );
      }

      const sessionId = createId();

      // ✅ Create top thread with id === sessionId
      const sessionThread: Thread = {
        id: sessionId,
        sessionId,
        createdAt: new Date(),
      };

      const session: Session = {
        id: sessionId,
        assistants: [...assistants],
        type: assistants.length > 1 ? 'group' : 'single',
        createdAt: new Date(),
        updatedAt: new Date(),
        description: generateSessionDescription(assistants, description),
        name: generateSessionName(assistants, name),
        sessionThread, // ✅ Include top thread
      };

      logger.info('Creating new session with top thread', {
        sessionId: session.id,
        topThreadId: sessionThread.id,
      });

      // Optimistic update
      setCurrent(session);

      // ... rest of optimistic update logic

      try {
        await dbService.sessions.upsert(session);
      } catch (error) {
        setCurrent(null);
        await mutate();
        throw error;
      }
    };

    // ... error handling
  },
  [mutate],
);
```

#### 5.2.4 Context Value 수정

```typescript
const contextValue: SessionContextType = useMemo(
  () => ({
    // ... existing fields ...
    sessionThread, // ✅ Add derived sessionThread
  }),
  [
    // ... existing dependencies ...
    sessionThread,
  ],
);
```

### 5.3 SessionHistoryContext (`src/context/SessionHistoryContext.tsx`)

#### 5.3.1 SWR Key 수정 - ThreadId 포함

**현재**:

```typescript
const { data, error, isLoading, setSize, mutate } = useSWRInfinite<
  Page<Message>
>(
  (pageIndex, previousPageData) => {
    if (!currentSession?.id) return null;
    if (previousPageData && !previousPageData.hasNextPage) return null;
    return [currentSession.id, 'messages', pageIndex + 1];
  },
  async ([sessionId, , page]: [string, string, number]) => {
    return backend.getMessagesPageForSession(sessionId, page, PAGE_SIZE);
  },
  // ...
);
```

**수정 후**:

```typescript
export function SessionHistoryProvider({
  children,
  threadId, // ✅ NEW: Accept threadId as prop
}: {
  children: ReactNode;
  threadId?: string; // Optional, defaults to top thread
}) {
  const { current: currentSession } = useSessionContext();

  // ✅ Determine effective threadId
  const effectiveThreadId = useMemo(
    () => threadId || currentSession?.id || '',
    [threadId, currentSession?.id],
  );

  const { data, error, isLoading, setSize, mutate } = useSWRInfinite<
    Page<Message>
  >(
    (pageIndex, previousPageData) => {
      if (!currentSession?.id || !effectiveThreadId) return null;
      if (previousPageData && !previousPageData.hasNextPage) return null;

      // ✅ Include threadId in key
      return [currentSession.id, effectiveThreadId, 'messages', pageIndex + 1];
    },
    async ([sessionId, threadId, , page]: [string, string, string, number]) => {
      // ✅ Pass both sessionId and threadId
      return backend.getMessagesPageForSession(
        sessionId,
        threadId,
        page,
        PAGE_SIZE,
      );
    },
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      revalidateIfStale: false,
    },
  );

  // ... rest of implementation
}
```

#### 5.3.2 addMessages 수정 - Explicit ThreadId

```typescript
const addMessages = useCallback(
  /**
   * Add messages to a specific thread.
   * @param messagesToAdd Messages to add
   * @param threadId Target thread ID (defaults to current effectiveThreadId)
   */
  (messagesToAdd: Message[], targetThreadId?: string): Promise<Message[]> => {
    if (!currentSession) throw new Error('No active session.');

    const threadId = targetThreadId || effectiveThreadId;
    if (!threadId) throw new Error('threadId is required');

    messagesToAdd.forEach(validateMessage);

    // ✅ Ensure all messages have correct threadId
    const messagesWithContext = messagesToAdd.map((m) => ({
      ...m,
      sessionId: currentSession.id,
      threadId, // ✅ Explicit threadId
    }));

    const previousData = data;

    return mutate(
      (currentData) => {
        if (!currentData || currentData.length === 0) {
          return [
            {
              items: messagesWithContext,
              page: 1,
              pageSize: PAGE_SIZE,
              totalItems: messagesWithContext.length,
              totalPages: 1,
              hasNextPage: false,
              hasPreviousPage: false,
            },
          ];
        }
        const newData = [...currentData];
        const last = { ...newData[newData.length - 1] };
        last.items = [...last.items, ...messagesWithContext];
        newData[newData.length - 1] = last;
        return newData;
      },
      { revalidate: false },
    )
      .then(() => backend.upsertMessages(messagesWithContext))
      .then(() => messagesWithContext)
      .catch((e) => {
        mutate(previousData, { revalidate: false });
        throw e;
      });
  },
  [currentSession, effectiveThreadId, mutate, data, validateMessage],
);
```

### 5.4 ServiceContextOptions (`src/features/tools/index.tsx`)

```typescript
export interface ServiceContextOptions {
  sessionId?: string;
  assistantId?: string;

  /**
   * Thread ID for tool context isolation.
   * Tools executed with the same threadId share context.
   *
   * OPTIONAL: If not provided, defaults to sessionId (top thread).
   * This allows backward compatibility with existing services.
   */
  threadId?: string; // ✅ Optional field with fallback
}
```

**Migration Strategy**: To ensure backward compatibility, all built-in services should use this pattern:

```typescript
// In any service's getServiceContext() or executeTool() method
getServiceContext(options?: ServiceContextOptions): Promise<ServiceContext> {
  // ✅ Fallback to sessionId if threadId not provided
  const effectiveThreadId = options?.threadId || options?.sessionId || '';

  if (!effectiveThreadId) {
    throw new Error('Either threadId or sessionId must be provided');
  }

  // Use effectiveThreadId for context isolation
  const state = this.stateManager.get(options?.sessionId || '', effectiveThreadId);
  // ...
}
```

**Affected Services**: The following built-in services need to be updated to use the fallback pattern:

- `planning-server` (Web MCP) - State management by (sessionId, threadId)
- `workspace-service` - File operations scoped to thread
- `browser-service` - Browser automation context per thread
- `content-store-service` - Content indexing per thread
- `playbook-service` - Playbook execution per thread

### 5.5 Tool Execution (`src/hooks/use-unified-mcp.ts`)

#### 5.5.1 executeToolCall Signature Update

```typescript
const executeToolCall = useCallback(
  /**
   * Execute a tool call with thread context.
   * @param toolCall Tool call to execute
   * @param threadId Thread where tool executes (optional, defaults to sessionId)
   */
  async (
    toolCall: ToolCall,
    threadId?: string, // ✅ OPTIONAL PARAMETER with fallback
  ): Promise<MCPResponse<unknown>> => {
    const { current: currentSession } = useSessionContext();
    const { currentAssistant } = useAssistantContext();

    // ✅ Determine effective threadId with fallback
    const effectiveThreadId = threadId || currentSession?.id || '';

    if (!effectiveThreadId) {
      throw new Error(
        'Cannot determine threadId: no active session or thread specified',
      );
    }

    // ... tool resolution logic ...

    // ✅ Inject ServiceContextOptions with threadId (supports fallback)
    let toolCallToExecute: ToolCall = actualToolCall;
    if (toolType === 'BuiltInRust') {
      const serviceContextOptions: ServiceContextOptions = {
        sessionId: currentSession?.id ?? '',
        assistantId: currentAssistant?.id ?? '',
        threadId: effectiveThreadId, // ✅ Use effective threadId
      };
      toolCallToExecute = {
        ...actualToolCall,
        serviceContextOptions,
      } as ToolCall & { serviceContextOptions: ServiceContextOptions };
    }

    // ... execution logic ...
  },
  [
    /* dependencies without threadId */
  ],
);
```

### 5.6 Backend Client (`src/lib/rust-backend-client.ts`)

#### 5.6.1 getMessagesPageForSession 수정

```typescript
/**
 * Get messages for a specific thread in a session.
 * @param sessionId Session ID
 * @param threadId Thread ID (REQUIRED)
 * @param page Page number (1-indexed)
 * @param pageSize Number of messages per page
 */
export async function getMessagesPageForSession(
  sessionId: string,
  threadId: string, // ✅ REQUIRED parameter
  page: number,
  pageSize: number,
): Promise<Page<Message>> {
  if (!sessionId || !threadId) {
    throw new Error('sessionId and threadId are required');
  }

  const result = await safeInvoke<Page<Record<string, unknown>>>(
    'messages_get_page',
    {
      sessionId,
      threadId, // ✅ Pass threadId to backend
      page,
      pageSize,
    },
  );

  // Deserialize result
  return {
    items: result.items.map((item) => ({
      id: item.id as string,
      sessionId: item.sessionId as string,
      threadId: item.threadId as string, // ✅ Deserialize threadId
      role: item.role as Message['role'],
      content: item.content as string,
      createdAt: new Date(item.createdAt as string),
      // ... other fields
    })),
    page: result.page,
    pageSize: result.pageSize,
    totalItems: result.totalItems,
    totalPages: result.totalPages,
    hasNextPage: result.hasNextPage,
    hasPreviousPage: result.hasPreviousPage,
  };
}
```

#### 5.6.2 upsertMessages 수정

```typescript
/**
 * Upsert messages with thread context.
 */
export async function upsertMessages(messages: Message[]): Promise<Message[]> {
  if (!messages.length) return [];

  // ✅ Verify all messages have threadId
  messages.forEach((m) => {
    if (!m.threadId) {
      throw new Error(`Message ${m.id} missing required threadId`);
    }
  });

  const result = await safeInvoke<Record<string, unknown>[]>(
    'messages_upsert',
    messages,
  );

  return result.map((r) => ({
    id: r.id as string,
    sessionId: r.sessionId as string,
    threadId: r.threadId as string, // ✅ Deserialize threadId
    role: r.role as Message['role'],
    content: r.content as string,
    createdAt: new Date(r.createdAt as string),
    // ... other fields
  }));
}
```

### 5.7 Database Schema (`src/lib/db/service.ts`)

#### 5.7.1 Schema Update - Composite Index

```typescript
export class DatabaseService extends Dexie {
  sessions!: Dexie.Table<Session, string>;
  messages!: Dexie.Table<Message, string>;

  constructor() {
    super('SynapticFlowDB');

    // ... existing versions ...

    // ✅ NEW VERSION: Add composite index for (sessionId, threadId)
    this.version(8).stores({
      sessions: '&id, createdAt, updatedAt',
      messages: '&id, sessionId, [sessionId+threadId], createdAt', // ✅ Composite index
    });
  }
}
```

#### 5.7.2 Migration - Add threadId to existing data

```typescript
this.version(8)
  .stores({
    sessions: '&id, createdAt, updatedAt',
    messages: '&id, sessionId, [sessionId+threadId], createdAt',
  })
  .upgrade(async (tx) => {
    logger.info('Migrating to version 8: Adding threadId support');

    // ✅ Add threadId to existing messages (default to sessionId)
    const messages = await tx.table('messages').toArray();
    for (const msg of messages) {
      if (!msg.threadId) {
        await tx.table('messages').update(msg.id, {
          threadId: msg.sessionId, // Default to top thread
        });
      }
    }

    // ✅ Add sessionThread to existing sessions
    const sessions = await tx.table('sessions').toArray();
    for (const session of sessions) {
      if (!session.sessionThread) {
        await tx.table('sessions').update(session.id, {
          sessionThread: {
            id: session.id,
            sessionId: session.id,
            assistantId: session.assistants?.[0]?.id,
            initialQuery: undefined,
            createdAt: session.createdAt,
          },
        });
      }
    }

    logger.info('Migration to version 8 complete');
  });
```

#### 5.7.3 Post-Migration: SWR Cache Invalidation

**Problem**: After migration, SWR cache keys change from `[sessionId, 'messages', page]` to `[sessionId, threadId, 'messages', page]`, causing stale data to be served temporarily.

**Solution**: Add explicit cache invalidation after successful migration:

**File**: `src/lib/db/service.ts` (within the upgrade function)

```typescript
this.version(8)
  .stores({
    sessions: '&id, createdAt, updatedAt',
    messages: '&id, sessionId, [sessionId+threadId], createdAt',
  })
  .upgrade(async (tx) => {
    logger.info('Migrating to version 8: Adding threadId support');

    // ... migration logic ...

    logger.info('Migration to version 8 complete');

    // ✅ IMPORTANT: Clear SWR caches after migration
    // This ensures old cache keys don't serve stale data
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        // Dispatch custom event to signal cache invalidation needed
        window.dispatchEvent(
          new CustomEvent('database-migrated', {
            detail: { version: 8, feature: 'threadId' },
          }),
        );
        logger.info(
          'Dispatched database-migrated event for cache invalidation',
        );
      } catch (e) {
        logger.warn('Failed to dispatch migration event', e);
      }
    }
  });
```

**File**: `src/context/SessionHistoryContext.tsx` (add effect to listen for migration events)

```typescript
export function SessionHistoryProvider({
  children,
  threadId,
}: {
  children: ReactNode;
  threadId?: string;
}) {
  // ... existing code ...

  // ✅ Listen for database migration events and invalidate caches
  useEffect(() => {
    const handleMigration = (event: CustomEvent) => {
      logger.info(
        'Database migration detected, invalidating SWR caches',
        event.detail,
      );

      // Clear all SWR caches for this context
      mutate(() => true); // Invalidate all keys matching the fetcher

      logger.info('SWR caches invalidated successfully');
    };

    window.addEventListener(
      'database-migrated',
      handleMigration as EventListener,
    );

    return () => {
      window.removeEventListener(
        'database-migrated',
        handleMigration as EventListener,
      );
    };
  }, [mutate]);

  // ... rest of implementation
}
```

**Alternative Strategy** (if above is too aggressive):

Use targeted cache invalidation based on the old key pattern:

```typescript
// In the migration event handler
const handleMigration = () => {
  // Invalidate only message-related caches
  mutate(
    (key) => {
      if (!Array.isArray(key)) return false;
      // Match old pattern: [sessionId, 'messages', page]
      return key.length === 3 && key[1] === 'messages';
    },
    undefined,
    { revalidate: true },
  );
};
```

### 5.8 Rust Backend Commands (`src-tauri/src/commands/messages.rs`)

The Rust backend must be updated to handle `threadId` parameters. All message query and storage operations need to filter by the (sessionId, threadId) tuple.

#### 5.8.1 messages_get_page Command Update

**Current Signature**:

```rust
#[tauri::command]
pub async fn messages_get_page(
    session_id: String,
    page: usize,
    page_size: usize,
) -> Result<Page<Message>, String> {
    // Current implementation only filters by session_id
}
```

**Updated Signature**:

```rust
#[tauri::command]
pub async fn messages_get_page(
    session_id: String,
    thread_id: String, // ✅ NEW: Thread ID parameter
    page: usize,
    page_size: usize,
) -> Result<Page<Message>, String> {
    // Validate inputs
    if session_id.is_empty() {
        return Err("session_id cannot be empty".to_string());
    }
    if thread_id.is_empty() {
        return Err("thread_id cannot be empty".to_string());
    }

    // Database query must filter by BOTH session_id AND thread_id
    let messages = db::query_messages()
        .filter("sessionId", &session_id)
        .filter("threadId", &thread_id) // ✅ Add thread filter
        .order_by("createdAt", Order::Desc)
        .paginate(page, page_size)
        .await
        .map_err(|e| format!("Failed to query messages: {}", e))?;

    Ok(messages)
}
```

#### 5.8.2 messages_upsert Command Update

**Current Signature**:

```rust
#[tauri::command]
pub async fn messages_upsert(
    messages: Vec<Message>,
) -> Result<Vec<Message>, String> {
    // Current implementation
}
```

**Updated Signature** (with validation):

```rust
#[tauri::command]
pub async fn messages_upsert(
    messages: Vec<Message>,
) -> Result<Vec<Message>, String> {
    // ✅ Validate all messages have threadId
    for msg in &messages {
        if msg.session_id.is_empty() {
            return Err(format!("Message {} missing sessionId", msg.id));
        }
        if msg.thread_id.is_none() || msg.thread_id.as_ref().unwrap().is_empty() {
            return Err(format!("Message {} missing required threadId", msg.id));
        }
    }

    // Proceed with upsert - threadId is now persisted
    db::upsert_messages(messages)
        .await
        .map_err(|e| format!("Failed to upsert messages: {}", e))
}
```

#### 5.8.3 Message Struct Update

**File**: `src-tauri/src/models/message.rs`

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Message {
    pub id: String,
    pub session_id: String,

    /// Thread ID this message belongs to.
    /// REQUIRED: Must always be specified.
    /// For top-level thread: thread_id == session_id
    pub thread_id: String, // ✅ NEW required field

    pub role: MessageRole,
    pub content: Vec<McpContent>,
    pub tool_calls: Option<Vec<ToolCall>>,
    pub tool_call_id: Option<String>,
    pub assistant_id: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: Option<DateTime<Utc>>,
    // ... other fields
}
```

#### 5.8.4 Database Query Functions

If using a database abstraction layer (e.g., Dexie-like wrapper in Rust), ensure queries support the composite filter:

```rust
// Example query helper
pub async fn get_messages_for_thread(
    session_id: &str,
    thread_id: &str,
    page: usize,
    page_size: usize,
) -> Result<Page<Message>, DbError> {
    let offset = (page - 1) * page_size;

    // Query with composite filter
    let messages: Vec<Message> = sqlx::query_as!(
        Message,
        r#"
        SELECT * FROM messages
        WHERE session_id = $1 AND thread_id = $2
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
        "#,
        session_id,
        thread_id,
        page_size as i64,
        offset as i64
    )
    .fetch_all(&pool)
    .await?;

    let total_count: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) FROM messages
        WHERE session_id = $1 AND thread_id = $2
        "#,
        session_id,
        thread_id
    )
    .fetch_one(&pool)
    .await?;

    Ok(Page {
        items: messages,
        page,
        page_size,
        total_items: total_count as usize,
        total_pages: ((total_count as usize + page_size - 1) / page_size),
        has_next_page: (page * page_size) < total_count as usize,
        has_previous_page: page > 1,
    })
}
```

#### 5.8.5 Error Handling

Add specific error types for thread-related failures:

```rust
#[derive(Debug, thiserror::Error)]
pub enum MessageError {
    #[error("Thread ID is required but was not provided")]
    MissingThreadId,

    #[error("Thread {0} does not belong to session {1}")]
    ThreadSessionMismatch(String, String),

    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
}
```

#### 5.8.6 Integration Notes

- **Backward Compatibility**: If there are existing messages without `thread_id`, a migration script should set `thread_id = session_id` for all existing records
- **Validation**: Ensure `thread_id` matches the expected pattern (either equals `session_id` for top threads, or is a valid sub-thread ID)
- **Indexing**: Add a composite index on `(session_id, thread_id, created_at)` for optimal query performance

---

## 6. Reusable Related Code

### 6.1 Thread 관련 Utility Functions

**파일**: `src/lib/utils/thread-utils.ts` (NEW)

```typescript
import type { Thread, Session } from '@/models/chat';

/**
 * Get the top-level thread for a session.
 */
export function getTopThread(session: Session): Thread {
  return session.sessionThread;
}

/**
 * Check if a threadId is the top thread.
 */
export function isTopThread(threadId: string, sessionId: string): boolean {
  return threadId === sessionId;
}

/**
 * Create a new thread object.
 */
export function createThread(
  sessionId: string,
  assistantId?: string,
  initialQuery?: string,
): Thread {
  return {
    id: createId(),
    sessionId,
    assistantId,
    initialQuery,
    createdAt: new Date(),
  };
}

/**
 * Create the default top thread for a session.
 */
export function createTopThread(
  sessionId: string,
  assistantId?: string,
  initialQuery?: string,
): Thread {
  return {
    id: sessionId,
    sessionId,
    assistantId,
    initialQuery,
    createdAt: new Date(),
  };
}
```

### 6.2 Thread Validation

**파일**: `src/lib/validation/thread-validation.ts` (NEW)

```typescript
import type { Thread, Message } from '@/models/chat';

export class ThreadValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ThreadValidationError';
  }
}

/**
 * Validate that a thread belongs to a session.
 */
export function validateThreadOwnership(
  thread: Thread,
  sessionId: string,
): void {
  if (thread.sessionId !== sessionId) {
    throw new ThreadValidationError(
      `Thread ${thread.id} does not belong to session ${sessionId}`,
    );
  }
}

/**
 * Validate that a message belongs to a thread.
 */
export function validateMessageThreadOwnership(
  message: Message,
  threadId: string,
): void {
  if (message.threadId !== threadId) {
    throw new ThreadValidationError(
      `Message ${message.id} does not belong to thread ${threadId}`,
    );
  }
}

/**
 * Validate that all messages belong to the same thread.
 */
export function validateMessagesConsistency(
  messages: Message[],
  threadId: string,
): void {
  messages.forEach((msg) => {
    validateMessageThreadOwnership(msg, threadId);
  });
}
```

### 6.3 기존 재사용 가능 코드

| 파일 경로                           | 주요 기능    | 재사용 포인트                |
| ----------------------------------- | ------------ | ---------------------------- |
| `src/lib/logger.ts`                 | 로깅 시스템  | Thread 작업 로깅에 활용      |
| `src/lib/create-id.ts`              | ID 생성      | Thread ID 생성               |
| `src/lib/db/service.ts`             | Dexie 래퍼   | Thread 데이터 저장           |
| `src/hooks/use-session-context.tsx` | Session 접근 | sessionThread 접근           |
| `src/models/pagination.ts`          | 페이지네이션 | Thread별 메시지 페이지네이션 |

---

## 7. Test Code 추가 및 수정 필요 부분에 대한 가이드

### 7.1 Unit Tests

#### 7.1.1 Thread Utils Test

**파일**: `src/lib/utils/thread-utils.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  getTopThread,
  isTopThread,
  createThread,
  createTopThread,
} from './thread-utils';
import type { Session } from '@/models/chat';

describe('Thread Utils', () => {
  const mockSession: Session = {
    id: 'session-1',
    type: 'single',
    assistants: [],
    createdAt: new Date(),
    updatedAt: new Date(),
    sessionThread: {
      id: 'session-1',
      sessionId: 'session-1',
      createdAt: new Date(),
    },
  };

  describe('getTopThread', () => {
    it('should return the session thread', () => {
      const topThread = getTopThread(mockSession);
      expect(topThread.id).toBe('session-1');
      expect(topThread.id).toBe(topThread.sessionId); // Top thread: id === sessionId
    });
  });

  describe('isTopThread', () => {
    it('should return true when threadId equals sessionId', () => {
      expect(isTopThread('session-1', 'session-1')).toBe(true);
    });

    it('should return false when threadId does not equal sessionId', () => {
      expect(isTopThread('thread-2', 'session-1')).toBe(false);
    });
  });

  describe('createThread', () => {
    it('should create a non-top thread', () => {
      const thread = createThread('session-1', 'assistant-1', 'Test query');
      expect(thread.sessionId).toBe('session-1');
      expect(thread.id).not.toBe(thread.sessionId); // Sub thread: id !== sessionId
      expect(thread.assistantId).toBe('assistant-1');
      expect(thread.initialQuery).toBe('Test query');
    });
  });

  describe('createTopThread', () => {
    it('should create a top thread with id === sessionId', () => {
      const topThread = createTopThread('session-1');
      expect(topThread.id).toBe('session-1');
      expect(topThread.sessionId).toBe('session-1');
      expect(topThread.id).toBe(topThread.sessionId); // Top thread indicator
    });
  });
});
```

#### 7.1.2 Thread Validation Test

**파일**: `src/lib/validation/thread-validation.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  validateThreadOwnership,
  validateMessageThreadOwnership,
  validateMessagesConsistency,
  ThreadValidationError,
} from './thread-validation';
import type { Thread, Message } from '@/models/chat';

describe('Thread Validation', () => {
  const mockThread: Thread = {
    id: 'thread-1',
    sessionId: 'session-1',
    createdAt: new Date(),
  };

  const mockMessage: Message = {
    id: 'msg-1',
    sessionId: 'session-1',
    threadId: 'thread-1',
    role: 'user',
    content: 'Test',
    createdAt: new Date(),
  };

  describe('validateThreadOwnership', () => {
    it('should not throw when thread belongs to session', () => {
      expect(() =>
        validateThreadOwnership(mockThread, 'session-1'),
      ).not.toThrow();
    });

    it('should throw when thread does not belong to session', () => {
      expect(() => validateThreadOwnership(mockThread, 'session-2')).toThrow(
        ThreadValidationError,
      );
    });
  });

  describe('validateMessageThreadOwnership', () => {
    it('should not throw when message belongs to thread', () => {
      expect(() =>
        validateMessageThreadOwnership(mockMessage, 'thread-1'),
      ).not.toThrow();
    });

    it('should throw when message does not belong to thread', () => {
      expect(() =>
        validateMessageThreadOwnership(mockMessage, 'thread-2'),
      ).toThrow(ThreadValidationError);
    });
  });

  describe('validateMessagesConsistency', () => {
    it('should not throw when all messages belong to thread', () => {
      const messages = [mockMessage, { ...mockMessage, id: 'msg-2' }];
      expect(() =>
        validateMessagesConsistency(messages, 'thread-1'),
      ).not.toThrow();
    });

    it('should throw when any message does not belong to thread', () => {
      const messages = [
        mockMessage,
        { ...mockMessage, id: 'msg-2', threadId: 'thread-2' },
      ];
      expect(() => validateMessagesConsistency(messages, 'thread-1')).toThrow(
        ThreadValidationError,
      );
    });
  });
});
```

### 7.2 Integration Tests

#### 7.2.1 SessionContext Integration Test

**파일**: `src/context/SessionContext.test.tsx`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { SessionContextProvider, useSessionContext } from './SessionContext';
import type { Assistant } from '@/models/chat';

describe('SessionContext - Thread Integration', () => {
  const mockAssistant: Assistant = {
    id: 'assistant-1',
    name: 'Test Assistant',
    // ... other fields
  };

  beforeEach(() => {
    // Clear database before each test
  });

  it('should create session with top thread', async () => {
    const { result } = renderHook(() => useSessionContext(), {
      wrapper: SessionContextProvider,
    });

    await waitFor(async () => {
      await result.current.start([mockAssistant]);
    });

    const session = result.current.current;
    expect(session).toBeDefined();
    expect(session?.sessionThread).toBeDefined();
    expect(session?.sessionThread.id).toBe(session?.id); // Top thread: id === sessionId
    expect(session?.sessionThread.sessionId).toBe(session?.id);
  });

  it('should expose sessionThread in context', async () => {
    const { result } = renderHook(() => useSessionContext(), {
      wrapper: SessionContextProvider,
    });

    await waitFor(async () => {
      await result.current.start([mockAssistant]);
    });

    expect(result.current.sessionThread).toBeDefined();
    expect(result.current.sessionThread?.id).toBe(result.current.current?.id);
  });
});
```

#### 7.2.2 SessionHistoryContext Integration Test

**파일**: `src/context/SessionHistoryContext.test.tsx`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { SessionHistoryProvider, useSessionHistoryContext } from './SessionHistoryContext';
import type { Message } from '@/models/chat';

describe('SessionHistoryContext - Thread Support', () => {
  const sessionId = 'session-1';
  const threadId = 'thread-1';

  const mockMessage: Message = {
    id: 'msg-1',
    sessionId,
    threadId,
    role: 'user',
    content: 'Test message',
    createdAt: new Date(),
  };

  it('should add messages with explicit threadId', async () => {
    const { result } = renderHook(
      () => useSessionHistoryContext(),
      {
        wrapper: ({ children }) => (
          <SessionHistoryProvider threadId={threadId}>
            {children}
          </SessionHistoryProvider>
        ),
      },
    );

    await waitFor(async () => {
      await result.current.addMessages([mockMessage], threadId);
    });

    expect(result.current.messages).toHaveLength(1);
    expect(result.current.messages[0].threadId).toBe(threadId);
  });

  it('should filter messages by threadId via SWR key', async () => {
    // Test that SWR key includes threadId and fetches correct messages
    // This requires mocking backend.getMessagesPageForSession
  });
});
```

### 7.3 E2E Test Scenarios

#### 7.3.1 Multi-Thread Message Flow

```typescript
describe('E2E: Multi-Thread Message Flow', () => {
  it('should support messages in multiple threads within same session', async () => {
    // 1. Create session
    // 2. Send message to top thread (threadId === sessionId)
    // 3. Create new thread
    // 4. Send message to new thread
    // 5. Verify both threads have independent message histories
    // 6. Verify SWR caches are independent
  });
});
```

#### 7.3.2 Tool Execution with ThreadId

```typescript
describe('E2E: Tool Execution with ThreadId', () => {
  it('should execute tools with correct thread context', async () => {
    // 1. Create session with thread
    // 2. Execute tool with explicit threadId
    // 3. Verify ServiceContextOptions contains correct threadId
    // 4. Verify tool results are associated with correct thread
  });
});
```

### 7.4 수정이 필요한 기존 테스트

| 테스트 파일                                  | 수정 필요 사항                               |
| -------------------------------------------- | -------------------------------------------- |
| `src/context/SessionContext.test.tsx`        | Session 생성 시 sessionThread 검증 추가      |
| `src/context/SessionHistoryContext.test.tsx` | addMessages에 threadId 파라미터 추가         |
| `src/lib/rust-backend-client.test.ts`        | getMessagesPageForSession 시그니처 변경 반영 |
| Tool execution 관련 테스트                   | executeToolCall에 threadId 파라미터 추가     |

---

## 8. Web MCP Server State Cleanup 및 Lifecycle 관리

### 8.1 planning-server.ts의 상태 구조 (Thread 지원)

**현재 상태 구조 (단일 session)**:

```typescript
Map<sessionId, EphemeralState>;
```

**변경 후 (다중 thread 지원)**:

```typescript
Map<sessionId, Map<threadId, EphemeralState>>;
```

### 8.2 Session 전환 시 Cleanup 패턴

**요구사항**: Session A → Session B로 전환할 때, Session A의 모든 thread state(goals, todos, notes, thoughts)가 메모리에서 제거되어야 함.

**구현 방식**:

```typescript
class SessionStateManager {
  private sessions: Map<string, Map<string, EphemeralState>> = new Map();
  private currentSessionId: string | null = null;

  /**
   * Switch to a new session and clean up the previous session's state.
   * ✅ Old session: all threads' states are removed from memory
   * ✅ New session: states are lazily created on first tool call
   */
  setSession(sessionId: string): void {
    // ✅ CLEANUP: Remove previous session's all thread states
    if (this.currentSessionId && this.currentSessionId !== sessionId) {
      const oldThreadMap = this.sessions.get(this.currentSessionId);
      if (oldThreadMap) {
        // ✅ Clear all threads in old session
        oldThreadMap.clear();
      }
      // ✅ Remove the session entry entirely
      this.sessions.delete(this.currentSessionId);
    }

    // ✅ Set new session (lazy initialization)
    this.currentSessionId = sessionId;
    // Don't create new session entry here; it's created on first tool call
  }

  /**
   * Get or create state for (sessionId, threadId) pair.
   * ✅ Lazy initialization: state is only created when a tool is called
   */
  private getState(sessionId: string, threadId: string): EphemeralState {
    if (!this.sessions.has(sessionId)) {
      this.sessions.set(sessionId, new Map());
    }
    const threadMap = this.sessions.get(sessionId)!;
    if (!threadMap.has(threadId)) {
      threadMap.set(threadId, new EphemeralState());
    }
    return threadMap.get(threadId)!;
  }

  /**
   * Clear all sessions (for testing or complete reset).
   */
  clearAllSessions(): void {
    // ✅ Cleanup all sessions and their threads
    for (const [sessionId, threadMap] of this.sessions.entries()) {
      threadMap.clear();
      this.sessions.delete(sessionId);
    }
    this.currentSessionId = null;
  }
}
```

### 8.3 switchContext 구현 (planning-server에서)

```typescript
async switchContext(context: ServiceContextOptions): Promise<void> {
  const sessionId = context.sessionId;
  if (sessionId) {
    // ✅ This triggers cleanup of previous session's all threads
    stateManager.setSession(sessionId);
    console.info(
      `[PlanningServer] switchContext -> session: ${sessionId} (previous session cleaned up)`,
    );
  }
}
```

### 8.4 상태 Lifecycle

```text
1. Session A Active
   ├── Thread-1: EphemeralState (goal, todos, notes)
   ├── Thread-2: EphemeralState
   └── Thread-3: EphemeralState

2. switchContext(sessionId: B) Called
   └── ✅ ALL states in Session A cleared from memory
       ├── Thread-1 state deleted
       ├── Thread-2 state deleted
       └── Thread-3 state deleted

3. Session B Active (Lazy Initialization)
   ├── No states loaded yet
   └── States created on first tool call

4. Tool call on Session B, Thread-1
   └── ✅ New EphemeralState created for (B, Thread-1)
```

### 8.5 메모리 효율성

**장점**:

- 이전 session의 모든 메모리가 명시적으로 해제됨
- GC 압력 감소 (Map 자체도 제거)
- Session 전환 시 깔끔한 상태 전이

**특징**:

- **Lazy initialization**: 필요할 때만 state 생성
- **Explicit cleanup**: Session 변경 시점에 명시적으로 제거
- **No leaks**: 이전 session state가 메모리에 남지 않음

### 8.6 Backend State 관리 전략

**분석 필요**:

- Rust backend에서 (sessionId, threadId) 튜플을 key로 사용하는 구조 설계
- 현재 Tauri 명령어들이 threadId를 어떻게 받고 처리해야 하는지
- Dexie는 메시지 저장소이고, planning-server의 상태는 메모리 전용 (cleanup됨)

**가이드**:

1. `src-tauri/src/commands/messages.rs` 파일 확인
2. `messages_get_page` 명령어에 threadId 파라미터 추가 필요 여부 확인
3. Rust 측에서 별도 메모리 캐시가 필요한지 검토

### 8.2 Full UI Implementation for Thread Management

This section provides a complete UI implementation plan for thread management, including component designs, state management, and user workflows.

#### 8.2.1 Thread Context Provider

**File**: `src/context/ThreadContext.tsx` (NEW)

```typescript
import { createContext, useContext, useState, useCallback, useMemo, useEffect, ReactNode } from 'react';
import { Thread } from '@/models/chat';
import { useSessionContext } from './SessionContext';
import { getLogger } from '@/lib/logger';

const logger = getLogger('ThreadContext');

interface ThreadContextType {
  /** Currently active thread (or null if session has no thread) */
  currentThread: Thread | null;

  /** Set the active thread for message viewing/sending */
  selectThread: (threadId: string) => void;

  /** Get the effective threadId (current or fallback to session top thread) */
  getEffectiveThreadId: () => string;
}

const ThreadContext = createContext<ThreadContextType | null>(null);

export function useThreadContext(): ThreadContextType {
  const context = useContext(ThreadContext);
  if (!context) {
    throw new Error('useThreadContext must be used within ThreadContextProvider');
  }
  return context;
}

export function ThreadContextProvider({ children }: { children: ReactNode }) {
  const { current: currentSession, sessionThread } = useSessionContext();
  const [selectedThreadId, setSelectedThreadId] = useState<string | null>(null);

  // Derive current thread from selection or default to session's top thread
  const currentThread = useMemo(() => {
    if (!currentSession) return null;

    // If a specific thread is selected, use it (in future, fetch from backend/cache)
    // For now, only sessionThread exists
    if (selectedThreadId && selectedThreadId === currentSession.id) {
      return sessionThread;
    }

    // Default to top thread
    return sessionThread;
  }, [currentSession, sessionThread, selectedThreadId]);

  const selectThread = useCallback((threadId: string) => {
    logger.info('Selecting thread', { threadId });
    setSelectedThreadId(threadId);
  }, []);

  const getEffectiveThreadId = useCallback(() => {
    return currentThread?.id || currentSession?.id || '';
  }, [currentThread, currentSession]);

  // Auto-select session's top thread when session changes
  useEffect(() => {
    if (currentSession && sessionThread) {
      setSelectedThreadId(sessionThread.id);
    } else {
      setSelectedThreadId(null);
    }
  }, [currentSession, sessionThread]);

  const contextValue = useMemo(
    () => ({
      currentThread,
      selectThread,
      getEffectiveThreadId,
    }),
    [currentThread, selectThread, getEffectiveThreadId],
  );

  return (
    <ThreadContext.Provider value={contextValue}>
      {children}
    </ThreadContext.Provider>
  );
}
```

#### 8.2.2 Thread Selector Component

**File**: `src/components/ThreadSelector.tsx` (NEW)

```typescript
import { useThreadContext } from '@/context/ThreadContext';
import { useSessionContext } from '@/context/SessionContext';
import { Button } from '@/components/ui/button';
import { PlusIcon, MessageSquare } from 'lucide-react';
import { cn } from '@/lib/utils';

export function ThreadSelector() {
  const { currentThread, selectThread } = useThreadContext();
  const { current: currentSession, sessionThread } = useSessionContext();

  if (!currentSession || !sessionThread) {
    return null;
  }

  // For Phase 1: Only show top thread
  // In future phases, fetch and display sub-threads here

  return (
    <div className="flex items-center gap-2 px-4 py-2 border-b">
      <MessageSquare className="h-4 w-4 text-muted-foreground" />
      <span className="text-sm font-medium">
        {sessionThread.id === currentSession.id ? 'Main Thread' : sessionThread.id}
      </span>

      {/* Future: Add thread creation button */}
      {/* <Button
        variant="ghost"
        size="sm"
        onClick={handleCreateThread}
        className="ml-auto"
      >
        <PlusIcon className="h-4 w-4" />
        New Thread
      </Button> */}
    </div>
  );
}
```

#### 8.2.3 Integration with SessionHistoryProvider

Update `SessionHistoryProvider` usage to pass `threadId`:

**File**: `src/app/chat/page.tsx` (or wherever SessionHistoryProvider is used)

```typescript
import { SessionHistoryProvider } from '@/context/SessionHistoryContext';
import { ThreadContextProvider, useThreadContext } from '@/context/ThreadContext';
import { ThreadSelector } from '@/components/ThreadSelector';

function ChatPageContent() {
  const { getEffectiveThreadId } = useThreadContext();
  const effectiveThreadId = getEffectiveThreadId();

  return (
    <SessionHistoryProvider threadId={effectiveThreadId}>
      <div className="flex flex-col h-full">
        <ThreadSelector />
        {/* Chat messages and input */}
        <ChatMessages />
        <ChatInput />
      </div>
    </SessionHistoryProvider>
  );
}

export default function ChatPage() {
  return (
    <ThreadContextProvider>
      <ChatPageContent />
    </ThreadContextProvider>
  );
}
```

#### 8.2.4 Chat Input Integration

Update chat input to send messages to the current thread:

**File**: `src/components/ChatInput.tsx` (modifications)

```typescript
import { useThreadContext } from '@/context/ThreadContext';
import { useSessionHistory } from '@/context/SessionHistoryContext';

function ChatInput() {
  const { getEffectiveThreadId } = useThreadContext();
  const { addMessage } = useSessionHistory();
  const [input, setInput] = useState('');

  const handleSend = async () => {
    const threadId = getEffectiveThreadId();

    if (!input.trim() || !threadId) return;

    const message: Message = {
      id: createId(),
      sessionId: currentSession.id,
      threadId, // ✅ Use current thread
      role: 'user',
      content: [{ type: 'text', text: input }],
      createdAt: new Date(),
    };

    await addMessage(message);
    setInput('');
  };

  return (
    <div className="flex gap-2 p-4">
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyDown={(e) => e.key === 'Enter' && handleSend()}
        placeholder="Type a message..."
        className="flex-1 px-3 py-2 border rounded"
      />
      <Button onClick={handleSend}>Send</Button>
    </div>
  );
}
```

#### 8.2.5 Phase 2: Thread List Sidebar (Future Enhancement)

For future iterations when sub-threads are supported:

**File**: `src/components/ThreadListSidebar.tsx` (FUTURE)

```typescript
import { Thread } from '@/models/chat';
import { useThreadContext } from '@/context/ThreadContext';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { MessageSquare, Plus } from 'lucide-react';

interface ThreadListSidebarProps {
  threads: Thread[]; // Fetched from backend
  onCreateThread: () => void;
}

export function ThreadListSidebar({ threads, onCreateThread }: ThreadListSidebarProps) {
  const { currentThread, selectThread } = useThreadContext();

  return (
    <div className="w-64 border-r flex flex-col">
      <div className="p-4 border-b">
        <Button onClick={onCreateThread} className="w-full">
          <Plus className="h-4 w-4 mr-2" />
          New Thread
        </Button>
      </div>

      <ScrollArea className="flex-1">
        {threads.map((thread) => (
          <button
            key={thread.id}
            onClick={() => selectThread(thread.id)}
            className={cn(
              'w-full p-3 flex items-start gap-2 hover:bg-accent transition',
              currentThread?.id === thread.id && 'bg-accent',
            )}
          >
            <MessageSquare className="h-4 w-4 mt-1 text-muted-foreground" />
            <div className="flex-1 text-left">
              <div className="text-sm font-medium">
                {thread.id === thread.sessionId
                  ? 'Main Thread'
                  : thread.initialQuery || `Thread ${thread.id.slice(0, 8)}`}
              </div>
              {thread.assistantId && (
                <div className="text-xs text-muted-foreground">
                  with {thread.assistantId}
                </div>
              )}
            </div>
          </button>
        ))}
      </ScrollArea>
    </div>
  );
}
```

#### 8.2.6 UI/UX Workflow

**Phase 1 (Current Implementation)**:

1. User selects a session
2. ThreadContext auto-selects the session's top thread (id === sessionId)
3. SessionHistoryProvider receives threadId and loads messages
4. User sends messages to the top thread
5. No UI for thread switching (only one thread exists)

**Phase 2 (Future with Sub-threads)**:

1. User selects a session
2. ThreadListSidebar displays all threads (top + sub-threads)
3. User can click "New Thread" to create a sub-thread with initial query
4. Selecting a thread updates ThreadContext
5. SessionHistoryProvider reloads messages for the new thread
6. Chat UI updates to show the selected thread's messages

**Phase 3 (Advanced Features)**:

- Thread renaming/metadata editing
- Thread archiving (hide but don't delete)
- Thread merging (combine multiple threads)
- Unread message counts per thread
- Thread search/filtering

### 8.3 Migration 전략 세부화

**분석 필요**:

- 대량의 기존 메시지가 있을 경우 마이그레이션 성능
- 마이그레이션 중 오류 처리
- 롤백 전략

**가이드**:

1. Dexie migration hook에서 progress tracking 추가
2. 마이그레이션 실패 시 복구 로직 설계
3. 마이그레이션 전 백업 자동화

### 8.4 Thread 생명주기 관리

**분석 필요**:

- Thread 생성/삭제 API 필요 여부
- Thread 메타데이터 업데이트 방법
- Thread 아카이빙/비활성화 전략

**가이드**:

1. Thread CRUD 연산이 필요한지 검토 (현재는 top thread만 자동 생성)
2. 향후 사용자가 sub-thread를 생성할 수 있는지 결정
3. Thread 삭제 시 관련 메시지 처리 방법 정의

---

## 9. 구현 체크리스트

### Phase 1: Data Models (2-3시간)

- [ ] Thread 인터페이스 추가 (`src/models/chat.ts`)
- [ ] Message 인터페이스에 threadId 필수 필드 추가
- [ ] Session 인터페이스에 sessionThread 필드 추가
- [ ] ServiceContextOptions에 threadId 필수 필드 추가
- [ ] TypeScript 컴파일 확인

### Phase 2: Context Layer (4-5시간)

- [ ] SessionContext에 sessionThread 파생 필드 추가
- [ ] start() 메서드에서 top thread 생성 로직 추가
- [ ] SessionHistoryContext에 threadId prop 추가
- [ ] SWR key에 threadId 포함
- [ ] addMessages에 threadId 파라미터 추가
- [ ] Context 통합 테스트

### Phase 3: Backend Integration (3-4시간)

- [ ] rust-backend-client.ts API 시그니처 변경
- [ ] getMessagesPageForSession에 threadId 파라미터 추가
- [ ] upsertMessages threadId 검증 추가
- [ ] Tauri 명령어 수정 (필요 시)
- [ ] Backend integration 테스트

### Phase 4: Database (2-3시간)

- [ ] Dexie 스키마에 composite index 추가
- [ ] Migration 로직 작성 (v8)
- [ ] 기존 데이터에 threadId 추가
- [ ] 기존 세션에 sessionThread 추가
- [ ] Migration 테스트

### Phase 5: Tool Execution (2-3시간)

- [ ] executeToolCall에 threadId 파라미터 추가
- [ ] ServiceContextOptions 주입 시 threadId 포함
- [ ] Tool 호출 지점에서 threadId 전달
- [ ] Tool execution 테스트

### Phase 6: Testing (4-6시간)

- [ ] Thread utils unit tests
- [ ] Thread validation unit tests
- [ ] SessionContext integration tests
- [ ] SessionHistoryContext integration tests
- [ ] E2E multi-thread scenarios
- [ ] Migration tests
- [ ] 기존 테스트 수정 및 통과 확인

### Phase 7: Validation (2-3시간)

- [ ] `pnpm refactor:validate` 통과
- [ ] 수동 UI 테스트
- [ ] 기존 기능 회귀 테스트
- [ ] 성능 검증
- [ ] 문서 업데이트

---

## 10. 예상 소요 시간

| Phase     | 작업 내용           | 예상 시간     |
| --------- | ------------------- | ------------- |
| Phase 1   | Data Models         | 2-3시간       |
| Phase 2   | Context Layer       | 4-5시간       |
| Phase 3   | Backend Integration | 3-4시간       |
| Phase 4   | Database            | 2-3시간       |
| Phase 5   | Tool Execution      | 2-3시간       |
| Phase 6   | Testing             | 4-6시간       |
| Phase 7   | Validation          | 2-3시간       |
| **Total** |                     | **19-27시간** |

---

## 11. 리스크 및 완화 전략

| 리스크                                | 영향 | 완화 전략                                |
| ------------------------------------- | ---- | ---------------------------------------- |
| 기존 데이터 마이그레이션 실패         | 높음 | 백업 자동화, 롤백 로직, 단계적 migration |
| Backend API 변경으로 인한 호환성 문제 | 중간 | Backward compatibility 유지, 점진적 배포 |
| SWR 캐시 동기화 문제                  | 중간 | 명확한 key 전략, 테스트 강화             |
| Tool execution context 버그           | 높음 | 철저한 integration test, 로깅 강화       |
| 성능 저하 (composite index)           | 낮음 | 성능 벤치마크, 인덱스 최적화             |

---

## 12. 성공 기준

- [ ] 모든 TypeScript 컴파일 에러 해결
- [ ] `pnpm refactor:validate` 통과
- [ ] 단위 테스트 커버리지 80% 이상
- [ ] 통합 테스트 모두 통과
- [ ] 기존 기능 회귀 없음
- [ ] 신규 thread 기능 정상 동작
- [ ] 마이그레이션 성공률 100%
- [ ] 문서 업데이트 완료

---

**다음 단계**: Phase 1 - Data Models부터 시작
