# Tool Processor UIResource 감지 및 Tool Recurring 제어 로직 개선 Refactoring Plan

## 작업의 목적

`use-tool-processor.ts`에서 UIResource 감지 시 tool recurring을 올바르게 제어하도록 로직을 개선한다. 현재 코드는 UIResource가 발견되어도 tool 결과를 submit하고 나서 중단하는 모순된 구조를 가지고 있어, UIResource 발견 시 submit을 하지 않고 tool recurring을 완전히 중단하도록 수정한다.

## 현재의 상태 / 문제점

### 1. Tool Recurring 제어 로직의 모순

현재 코드는 UIResource 발견 시에도 결과를 submit하고 나서 중단을 시도하는 잘못된 구조:

```typescript
await submitRef.current(messages, currentAssistant?.id);

if (shouldStopRecurring) {
  logger.info('Tool recurring stopped due to UIResource');
  return; // ← 이미 submit했는데 중단?
}
```

**문제점:**
- `submit()`은 AI에게 tool 결과를 전달하여 새로운 tool call을 유발할 수 있음
- UIResource가 있으면 tool recurring을 중단해야 하는데 이미 submit을 해버림
- `return`은 현재 함수만 종료할 뿐, 이미 시작된 AI 응답/tool call은 막을 수 없음

### 2. 중복된 UIResource 검사 로직

동일한 UIResource 타입 가드 로직이 두 번 반복됨:

```typescript
// 첫 번째 검사 (hasUIResource)
const hasUIResource = mcpResponse.result.content.some(
  (item: unknown) => /* 긴 타입 체크 로직 */
);

// 두 번째 검사 (uiResource 추출)
const uiResource = mcpResponse.result.content.find(
  (item: unknown) => /* 동일한 긴 타입 체크 로직 */
);
```

**문제점:**
- 복잡한 타입 가드 로직이 중복되어 코드 가독성 저하
- 성능 낭비 (동일한 배열을 두 번 순회)
- 유지보수성 저하 (타입 체크 로직 변경 시 두 곳 수정 필요)

### 3. 잘못된 Tool Recurring 이해

Tool recurring은 AI가 tool 결과를 보고 추가 tool call을 하는 패턴인데, 현재 코드는 이를 잘못 이해하고 있음:

```typescript
// 모든 tool을 병렬 실행하고 완료까지 기다림
const toolResults = await Promise.all(toolPromises);

// 결과를 submit (AI에게 전달)
await submitRef.current(messages, currentAssistant?.id);

// submit 후에 "이제 중단해야지" → 말이 안됨
if (shouldStopRecurring) {
  return;
}
```

**올바른 이해:**
- UIResource가 있으면 AI가 추가 tool call을 하면 안됨
- 따라서 UIResource가 있으면 submit을 하지 말아야 함
- 모든 tool을 실행한 후 UIResource 유무에 따라 submit 여부 결정

## 추가 분석 과제

1. **UIResource 타입 가드 성능 최적화**
   - 현재 복잡한 타입 체크가 성능에 미치는 영향 분석
   - 더 효율적인 UIResource 감지 방법 검토

2. **Tool 실행 순서와 UIResource 처리 정책**
   - 여러 tool 중 일부만 UIResource를 반환하는 경우 처리 방식
   - UIResource가 없는 tool 결과들의 처리 방법

3. **Error Handling과 UIResource 상호작용**
   - Tool 실행 실패와 UIResource 감지가 동시에 발생하는 경우
   - 부분적 실패 시 UIResource 우선순위 결정

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **UIResource 감지 시 Submit 차단**: UIResource가 하나라도 발견되면 tool 결과를 submit하지 않음
2. **Tool Recurring 완전 중단**: UIResource 발견 시 AI가 추가 tool call을 할 수 없도록 완전 차단
3. **타입 가드 로직 단일화**: UIResource 검사 로직이 한 번만 실행되고 결과 재사용
4. **코드 가독성 향상**: 복잡한 타입 체크 로직을 별도 함수로 분리하여 명확성 확보

### UI 동작 시나리오

- **UIResource 없음**: 모든 tool 결과 submit → AI가 추가 tool call 가능 → tool recurring 계속
- **UIResource 있음**: UIResource 포함 메시지만 submit → AI가 추가 tool call 불가 → tool recurring 중단
- **혼재 상황**: UIResource가 있는 tool과 없는 tool 혼재 시 UIResource 우선하여 중단

### 검증 방법

1. **Unit Test**: UIResource 감지 로직의 정확성 검증
2. **Integration Test**: Tool recurring 중단 시나리오 테스트
3. **Performance Test**: 타입 가드 최적화 효과 측정
4. **Manual Test**: promptUser 도구로 실제 UIResource 시나리오 검증

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. UIResource 타입 가드 함수 분리

**파일**: `src/hooks/use-tool-processor.ts`
**수정 범위**: 중복된 타입 체크 로직을 별도 함수로 분리

```typescript
// 추가할 유틸리티 함수
const isUIResource = (item: unknown): item is { type: 'resource'; resource: { uri: string } } => {
  return (
    typeof item === 'object' &&
    item !== null &&
    'type' in item &&
    item.type === 'resource' &&
    'resource' in item &&
    typeof item.resource === 'object' &&
    item.resource !== null &&
    'uri' in item.resource &&
    typeof item.resource.uri === 'string' &&
    item.resource.uri.startsWith('ui://')
  );
};

const findUIResource = (content: unknown[]): unknown | undefined => {
  return content.find(isUIResource);
};
```

### 2. Tool 실행 루프에서 UIResource 검사 단순화

**파일**: `src/hooks/use-tool-processor.ts`
**수정 범위**: toolPromises 내부 UIResource 검사 로직 개선

```typescript
// 기존 중복 로직 제거
// const hasUIResource = mcpResponse.result.content.some(/* 복잡한 체크 */);
// const uiResource = mcpResponse.result.content.find(/* 동일한 체크 */);

// 개선된 단일 검사
if (
  !isMCPError(mcpResponse) &&
  Array.isArray(mcpResponse.result?.content)
) {
  const uiResource = findUIResource(mcpResponse.result.content);
  
  if (uiResource) {
    logger.info('Tool returned UIResource', {
      toolName,
      toolCallId: toolCall.id,
    });

    const toolResultMessage: Message = {
      id: createId(),
      assistantId: currentAssistant?.id,
      role: 'tool',
      content: mcpResponse.result.content,
      tool_call_id: toolCall.id,
      sessionId: currentSession?.id || '',
      uiResource,
    };

    return { message: toolResultMessage, stopRecurring: true };
  }
}
```

### 3. Submit 로직 조건부 실행으로 변경

**파일**: `src/hooks/use-tool-processor.ts`
**수정 범위**: tool 결과 처리 및 submit 로직 완전 재구성

```typescript
// 기존 잘못된 로직
// await submitRef.current(messages, currentAssistant?.id);
// if (shouldStopRecurring) {
//   logger.info('Tool recurring stopped due to UIResource');
//   return;
// }

// 개선된 조건부 submit 로직
const toolResults = await Promise.all(toolPromises);
const shouldStopRecurring = toolResults.some(result => result.stopRecurring);

if (shouldStopRecurring) {
  // UIResource가 있는 경우: UIResource 결과만 submit하고 tool recurring 중단
  const uiResourceMessages = toolResults
    .filter(result => result.stopRecurring)
    .map(result => result.message);
  
  if (uiResourceMessages.length > 0) {
    logger.info('Submitting UIResource results and stopping tool recurring', {
      uiResourceCount: uiResourceMessages.length,
      messageId: tcMessage.id,
    });
    
    await submitRef.current(uiResourceMessages, currentAssistant?.id);
  }
  
  logger.info('Tool recurring stopped due to UIResource');
  return; // 완전 중단 - AI가 추가 tool call 불가
}

// UIResource가 없는 경우: 모든 결과 submit하고 tool recurring 계속
const messages = toolResults.map(result => result.message);
if (messages.length > 0) {
  logger.info('Submitting all tool results', {
    resultCount: messages.length,
    messageId: tcMessage.id,
  });
  
  await submitRef.current(messages, currentAssistant?.id);
  // tool recurring 계속 진행 가능
}
```

### 4. 로깅 메시지 명확화

**파일**: `src/hooks/use-tool-processor.ts`
**수정 범위**: UIResource 관련 로깅 메시지 개선

```typescript
// 기존 모호한 로깅
// logger.info('Tool returned UIResource, stopping tool recurring');

// 개선된 명확한 로깅
logger.info('UIResource detected in tool response', {
  toolName,
  toolCallId: toolCall.id,
  willStopRecurring: true,
});

// submit 시점 로깅도 개선
logger.info('UIResource results submitted, tool recurring will be stopped', {
  uiResourceCount: uiResourceMessages.length,
  totalToolCount: toolResults.length,
});
```

## 재사용 가능한 연관 코드

### 관련 파일 경로 및 주요 기능

1. **`src/hooks/use-tool-processor.ts`**
   - 주요 기능: Tool 실행 관리, Tool recurring 제어, UIResource 감지
   - 인터페이스: `UseToolProcessorConfig`, `processToolCalls`, `isProcessing`
   - 재사용 요소: UIResource 타입 가드, tool 실행 패턴, 에러 처리

2. **`src/lib/mcp-types.ts`**
   - 주요 기능: MCP 타입 정의, 에러 처리 유틸리티
   - 인터페이스: `MCPResponse`, `isMCPError`
   - 재사용 요소: 타입 가드 패턴, MCP 표준 준수

3. **`src/models/chat.ts`**
   - 주요 기능: Chat 메시지 타입 정의
   - 인터페이스: `Message`, `ToolCall`, `UIResource`
   - 재사용 요소: 메시지 구조, UIResource 저장 방식

4. **`src/context/ChatContext.tsx`**
   - 주요 기능: Chat 상태 관리, 메시지 처리
   - 인터페이스: `submit`, `onToolExecutionChange`
   - 재사용 요소: tool 실행 상태 관리, 메시지 submit 패턴

### 재사용 가능한 패턴

- **타입 가드 패턴**: `isUIResource` 함수와 같은 명확한 타입 체크
- **조건부 처리 패턴**: UIResource 유무에 따른 분기 처리
- **병렬 실행 패턴**: `Promise.all`을 사용한 tool 병렬 실행
- **에러 핸들링 패턴**: tool 실행 실패 시 에러 메시지 생성

### 데이터 타입 및 인터페이스

- **UIResource 감지**: `type: 'resource'` && `uri.startsWith('ui://')`
- **Tool 결과**: `{ message: Message, stopRecurring: boolean }`
- **Submit 조건**: `shouldStopRecurring` 플래그 기반 분기
- **로깅 컨텍스트**: `toolName`, `toolCallId`, `executionTime` 등

### 성능 고려사항

- **단일 검사**: UIResource 검사를 한 번만 수행하여 성능 최적화
- **조건부 Submit**: 불필요한 submit 방지로 네트워크 비용 절약
- **병렬 실행**: tool 실행은 여전히 병렬로 유지하여 성능 확보
- **메모리 효율**: 중복 객체 생성 방지 및 결과 재사용
