# Refactoring Plan: Chat Context 메시지 불안정 해결

## 작업의 목적

포커스 변경 시 메시지가 사라지는 불안정 현상을 해결하여, 사용자가 다른 창으로 이동했다가 돌아와도 메시지가 안정적으로 유지되도록 개선

## 현재의 상태 / 문제점

### 주요 문제점

1. **SWR `revalidateOnFocus: true`와 streamingMessage 상태 불일치**
   - 포커스 복귀 시 SWR이 자동으로 IndexedDB를 리페치
   - streamingMessage가 아직 DB에 저장되지 않은 상태에서 컴포넌트 언마운트 시 상태 초기화
   - 결과적으로 메시지가 완전히 소실됨

2. **Critical Race Condition**

   ```tsx
   // ChatContext.tsx - 위험한 타이밍
   // 1. AI 응답 완료 → isStreaming: false
   // 2. addMessage(finalizedMessage) 호출 (비동기)
   // 3. 포커스 변경 → streamingMessage 초기화
   // 4. SWR 리페치 → DB에 메시지 없음 → 메시지 소실
   ```

3. **컴포넌트 언마운트 시 무조건적 상태 초기화**

   ```tsx
   useEffect(() => {
     return () => {
       setStreamingMessage(null); // 무조건 초기화
       setIsToolExecuting(false);
     };
   }, []);
   ```

### 재현 시나리오

1. 메시지 스트리밍 중 또는 완료 직후
2. 다른 창으로 포커스 이동
3. 다시 돌아오면 메시지 사라짐

## 추가 분석 과제

1. **IndexedDB 저장 완료 시점 확인**
   - `addMessage` 호출부터 실제 DB 저장 완료까지의 시간 측정
   - 저장 실패 케이스 분석

2. **SWR 캐시 동작 분석**
   - `revalidateOnFocus` 비활성화 시 부작용 확인
   - 다른 revalidate 옵션들의 영향도 분석

3. **React Strict Mode 영향도**
   - 개발 환경에서 컴포넌트 이중 마운트가 문제에 미치는 영향

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **메시지 지속성 보장**
   - 포커스 변경 후에도 스트리밍 중이거나 완료된 메시지가 유지됨
   - 브라우저 재로드 시에도 메시지 복원됨

2. **성능 최적화**
   - 불필요한 리페치 방지
   - 메모리 누수 없이 상태 관리

3. **테스트 케이스**
   - 메시지 스트리밍 중 포커스 변경
   - 메시지 완료 직후 포커스 변경
   - 연속된 포커스 변경
   - 브라우저 최소화/복원

## 수정이 필요한 코드 및 수정부분

### 1. SessionHistoryContext.tsx (Line 74-76)

```tsx
// 현재 코드
{
  revalidateOnFocus: true,      // 문제의 원인
  revalidateOnReconnect: true,
  revalidateIfStale: true,
}

// 수정 후
{
  revalidateOnFocus: false,     // 포커스 시 자동 리페치 비활성화
  revalidateOnReconnect: true,  // 네트워크 재연결 시만 리페치
  revalidateIfStale: false,     // 수동 갱신으로 변경
}
```

### 2. ChatContext.tsx (Line 209-213, 325-335)

```tsx
// 현재: 무조건적 초기화
useEffect(() => {
  return () => {
    setStreamingMessage(null);
    setIsToolExecuting(false);
  };
}, []);

// 수정 후: 조건부 초기화
useEffect(() => {
  return () => {
    // streamingMessage가 이미 history에 저장된 경우만 초기화
    if (streamingMessage && !streamingMessage.isStreaming) {
      const isInHistory = history.some((msg) => msg.id === streamingMessage.id);
      if (isInHistory) {
        setStreamingMessage(null);
      }
    }
    setIsToolExecuting(false);
  };
}, [streamingMessage, history]);
```

### 3. ChatContext.tsx - 새로운 영속성 보장 로직

```tsx
// 추가: streamingMessage 영속성 보장
useEffect(() => {
  const handleBeforeUnload = async () => {
    if (streamingMessage && !streamingMessage.isStreaming) {
      // 페이지 언로드 전에 메시지 강제 저장
      try {
        await addMessage(streamingMessage);
      } catch (error) {
        logger.error('Failed to persist message before unload', error);
      }
    }
  };

  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [streamingMessage, addMessage]);
```

## 재사용 가능한 연관 코드

### 관련 파일들

1. **`src/context/SessionHistoryContext.tsx`**
   - SWR Infinite 설정 관리
   - 메시지 CRUD operations
   - 페이지네이션 로직

2. **`src/context/ChatContext.tsx`**
   - streamingMessage 상태 관리
   - AI 서비스 통합
   - 메시지 제출 로직

3. **`src/lib/db/index.ts`**
   - IndexedDB 추상화 레이어
   - 메시지 저장/조회 로직

### 주요 인터페이스

```tsx
// Message 인터페이스
interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  sessionId: string;
  isStreaming?: boolean;
  // ... 기타 필드
}

// SessionHistoryContext 인터페이스
interface SessionHistoryContextType {
  messages: Message[];
  addMessage: (message: Message) => Promise<Message>;
  addMessages: (messages: Message[]) => Promise<Message[]>;
  // ... 기타 메서드
}
```

### 재사용 가능한 유틸리티

1. **메시지 검증 로직** (`validateMessage`)
2. **낙관적 업데이트 패턴** (`mutate` with rollback)
3. **세션 변경 감지 로직**

## 구현 단계

1. **1단계**: SWR 설정 변경 및 테스트
2. **2단계**: streamingMessage 영속성 로직 구현
3. **3단계**: 컴포넌트 언마운트 처리 개선
4. **4단계**: 통합 테스트 및 성능 검증

## 리스크 및 고려사항

1. **성능 영향**: `revalidateOnFocus` 비활성화로 인한 데이터 신선도 저하
2. **메모리 사용량**: 영속성 보장을 위한 추가 상태 관리
3. **호환성**: 기존 사용자 경험에 미치는 영향

## 테스트 계획

1. **단위 테스트**: 각 Context의 상태 전환 테스트
2. **통합 테스트**: 포커스 변경 시나리오 테스트
3. **성능 테스트**: 메모리 누수 및 리페치 빈도 측정
