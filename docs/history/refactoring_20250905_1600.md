# Refactoring Plan: Tool Call 연속 실행 시 User Message 컨텍스트 유지

## 작업의 목적

Tool Call이 연속적으로 발생할 때 message stack에서 user message가 사라져 AI가 사용자의 원래 요청을 잃어버리는 문제를 해결하여, 연속된 tool call 과정에서도 최소한의 사용자 맥락을 유지하도록 개선

## 현재의 상태 / 문제점

### 주요 문제점

1. **Context Window 제한으로 인한 User Message 누락**
   - `selectMessagesWithinContext` 함수가 토큰 제한에 따라 메시지를 역순으로 선택
   - Tool call 응답들이 많아질수록 초기 user message가 context window에서 제외됨
   - AI가 사용자의 원래 의도를 파악할 수 없게 됨

2. **Tool Chain 무결성 우선으로 인한 User Message 손실**

   ```typescript
   // token-utils.ts의 현재 로직
   for (let i = messages.length - 1; i >= 0; i--) {
     // 최신 메시지부터 역순으로 선택
     // Tool chain 무결성을 위해 불완전한 tool call 제거
     // → User message가 오래된 경우 우선적으로 제외됨
   }
   ```

3. **System Prompt에 사용자 맥락 부족**
   - 현재 `buildSystemPrompt`는 assistant 설정과 extension만 포함
   - User message가 없을 때 대체 맥락 제공 메커니즘 부재

### 재현 시나리오

1. 사용자가 복잡한 작업 요청 (예: "여러 파일을 분석해서 리포트 작성")
2. AI가 연속적으로 여러 tool call 실행 (파일 읽기, 분석, 작성 등)
3. Context window 제한으로 초기 user message 제외
4. AI가 원래 요청을 기억하지 못하고 맥락 없는 응답 생성

## 추가 분석 과제

1. **Message Priority 전략 검토**
   - User message 보존 우선순위 정책 수립 필요
   - Tool chain 무결성과 user context 보존 간의 균형점 탐색

2. **Token Estimation 정확도 개선**
   - 현재 BPE 기반 추정의 실제 정확도 검증
   - Provider별 토큰 계산 차이 분석

3. **Alternative Context Preservation 방법**
   - Message summarization을 통한 맥락 압축 가능성
   - User intent extraction 및 별도 보관 방안

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **User Context 지속성 보장**
   - Tool call이 연속적으로 발생해도 사용자 요청의 핵심 내용이 system prompt에 유지됨
   - AI 응답이 원래 사용자 의도와 일치함

2. **성능 최적화**
   - Context window 효율성 유지
   - 불필요한 토큰 사용 최소화

3. **테스트 케이스**
   - 5회 이상 연속 tool call 시나리오
   - 복잡한 다단계 작업 요청 처리
   - 긴 대화 이력에서의 맥락 유지

### 품질 지표

- Tool call 연속 실행 후 사용자 요청 일치율: 95% 이상
- Context window 사용 효율성: 기존 대비 10% 이내 증가
- 응답 품질 저하 없음

## 수정이 필요한 코드 및 수정부분

### 1. ChatContext.tsx - buildSystemPrompt 함수 (Line 233-244)

```tsx
// 현재 코드
const buildSystemPrompt = useCallback(async (): Promise<string> => {
  const basePrompt =
    getCurrentAssistant()?.systemPrompt || DEFAULT_SYSTEM_PROMPT;
  const extensionPrompt = await getSystemPrompt();
  const combined = [basePrompt, extensionPrompt].filter(Boolean).join('\n\n');
  logger.info('Built combined system prompt', {
    baseLength: basePrompt.length,
    extensionLength: extensionPrompt.length,
    totalLength: combined.length,
  });
  return combined;
}, [getCurrentAssistant, getSystemPrompt]);

// 수정 후
const buildSystemPrompt = useCallback(async (): Promise<string> => {
  const basePrompt =
    getCurrentAssistant()?.systemPrompt || DEFAULT_SYSTEM_PROMPT;
  const extensionPrompt = await getSystemPrompt();

  // User message 존재 여부 확인 및 last user query 추가
  const hasUserMessage = messages.some((msg) => msg.role === 'user');
  let lastUserQuerySection = '';

  if (!hasUserMessage) {
    const lastUserMessage = history
      .slice()
      .reverse()
      .find((msg) => msg.role === 'user');

    if (lastUserMessage) {
      lastUserQuerySection = `\n\nLast user query: ${lastUserMessage.content}`;
      logger.info('Added last user query to system prompt', {
        userQueryLength: lastUserMessage.content.length,
      });
    }
  }

  const combined = [basePrompt, extensionPrompt, lastUserQuerySection]
    .filter(Boolean)
    .join('\n\n');

  logger.info('Built combined system prompt', {
    baseLength: basePrompt.length,
    extensionLength: extensionPrompt.length,
    lastUserQueryLength: lastUserQuerySection.length,
    totalLength: combined.length,
    hasUserInMessages: hasUserMessage,
  });
  return combined;
}, [getCurrentAssistant, getSystemPrompt, messages, history]);
```

### 2. token-utils.ts - selectMessagesWithinContext 함수 (선택적 개선)

```typescript
// 향후 고려사항: User message 우선 보존 로직
// 현재는 system prompt 접근법으로 해결하되, 필요시 추가 개선

// 예시: User message 가중치 부여
function selectMessagesWithUserPriority(
  messages: Message[],
  safeWindow: number,
): Message[] {
  // User message에 높은 우선순위 부여하는 로직
  // 구현은 추후 필요성에 따라 결정
}
```

## 재사용 가능한 연관 코드

### 관련 파일들

1. **`src/context/ChatContext.tsx`**
   - `buildSystemPrompt`: System prompt 구성 담당
   - `submit`: AI 서비스 호출 전 메시지 처리
   - `messages`, `history`: 메시지 상태 관리

2. **`src/context/SessionHistoryContext.tsx`**
   - `history`: 영구 저장된 메시지 이력
   - `addMessage`, `addMessages`: 메시지 영속화
   - SWR을 통한 메시지 캐시 관리

3. **`src/hooks/use-ai-service.ts`**
   - `selectMessagesWithinContext`: Context window 적용
   - AI 서비스 호출 및 스트리밍 처리

4. **`src/lib/token-utils.ts`**
   - `selectMessagesWithinContext`: 메시지 필터링 로직
   - `estimateTokensBPE`: 토큰 수 추정
   - Tool chain 무결성 검증

### 주요 인터페이스

```typescript
// Message 인터페이스
interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  sessionId: string;
  tool_calls?: ToolCall[];
  tool_call_id?: string;
  // ... 기타 필드
}

// ChatContext 인터페이스
interface ChatContextValue {
  submit: (messageToAdd?: Message[], agentKey?: string) => Promise<Message>;
  isLoading: boolean;
  messages: Message[];
  cancel: () => void;
}

// AI Service Config
interface AIServiceConfig {
  tools: ToolDefinition[];
  maxRetries: number;
  maxTokens: number;
}
```

### 재사용 가능한 유틸리티

1. **User Message Detection**

   ```typescript
   const hasUserMessage = (messages: Message[]) =>
     messages.some((msg) => msg.role === 'user');
   ```

2. **Last User Message Finder**

   ```typescript
   const findLastUserMessage = (messages: Message[]) =>
     messages
       .slice()
       .reverse()
       .find((msg) => msg.role === 'user');
   ```

3. **Context Preservation Helper**
   ```typescript
   const buildUserContextSection = (lastUserMessage: Message | undefined) =>
     lastUserMessage ? `\n\nLast user query: ${lastUserMessage.content}` : '';
   ```

## 구현 단계

1. **1단계**: `buildSystemPrompt` 함수에 user context 보존 로직 추가
2. **2단계**: 로깅 및 디버깅 정보 추가로 동작 검증
3. **3단계**: 연속 tool call 시나리오 테스트
4. **4단계**: 성능 영향도 측정 및 최적화
5. **5단계**: (선택적) token-utils.ts의 message priority 로직 개선

## 리스크 및 고려사항

1. **System Prompt 길이 증가**: 사용자 쿼리 추가로 인한 토큰 사용량 증가
2. **컨텍스트 중복**: 이미 있는 user message와 system prompt의 중복 가능성
3. **성능 영향**: 매번 history 검색으로 인한 성능 오버헤드
4. **다국어 지원**: 다양한 언어의 user query 처리

## 테스트 계획

1. **단위 테스트**: `buildSystemPrompt` 함수의 user context 추가 로직
2. **통합 테스트**: 연속 tool call 시나리오에서의 맥락 유지
3. **성능 테스트**: System prompt 생성 시간 및 토큰 사용량 측정
4. **사용자 테스트**: 실제 복잡한 작업 시나리오에서의 응답 품질 검증
