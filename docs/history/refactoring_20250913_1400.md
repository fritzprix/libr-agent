# Refactoring Plan: DnDContext 통합을 통한 드래그앤드롭 시스템 일원화

## 작업의 목적

### 주요 목표

- **통합된 드래그앤드롭 시스템**: 현재 분산된 드래그앤드롭 로직을 `DnDContext`로 중앙화하여 일관성 있는 UX 제공
- **충돌 방지**: `ChatInput`과 `WorkspaceFilesPanel`이 동일한 뷰에서 렌더링될 때 이벤트 충돌 해결
- **코드 단순화**: `@dnd-kit` 제거 및 직접 Tauri 이벤트 리스너 제거로 의존성 감소
- **확장성 향상**: 새로운 드롭 존 추가 시 일관된 패턴 적용 가능

### 비즈니스 가치

- 사용자 경험 향상 (일관된 드래그앤드롭 피드백)
- 개발 생산성 향상 (통일된 드래그앤드롭 API)
- 유지보수성 개선 (중앙화된 이벤트 관리)

## 현재의 상태 / 문제점

### 1. `useFileAttachment.ts` - 직접 Tauri 리스너 사용

**문제점:**

- 전역 스코프에서 Tauri `onDragDropEvent` 직접 리스닝
- 모든 드래그 이벤트를 후크 레벨에서 처리하여 영역별 분리 불가
- 다른 컴포넌트와 이벤트 충돌 가능성

**현재 코드 패턴:**

```typescript
// Lines 281-317: useFileAttachment.ts
useEffect(() => {
  let unlisten: (() => void) | undefined;
  const setupDragDrop = async () => {
    const webview = getCurrentWebview();
    unlisten = await webview.onDragDropEvent((event) => {
      // 전역 이벤트 처리 - 영역 구분 없음
      if (event.payload.type === 'enter') {
        const isValid = validateFiles(event.payload.paths);
        setDragState(isValid ? 'valid' : 'invalid');
      }
      // ...
    });
  };
  // ...
}, []);
```

### 2. `WorkspaceFilesPanel.tsx` - 이중 드래그앤드롭 시스템

**문제점:**

- `@dnd-kit` 사용으로 인한 복잡성 증가 (11개의 관련 import)
- 내부 파일 드래그와 외부 파일 드롭이 별도 시스템으로 구현
- 불필요한 의존성 및 복잡한 센서 설정

**현재 코드 패턴:**

```typescript
// Lines 1-11: WorkspaceFilesPanel.tsx
import {
  DndContext,
  DragOverlay,
  useSensor,
  useSensors,
  PointerSensor,
  DragStartEvent,
  DragOverEvent,
  DragEndEvent,
} from '@dnd-kit/core';

// Lines 61-67: 복잡한 센서 설정
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: { distance: 8 },
  }),
);
```

### 3. `ChatInput.tsx` - 간접적 드래그 상태 의존

**문제점:**

- `useFileAttachment`에서 제공하는 `dragState`에 의존
- 자체적인 드롭 존 영역 정의 없음
- 다른 컴포넌트와의 이벤트 충돌 시 예측 불가능한 동작

## 추가 분석 과제

### 1. 우선순위 시스템 설계

- `ChatInput`과 `WorkspaceFilesPanel`이 겹치는 영역에서의 우선순위 결정
- 사용자 의도 파악을 위한 드롭 존 크기 및 위치 최적화

### 2. 파일 타입 검증 통합

- 현재 각 컴포넌트별로 다른 파일 검증 로직 존재
- 통합된 파일 타입 검증 시스템 필요성 검토

### 3. 성능 영향 분석

- `DnDContext`의 위치 기반 이벤트 라우팅이 성능에 미치는 영향
- 대량 파일 드롭 시의 이벤트 처리 최적화

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **기능적 요구사항**
   - [ ] `ChatInput`과 `WorkspaceFilesPanel`이 동일 뷰에서 각각의 영역에만 반응
   - [ ] 외부 파일 드래그 시 올바른 영역에서만 시각적 피드백 제공
   - [ ] 파일 드롭 시 의도한 컴포넌트에서만 처리

2. **코드 품질 요구사항**
   - [ ] `@dnd-kit` 의존성 제거 (package.json에서 삭제)
   - [ ] `useFileAttachment`에서 직접 Tauri 리스너 제거
   - [ ] 모든 드래그앤드롭이 `DnDContext` 패턴 사용

3. **사용자 경험 요구사항**
   - [ ] 일관된 드래그 오버 시각적 피드백
   - [ ] 잘못된 영역 드롭 시 명확한 피드백
   - [ ] 기존 기능 동작 100% 유지

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. `src/features/chat/hooks/useFileAttachment.ts`

**제거할 코드:**

```typescript
// Lines 281-317: 전체 useEffect 블록 제거
useEffect(() => {
  let unlisten: (() => void) | undefined;
  const setupDragDrop = async () => {
    try {
      const webview = getCurrentWebview();
      unlisten = await webview.onDragDropEvent((event) => {
        // 전체 이벤트 처리 로직 제거
      });
    } catch (error) {
      logger.error('Failed to setup drag and drop listener:', error);
    }
  };
  setupDragDrop();
  return () => {
    if (unlisten) unlisten();
    if (dropTimeoutRef.current) clearTimeout(dropTimeoutRef.current);
  };
}, []);
```

**수정할 return 값:**

```typescript
// 기존
return {
  dragState, // 제거
  // ... 다른 값들 유지
};

// 수정 후
return {
  // dragState 제거
  processFileDrop, // 외부에서 호출 가능하도록 노출
  validateFiles, // 파일 검증 로직 노출
  // ... 다른 값들 유지
};
```

### 2. `src/features/chat/components/ChatInput.tsx`

**추가할 import:**

```typescript
import {
  useDnDContext,
  type DragAndDropEvent,
  type DragAndDropPayload,
} from '@/context/DnDContext';
```

**추가할 상태 및 ref:**

```typescript
const chatInputRef = useRef<HTMLFormElement>(null);
const { subscribe } = useDnDContext();
const [dragState, setDragState] = useState<'none' | 'valid' | 'invalid'>(
  'none',
);
```

**추가할 useEffect:**

```typescript
useEffect(() => {
  const handler = (event: DragAndDropEvent, payload: DragAndDropPayload) => {
    if (event === 'drag-over') {
      const isValid = payload.paths ? validateFiles(payload.paths) : false;
      setDragState(isValid ? 'valid' : 'invalid');
    } else if (event === 'drop') {
      setDragState('none');
      if (payload.paths) {
        processFileDrop(payload.paths);
      }
    } else if (event === 'leave') {
      setDragState('none');
    }
  };

  const unsub = subscribe(chatInputRef, handler, { priority: 10 });
  return () => unsub();
}, [subscribe, processFileDrop, validateFiles]);
```

**수정할 JSX:**

```typescript
// 기존
<form onSubmit={handleSubmit} className="...">

// 수정 후
<form ref={chatInputRef} onSubmit={handleSubmit} className="...">
```

### 3. `src/features/chat/components/WorkspaceFilesPanel.tsx`

**제거할 imports:**

```typescript
// 전체 @dnd-kit 관련 import 제거
import {
  DndContext,
  DragOverlay,
  useSensor,
  useSensors,
  PointerSensor,
  DragStartEvent,
  DragOverEvent,
  DragEndEvent,
} from '@dnd-kit/core';
```

**추가할 import:**

```typescript
import {
  useDnDContext,
  type DragAndDropEvent,
  type DragAndDropPayload,
} from '@/context/DnDContext';
```

**제거할 상태:**

```typescript
// 제거
const [draggedItem, setDraggedItem] = useState<DraggedFile | null>(null);
const [expandTimer, setExpandTimer] = useState<number | null>(null);
const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);
const sensors = useSensors(useSensor(PointerSensor, { ... }));
```

**추가할 상태 및 ref:**

```typescript
const panelRef = useRef<HTMLDivElement>(null);
const { subscribe } = useDnDContext();
const [dragState, setDragState] = useState<{ isOver: boolean }>({
  isOver: false,
});
```

**추가할 useEffect:**

```typescript
useEffect(() => {
  const handler = (event: DragAndDropEvent, payload: DragAndDropPayload) => {
    if (event === 'drag-over') {
      setDragState({ isOver: true });
    } else if (event === 'drop') {
      setDragState({ isOver: false });
      if (payload.paths) {
        handleWorkspaceFileDrop(payload.paths);
      }
    } else if (event === 'leave') {
      setDragState({ isOver: false });
    }
  };

  const unsub = subscribe(panelRef, handler, { priority: 5 });
  return () => unsub();
}, [subscribe]);
```

**수정할 JSX (DndContext 제거):**

```typescript
// 기존 전체 DndContext 래퍼 제거
<DndContext sensors={sensors} onDragStart={handleDragStart} ...>
  {/* 컨텐츠 */}
  <DragOverlay>{/* ... */}</DragOverlay>
</DndContext>

// 수정 후
<div ref={panelRef} className="...">
  {/* 기존 컨텐츠, DragOverlay 제거 */}
</div>
```

## 재사용 가능한 연관 코드

### 1. DnDContext 패턴 (`src/context/DnDContext.tsx`)

**주요 인터페이스:**

```typescript
export interface DnDContextReturnType {
  subscribe: (
    ref: RefObject<HTMLElement>,
    handler: (event: DragAndDropEvent, payload: DragAndDropPayload) => void,
    options?: { priority?: number },
  ) => DnDUnlisten;
}
```

**활용 방법:**

- `ref`: 드롭 존으로 사용할 HTML 요소 참조
- `handler`: 드래그 이벤트 처리 함수
- `priority`: 겹치는 영역에서의 우선순위 (높을수록 우선)

### 2. 파일 처리 유틸리티 재사용

**파일 위치:** `src/features/chat/hooks/useFileAttachment.ts`

```typescript
// 재사용 가능한 함수들
export const validateFiles = (paths: string[]): boolean => { ... };
export const getMimeType = (filename: string): string => { ... };
export const processFileDrop = async (filePaths: string[]) => { ... };
```

### 3. 참조 구현 (`src/features/dnd/DnDTestPage.tsx`)

**기본 패턴:**

```typescript
const zoneRef = useRef<HTMLDivElement>(null);
const { subscribe } = useDnDContext();
const [zoneState, setZoneState] = useState({ isOver: false });

useEffect(() => {
  const handler = (event: DragAndDropEvent, payload: DragAndDropPayload) => {
    // 이벤트별 상태 업데이트 및 처리
  };
  const unsub = subscribe(zoneRef, handler, { priority: 1 });
  return () => unsub();
}, [subscribe]);
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. 단위 테스트 추가

**파일:** `src/features/chat/hooks/__tests__/useFileAttachment.test.ts`

```typescript
describe('useFileAttachment after DnDContext migration', () => {
  test('should not setup direct Tauri listeners', () => {
    // 직접 Tauri 리스너 설정하지 않는지 확인
  });

  test('should expose processFileDrop for external use', () => {
    // processFileDrop 함수가 노출되는지 확인
  });

  test('should validate files correctly', () => {
    // validateFiles 함수 동작 확인
  });
});
```

### 2. 통합 테스트 추가

**파일:** `src/features/chat/components/__tests__/ChatInput.integration.test.tsx`

```typescript
describe('ChatInput with DnDContext', () => {
  test('should register drop zone with DnDContext', () => {
    // DnDContext 구독 확인
  });

  test('should handle file drop events correctly', () => {
    // 파일 드롭 이벤트 시뮬레이션 및 처리 확인
  });

  test('should show correct drag state feedback', () => {
    // 드래그 상태별 UI 피드백 확인
  });
});
```

### 3. E2E 테스트 시나리오

**파일:** `e2e/drag-drop-conflicts.spec.ts`

```typescript
describe('Drag and Drop Conflicts Resolution', () => {
  test('should handle file drop in correct zone when both ChatInput and WorkspaceFilesPanel are visible', () => {
    // 두 컴포넌트 동시 렌더링 시 올바른 영역에서만 이벤트 처리 확인
  });

  test('should show visual feedback only in target zone', () => {
    // 드래그 오버 시 타겟 존에서만 시각적 피드백 확인
  });
});
```

### 4. 성능 테스트

**파일:** `src/context/__tests__/DnDContext.performance.test.ts`

```typescript
describe('DnDContext Performance', () => {
  test('should handle multiple zone registrations efficiently', () => {
    // 다중 존 등록 시 성능 확인
  });

  test('should route events efficiently with many zones', () => {
    // 대량 존 등록 시 이벤트 라우팅 성능 확인
  });
});
```

## 구현 단계별 가이드

### Phase 1: 의존성 정리

1. `package.json`에서 `@dnd-kit/core` 제거
2. `pnpm install`로 의존성 업데이트
3. 빌드 에러 확인

### Phase 2: useFileAttachment 마이그레이션

1. 직접 Tauri 리스너 제거
2. `processFileDrop`, `validateFiles` 함수 외부 노출
3. `dragState` 관리 제거

### Phase 3: ChatInput 마이그레이션

1. `DnDContext` 구독 추가
2. 자체 `dragState` 관리 구현
3. 드롭 존 ref 설정

### Phase 4: WorkspaceFilesPanel 마이그레이션

1. `@dnd-kit` 관련 코드 모두 제거
2. `DnDContext` 구독 추가
3. 외부 파일 드롭 처리만 구현

### Phase 5: 테스트 및 검증

1. 각 컴포넌트 개별 테스트
2. 통합 시나리오 테스트
3. 성능 및 사용성 검증

---

_작성일: 2025-09-13_
_대상 브랜치: fix/mcp-ui_
_예상 작업 시간: 4-6시간_
