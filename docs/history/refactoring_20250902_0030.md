# Refactoring Plan: Anthropic Tool Chain Tail 관리 및 벤더 간 Tool 호출 연결성 보장

## 작업의 목적

Gemini와 같은 다중 도구 호출을 지원하는 AI 서비스에서 Anthropic으로 벤더 전환 시 발생하는 "tool_use without tool_result" 400 에러를 해결한다. 특히 agentic workflow에서 많은 tool 호출이 발생한 후 메시지 윈도우 제한으로 인해 tool 체인이 불완전하게 잘릴 때, Anthropic의 엄격한 1:1 tool_use↔tool_result 매칭 규칙을 위반하지 않도록 tail 관리 로직을 구현한다.

## 현재의 상태 / 문제점

### 1. 메시지 윈도우 제한으로 인한 Tool 체인 절단

- **문제**: ChatContext의 messageWindowSize(20개) 제한과 selectMessagesWithinContext의 토큰 기반 선택으로 인해 tool 체인이 임의로 잘림
- **현상**: Gemini에서 생성된 assistant 메시지의 tool_calls는 윈도우 내에 포함되지만, 해당하는 tool 결과 메시지들이 윈도우 밖으로 밀려남
- **결과**: Anthropic API에서 "tool_use ids were found without tool_result blocks immediately after" 오류 발생

### 2. MessageNormalizer의 부적절한 Orphaned Tool 제거 로직

- **문제**: 현재 MessageNormalizer가 윈도우 내에서만 매칭을 검색하여 많은 tool 메시지를 "orphaned"로 잘못 판단
- **현상**: 로그에서 20개 이상의 "Orphaned tool message found, skipping" 경고 발생
- **결과**: tool_result는 제거되었지만 tool_use는 남아있어 Anthropic 규칙 위반

### 3. 벤더별 Tool 호출 방식 차이로 인한 호환성 문제

- **Gemini**: 다중 functionCall을 한 번에 처리, tool ID를 자체 생성
- **Anthropic**: 1:1 tool_use↔tool_result 엄격 매칭, API에서 제공한 ID 사용 필수
- **문제**: 벤더 전환 시 tool 체인의 연결성과 완전성이 보장되지 않음

### 4. 메시지 선택과 정리 로직 간의 불일치

- **selectMessagesWithinContext**: 토큰 기반으로 더 많은 메시지 선택 가능
- **MessageNormalizer**: 선택된 메시지 범위 내에서만 tool 체인 검증
- **결과**: 체인이 완전하지 않은 메시지 집합에 대해 부분적 정리만 수행

## 추가 분석 과제

### 1. 다른 벤더들의 Tool 체인 요구사항 조사

- OpenAI/Groq/Cerebras의 tool_calls 처리 방식과 제약사항 분석
- 각 벤더별로 불완전 tool 체인에 대한 허용 수준 파악
- 향후 새로운 AI 서비스 통합 시 확장 가능한 tail 관리 패턴 정의

### 2. 메시지 윈도우 최적화 전략

- Tool 체인 보존을 위한 intelligent windowing 알고리즘 검토
- 토큰 제한과 tool 체인 완전성 간의 트레이드오프 분석
- 벤더별로 다른 컨텍스트 윈도우 크기에 따른 동적 조정 방안

### 3. 성능 영향 평가

- Tool 체인 검증 로직의 computational overhead 측정
- 대용량 agentic workflow에서의 메모리 사용량 분석
- 실시간 대화 응답성에 미치는 영향 평가

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **API 오류 완전 해결**: Gemini→Anthropic 전환 시 "tool_use without tool_result" 400 에러 발생률 0%
2. **Tool 체인 완전성 보장**: 메시지 윈도우 내 모든 tool_use에 대해 대응하는 tool_result 존재 확인
3. **데이터 무결성**: 불완전한 tool 체인 제거 시 관련 assistant 메시지의 tool_use도 함께 정리
4. **로그 정리**: "Orphaned tool message" 경고 대신 정확한 tail 관리 정보 제공
5. **벤더 간 호환성**: 모든 AI 서비스 간 전환에서 tool 호출 관련 오류 발생하지 않음

### 검증 방법

- 다중 도구 호출이 포함된 긴 agentic workflow 후 벤더 전환 테스트
- 메시지 윈도우 경계에서 tool 체인이 잘리는 시나리오 테스트
- 다양한 메시지 윈도우 크기에서의 안정성 테스트
- 벤더별 tool 호출 형식 변환 정확성 검증

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. MessageNormalizer에 Anthropic용 Tool 체인 Tail 관리 로직 추가

**파일**: `src/lib/ai-service/message-normalizer.ts`

```typescript
// BEFORE (Line 25-65) - 단순 orphaned tool 제거
private static fixAnthropicToolCallChain(messages: Message[]): Message[] {
  const result: Message[] = [];

  for (let i = 0; i < messages.length; i++) {
    const currentMsg = { ...messages[i] };

    // If this is a tool message, ensure it has a corresponding assistant message before it
    if (currentMsg.role === 'tool' && currentMsg.tool_call_id) {
      // ... 기존 로직: 이전 메시지에서만 검색
    }

    result.push(currentMsg);
  }

  return result;
}

// AFTER - 전체 윈도우에서 tool 체인 완전성 보장
private static fixAnthropicToolCallChain(messages: Message[]): Message[] {
  const result: Message[] = [];
  const pendingToolUseIds = new Set<string>();
  const completedToolUseIds = new Set<string>();

  // 1단계: 모든 tool_use ID 수집
  for (const msg of messages) {
    if (msg.role === 'assistant' && msg.tool_calls) {
      msg.tool_calls.forEach(tc => pendingToolUseIds.add(tc.id));
    }
  }

  // 2단계: tool_result로 완료된 tool_use 식별
  for (const msg of messages) {
    if (msg.role === 'tool' && msg.tool_call_id && pendingToolUseIds.has(msg.tool_call_id)) {
      completedToolUseIds.add(msg.tool_call_id);
    }
  }

  // 3단계: 완전한 체인만 포함하여 메시지 재구성
  for (const msg of messages) {
    const processedMsg = { ...msg };

    if (msg.role === 'assistant' && msg.tool_calls) {
      // 완료되지 않은 tool_calls 제거
      const completedToolCalls = msg.tool_calls.filter(tc =>
        completedToolUseIds.has(tc.id)
      );

      if (completedToolCalls.length !== msg.tool_calls.length) {
        const removedIds = msg.tool_calls
          .filter(tc => !completedToolUseIds.has(tc.id))
          .map(tc => tc.id);

        logger.warn('Removing incomplete tool_calls from assistant message', {
          messageId: msg.id,
          removedToolIds: removedIds,
          completedCount: completedToolCalls.length,
          totalCount: msg.tool_calls.length,
        });
      }

      if (completedToolCalls.length > 0) {
        processedMsg.tool_calls = completedToolCalls;
        // Anthropic용 tool_use 설정 (첫 번째 tool만)
        const firstToolCall = completedToolCalls[0];
        processedMsg.tool_use = {
          id: firstToolCall.id,
          name: firstToolCall.function.name,
          input: JSON.parse(firstToolCall.function.arguments),
        };
      } else {
        delete processedMsg.tool_calls;
        delete processedMsg.tool_use;
      }
    } else if (msg.role === 'tool' && msg.tool_call_id) {
      // 완료된 tool_use에 대응하는 tool_result만 포함
      if (!completedToolUseIds.has(msg.tool_call_id)) {
        logger.debug('Skipping tool_result for incomplete tool_use', {
          messageId: msg.id,
          toolCallId: msg.tool_call_id,
        });
        continue;
      }
    }

    result.push(processedMsg);
  }

  // 대화 시작 부분의 tool 메시지 제거
  while (result.length > 0 && result[0].role === 'tool') {
    logger.warn('Removing tool message from beginning of conversation', {
      messageId: result[0].id,
    });
    result.shift();
  }

  logger.info('Anthropic tool chain tail management completed', {
    originalMessages: messages.length,
    processedMessages: result.length,
    pendingToolUses: pendingToolUseIds.size,
    completedToolUses: completedToolUseIds.size,
  });

  return result;
}
```

### 2. 메시지 선택 시 Tool 체인 경계 고려

**파일**: `src/lib/token-utils.ts`

```typescript
// 기존 selectMessagesWithinContext 함수 개선
export function selectMessagesWithinContext(
  messages: Message[],
  providerId: string,
  modelId: string,
): Message[] {
  const modelInfo = llmConfigManager.getModel(providerId, modelId);
  if (!modelInfo) {
    logger.warn(
      `Could not find model info for provider: ${providerId}, model: ${modelId}. Returning all messages.`,
    );
    return messages;
  }

  const safeWindow = Math.floor(modelInfo.contextWindow * 0.9);
  let totalTokens = 0;
  const selected: Message[] = [];

  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    const tokens = estimateTokensBPE(msg);

    if (totalTokens + tokens > safeWindow) {
      // Anthropic인 경우 tool 체인 경계 검사
      if (providerId === 'anthropic') {
        const hasIncompleteToolChain = checkIncompleteToolChain(selected, msg);
        if (hasIncompleteToolChain) {
          logger.info(
            'Adjusting context window to preserve tool chain integrity',
            {
              originalSelected: selected.length,
              contextWindow: safeWindow,
              totalTokens,
            },
          );
          // tool 체인을 완전하게 만들기 위해 일부 메시지 제거
          const adjustedSelected = removeIncompleteToolChains(selected);
          return adjustedSelected.reverse();
        }
      }

      logger.info(
        `Context window limit reached. Total tokens: ${totalTokens}, Safe window: ${safeWindow}`,
      );
      break;
    }

    selected.unshift(msg);
    totalTokens += tokens;
  }

  return selected;
}

// Tool 체인 완전성 검사 헬퍼 함수
function checkIncompleteToolChain(
  selected: Message[],
  candidateMsg: Message,
): boolean {
  // 구현: 선택된 메시지에 tool_use가 있는데 대응하는 tool_result가 없는지 확인
  // ...
}
```

### 3. 로깅 개선 및 디버깅 정보 추가

**파일**: `src/lib/ai-service/anthropic.ts`

```typescript
// convertToAnthropicMessages 메서드에 검증 로직 추가
private convertToAnthropicMessages(
  messages: Message[],
): AnthropicMessageParam[] {
  const anthropicMessages: AnthropicMessageParam[] = [];
  const toolUseIds = new Set<string>();
  const toolResultIds = new Set<string>();

  // 디버깅을 위한 tool 체인 추적
  for (const m of messages) {
    if (m.role === 'assistant' && m.tool_use) {
      toolUseIds.add(m.tool_use.id);
    } else if (m.role === 'tool' && m.tool_call_id) {
      toolResultIds.add(m.tool_call_id);
    }
  }

  // 체인 완전성 검증
  const unmatchedToolUses = Array.from(toolUseIds).filter(id => !toolResultIds.has(id));
  const unmatchedToolResults = Array.from(toolResultIds).filter(id => !toolUseIds.has(id));

  if (unmatchedToolUses.length > 0 || unmatchedToolResults.length > 0) {
    logger.error('Tool chain integrity violation detected before Anthropic API call', {
      unmatchedToolUses,
      unmatchedToolResults,
      totalMessages: messages.length,
    });
    // 이 시점에서 에러를 발생시켜 API 호출 전에 문제를 감지
    throw new Error(`Incomplete tool chain: ${unmatchedToolUses.length} unmatched tool_use, ${unmatchedToolResults.length} unmatched tool_result`);
  }

  // 기존 변환 로직...
  return anthropicMessages;
}
```

## 재사용 가능한 연관 코드

### 핵심 인터페이스 및 유틸리티

- **파일**: `src/lib/ai-service/message-normalizer.ts`
  - `MessageNormalizer` 클래스: 벤더별 메시지 정리 및 tail 관리
  - `fixAnthropicToolCallChain`: Anthropic 전용 tool 체인 완전성 보장
- **파일**: `src/lib/token-utils.ts`
  - `selectMessagesWithinContext`: 컨텍스트 윈도우 내 메시지 선택
  - Tool 체인 경계 고려 로직 추가 예정

### 벤더별 서비스 통합 포인트

- **파일**: `src/lib/ai-service/base-service.ts`
  - `prepareStreamChat`: 공통 전처리 로직
  - `sanitizeMessages`: 벤더별 메시지 정리 훅
- **파일**: `src/lib/ai-service/anthropic.ts`
  - `convertToAnthropicMessages`: Anthropic 포맷 변환 및 검증
- **파일**: `src/lib/ai-service/gemini.ts`
  - `validateGeminiMessageStack`: Gemini 메시지 스택 검증 (참고 구현)

### 메시지 플로우 관리

- **파일**: `src/context/ChatContext.tsx`
  - `submit`: 메시지 윈도우 크기 설정 및 AI 서비스 호출
- **파일**: `src/hooks/use-ai-service.ts`
  - `submit`: 메시지 전처리 및 컨텍스트 윈도우 적용

### 확장 가능한 패턴

1. **새 벤더 추가**: MessageNormalizer에 vendor-specific tail 관리 로직 추가
2. **Tool 체인 복잡도 증가**: 다중 도구 호출, 중첩 호출 등에 대한 확장
3. **성능 최적화**: Tool 체인 검증의 시간 복잡도 개선 및 캐싱 전략

이 리팩토링을 통해 AI 서비스 간 전환에서 tool 호출의 안정성과 예측 가능성을 확보하고, 특히 Anthropic의 엄격한 API 규칙을 위반하지 않는 robust한 시스템을 구축한다.
