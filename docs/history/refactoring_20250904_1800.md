# UI Resource 기본 표시 및 텍스트 분리 Refactoring Plan

## 작업의 목적

**Tool Output에서 UI Resource와 텍스트 콘텐츠를 분리하여 사용자 경험을 개선**한다. UI Resource는 사용자에게 보여주기 위한 용도이므로 기본적으로 표시되어야 하고, 텍스트는 AI Agent가 상황을 인지하기 위한 용도이므로 collapse되어도 무방하다.

### 핵심 목표

- **UI Resource 기본 표시**: 사용자 상호작용을 위한 UI 요소는 항상 펼쳐진 상태로 제공
- **텍스트 콘텐츠 분리**: AI Agent용 상황 인지 텍스트는 별도 collapse 영역에 표시
- **향상된 사용자 경험**: 중요한 UI는 바로 보이고, 부가 정보는 필요시 확인 가능
- **MCP 표준 유지**: 기존 MCPContent 배열 구조와 호환성 보장

## 현재의 상태 / 문제점

### 1. 전체 콘텐츠 일괄 Collapse

**ToolOutputBubble.tsx** - 현재 구조:

```tsx
// 문제: 텍스트와 UI Resource가 모두 함께 collapse됨
if (Array.isArray(content)) {
  return (
    <BaseBubble
      defaultExpanded={false} // 전체가 collapse
      collapsedSummary={<span>{content.length} content items</span>}
    >
      <MessageRenderer content={content} /> // 모든 콘텐츠가 숨겨짐
    </BaseBubble>
  );
}
```

### 2. UI Resource 접근성 저하

- **사용자 관점**: export된 파일, 생성된 UI 등이 기본적으로 숨겨져 있음
- **상호작용 지연**: 사용자가 매번 expand 버튼을 클릭해야 UI에 접근 가능
- **용도 불일치**: UI Resource는 즉시 사용되어야 하는 요소임에도 숨겨짐

### 3. 혼재된 콘텐츠 처리

**MessageRenderer.tsx** - 현재 구조:

```tsx
// 모든 타입이 동일하게 처리됨
{
  content.map((item, index) => {
    switch (item.type) {
      case 'text': // AI용 텍스트
      case 'resource': // 사용자용 UI
      // 둘 다 같은 레벨에서 렌더링
    }
  });
}
```

## 추가 분석 과제

### 1. 다른 콘텐츠 타입 영향도 확인

- **image, audio 타입**: UI Resource와 같이 기본 표시가 적절한지 검토
- **resource_link 타입**: 링크도 사용자 상호작용 요소로 기본 표시 고려

### 2. 기존 UI 동작 호환성

- **BaseBubble 재사용성**: 텍스트 전용 collapse에서도 기존 기능(copy, summary) 유지
- **다중 UI Resource**: 여러 UI Resource가 있을 때의 레이아웃 최적화

### 3. 성능 영향 분석

- **조건부 렌더링**: 콘텐츠 분리 로직이 렌더링 성능에 미치는 영향
- **메모리 효율성**: 필터링된 배열 생성의 최적화 방안

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **UI Resource 즉시 표시**: tool output 메시지에서 UI Resource가 expand 없이 바로 보임
2. **텍스트 분리 표시**: AI용 텍스트는 별도 collapse 영역에서 관리
3. **기존 기능 유지**: copy, summary 등 BaseBubble 기능이 텍스트 영역에서 정상 동작
4. **호환성 보장**: 기존 MCPContent 구조와 완전 호환

### 검증 방법

- export 도구 실행 후 UI Resource가 즉시 표시되는지 확인
- 텍스트가 포함된 응답에서 collapse 영역이 올바르게 분리되는지 확인
- 기존 tool output 기능들이 정상 동작하는지 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ToolOutputBubble.tsx - 메인 수정

```tsx
// 기존 코드 (수정 전)
if (Array.isArray(content)) {
  return (
    <BaseBubble
      title="Tool Output"
      badge={
        <span className="px-2 py-1 bg-primary text-primary-foreground text-xs rounded-full">
          MCP
        </span>
      }
      defaultExpanded={defaultExpanded}
      copyData={JSON.stringify(content, null, 2)}
      collapsedSummary={<span>{content.length} content items</span>}
    >
      <MessageRenderer content={content} className="text-sm" />
    </BaseBubble>
  );
}

// 수정 후 구조
if (Array.isArray(content)) {
  const textContent = content.filter(
    (item) =>
      item.type === 'text' ||
      (item.type !== 'resource' &&
        item.type !== 'image' &&
        item.type !== 'audio'),
  );
  const uiContent = content.filter(
    (item) =>
      item.type === 'resource' ||
      item.type === 'image' ||
      item.type === 'audio' ||
      item.type === 'resource_link',
  );

  return (
    <div className="space-y-4">
      {/* UI Resource는 항상 표시 */}
      {uiContent.length > 0 && (
        <MessageRenderer content={uiContent} className="text-sm" />
      )}

      {/* 텍스트는 collapse */}
      {textContent.length > 0 && (
        <BaseBubble
          title="Tool Output Details"
          badge={
            <span className="px-2 py-1 bg-primary text-primary-foreground text-xs rounded-full">
              MCP
            </span>
          }
          defaultExpanded={defaultExpanded}
          copyData={JSON.stringify(textContent, null, 2)}
          collapsedSummary={<span>{textContent.length} text items</span>}
        >
          <MessageRenderer content={textContent} className="text-sm" />
        </BaseBubble>
      )}
    </div>
  );
}
```

### 2. MessageRenderer.tsx - 필터링 지원 (선택적)

```tsx
// 기존 인터페이스 확장
interface MessageRendererProps {
  content: string | MCPContent[];
  className?: string;
  filterTypes?: string[]; // 특정 타입만 렌더링
}

// 필터링 로직 추가
{
  content
    .filter((item) => !filterTypes || filterTypes.includes(item.type))
    .map((item, index) => {
      // 기존 switch 로직
    });
}
```

## 재사용 가능한 연관 코드

### 관련 파일 및 경로

1. **핵심 수정 파일**
   - `src/features/chat/ToolOutputBubble.tsx` - 메인 로직 수정
   - `src/components/MessageRenderer.tsx` - 필터링 지원 (선택적)

2. **연관 컴포넌트**
   - `src/components/ui/BaseBubble.tsx` - collapse UI 제공
   - `src/components/ui/UIResourceRenderer.tsx` - UI Resource 렌더링
   - `src/features/chat/MessageBubbleRouter.tsx` - 메시지 라우팅

3. **타입 정의**
   - `src/lib/mcp-types.ts` - MCPContent 인터페이스
   - `src/models/chat.ts` - Message 인터페이스

### 주요 기능 및 인터페이스

```tsx
// MCPContent 타입 분류
type UIContentType = 'resource' | 'image' | 'audio' | 'resource_link';
type TextContentType = 'text';

// 콘텐츠 분리 유틸리티
const separateContentByPurpose = (content: MCPContent[]) => {
  const uiContent = content.filter((item) =>
    ['resource', 'image', 'audio', 'resource_link'].includes(item.type),
  );
  const textContent = content.filter(
    (item) =>
      !['resource', 'image', 'audio', 'resource_link'].includes(item.type),
  );

  return { uiContent, textContent };
};
```

### BaseBubble 인터페이스 활용

```tsx
interface BaseBubbleProps {
  title: string;
  badge?: React.ReactNode;
  defaultExpanded?: boolean;
  copyData?: string;
  collapsedSummary?: React.ReactNode;
  children: React.ReactNode;
  className?: string;
}
```

이 구조를 통해 UI Resource는 즉시 사용자에게 노출되고, 텍스트 정보는 필요시 확인할 수 있는 개선된 사용자 경험을 제공할 수 있습니다.
