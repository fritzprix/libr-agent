# Refactoring Plan: planning-server.ts Observation/Thinking 구조 개선

## 1. 작업의 목적

- AI Agent의 기억 한계(Context Window)를 명확히 인지시키고,
- 복잡/장기 작업의 망각 방지를 위해 목표/계획/관찰(Observation)/사고(Sequential Thinking) 관리 구조를 강화한다.
- 도구의 목적과 사용법을 명확히 하여, AI가 상황에 맞는 최적의 도구를 활용할 수 있도록 한다.

## 2. 현재의 상태 / 문제점

- `think_note` 도구가 생각/관찰/메모 등 여러 역할을 혼합하고 있어 목적이 불명확함.
- 관찰(Observation) 기록에 upper bound가 없음.
- sequential thinking(단계적 사고)와 observation(관찰) 관리가 분리되어 있지 않음.
- getServiceContext가 단순 상태 요약에 그치고, 도구 활용 안내 및 기억 한계 설명이 부족함.

## 3. 변경 이후의 상태 / 해결 판정 기준

- `think_note` → `add_observation`으로 목적 및 description 변경, 최대 10개 제한 적용.
- EphemeralState에서 observation 관리 로직 개선(최대 10개, 오래된 것 삭제).
- sequential_thinking 인터페이스/도구 추가(필요시).
- getServiceContext에서 기억 한계 안내, 도구 설명, 상황 프롬프트 포함.
- 각 도구의 목적/설명 명확화.
- 변경 후, AI가 복잡한 작업을 잊지 않고, 상황에 맞는 도구를 활용해 장기적 문제 해결이 가능해야 함.

## 4. 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 4.1 파일 경로: `/home/fritzprix/my_works/tauri-agent/src/lib/web-mcp/modules/planning-server.ts`

### 4.2 인터페이스 및 타입 정의 추가

**현재 코드 (라인 1-20):**

```typescript
import type { MCPTool, WebMCPServer } from '@/lib/mcp-types';

// Ephemeral 상태 관리 (메모리 기반)
interface Goal {
  id: number;
  name: string;
  description?: string;
  status: 'active' | 'completed' | 'paused';
  createdAt: Date;
}

interface Todo {
  id: number;
  name: string;
  description?: string;
  status: 'pending' | 'in_progress' | 'completed';
  createdAt: Date;
}

interface ThinkNote {
  id: number;
  content: string;
  tags?: string[];
  createdAt: Date;
}
```

**제안 코드:**

```typescript
import type { MCPTool, WebMCPServer } from '@/lib/mcp-types';

// Ephemeral 상태 관리 (메모리 기반)
interface Goal {
  id: number;
  name: string;
  description?: string;
  status: 'active' | 'completed' | 'paused';
  createdAt: Date;
}

interface Todo {
  id: number;
  name: string;
  description?: string;
  status: 'pending' | 'in_progress' | 'completed';
  createdAt: Date;
}

interface Observation {
  id: number;
  content: string;
  tags?: string[];
  createdAt: Date;
}

interface SequentialThinking {
  thoughtNumber: number;
  totalThoughts: number;
  thought: string;
  nextThoughtNeeded: boolean;
  createdAt: Date;
}
```

### 4.3 EphemeralState 클래스 수정

**현재 코드 (라인 21-50):**

```typescript
class EphemeralState {
  private goal: Goal | null = null;
  private todos: Todo[] = [];
  private notes: ThinkNote[] = [];

  createGoal(name: string, description?: string): Goal {
    const id = 0;
    this.goal = {
      id,
      name,
      description,
      status: 'active',
      createdAt: new Date(),
    };
    return this.goal;
  }
```

**제안 코드:**

```typescript
class EphemeralState {
  private goal: Goal | null = null;
  private todos: Todo[] = [];
  private observations: Observation[] = [];
  private sequentialThinking: SequentialThinking[] = [];

  createGoal(name: string, description?: string): Goal {
    const id = 0;
    this.goal = {
      id,
      name,
      description,
      status: 'active',
      createdAt: new Date(),
    };
    return this.goal;
  }
```

### 4.4 addObservation 메서드 추가

**현재 코드 (라인 75-85):**

```typescript
  addNote(
    content: string,
    tags?: string[],
  ): { noteId: number; notes: ThinkNote[] } {
    const id = this.notes.length;
    const note: ThinkNote = {
      id,
      content,
      tags,
      createdAt: new Date(),
    };
    this.notes.push(note);
    return { noteId: note.id, notes: this.notes };
  }
```

**제안 코드:**

```typescript
  addObservation(
    content: string,
    tags?: string[],
  ): { observationId: number; observations: Observation[] } {
    if (this.observations.length >= 10) {
      this.observations.shift(); // 가장 오래된 observation 삭제
    }
    const id = this.observations.length;
    const observation: Observation = {
      id,
      content,
      tags,
      createdAt: new Date(),
    };
    this.observations.push(observation);
    return { observationId: observation.id, observations: this.observations };
  }

  addSequentialThinking(
    thought: string,
    thoughtNumber: number,
    totalThoughts: number,
    nextThoughtNeeded: boolean,
  ): SequentialThinking {
    const thinking: SequentialThinking = {
      thoughtNumber,
      totalThoughts,
      thought,
      nextThoughtNeeded,
      createdAt: new Date(),
    };
    this.sequentialThinking.push(thinking);
    return thinking;
  }

  getObservations(): Observation[] {
    return this.observations;
  }

  getSequentialThinking(): SequentialThinking[] {
    return this.sequentialThinking;
  }
```

### 4.5 MCPTool 목록 수정

**현재 코드 (라인 130-145):**

```typescript
  {
    name: 'think_note',
    description: 'Record thoughts or notes during the session.',
    inputSchema: {
      type: 'object',
      properties: {
        content: { type: 'string' },
        tags: { type: 'array', items: { type: 'string' } },
      },
      required: ['content'],
    },
  },
```

**제안 코드:**

```typescript
  {
    name: 'add_observation',
    description: '작업/계획/실행 중 발견한 주요 사실(Observation)을 기록합니다. 최대 10개까지 저장됩니다.',
    inputSchema: {
      type: 'object',
      properties: {
        content: { type: 'string' },
        tags: { type: 'array', items: { type: 'string' } },
      },
      required: ['content'],
    },
  },
  {
    name: 'sequential_thinking',
    description: '복잡한 문제를 단계적으로 사고하며, 각 단계별 생각을 기록합니다.',
    inputSchema: {
      type: 'object',
      properties: {
        thought: { type: 'string' },
        thoughtNumber: { type: 'number' },
        totalThoughts: { type: 'number' },
        nextThoughtNeeded: { type: 'boolean' },
      },
      required: ['thought', 'thoughtNumber', 'totalThoughts', 'nextThoughtNeeded'],
    },
  },
```

### 4.6 callTool 메서드 수정

**현재 코드 (라인 190-200):**

```typescript
      case 'think_note':
        return state.addNote(
          typedArgs.content as string,
          typedArgs.tags as string[],
        );
```

**제안 코드:**

```typescript
      case 'add_observation':
        return state.addObservation(
          typedArgs.content as string,
          typedArgs.tags as string[],
        );
      case 'sequential_thinking':
        return state.addSequentialThinking(
          typedArgs.thought as string,
          typedArgs.thoughtNumber as number,
          typedArgs.totalThoughts as number,
          typedArgs.nextThoughtNeeded as boolean,
        );
```

### 4.7 getServiceContext 개선

**현재 코드 (라인 210-225):**

```typescript
  async getServiceContext(): Promise<string> {
    // reference options to avoid "declared but its value is never read" / "defined but never used"

    const goal = state.getGoal();
    const todos = state.listTodos();

    const goalText = goal ? `Current Goal: ${goal.name}` : 'No active goal';
    const activeTodos = todos.filter((t) => t.status !== 'completed');
    const todosText =
      activeTodos.length > 0
        ? `Active Todos: ${activeTodos.map((t) => t.name).join(', ')}`
        : 'No active todos';

    // Note: planning-server는 현재 전역 상태를 관리하므로 sessionId를 직접 사용하지 않지만,
    // 향후 세션별 목표/할일 관리를 위해 인터페이스는 동일하게 맞춰둠
    return `# Planning Context\n${goalText}\n${todosText}`;
  },
```

**제안 코드:**

```typescript
  async getServiceContext(): Promise<string> {
    const goal = state.getGoal();
    const todos = state.listTodos();
    const observations = state.getObservations();
    const sequentialThinking = state.getSequentialThinking();

    const goalText = goal ? `Current Goal: ${goal.name}` : 'No active goal';
    const activeTodos = todos.filter((t) => t.status !== 'completed');
    const todosText = activeTodos.length > 0
      ? `Active Todos: ${activeTodos.map((t) => t.name).join(', ')}`
      : 'No active todos';
    const observationsText = observations.length > 0
      ? `Observations: ${observations.map((o) => o.content.substring(0, 50) + '...').join('; ')}`
      : 'No observations';
    const thinkingText = sequentialThinking.length > 0
      ? `Sequential Thinking: ${sequentialThinking[sequentialThinking.length - 1].thought.substring(0, 50)}...`
      : 'No sequential thinking';

    return `
# Instruction
AI Agent는 기억의 한계(Context Window)가 있으므로, 복잡하거나 오래 걸리는 일은 반드시 목표와 할 일(todo), 관찰(Observation)로 기록해야 합니다.
아래 도구들을 활용해 목표, 할 일, 관찰, 사고를 관리하세요.

# Tools
- create_goal: 목표 생성
- add_todo: 할 일 추가
- add_observation: 주요 사실 기록(최대 10개)
- sequential_thinking: 단계적 사고 기록

# Context Information
${goalText}
${todosText}
${observationsText}
${thinkingText}

# Prompt
상황에 맞는 도구를 선택해 다음 액션을 제안하거나 실행하세요.
    `.trim();
  },
```

## 5. 구현 단계 및 순서

### 단계 1: 인터페이스 및 타입 정의

- `ThinkNote` → `Observation` 인터페이스 변경
- `SequentialThinking` 인터페이스 추가

### 단계 2: EphemeralState 클래스 수정

- `notes` → `observations` 필드 변경
- `addNote` → `addObservation` 메서드 변경 (최대 10개 제한 추가)
- `addSequentialThinking` 메서드 추가
- `getObservations`, `getSequentialThinking` getter 추가

### 단계 3: MCPTool 목록 업데이트

- `think_note` → `add_observation` 도구 변경
- `sequential_thinking` 도구 추가

### 단계 4: callTool 메서드 수정

- `think_note` case → `add_observation` 변경
- `sequential_thinking` case 추가

### 단계 5: getServiceContext 개선

- 기억 한계 안내 및 도구 설명 추가
- observations, sequentialThinking 상태 포함
- 구조화된 프롬프트 형식 적용

### 단계 6: 기존 사용법 마이그레이션

- 기존 `think_note` 호출은 `add_observation`으로 자동 변환
- 필요시 기존 데이터 마이그레이션 스크립트 작성

## 6. file 규칙

- 변경 내역 및 계획은 `./docs/history/refactoring_{yyyyMMdd_hhmm}.md`에 기록
