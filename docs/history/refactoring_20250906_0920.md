# Planning Server UI Migration: HTML to React/Remote DOM

## 작업의 목적

Planning Server의 promptUser 기능에서 사용하는 UI 렌더링 방식을 기존 HTML 문자열 기반에서 React/Remote DOM 기반으로 마이그레이션하여:

1. **현대적 UI 프레임워크 호환성**: React 환경에서의 원활한 렌더링 지원
2. **테마 일관성**: SynapticFlow 기본 테마와 호환되는 스타일링 적용
3. **유지보수성 향상**: 하드코딩된 스타일을 Tailwind CSS 클래스로 변경
4. **타입 안전성**: promptUser 인터페이스의 타입 정의 개선

## 현재의 상태 / 문제점

### 1. HTML 문자열 기반 렌더링

- `generatePromptHTML()` 함수가 하드코딩된 HTML 문자열 생성
- 인라인 스타일로 인한 테마 시스템과의 분리
- React 환경에서의 제한적 호환성

### 2. 스타일링 문제

```typescript
// 현재: 하드코딩된 색상 값
style = 'background: #2563eb; color: white; border: none;';
style = 'background: #6b7280; color: white;';
style = 'background: #f3f4f6; border: 1px solid #d1d5db;';
```

### 3. 중복된 타입 정의

```typescript
// yesno 타입이 options의 특수 케이스로 중복됨
type: 'yesno' | 'options' | 'text';
```

### 4. UI 리소스 타입 불일치

```typescript
// 현재: rawHtml 타입 사용
content: {
  type: 'rawHtml',
  htmlString: htmlContent,
}
```

## 추가 분석 과제

1. **Tailwind CSS 클래스 호환성**: 현재 프로젝트의 Tailwind 설정과 사용 가능한 클래스 확인
2. **Remote DOM 프레임워크 설정**: `@mcp-ui/client`의 React 통합 및 설정 상태 검증
3. **기존 호출부 영향도**: promptUser를 사용하는 다른 모듈들의 호환성 확인
4. **메시지 통신 패턴**: `window.parent.postMessage` 방식의 일관성 검토

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **Remote DOM 스크립트 생성**: JavaScript 기반 DOM 조작으로 UI 생성
2. **테마 호환**: Tailwind CSS 클래스 사용으로 기본 테마와 일관성 유지
3. **타입 단순화**: `yesno` 타입 제거 및 `options` 통합
4. **React 렌더링**: `UIResourceRenderer` 컴포넌트에서 정상 렌더링

### 검증 방법

- [ ] promptUser 호출 시 React 환경에서 정상 렌더링
- [ ] 기본 테마 색상과 일치하는 스타일 적용
- [ ] 사용자 입력 이벤트의 정상 동작
- [ ] 기존 기능의 backward compatibility 유지

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. promptUser 타입 정의 수정

```typescript
// 현재
inputSchema: {
  type: 'object',
  properties: {
    question: { type: 'string' },
    type: { type: 'string', enum: ['yesno', 'options', 'text'] },
    options: { type: 'array', items: { type: 'string' } },
  },
  required: ['question', 'type'],
}

// 수정 후
inputSchema: {
  type: 'object',
  properties: {
    question: { type: 'string' },
    type: { type: 'string', enum: ['options', 'text'] },
    options: { type: 'array', items: { type: 'string' } },
  },
  required: ['question', 'type'],
}
```

### 2. HTML 생성 함수를 Remote DOM 스크립트로 변경

```typescript
// 현재: generatePromptHTML()
function generatePromptHTML(params: {
  question: string;
  type: string;
  options?: string[];
}): string {
  // HTML 문자열 반환
}

// 수정 후: generatePromptRemoteDom()
function generatePromptRemoteDom(params: {
  question: string;
  type: string;
  options?: string[];
}): string {
  const { question, type, options } = params;

  let script = `
    const container = document.createElement('div');
    container.className = 'max-w-md mx-auto p-5 font-sans leading-relaxed';

    const header = document.createElement('div');
    header.className = 'mb-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded';
    
    const title = document.createElement('h3');
    title.textContent = '❓ User Input Required';
    title.className = 'text-blue-700 font-semibold mb-2 m-0';
    
    const questionText = document.createElement('div');
    questionText.textContent = "${question}";
    questionText.className = 'text-gray-800 text-base';
    
    header.appendChild(title);
    header.appendChild(questionText);
    container.appendChild(header);
  `;

  if (type === 'options' && options && options.length > 0) {
    script += `
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-4 space-y-2';
      
      ${options
        .map(
          (option) => `
        const btn = document.createElement('button');
        btn.textContent = "${option}";
        btn.className = 'block w-full mb-2 px-4 py-2 bg-gray-50 border border-gray-300 rounded text-left hover:bg-gray-100 transition-colors cursor-pointer';
        btn.onclick = () => window.parent.postMessage({type: 'prompt', payload: {prompt: '${option}'}}, '*');
        buttonContainer.appendChild(btn);
      `,
        )
        .join('')}
      
      container.appendChild(buttonContainer);
    `;
  } else if (type === 'text') {
    script += `
      const inputContainer = document.createElement('div');
      inputContainer.className = 'mt-4';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type your response...';
      input.className = 'w-full px-3 py-2 border border-gray-300 rounded mb-2 focus:outline-none focus:ring-2 focus:ring-blue-500';
      input.id = 'textInput';
      
      const submitBtn = document.createElement('button');
      submitBtn.textContent = 'Submit';
      submitBtn.className = 'px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors cursor-pointer';
      submitBtn.onclick = () => {
        if (input.value.trim()) {
          window.parent.postMessage({type: 'prompt', payload: {prompt: input.value}}, '*');
        }
      };
      
      inputContainer.appendChild(input);
      inputContainer.appendChild(submitBtn);
      container.appendChild(inputContainer);
    `;
  }

  script += `document.body.appendChild(container);`;
  return script;
}
```

### 3. UI 리소스 생성 함수 수정

```typescript
// 현재: createPromptUIResource()
function createPromptUIResource(params: {
  question: string;
  type: string;
  options?: string[];
}) {
  const htmlContent = generatePromptHTML(params);

  return createUIResource({
    uri: `ui://prompt/${Date.now()}`,
    content: {
      type: 'rawHtml',
      htmlString: htmlContent,
    },
    encoding: 'text',
  });
}

// 수정 후
function createPromptUIResource(params: {
  question: string;
  type: string;
  options?: string[];
}) {
  const remoteDomScript = generatePromptRemoteDom(params);

  return createUIResource({
    uri: `ui://prompt/${Date.now()}`,
    content: {
      type: 'remoteDom',
      script: remoteDomScript,
      framework: 'react',
    },
    encoding: 'text',
  });
}
```

### 4. callTool의 promptUser case 수정

```typescript
// yesno case 제거 및 타입 안전성 개선
case 'promptUser': {
  const params = typedArgs as {
    question: string;
    type: 'options' | 'text';
    options?: string[];
  };

  // options 타입일 때 options 배열 필수 검증
  if (params.type === 'options' && (!params.options || params.options.length === 0)) {
    throw new Error('Options array is required for options type');
  }

  const uiResource: MCPContent = createPromptUIResource(params);

  const baseResponse = normalizeToolResult(
    {
      success: true,
      question: params.question,
      type: params.type,
      options: params.options,
    },
    'promptUser',
  );

  if (baseResponse.result?.content) {
    baseResponse.result.content.unshift(uiResource);
  }

  return baseResponse;
}
```

## 재사용 가능한 연관 코드

### 관련 파일

- **`/src/lib/web-mcp/modules/planning-server.ts`**: 주 수정 대상
- **`/src/lib/mcp-types.ts`**: MCPContent, UIResource 타입 정의
- **`/docs/3rd_party/mcp-ui/react-guide.md`**: React 통합 가이드
- **`/docs/3rd_party/mcp-ui/remote-dom-guide.md`**: Remote DOM 사용법

### 주요 인터페이스

```typescript
// @mcp-ui/server
interface UIResource {
  uri: string;
  content: {
    type: 'remoteDom';
    script: string;
    framework: 'react';
  };
  encoding: 'text';
}

// 프로젝트 내부 타입
interface MCPContent {
  type: 'resource';
  resource: UIResource;
}
```

### 의존성

- **`@mcp-ui/server`**: createUIResource 함수
- **`@mcp-ui/client`**: UIResourceRenderer 컴포넌트 (렌더링 측)
- **Tailwind CSS**: 스타일링 클래스

### 테스트 고려사항

- promptUser 도구 호출 테스트
- React 환경에서의 렌더링 테스트
- 사용자 인터랙션 이벤트 테스트
- 기존 HTML 방식과의 기능 동등성 검증
