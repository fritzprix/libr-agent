# Content-Store와 Workspace 파일 동기화 리팩토링 플랜

**작성일**: 2025-09-20 18:30  
**브랜치**: fix/mcp-ui

## 작업의 목적

현재 파일 첨부 시스템에서 파일이 Content-Store에만 저장되는 구조를 개선하여, Content-Store와 Workspace에 동시에 저장되는 동기화 시스템을 구축합니다. 이를 통해 AI 에이전트가 두 저장소 모두에서 파일에 접근할 수 있도록 하여 시스템의 유연성과 확장성을 향상시킵니다.

## 현재의 상태 / 문제점

### 현재 파일 첨부 흐름

1. **DnD/파일 선택** → `pendingFiles`에 추가
2. **메시지 전송** → `commitPendingFiles()` 호출
3. **Content-Store 업로드** → `addFileInternal()` 실행
4. **완료** → `sessionFiles`로 이동

### 주요 문제점

- 파일이 Content-Store에만 저장되어 Workspace 도구들이 직접 접근 불가
- 파일의 workspace 경로 정보가 없어 다운로드/관리 기능 제한
- Content-Store와 Workspace 간 데이터 불일치 가능성

### 현재 파일 크기 제한 불일치

- **Content-Store**: 50MB
- **Workspace**: 10MB
- **UI 검증**: 50MB

## 관련 코드의 구조 및 동작 방식 Summary (Birdeye View)

### 전체 아키텍처 개요

```text
Frontend (React)                    Backend (Rust)
┌─────────────────────────┐         ┌──────────────────────┐
│ ChatInput.tsx           │         │ SecureFileManager    │
│ ├─ DnD/파일선택 처리     │         │ ├─ writeFile()       │
│ └─ handleSubmit()       │         │ └─ validate_path()   │
└─────────────────────────┘         └──────────────────────┘
           │                                  ▲
           ▼                                  │
┌─────────────────────────┐                  │
│ useFileAttachment       │                  │
│ ├─ processFileDrop()    │                  │
│ ├─ validateFiles()      │                  │
│ └─ getMimeType()        │                  │
└─────────────────────────┘                  │
           │                                  │
           ▼                                  │
┌─────────────────────────┐         ┌──────────────────────┐
│ ResourceAttachmentCtx   │         │ rust-backend-client  │
│ ├─ pendingFiles[]       │────────▶│ ├─ writeFile()       │
│ ├─ sessionFiles[]       │         │ ├─ readDroppedFile() │
│ ├─ commitPendingFiles() │         │ └─ safeInvoke()      │
│ └─ addFileInternal()    │         └──────────────────────┘
└─────────────────────────┘
           │
           ▼
┌─────────────────────────┐
│ Content-Store (Web MCP) │
│ ├─ IndexedDB 저장       │
│ ├─ addContent()         │
│ └─ listContent()        │
└─────────────────────────┘
```

### 핵심 컴포넌트별 역할

1. **ChatInput.tsx**: 사용자 파일 첨부 진입점, DnD 이벤트 처리
2. **useFileAttachment.ts**: 파일 검증, File 객체 변환, 배치 처리
3. **ResourceAttachmentContext.tsx**: 상태 관리, Content-Store 업로드 오케스트레이션
4. **rust-backend-client.ts**: Tauri 명령어 래퍼, workspace 파일 I/O
5. **Content-Store Server**: Web Worker 기반 MCP 서버, IndexedDB 영구 저장

### 현재 데이터 흐름

```mermaid
File Drop/Select → File Object → pendingFiles (UI State)
     ↓
commitPendingFiles() → addFileInternal() → Content-Store Server
     ↓
sessionFiles (SWR Cache) ← AddContentOutput ← IndexedDB
```

### 현재 구조의 한계점

- **단방향 저장**: Content-Store로만 파일이 이동
- **경로 정보 부재**: workspace 위치 추적 불가
- **도구 접근 제한**: Rust 기반 workspace 도구들이 Content-Store 파일에 직접 접근 어려움

## 추가 분석 과제

### 1. 세션별 Workspace 디렉토리 구조 설계

**분석 목표**: 효율적이고 안전한 workspace 파일 조직 구조 결정

**검토 사항**:

- 경로 패턴: `/workspace/sessions/{sessionId}/attachments/{timestamp}_{filename}` vs `/workspace/sessions/{sessionId}/files/{filename}`
- 파일명 중복 처리: 타임스탬프 prefix vs 순차번호 vs UUID
- 디렉토리 권한 및 보안 검증 (`SecurityValidator` 활용)

**조사 방법**:

- `src-tauri/src/services/secure_file_manager.rs`의 `validate_path()` 동작 분석
- 기존 workspace 도구들의 파일 접근 패턴 조사
- 세션 생명주기와 파일 정리 정책 검토

### 2. 동기화 실패 시나리오 분석

**분석 목표**: 부분 실패 시 시스템 일관성 유지 방안 설계

**핵심 시나리오**:

- Content-Store 성공 + Workspace 실패 → 사용자 알림 + 재시도 옵션
- Content-Store 실패 + Workspace 성공 → 기존 에러 처리 유지
- 네트워크/권한 오류 → 명확한 오류 메시지 제공

**조사 방법**:

- `ResourceAttachmentContext.tsx`의 현재 에러 처리 패턴 분석
- Tauri 파일 I/O 오류 케이스 테스트
- 사용자 경험 관점에서 알림 방식 설계

### 3. 기존 Content-Store 파일 마이그레이션 전략

**분석 목표**: 기존 사용자 데이터의 안전한 workspace 동기화

**검토 옵션**:

- **점진적 마이그레이션**: 사용자 요청 시에만 workspace 동기화
- **백그라운드 동기화**: 앱 실행 시 기존 파일 자동 동기화
- **선택적 동기화**: 사용자가 필요한 파일만 workspace로 이동

**조사 방법**:

- `sessionFiles` 데이터 구조 및 기존 파일 접근 패턴 분석
- Content-Store의 `listContent()` API를 통한 기존 파일 목록 조회
- 마이그레이션 시 UI/UX 영향도 평가

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **파일 첨부 시**: Content-Store와 Workspace 모두에 저장
2. **AttachmentReference**: `workspacePath` 필드 포함
3. **파일 크기 제한**: 통일된 10MB 제한 적용
4. **에러 처리**: 개별 파일 실패 시에도 다른 파일 처리 계속
5. **UI 표시**: workspace 경로 기반 다운로드/관리 기능 제공

### 판정 기준

- [ ] DnD 파일 첨부 → 양쪽 저장소에 파일 존재
- [ ] 파일 크기 10MB 초과 시 업로드 차단
- [ ] 개별 파일 동기화 실패 시 다른 파일 처리 계속
- [ ] UI에서 workspace 경로 확인 가능
- [ ] 기존 기능 동작 보장 (회귀 없음)

## 수정이 필요한 코드 및 수정부분

### 1. AttachmentReference 타입 확장

**파일**: `src/models/chat.ts`

```typescript
export interface AttachmentReference {
  storeId: string;
  contentId: string;
  filename: string;
  mimeType: string;
  size: number;
  lineCount: number;
  preview: string;
  uploadedAt: string;
  chunkCount?: number;
  lastAccessedAt?: string;
  // 기존 pending 필드들
  originalUrl?: string;
  originalPath?: string;
  file?: File;
  blobCleanup?: () => void;
  // 새로 추가
  workspacePath?: string; // Workspace에 저장된 파일 경로
}
```

### 2. 파일 크기 제한 통합

**파일**: `src/features/chat/hooks/useFileAttachment.ts`

```typescript
// 현재
if (file.size > 50 * 1024 * 1024) {

// 변경 후
const MAX_CONTENT_STORE_SIZE = 50 * 1024 * 1024; // 50MB
const MAX_WORKSPACE_SIZE = 10 * 1024 * 1024;     // 10MB
const EFFECTIVE_MAX_SIZE = Math.min(MAX_CONTENT_STORE_SIZE, MAX_WORKSPACE_SIZE); // 10MB

if (file.size > EFFECTIVE_MAX_SIZE) {
  alert(`File "${file.name}" is too large. Maximum size is ${EFFECTIVE_MAX_SIZE / (1024 * 1024)}MB.`);
```

### 3. Workspace 동기화 로직 추가

**파일**: `src/context/ResourceAttachmentContext.tsx`

```typescript
// addFileInternal 함수 수정
const addFileInternal = useCallback(
  async (
    url: string,
    mimeType: string,
    filename?: string,
    originalPath?: string,
    file?: File,
  ): Promise<AttachmentReference> => {
    // 기존 Content-Store 업로드 로직
    const contentStoreResult = await server.addContent({...});

    // 새로 추가: Workspace 저장
    let workspacePath: string | undefined;
    if (file && currentSession?.id) {
      try {
        workspacePath = await syncFileToWorkspace(file, currentSession.id);
      } catch (error) {
        logger.warn('Workspace sync failed, continuing with content-store only', {
          filename,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }

    return {
      ...contentStoreResult,
      workspacePath, // 새로 추가된 필드
    };
  },
  [server, currentSession?.id]
);
```

### 4. Workspace 동기화 서비스 함수 생성

**새 파일**: `src/lib/workspace-sync-service.ts`

```typescript
import { writeFile } from '@/lib/rust-backend-client';
import { getLogger } from '@/lib/logger';

const logger = getLogger('WorkspaceSync');

export async function syncFileToWorkspace(
  file: File,
  sessionId: string,
): Promise<string> {
  // workspace 경로 생성
  const timestamp = Date.now();
  const workspacePath = `/workspace/sessions/${sessionId}/attachments/${timestamp}_${file.name}`;

  // File 객체를 number[]로 변환
  const arrayBuffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);
  const numberArray = Array.from(uint8Array);

  // Rust 백엔드로 파일 저장
  await writeFile(workspacePath, numberArray);

  logger.info('File synced to workspace', {
    filename: file.name,
    workspacePath,
    size: file.size,
  });

  return workspacePath;
}

export function generateWorkspacePath(
  sessionId: string,
  filename: string,
): string {
  const timestamp = Date.now();
  return `/workspace/sessions/${sessionId}/attachments/${timestamp}_${filename}`;
}
```

## 재사용 가능한 연관 코드

### 기존 활용 가능한 코드

1. **rust-backend-client.ts**
   - `writeFile(filePath: string, content: number[]): Promise<void>`
   - 파일 데이터 변환 로직 재사용

2. **useFileAttachment.ts**
   - `processFileDrop()`: DnD 파일 처리 로직
   - `handleFileAttachment()`: 파일 선택 처리 로직
   - 파일 검증 및 File 객체 생성 로직

3. **ResourceAttachmentContext.tsx**
   - `commitPendingFiles()`: 배치 업로드 프레임워크
   - `addFileInternal()`: 개별 파일 업로드 로직
   - SWR 기반 상태 관리

### 확장 필요한 인터페이스

1. **FileAttachment.tsx**
   - workspace 경로 표시 기능
   - 다운로드/열기 버튼 추가

2. **ChatInput.tsx**
   - 파일 크기 제한 메시지 업데이트
   - workspace 동기화 상태 표시

## Test Code 추가 및 수정 필요 부분

### 단위 테스트

1. **workspace-sync-service.test.ts**

   ```typescript
   describe('WorkspaceSync', () => {
     test('generateWorkspacePath should create unique paths', () => {
       const path1 = generateWorkspacePath('session1', 'test.txt');
       const path2 = generateWorkspacePath('session1', 'test.txt');
       expect(path1).not.toBe(path2);
     });

     test('syncFileToWorkspace should handle file conversion', async () => {
       const mockFile = new File(['test content'], 'test.txt');
       const result = await syncFileToWorkspace(mockFile, 'session1');
       expect(result).toMatch(
         /\/workspace\/sessions\/session1\/attachments\/\d+_test\.txt/,
       );
     });
   });
   ```

2. **useFileAttachment.test.ts**

   ```typescript
   describe('File Size Validation', () => {
     test('should reject files larger than effective max size', () => {
       const largeFile = { size: 15 * 1024 * 1024 }; // 15MB
       expect(validateFileSize(largeFile)).toBe(false);
     });
   });
   ```

### 통합 테스트

1. **파일 첨부 전체 플로우 테스트**
   - DnD → pending → commit → 양쪽 저장소 확인
   - 부분 실패 시나리오 테스트

2. **Content-Store와 Workspace 동기화 테스트**
   - 동일한 파일이 양쪽에 올바르게 저장되는지 확인
   - 파일 내용 일치성 검증

### 기존 테스트 수정

1. **ResourceAttachmentContext.test.ts**
   - `commitPendingFiles` 테스트에 workspace 동기화 검증 추가
   - `AttachmentReference` 타입 변경에 따른 목업 데이터 수정

2. **ChatInput.test.ts**
   - 파일 크기 제한 변경에 따른 테스트 케이스 업데이트

## 구현 순서 권장사항

1. **Phase 1**: 타입 정의 및 기본 구조
   - `AttachmentReference` 타입 확장
   - `workspace-sync-service.ts` 생성
   - 파일 크기 제한 통합

2. **Phase 2**: 핵심 동기화 로직
   - `addFileInternal` 수정
   - 에러 처리 로직 추가
   - 단위 테스트 작성

3. **Phase 3**: UI 및 사용자 경험
   - 파일 크기 제한 메시지 업데이트
   - workspace 경로 표시 기능
   - 통합 테스트 작성

4. **Phase 4**: 최적화 및 검증
   - 성능 테스트
   - 기존 기능 회귀 테스트
   - 문서화 업데이트

## 주의 사항

- **점진적 구현**: 기존 기능을 중단하지 않도록 단계적 적용
- **에러 처리**: workspace 동기화 실패 시에도 content-store 기능은 정상 동작 보장
- **성능 고려**: 대용량 파일 처리 시 메모리 사용량 모니터링
- **사용자 피드백**: 동기화 상태를 사용자에게 명확히 전달
