# Refactoring Plan: 시스템 프롬프트 중앙 집중화 및 서비스별 컨텍스트 제공

## 작업의 목적

시스템 프롬프트 관리를 중앙 집중화하고 각 Built-in 서비스가 자신의 현재 상태 정보를 시스템 프롬프트에 제공할 수 있도록 하는 리팩토링을 수행한다.

### 세부 목표
1. **중앙 집중화**: `BuiltInToolProvider`에서 모든 Built-in 서비스의 컨텍스트를 수집하여 시스템 프롬프트로 등록
2. **서비스별 컨텍스트 제공**: 각 서비스가 `getServiceContext()` 메서드를 통해 자신의 현재 상태를 제공
3. **코드 중복 제거**: `BuiltInToolsSystemPrompt` 컴포넌트를 제거하고 기능을 `BuiltInToolProvider`로 통합
4. **확장성 향상**: 새로운 서비스 추가 시 컨텍스트 제공 로직만 구현하면 됨

## 현재의 상태 / 문제점

### 현재 아키텍처의 문제점
1. **분산된 시스템 프롬프트 관리**
   - `BuiltInToolsSystemPrompt`가 별도 컴포넌트로 존재
   - 각 프롬프트 컴포넌트가 독립적으로 `useSystemPrompt`를 사용
   - 코드 중복 및 일관성 부족

2. **서비스별 컨텍스트 정보 부족**
   - `content-store`: 정적 문자열 반환 (실제 첨부 파일 정보 미제공)
   - `planning-server`: `getServiceContext` 미구현
   - `BrowserToolProvider`: `getServiceContext` 미구현

3. **BuiltInToolProvider의 미활용**
   - 이미 `buildToolPrompt` 함수가 존재하지만 `useSystemPrompt`와 연동되지 않음
   - 각 서비스의 `getServiceContext`를 활용하지 못함

### 현재 코드 구조
```typescript
// ❌ 현재: 분산된 구조
BuiltInToolsSystemPrompt.tsx     // 별도 컴포넌트
├── useSystemPrompt 직접 사용
└── useWebMCPServer로 content-store 접근

BuiltInToolProvider.tsx          // 컨텍스트 관리만 함
├── buildToolPrompt() 존재
└── useSystemPrompt 미사용
```

## 변경 이후의 상태 / 해결 판정 기준

### 목표 아키텍처
```typescript
// ✅ 변경 후: 중앙 집중화된 구조
BuiltInToolProvider.tsx          // 시스템 프롬프트 등록
├── useSystemPrompt 사용
├── 각 서비스의 getServiceContext() 호출
├── buildToolPrompt() 개선 및 활용
└── 통합된 시스템 프롬프트 구성

각 서비스 모듈들
├── content-store: 실제 첨부 파일 정보 제공
├── planning-server: 목표/할일 목록 제공  
├── BrowserToolProvider: 브라우저 세션 정보 제공
└── getServiceContext() 구현
```

### 해결 판정 기준
1. **✅ BuiltInToolProvider가 시스템 프롬프트를 등록**
   - `useSystemPrompt`를 사용하여 시스템 프롬프트 등록
   - 각 서비스의 `getServiceContext()`를 호출하여 컨텍스트 수집
   - `BuiltInToolsSystemPrompt` 컴포넌트 제거 완료

2. **✅ 각 서비스별 getServiceContext 구현**
   - `content-store`: 현재 세션의 실제 첨부 파일 목록 제공
   - `planning-server`: 현재 목표와 할 일 목록 제공
   - `BrowserToolProvider`: 열려있는 브라우저 세션 정보 제공

3. **✅ 시스템 프롬프트 내용 검증**
   - AI가 각 서비스의 현재 상태를 인지하고 더 정확한 응답을 제공
   - 시스템 프롬프트에 중복 정보 제거
   - 새로운 서비스 추가 시 컨텍스트 자동 포함

## 수정이 필요한 코드 및 수정부분의 코드 스니펫

### 1. BuiltInToolProvider.tsx 수정
**파일**: `src/features/tools/index.tsx`

**현재 코드**:
```typescript
export function BuiltInToolProvider({ children }: BuiltInToolProviderProps) {
  // Simplified state: A single map holds the service and its status.
  const [serviceEntries, setServiceEntries] = useState<
    Map<string, ServiceEntry>
  >(new Map());

  const buildToolPrompt = useCallback(async (): Promise<string> => {
    const prompts: string[] = [];
    for (const [serviceId, entry] of serviceEntries.entries()) {
      if (entry.status === 'ready' && entry.service.getServiceContext) {
        try {
          const prompt = await entry.service.getServiceContext();
          if (prompt) {
            prompts.push(prompt);
          }
        } catch (err) {
          logger.error('Failed to get service context from service', {
            serviceId,
            err,
          });
        }
      }
    }
    return prompts.join('\n\n');
  }, [serviceEntries]);
```

**수정 후 코드**:
```typescript
export function BuiltInToolProvider({ children }: BuiltInToolProviderProps) {
  const { register: registerPrompt, unregister: unregisterPrompt } = useSystemPrompt();
  // Simplified state: A single map holds the service and its status.
  const [serviceEntries, setServiceEntries] = useState<
    Map<string, ServiceEntry>
  >(new Map());

  const buildToolPrompt = useCallback(async (): Promise<string> => {
    const prompts: string[] = [];

    // 1. Built-in Tools Section
    const availableToolsCount = availableTools.length;
    const isLoadingTauriTools = false; // No longer tracked in new API

    prompts.push(`# Available Built-in Tools

You have access to built-in tools for file operations, code execution, and web-based processing.
Tool details and usage instructions are provided separately.

**Available Built-In Tools:** ${availableToolsCount} ${isLoadingTauriTools ? '(Loading...)' : ''}

**Important Instruction:** When calling built-in tools, you MUST use the tool name exactly as it appears in the available tools list. Do not add or remove the "builtin." prefix - use it "as is" (e.g., if the tool name is "builtin.file_read", call it as "builtin.file_read", not "file_read" or "builtin.builtin.file_read").
`);

    // 2. Service Contexts Section
    for (const [serviceId, entry] of serviceEntries.entries()) {
      if (entry.status === 'ready' && entry.service.getServiceContext) {
        try {
          const prompt = await entry.service.getServiceContext();
          if (prompt) {
            prompts.push(prompt);
          }
        } catch (err) {
          logger.error('Failed to get service context from service', {
            serviceId,
            err,
          });
        }
      }
    }
    return prompts.join('\n\n');
  }, [serviceEntries, availableTools.length]);

  // Register system prompt when component mounts
  useEffect(() => {
    const promptId = registerPrompt('builtin-tools', buildToolPrompt, 1);
    return () => {
      unregisterPrompt(promptId);
    };
  }, [buildToolPrompt, registerPrompt, unregisterPrompt]);
```

### 2. content-store.ts의 getServiceContext 개선
**파일**: `src/lib/web-mcp/modules/content-store.ts`

**현재 코드**:
```typescript
async getServiceContext(): Promise<string> {
  return `# Attached Files\nThis service allows attaching and managing files. You can use tools like 'addContent', 'listContent', and 'readContent' to interact with files in the current session.`;
}
```

**수정 후 코드**:
```typescript
async getServiceContext(): Promise<string> {
  try {
    // 현재 활성화된 세션 찾기 (세션 컨텍스트 접근 방법 필요)
    // 임시로 모든 스토어의 콘텐츠를 가져오는 방식으로 구현
    const allStores = await dbService.fileStores.getPage(1, 100);
    const activeStores = allStores.items.filter(store => store.sessionId);

    if (activeStores.length === 0) {
      return '# Attached Files\nNo files currently attached.';
    }

    let allContents: ContentSummary[] = [];
    for (const store of activeStores) {
      try {
        const result = await listContent({ storeId: store.id });
        allContents.push(...result.contents);
      } catch (error) {
        logger.warn('Failed to get contents for store', { storeId: store.id, error });
      }
    }

    if (allContents.length === 0) {
      return '# Attached Files\nNo files currently attached.';
    }

    const attachedResources = allContents
      .map(c => JSON.stringify({
        storeId: c.storeId,
        contentId: c.contentId,
        preview: c.preview,
        filename: c.filename,
        type: c.mimeType,
        size: c.size,
      }))
      .join('\n');

    return `# Attached Files\n${attachedResources}`;
  } catch (error) {
    logger.error('Failed to build content-store service context', { error });
    return '# Attached Files\nError loading attached files.';
  }
}
```

### 3. planning-server.ts에 getServiceContext 추가
**파일**: `src/lib/web-mcp/modules/planning-server.ts`

**추가 코드**:
```typescript
// 기존 planningServer 객체에 추가
const planningServer: WebMCPServer = {
  // ... 기존 코드 ...
  async getServiceContext(): Promise<string> {
    const goal = this.goal ? `Current Goal: ${this.goal.name}` : 'No active goal';
    const todos = this.todos.length > 0
      ? `Active Todos: ${this.todos.filter(t => t.status !== 'completed').map(t => t.name).join(', ')}`
      : 'No active todos';

    return `# Planning Context\n${goal}\n${todos}`;
  },
  // ... 기존 코드 ...
};
```

### 4. BrowserToolProvider.tsx에 getServiceContext 추가
**파일**: `src/features/tools/BrowserToolProvider.tsx`

**수정 코드**:
```typescript
// service 객체에 getServiceContext 추가
const service = {
  // ... 기존 코드 ...
  getServiceContext: async (): Promise<string> => {
    try {
      const sessions = await listBrowserSessions();
      if (sessions.length === 0) {
        return '# Browser Sessions\nNo active browser sessions.';
      }

      const sessionInfo = sessions
        .map(s => `Session ${s.id}: ${s.url || 'No URL'} (${s.title || 'Untitled'})`)
        .join('\n');

      return `# Browser Sessions\n${sessionInfo}`;
    } catch (error) {
      logger.error('Failed to get browser sessions', { error });
      return '# Browser Sessions\nError loading browser sessions.';
    }
  },
  // ... 기존 코드 ...
};
```

### 5. Chat.tsx에서 BuiltInToolsSystemPrompt 제거
**파일**: `src/features/chat/Chat.tsx`

**현재 코드**:
```typescript
return (
  <ChatProvider>
    <BuiltInToolsSystemPrompt />
    <TimeLocationSystemPrompt />
    {/* <JailbreakSystemPrompt /> */}
    <div className="h-full w-full font-mono flex flex-col rounded-lg overflow-hidden shadow-2xl">
      {children}
      <ToolsModal
        isOpen={showToolsDetail}
        onClose={() => setShowToolsDetail(false)}
      />
    </div>
  </ChatProvider>
);
```

**수정 후 코드**:
```typescript
return (
  <ChatProvider>
    <TimeLocationSystemPrompt />
    {/* <JailbreakSystemPrompt /> */}
    <div className="h-full w-full font-mono flex flex-col rounded-lg overflow-hidden shadow-2xl">
      {children}
      <ToolsModal
        isOpen={showToolsDetail}
        onClose={() => setShowToolsDetail(false)}
      />
    </div>
  </ChatProvider>
);
```

### 6. 관련 파일 정리
1. **삭제**: `src/features/prompts/BuiltInToolsSystemPrompt.tsx`
2. **수정**: `src/features/prompts/index.ts`에서 BuiltInToolsSystemPrompt export 제거
3. **수정**: `src/features/chat/Chat.tsx`에서 BuiltInToolsSystemPrompt import 제거

## 구현 순서

1. **Phase 1**: BuiltInToolProvider에 useSystemPrompt 통합
2. **Phase 2**: 각 서비스별 getServiceContext 구현
   - content-store 개선
   - planning-server 추가
   - BrowserToolProvider 추가
3. **Phase 3**: BuiltInToolsSystemPrompt 제거 및 정리
4. **Phase 4**: 테스트 및 검증

## 예상 이점

1. **중앙 집중화**: 시스템 프롬프트 관리가 한 곳에서 이루어짐
2. **확장성**: 새로운 서비스 추가 시 컨텍스트 제공 로직만 구현
3. **일관성**: 모든 Built-in 서비스의 컨텍스트가 동일한 방식으로 제공
4. **성능**: 불필요한 컴포넌트 렌더링 제거
5. **유지보수성**: 코드 중복 제거 및 구조 단순화

## 위험 요소 및 완화 방안

1. **세션 컨텍스트 접근**: content-store에서 현재 세션 정보를 어떻게 접근할 것인가?
   - 해결: 세션 컨텍스트를 주입받거나 글로벌 상태를 활용하는 방식 고려

2. **타이밍 이슈**: BuiltInToolProvider가 SystemPromptProvider보다 먼저 초기화되는 경우
   - 해결: 초기화 순서 보장 또는 폴백 처리

3. **에러 처리**: 각 서비스의 getServiceContext 실패 시 적절한 폴백 제공
   - 해결: try-catch로 에러 처리 및 기본 메시지 제공

## 성공 지표

1. ✅ 시스템 프롬프트에 각 서비스의 현재 상태가 포함됨
2. ✅ BuiltInToolsSystemPrompt 컴포넌트가 제거됨
3. ✅ 새로운 서비스 추가 시 컨텍스트가 자동으로 포함됨
4. ✅ 코드 중복이 제거되고 구조가 단순화됨
5. ✅ AI의 응답 품질이 향상됨 (더 맥락에 맞는 응답)</content>
<parameter name="filePath">/Users/1111108/my_work/synaptic-flow/docs/history/refactoring_20250828_1658.md
