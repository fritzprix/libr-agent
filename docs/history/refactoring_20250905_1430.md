# UI Thread Block 현상 해결을 위한 리팩토링 계획

## 작업의 목적

UI thread가 tool call 실행 및 submit 과정에서 block되는 현상을 해결하여 사용자 경험을 개선하고, React 18의 concurrent features를 활용한 반응성 향상을 달성한다.

## 현재의 상태 / 문제점

### 1. ToolCaller의 순차적 Tool 실행 (Critical)

- `ChatContext.tsx`의 ToolCaller에서 `for...of` 루프로 tool call들을 순차 실행
- 각 `executeToolCall`과 `submit` 호출이 연속적으로 `await`되어 UI thread 장시간 점유
- 여러 tool call이 있을 때 사용자 입력이 지연되거나 무반응 상태 발생

### 2. Tool Name Resolution의 비효율적 처리

- `useUnifiedMCP.ts`의 `resolveToolName` 함수에서 복잡한 문자열 처리와 Map 순회
- 동일한 tool name에 대해 반복적인 resolution 작업 수행
- 캐싱 메커니즘 부재로 불필요한 연산 반복

### 3. AI Service 응답 처리의 동기적 특성

- `useAIService.ts`에서 streaming chunk 처리 시 매번 setState 호출
- chunk 단위의 잦은 re-render로 인한 성능 저하
- 대량의 streaming data 처리 시 UI 반응성 저하

### 4. useAsyncFn의 제한적 활용 및 React 패턴 위반

- 상태 관리만 수행하고 실제 비동기 작업의 UI block은 해결하지 못함
- React 18 concurrent features 미활용
- `ChatContext` 내부에서 자식 컴포넌트(`ToolCaller`)가 부모 context를 사용하는 순환 참조 구조
- `useCallback` 의존성 배열에 불안정한 참조들이 포함되어 무한 re-render 위험

## 추가 분석 과제

### 1. React 의존성 체인 분석 (Critical)

- `ChatContext.tsx`의 `ToolCaller` 컴포넌트가 `useChatContext` 훅을 사용하는 순환 참조 위험
- `useUnifiedMCP` → `useMCPServer` → `MCPServerContext` → `useRustBackend` 의존성 체인 최적화
- `useCallback` 의존성 배열의 무한 re-render 가능성 검증

### 2. Context Provider 중첩 구조 최적화

- `ChatProvider` 내부에 `ToolCaller` 컴포넌트가 직접 포함되어 결합도 증가
- `BuiltInToolProvider`, `MCPServerProvider`, `ChatProvider` 간 상태 동기화 문제
- Provider 트리 깊이로 인한 prop drilling 및 성능 영향 분석

### 3. useAsyncFn과 useTransition 호환성 검증

- `react-use`의 `useAsyncFn`과 React 18의 `useTransition` 동시 사용 시 상태 충돌 가능성
- Tool 실행 중 컴포넌트 unmount 시 메모리 누수 및 cleanup 로직 검증
- Concurrent rendering 환경에서의 race condition 분석

### 4. Tool Call ID 생성 및 추적 개선

- `createId()` 함수의 deterministic ID 생성 로직이 병렬 실행 시 충돌 가능성
- Tool call과 tool result 메시지 간 ID 매칭 무결성 검증
- 비동기 실행 순서 변경 시 tool result 순서 보장 방안

## 변경 이후의 상태 / 해결 판정 기준

### 성능 개선 목표

- Tool call 실행 시간: 70-80% 단축 (병렬화 효과)
- UI 반응 지연: 즉시 반응 (useTransition 적용)
- Tool name resolution: 90% 성능 향상 (캐싱 적용)
- 메모리 사용량: 기존 대비 20% 이내 증가 허용

### 사용자 경험 개선 기준

- Tool 실행 중 버튼 클릭, 텍스트 입력 등 즉시 반응
- 로딩 상태 UI가 즉시 표시
- 여러 tool call 실행 시에도 애플리케이션 반응성 유지
- 에러 발생 시에도 UI가 정상적으로 동작

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ChatContext.tsx - ToolCaller 병렬화

**현재 코드:**

```tsx
// ChatContext.tsx - ToolCaller 내부
for (const toolCall of tcMessage.tool_calls) {
  const mcpResponse = await executeToolCall(toolCall);
  const toolResult: Message = {
    role: 'tool',
    content: JSON.stringify(mcpResponse.result || mcpResponse.error),
    tool_call_id: toolCall.id,
    id: createId(),
    sessionId: currentSession?.id || '',
  };
  toolResults.push(toolResult);
}
await submit(toolResults, currentAssistant?.id);
```

**수정 예시:**

```tsx
// 병렬 처리로 변경
const toolPromises = tcMessage.tool_calls.map(async (toolCall) => {
  const mcpResponse = await executeToolCall(toolCall);
  return {
    role: 'tool' as const,
    content: JSON.stringify(mcpResponse.result || mcpResponse.error),
    tool_call_id: toolCall.id,
    id: createId(),
    sessionId: currentSession?.id || '',
  };
});

const toolResults = await Promise.all(toolPromises);
await submit(toolResults, currentAssistant?.id);
```

### 2. ChatContext.tsx - useTransition 적용

**현재 코드:**

```tsx
const ToolCaller: React.FC<ToolCallerProps> = ({ onToolExecutionChange }) => {
  const [{ loading }, execute] = useAsyncFn(
    async (tcMessage: Message) => {
      // ... 실행 로직 ...
    },
    [dependencies],
  );

  useEffect(() => {
    if (shouldExecuteToolCall) {
      execute(lastMessage);
    }
  }, [messages, execute, loading]);
};
```

**수정 예시:**

```tsx
const ToolCaller: React.FC<ToolCallerProps> = ({ onToolExecutionChange }) => {
  const [isPending, startTransition] = useTransition();
  const [{ loading }, execute] = useAsyncFn(
    async (tcMessage: Message) => {
      // ... 실행 로직 ...
    },
    [dependencies],
  );

  useEffect(() => {
    if (shouldExecuteToolCall) {
      startTransition(() => {
        execute(lastMessage);
      });
    }
  }, [messages, execute, loading]);
};
```

### 3. useUnifiedMCP.ts - Tool Name Resolution 캐싱

**현재 코드:**

```tsx
const resolveToolName = useCallback(
  (calledToolName: string): string | null => {
    // 1. Check exact match first
    if (toolTypeMap.has(calledToolName)) {
      return calledToolName;
    }

    // 2. Look for tools that end with the called name
    for (const [registeredName, type] of toolTypeMap.entries()) {
      // ... 복잡한 해석 로직 ...
    }
    return null;
  },
  [toolTypeMap, getToolNamespace],
);
```

**수정 예시:**

```tsx
const resolutionCacheRef = useRef<Map<string, string | null>>(new Map());

const resolveToolName = useCallback(
  (calledToolName: string): string | null => {
    // 캐시 체크
    const cached = resolutionCacheRef.current.get(calledToolName);
    if (cached !== undefined) {
      return cached;
    }

    // 기존 해석 로직
    let resolved: string | null = null;
    if (toolTypeMap.has(calledToolName)) {
      resolved = calledToolName;
    } else {
      // ... 기존 복잡한 해석 로직 ...
    }

    // 캐시에 저장
    resolutionCacheRef.current.set(calledToolName, resolved);
    return resolved;
  },
  [toolTypeMap, getToolNamespace],
);
```

### 5. React Context Architecture 개선

**현재 코드:**

```tsx
// ChatContext.tsx - 순환 참조 구조
export function ChatProvider({ children }: ChatProviderProps) {
  // ... 상태 관리 ...

  return (
    <ChatContext.Provider value={value}>
      {children}
      {/* ToolCaller가 같은 Context를 사용하는 순환 구조 */}
      <ToolCaller onToolExecutionChange={setIsToolExecuting} />
    </ChatContext.Provider>
  );
}

const ToolCaller: React.FC<ToolCallerProps> = ({ onToolExecutionChange }) => {
  // ChatContext를 사용하여 순환 참조 발생
  const { messages, submit } = useChatContext();
  const { executeToolCall } = useUnifiedMCP();

  // 불안정한 의존성 배열
  const [{ loading }, execute] = useAsyncFn(/* ... */, [
    submit, // 매번 새로운 함수 참조
    executeToolCall, // 매번 새로운 함수 참조
    currentAssistant, // 객체 참조
    currentSession, // 객체 참조
    onToolExecutionChange, // 함수 참조
  ]);
};
```

**수정 예시:**

```tsx
// 1. ToolCaller를 Provider 외부로 분리
export function ChatProvider({ children }: ChatProviderProps) {
  // ... 상태 관리 ...

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
}

// 2. ToolCaller를 별도 Provider로 관리하거나 커스텀 훅으로 분리
export function useToolCallProcessor() {
  const [isPending, startTransition] = useTransition();

  // 안정적인 참조 사용
  const stableExecuteRef = useRef<typeof executeToolCall>();
  const stableSubmitRef = useRef<typeof submit>();

  useEffect(() => {
    stableExecuteRef.current = executeToolCall;
    stableSubmitRef.current = submit;
  });

  const processToolCalls = useCallback((message: Message) => {
    startTransition(async () => {
      // 병렬 처리 로직
    });
  }, []); // 빈 의존성 배열로 안정성 확보

  return { processToolCalls, isPending };
}
```

### 6. useCallback 의존성 최적화

**현재 코드:**

```tsx
// useUnifiedMCP.ts - 불안정한 의존성들
const executeToolCall = useCallback(
  async (toolCall: ToolCall): Promise<MCPResponse> => {
    // ... 실행 로직 ...
  },
  [
    getToolType, // 매번 새로운 함수
    getToolNamespace, // 매번 새로운 함수
    executeExternalMCP, // 외부 hook에서 온 불안정한 참조
    executeRustBuiltinTool, // 외부 hook에서 온 불안정한 참조
    toolTypeMap, // Map 객체 참조
  ],
);
```

**수정 예시:**

```tsx
// Ref를 사용한 안정적인 참조 관리
const executeToolCall = useCallback(
  async (toolCall: ToolCall): Promise<MCPResponse> => {
    // 최신 참조를 ref에서 가져와 사용
    const currentGetToolType = getToolTypeRef.current;
    const currentExecuteExternal = executeExternalRef.current;
    // ... 실행 로직 ...
  },
  [], // 빈 의존성 배열로 최적화
);

// 또는 useStableHandler 패턴 활용
const executeToolCall = useStableHandler(
  async (toolCall: ToolCall): Promise<MCPResponse> => {
    // ... 실행 로직 ...
  },
);
```

## 재사용 가능한 연관 코드

### 주요 파일들

#### Core Context 파일들

- **`src/context/ChatContext.tsx`**: 메인 채팅 로직, ToolCaller 컴포넌트 포함
  - `submit` 함수: 메시지 처리 및 AI 서비스 호출
  - `ToolCaller` 컴포넌트: tool call 실행 관리
  - `useAsyncFn`: Tool 실행 비동기 상태 관리

#### Hook 파일들

- **`src/hooks/use-unified-mcp.ts`**: 통합 MCP tool 관리
  - `executeToolCall` 함수: tool call 실행의 핵심 함수
  - `resolveToolName` 함수: tool name 해석 로직
  - `toolTypeMap` 관리: tool type mapping 최적화 대상

- **`src/hooks/use-ai-service.ts`**: AI 서비스 통신
  - `submit` 함수: AI 모델과의 통신 및 streaming 처리
  - streaming chunk 처리 로직

- **`src/hooks/use-mcp-server.ts`**: MCP 서버 관리 wrapper

#### Context Provider 파일들

- **`src/context/MCPServerContext.tsx`**: MCP 서버 상태 관리
  - `executeToolCall` 함수: 실제 MCP tool 실행
  - `useAsyncFn` 활용: 서버 연결 관리

### 활용 가능한 유틸리티

#### Performance 관련

- **`src/lib/utils.ts`**:
  - `throttlePromise` 함수: 비동기 함수 throttling
  - 성능 최적화에 활용 가능

#### Hook 패턴

- **`src/hooks/use-tool-handler.ts`**:
  - `useStableHandler`: 안정적인 핸들러 생성
  - tool call 처리에서 불필요한 re-render 방지

#### Browser 관련

- **`src/hooks/use-browser-invoker.ts`**:
  - 비blocking 스크립트 실행 패턴
  - polling 메커니즘 참고 가능

### 인터페이스 및 타입

#### 핵심 타입들

```tsx
// src/models/chat.ts
interface ToolCall {
  id: string;
  function: {
    name: string;
    arguments: string;
  };
}

interface Message {
  id: string;
  role: 'user' | 'assistant' | 'tool';
  content: string;
  tool_calls?: ToolCall[];
  // ...
}
```

#### MCP 관련 타입들

```tsx
// src/lib/mcp-types.ts
interface MCPResponse {
  jsonrpc: '2.0';
  id: string;
  result?: unknown;
  error?: MCPError;
}

interface MCPTool {
  name: string;
  description: string;
  inputSchema: object;
}
```

### 확장 고려사항

#### React 아키텍처 개선 영역

1. **Context Provider 분리**: Chat, Tool, MCP 관련 Provider들의 책임 분리
2. **Custom Hook 최적화**: 불안정한 의존성 제거를 위한 ref 패턴 활용
3. **Concurrent Features 활용**: useTransition, useDeferredValue 등 적극 활용
4. **Error Boundary 개선**: Tool 실행 오류가 전체 앱을 중단시키지 않도록 격리

#### React 패턴 준수사항

1. **단방향 데이터 플로우**: Context 내부에서 자식이 부모 Context를 사용하지 않도록 구조 개선
2. **의존성 안정성**: useCallback, useMemo의 의존성 배열에서 불안정한 참조 제거
3. **컴포넌트 분리**: ToolCaller를 독립적인 훅 또는 별도 Provider로 분리
4. **상태 동기화**: 여러 Context 간 상태 불일치 방지를 위한 동기화 메커니즘

#### 성능 최적화 고려사항

1. **React DevTools Profiler**: re-render 패턴 분석 및 최적화 포인트 식별
2. **메모이제이션 전략**: 적절한 React.memo, useMemo 활용으로 불필요한 re-render 방지
3. **배치 업데이트**: setState 호출 패턴 최적화로 렌더링 횟수 최소화
4. **Concurrent Rendering**: React 18의 자동 배치 기능 활용
