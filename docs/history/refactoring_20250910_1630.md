# Planning Server 히스토리 관리 개선 리팩터링 계획

**일시**: 2025년 9월 10일 16:30  
**대상 파일**: `src/lib/web-mcp/modules/planning-server.ts`

## 작업의 목적

Planning Server의 상태 관리에서 완료된 Todo와 Clear된 Goal의 히스토리를 제한적으로 유지하여, 복잡한 작업에서 이전 수행 기록을 통해 컨텍스트를 파악할 수 있도록 개선합니다.

현재 상황에서는 완료된 Todo가 무제한으로 쌓이거나, Clear된 Goal이 완전히 사라져 이전 작업 맥락을 잃는 문제를 해결합니다.

## 현재의 상태 / 문제점

### Todo 관리 문제점

- **무제한 누적**: `toggleTodo()`에서 완료된 Todo가 계속 `todos` 배열에 남아있어 과도하게 쌓임
- **컨텍스트 혼란**: 오래된 완료 Todo와 현재 작업 Todo가 구분되지 않아 혼란 야기
- **메모리 비효율**: 불필요한 완료 Todo가 메모리에 지속적으로 남아있음

### Goal 관리 문제점

- **완전 삭제**: `clearGoal()`에서 기존 Goal이 `null`로 설정되어 이전 작업 맥락 상실
- **연속성 부족**: 새로운 Goal 설정 시 이전 Goal과의 연관성을 파악할 수 없음
- **디버깅 어려움**: Goal 변경 히스토리가 없어 작업 흐름 추적 곤란

### getServiceContext 출력 문제점

- **히스토리 부재**: 완료된 작업과 이전 Goal에 대한 정보가 컨텍스트에 포함되지 않음
- **제한된 컨텍스트**: 현재 상태만 표시되어 작업 진행 상황을 파악하기 어려움

## 추가 분석 과제

1. **최적 히스토리 크기**: 완료된 Todo 2개, 이전 Goal 1개가 적절한지 실제 사용 패턴을 통해 검증 필요
2. **메모리 사용량**: 히스토리 유지로 인한 메모리 사용량 증가 모니터링
3. **UI 표시 방법**: 히스토리 정보를 사용자에게 어떻게 표시할지 UX 관점에서 검토 필요

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **Todo 히스토리 관리**: 완료된 Todo가 최대 2개까지만 유지됨
2. **Goal 히스토리 유지**: 이전에 Clear된 Goal이 1개 보존됨
3. **컨텍스트 향상**: `getServiceContext()`에서 히스토리 정보가 포함된 풍부한 컨텍스트 제공
4. **기존 기능 유지**: 모든 기존 API가 동일하게 작동함

### 검증 방법

- Todo를 3개 이상 완료했을 때 오래된 것이 자동 삭제되는지 확인
- Goal을 Clear한 후 이전 Goal 정보가 보존되는지 확인
- getServiceContext 출력에 히스토리 섹션이 포함되는지 확인

## 수정이 필요한 코드 및 수정부분

### 1. EphemeralState 클래스 확장

**현재 코드 (라인 10-16)**:

```typescript
class EphemeralState {
  private goal: string | null = null;
  private todos: SimpleTodo[] = [];
  private observations: string[] = [];
```

**수정 후**:

```typescript
class EphemeralState {
  private goal: string | null = null;
  private lastClearedGoal: string | null = null; // 추가
  private todos: SimpleTodo[] = [];
  private observations: string[] = [];
```

### 2. clearGoal 메서드 수정

**현재 코드 (라인 23-26)**:

```typescript
clearGoal(): { success: boolean } {
  this.goal = null;
  return { success: true };
}
```

**수정 후**:

```typescript
clearGoal(): { success: boolean } {
  if (this.goal) {
    this.lastClearedGoal = this.goal;
  }
  this.goal = null;
  return { success: true };
}
```

### 3. toggleTodo 메서드 수정

**현재 코드 (라인 35-48)**:

```typescript
toggleTodo(index: number): { todo: SimpleTodo | null; todos: SimpleTodo[] } {
  // Adjust for 1-based user input (subtract 1 for 0-based array access)
  const adjustedIndex = index - 1;

  // Validate the adjusted index
  if (adjustedIndex < 0 || adjustedIndex >= this.todos.length) {
    return { todo: null, todos: this.todos };
  }

  const todo = this.todos[adjustedIndex];
  if (!todo) return { todo: null, todos: this.todos };

  todo.status = todo.status === 'completed' ? 'pending' : 'completed';
  return { todo, todos: this.todos };
}
```

**수정 후**:

```typescript
toggleTodo(index: number): { todo: SimpleTodo | null; todos: SimpleTodo[] } {
  // Adjust for 1-based user input (subtract 1 for 0-based array access)
  const adjustedIndex = index - 1;

  // Validate the adjusted index
  if (adjustedIndex < 0 || adjustedIndex >= this.todos.length) {
    return { todo: null, todos: this.todos };
  }

  const todo = this.todos[adjustedIndex];
  if (!todo) return { todo: null, todos: this.todos };

  todo.status = todo.status === 'completed' ? 'pending' : 'completed';

  // 히스토리 관리: 완료된 todo가 2개를 초과하면 오래된 것 삭제
  if (todo.status === 'completed') {
    this.manageCompletedTodoHistory();
  }

  return { todo, todos: this.todos };
}
```

### 4. 새로운 헬퍼 메서드 추가

**추가할 코드**:

```typescript
private manageCompletedTodoHistory(): void {
  const completedTodos = this.todos.filter(t => t.status === 'completed');
  if (completedTodos.length > 2) {
    // 완료된 todo 중 가장 오래된 것 찾아서 삭제
    const firstCompletedIndex = this.todos.findIndex(t => t.status === 'completed');
    if (firstCompletedIndex !== -1) {
      this.todos.splice(firstCompletedIndex, 1);
    }
  }
}

getLastClearedGoal(): string | null {
  return this.lastClearedGoal;
}
```

### 5. getServiceContext 메서드 수정

**현재 코드 (라인 240-250)**:

```typescript
const goalText = goal ? `Current Goal: ${goal}` : 'No active goal';
const todosText =
  todos.length > 0
    ? `Todos:\n${todos
        .map(
          (t, idx) =>
            `  ${idx + 1}. [${t.status === 'completed' ? '✔' : ' '}] ${t.name}`,
        )
        .join('\n')}`
    : 'Todos: (none)';
```

**수정 후**:

```typescript
const goalText = goal ? `Current Goal: ${goal}` : 'No active goal';
const lastGoalText = state.getLastClearedGoal()
  ? `Last Cleared Goal: ${state.getLastClearedGoal()}`
  : '';

const activeTodos = todos.filter((t) => t.status === 'pending');
const completedTodos = todos.filter((t) => t.status === 'completed');

const activeTodosText =
  activeTodos.length > 0
    ? `Active Todos:\n${activeTodos
        .map((t, idx) => `  ${idx + 1}. [ ] ${t.name}`)
        .join('\n')}`
    : 'Active Todos: (none)';

const completedTodosText =
  completedTodos.length > 0
    ? `Recently Completed:\n${completedTodos
        .map((t, idx) => `  ${idx + 1}. [✔] ${t.name}`)
        .join('\n')}`
    : '';
```

## 재사용 가능한 연관 코드

### 관련 파일 및 기능

- **파일**: `src/lib/web-mcp/modules/planning-server.ts`
- **주요 클래스**: `EphemeralState` - 상태 관리 핵심 클래스
- **주요 인터페이스**: `SimpleTodo` - Todo 아이템 구조 정의
- **연관 상수**: `MAX_OBSERVATIONS` - 유사한 히스토리 관리 패턴

### 재사용 가능한 패턴

- **히스토리 관리 패턴**: `observations` 배열에서 사용하는 최대 크기 제한 패턴
- **상태 캡슐화**: private 필드와 public 메서드를 통한 상태 접근 제어
- **배열 조작**: `filter()`, `splice()`, `findIndex()` 등을 활용한 안전한 배열 조작

### 인터페이스 확장 고려사항

```typescript
interface SimpleTodo {
  name: string;
  status: 'pending' | 'completed';
  // 향후 확장 가능: completedAt?: string; 완료 시간 추가
}
```

이 리팩터링을 통해 Planning Server가 적절한 히스토리를 유지하면서도 메모리 효율성을 보장하고, AI Agent가 이전 작업 맥락을 활용할 수 있는 환경을 제공할 수 있습니다.
