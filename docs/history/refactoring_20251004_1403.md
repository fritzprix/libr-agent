# ContentStore Module Refactoring Plan

## 작업의 목적

`src-tauri/src/mcp/builtin/content_store/mod.rs` 파일(973 lines)의 크기가 과도하게 커져 유지보수성, 가독성, 테스트 용이성이 저하되었습니다. 이를 논리적 책임에 따라 여러 모듈로 분리하여 코드 품질을 향상시키고, 향후 기능 추가 및 수정을 용이하게 만드는 것이 목표입니다.

**핵심 목표:**

- 단일 파일의 책임을 명확히 분리 (SRP - Single Responsibility Principle)
- 각 모듈의 독립적인 단위 테스트 가능
- 코드 리뷰 및 병합 충돌(merge conflict) 최소화
- 컴파일 시간 단축 (smaller compilation units)
- 외부 API 변경 없이 내부 구조만 개선 (zero breaking changes)

## 현재의 상태 / 문제점

### 파일 구조 분석

```
content_store/
├── mod.rs (973 lines)  ⚠️ 과도하게 큼
├── parsers.rs (519 lines)
├── search.rs (187 lines)
├── storage.rs (443 lines)
└── utils.rs (30 lines)
```

### mod.rs 내부 구성 (Line Distribution)

```rust
Lines   1-32:   Helper 함수 (extract_file_path_from_url)
Lines  34-88:   Type 정의 (6개 arg structs with serde annotations)
Lines  90-180:  ContentStoreServer struct + constructors + utility methods
Lines 182-344:  BuiltinMCPServer trait implementation
Lines 346-459:  Tool schema definitions (4개 schema 생성 함수)
Lines 463-683:  handle_add_content (~220 lines) ⚠️ 매우 복잡
Lines 685-778:  handle_list_content (~93 lines)
Lines 780-821:  handle_read_content (~41 lines)
Lines 823-954:  handle_keyword_search (~131 lines)
Lines 955-974:  Helper wrapper functions (3개 schema builder wrappers)
```

### 주요 문제점

1. **가독성 저하**: 단일 파일에서 type 정의, schema, handler 로직, server 구현이 혼재
2. **테스트 어려움**: Handler 로직이 server struct 내부에 강결합되어 독립적 테스트 불가
3. **코드 네비게이션 불편**: 973줄의 파일에서 특정 함수/타입 찾기 어려움
4. **병합 충돌 가능성**: 여러 개발자가 동시에 다른 handler를 수정할 때 같은 파일 충돌
5. **컴파일 단위 비효율**: 작은 수정에도 전체 파일 재컴파일 필요
6. **책임 분리 부족**: Schema 정의, 비즈니스 로직, 응답 생성이 한 곳에 존재

### 외부 의존성 분석

```rust
// src-tauri/src/mcp/builtin/mod.rs에서만 사용
Line 312: ContentStoreServer::new(session_manager.clone())
Line 341: ContentStoreServer::new_with_sqlite(session_manager.clone(), sqlite_db_url)
```

**결론**: 외부에서는 오직 2개의 생성자만 호출. 내부 구현 변경이 안전함.

## 관련 코드의 구조 및 동작 방식 Summary

### Bird's Eye View: ContentStore Architecture

```
┌─────────────────────────────────────────────────────────┐
│                   BuiltinMCPServer Trait                │
│  (name, description, tools, get_service_context, etc.)  │
└─────────────────────────────────────────────────────────┘
                            ▲
                            │ implements
                            │
┌───────────────────────────┴─────────────────────────────┐
│              ContentStoreServer                         │
│  Fields:                                                 │
│    - session_manager: Arc<SessionManager>               │
│    - storage: Mutex<ContentStoreStorage>                │
│    - search_engine: Arc<Mutex<ContentSearchEngine>>     │
│                                                          │
│  Public API:                                             │
│    - new(session_manager) -> Self                       │
│    - new_with_sqlite(session_manager, db_url) -> Result │
└──────────────────────────────────────────────────────────┘
                            │
            ┌───────────────┼───────────────┐
            │               │               │
            ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │ Storage  │    │  Search  │    │ Parsers  │
    │ (SQLite/ │    │  (BM25)  │    │ (Doc     │
    │ InMemory)│    │          │    │  Parser) │
    └──────────┘    └──────────┘    └──────────┘
```

### 데이터 흐름 (Request Flow)

```
1. Frontend/LLM
       │
       ▼
2. call_tool(tool_name, args: Value)
       │
       ├─→ "addContent"           → handle_add_content()
       ├─→ "listContent"          → handle_list_content()
       ├─→ "readContent"          → handle_read_content()
       └─→ "keywordSimilaritySearch" → handle_keyword_search()
              │
              ▼
3. Handler Logic (각 handle_* 함수)
   a) Deserialize args (AddContentArgs, etc.)
   b) require_active_session() - 세션 검증
   c) ensure_session_store() - 스토어 존재 확인
   d) Business Logic:
      - File parsing (parsers::DocumentParser)
      - Content chunking (lines.chunks(10))
      - Storage operation (storage.add_content())
      - Search indexing (search_engine.add_chunks())
   e) Response creation (dual_response/error_response)
              │
              ▼
4. MCPResponse (JSON-RPC format)
       │
       ▼
5. Frontend/LLM receives result
```

### Handler 복잡도 분석

| Handler               | Lines | Complexity | Key Operations                                            |
| --------------------- | ----- | ---------- | --------------------------------------------------------- |
| handle_add_content    | ~220  | High       | File parsing, MIME detection, chunking, storage, indexing |
| handle_keyword_search | ~131  | Medium     | BM25 search, session filtering, threshold application     |
| handle_list_content   | ~93   | Low        | Pagination, storage query, JSON formatting                |
| handle_read_content   | ~41   | Low        | Content retrieval, line range slicing                     |

**핵심 발견**: `handle_add_content`가 지나치게 복잡하며, 추가 분해가 필요할 수 있음.

## 변경 이후의 상태 / 해결 판정 기준

### 목표 구조

```
content_store/
├── mod.rs (~120 lines)           # Module declarations + re-exports
├── server.rs (~150 lines)        # ContentStoreServer struct + impl
├── types.rs (~90 lines)          # Request/response arg structs
├── schemas.rs (~120 lines)       # Tool schema builders
├── handlers.rs (~500 lines)      # 4 handler functions
├── helpers.rs (~40 lines)        # Utility functions (URL parsing, MIME)
├── parsers.rs (unchanged)
├── search.rs (unchanged)
├── storage.rs (unchanged)
└── utils.rs (unchanged)
```

### 성공 판정 기준

#### 1. 빌드 및 테스트

- [ ] `cargo build` 성공 (no warnings)
- [ ] `cargo clippy -- -D warnings` 통과
- [ ] `cargo test --all` 통과
- [ ] `pnpm refactor:validate` 전체 파이프라인 통과

#### 2. API 호환성

- [ ] `ContentStoreServer::new()` 동일한 signature 유지
- [ ] `ContentStoreServer::new_with_sqlite()` 동일한 signature 유지
- [ ] `BuiltinMCPServer` trait 구현 유지
- [ ] MCP tool 이름/스키마 변경 없음 (addContent, listContent, readContent, keywordSimilaritySearch)

#### 3. 코드 품질 지표

- [ ] 모든 파일이 500줄 이하
- [ ] 각 모듈이 단일 책임 원칙 준수
- [ ] Public API가 명확히 문서화됨
- [ ] 단위 테스트 추가 가능한 구조

#### 4. 기능 검증

- [ ] 기존 MCP integration test 통과
- [ ] Session context switching 정상 동작
- [ ] Content add/list/read/search 시나리오 검증
- [ ] Concurrent operations (add + search) deadlock 없음

#### 5. 성능 회귀 없음

- [ ] 컴파일 시간 동등하거나 개선
- [ ] Runtime 성능 동등
- [ ] Memory footprint 동등

## 수정이 필요한 코드 및 수정부분의 코드 스니펫

### Phase 1: Types 분리

**생성할 파일**: `src-tauri/src/mcp/builtin/content_store/types.rs`

```rust
// types.rs - Request argument types
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub(crate) struct AddContentArgs {
    #[serde(rename = "fileUrl", alias = "file_url")]
    pub file_url: Option<String>,
    pub content: Option<String>,
    pub metadata: Option<AddContentMetadata>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct AddContentMetadata {
    pub filename: Option<String>,
    #[serde(rename = "mimeType", alias = "mime_type")]
    pub mime_type: Option<String>,
    pub size: Option<u64>,
    #[serde(rename = "uploadedAt", alias = "uploaded_at")]
    pub uploaded_at: Option<String>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct PaginationArgs {
    #[serde(default)]
    pub offset: Option<usize>,
    #[serde(default)]
    pub limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct ListContentArgs {
    #[serde(default)]
    pub pagination: Option<PaginationArgs>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct ReadContentArgs {
    pub content_id: String,
    pub from_line: Option<usize>,
    pub to_line: Option<usize>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct SearchOptions {
    #[serde(rename = "topN", alias = "top_n")]
    #[serde(default)]
    pub top_n: Option<usize>,
    #[serde(default)]
    pub threshold: Option<f64>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct KeywordSearchArgs {
    pub query: String,
    #[serde(default)]
    pub options: Option<SearchOptions>,
}
```

### Phase 2: Schemas 분리

**생성할 파일**: `src-tauri/src/mcp/builtin/content_store/schemas.rs`

```rust
// schemas.rs - Tool schema definitions
use crate::mcp::schema::JSONSchema;
use crate::mcp::utils::schema_builder::{integer_prop, number_prop, object_schema, string_prop};
use std::collections::HashMap;

pub(crate) fn tool_add_content_schema() -> JSONSchema {
    let mut props: HashMap<String, JSONSchema> = HashMap::new();
    props.insert(
        "file_url".to_string(),
        string_prop(None, None, Some("File URL (file://) to add")),
    );
    props.insert(
        "content".to_string(),
        string_prop(None, None, Some("Direct content to add")),
    );
    props.insert(
        "metadata".to_string(),
        object_schema(
            {
                let mut meta_props: HashMap<String, JSONSchema> = HashMap::new();
                meta_props.insert(
                    "filename".to_string(),
                    string_prop(None, None, Some("Content filename")),
                );
                meta_props.insert(
                    "mime_type".to_string(),
                    string_prop(None, None, Some("MIME type")),
                );
                meta_props.insert(
                    "size".to_string(),
                    integer_prop(Some(0), None, Some("Content size in bytes")),
                );
                meta_props.insert(
                    "uploaded_at".to_string(),
                    string_prop(None, None, Some("Upload timestamp")),
                );
                meta_props
            },
            vec![],
        ),
    );
    object_schema(props, vec![])
}

pub(crate) fn tool_list_content_schema() -> JSONSchema {
    // ... (similar pattern for other schemas)
}

pub(crate) fn tool_read_content_schema() -> JSONSchema {
    // ...
}

pub(crate) fn tool_keyword_search_schema() -> JSONSchema {
    // ...
}
```

### Phase 3: Helpers 분리

**생성할 파일**: `src-tauri/src/mcp/builtin/content_store/helpers.rs`

```rust
// helpers.rs - Utility functions
use std::path::Path;

/// Extract file path from file:// URL
pub(crate) fn extract_file_path_from_url(file_url: &str) -> Result<String, String> {
    if let Some(path) = file_url.strip_prefix("file://") {
        Ok(path.to_string())
    } else {
        Err(format!("Invalid file URL format: {file_url}"))
    }
}

/// Determine MIME type from file extension
pub(crate) fn mime_type_from_extension(path: &Path) -> &'static str {
    match path.extension() {
        Some(ext) => match ext.to_str().unwrap_or("").to_lowercase().as_str() {
            "docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "xlsx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "pdf" => "application/pdf",
            "txt" => "text/plain",
            "md" => "text/markdown",
            "csv" => "text/csv",
            _ => "text/plain",
        },
        None => "text/plain",
    }
}

/// Create text chunks from content lines
pub(crate) fn create_text_chunks(lines: &[&str], chunk_size: usize) -> Vec<String> {
    lines
        .chunks(chunk_size)
        .map(|chunk| chunk.join("\n"))
        .collect()
}
```

### Phase 4: Server 분리

**생성할 파일**: `src-tauri/src/mcp/builtin/content_store/server.rs`

```rust
// server.rs - ContentStoreServer implementation
use crate::mcp::types::{ServiceContext, ServiceContextOptions};
use crate::mcp::{MCPResponse, MCPTool};
use crate::session::SessionManager;
use log::{error, info};
use serde_json::Value;
use std::sync::Arc;
use tokio::sync::Mutex;

use super::{parsers, search, storage, utils, schemas, types};

/// Content-Store built-in MCP server (native backend)
#[derive(Debug)]
pub struct ContentStoreServer {
    session_manager: Arc<SessionManager>,
    pub(crate) storage: Mutex<storage::ContentStoreStorage>,
    pub(crate) search_engine: Arc<Mutex<search::ContentSearchEngine>>,
}

impl ContentStoreServer {
    pub fn new(session_manager: Arc<SessionManager>) -> Self {
        let session_dir = session_manager.get_session_workspace_dir();
        let search_index_dir = session_dir.join("content_store_search");
        let search_engine = search::ContentSearchEngine::new(search_index_dir)
            .expect("Failed to initialize search engine");

        Self {
            session_manager,
            storage: Mutex::new(storage::ContentStoreStorage::new()),
            search_engine: Arc::new(Mutex::new(search_engine)),
        }
    }

    pub async fn new_with_sqlite(
        session_manager: Arc<SessionManager>,
        database_url: String,
    ) -> Result<Self, String> {
        // ... (existing implementation)
    }

    // Utility methods
    pub(crate) fn generate_request_id() -> Value {
        utils::generate_request_id()
    }

    pub(crate) fn dual_response(
        request_id: Value,
        message: &str,
        structured_content: Value,
    ) -> MCPResponse {
        utils::create_dual_response(request_id, message, structured_content)
    }

    pub(crate) fn error_response(request_id: Value, code: i32, message: &str) -> MCPResponse {
        utils::create_error_response(request_id, code, message)
    }

    pub(crate) fn require_active_session(&self, request_id: &Value) -> Result<String, Box<MCPResponse>> {
        // ... (existing implementation)
    }

    pub(crate) async fn ensure_session_store(&self, session_id: &str) -> Result<(), String> {
        // ... (existing implementation)
    }
}
```

### Phase 5: Handlers 분리

**생성할 파일**: `src-tauri/src/mcp/builtin/content_store/handlers.rs`

```rust
// handlers.rs - Tool handler implementations
use super::server::ContentStoreServer;
use super::types::*;
use super::{helpers, parsers, search};
use crate::mcp::MCPResponse;
use log::error;
use serde_json::Value;

impl ContentStoreServer {
    pub(crate) async fn handle_add_content(&self, params: Value) -> MCPResponse {
        let id = Self::generate_request_id();

        let args: AddContentArgs = match serde_json::from_value(params) {
            Ok(args) => args,
            Err(e) => {
                return Self::error_response(
                    id,
                    -32602,
                    &format!("Invalid add_content parameters: {e}"),
                );
            }
        };

        // Extract metadata
        let metadata = args.metadata.as_ref();
        let filename = metadata.and_then(|m| m.filename.clone());
        // ... (rest of implementation - consider breaking into smaller functions)

        // Validate input
        let content_text = match (&args.content, &args.file_url) {
            (Some(content), None) => content.clone(),
            (None, Some(file_url)) => {
                let file_path_str = match helpers::extract_file_path_from_url(file_url) {
                    Ok(path) => path,
                    Err(e) => {
                        return Self::error_response(id, -32602, &format!("Invalid file URL: {e}"));
                    }
                };

                let mime_type = helpers::mime_type_from_extension(
                    std::path::Path::new(&file_path_str)
                );

                // Parse file
                match parsers::DocumentParser::parse_file(
                    std::path::Path::new(&file_path_str),
                    mime_type
                ).await {
                    parsers::ParseResult::Text(content) => content,
                    parsers::ParseResult::Error(e) => {
                        return Self::error_response(
                            id,
                            -32603,
                            &format!("Failed to parse file {file_path_str}: {e}"),
                        );
                    }
                }
            }
            // ... (rest of validation)
        };

        // ... (rest of handler logic)
    }

    pub(crate) async fn handle_list_content(&self, params: Value) -> MCPResponse {
        // ... (existing implementation)
    }

    pub(crate) async fn handle_read_content(&self, params: Value) -> MCPResponse {
        // ... (existing implementation)
    }

    pub(crate) async fn handle_keyword_search(&self, params: Value) -> MCPResponse {
        // ... (existing implementation)
    }
}
```

### Phase 6: mod.rs 정리

**수정할 파일**: `src-tauri/src/mcp/builtin/content_store/mod.rs`

```rust
// mod.rs - Module declarations and re-exports
use async_trait::async_trait;

use crate::mcp::{MCPResponse, MCPTool};

mod helpers;
mod schemas;
mod server;
mod types;

// Existing modules
pub mod parsers;
pub mod search;
pub mod storage;
pub mod utils;

// Re-export public API
pub use server::ContentStoreServer;

use super::BuiltinMCPServer;
use crate::mcp::types::{ServiceContext, ServiceContextOptions};
use serde_json::Value;

// BuiltinMCPServer trait implementation
#[async_trait]
impl BuiltinMCPServer for ContentStoreServer {
    fn name(&self) -> &str {
        "contentstore"
    }

    fn description(&self) -> &str {
        "File attachment and semantic search system with native performance and BM25 indexing"
    }

    fn tools(&self) -> Vec<MCPTool> {
        vec![
            MCPTool {
                name: "addContent".to_string(),
                title: None,
                description: "Add and parse file content with chunking and BM25 indexing".to_string(),
                input_schema: schemas::tool_add_content_schema(),
                output_schema: None,
                annotations: None,
            },
            // ... (other tools)
        ]
    }

    fn get_service_context(&self, options: Option<&Value>) -> ServiceContext {
        // ... (existing implementation from server.rs or keep here)
    }

    async fn switch_context(&self, options: ServiceContextOptions) -> Result<(), String> {
        // ... (existing implementation)
    }

    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse {
        match tool_name {
            "addContent" => self.handle_add_content(args).await,
            "listContent" => self.handle_list_content(args).await,
            "readContent" => self.handle_read_content(args).await,
            "keywordSimilaritySearch" => self.handle_keyword_search(args).await,
            _ => {
                let id = ContentStoreServer::generate_request_id();
                ContentStoreServer::error_response(id, -32601, &format!("Unknown tool: {tool_name}"))
            }
        }
    }
}
```

## 재사용 가능한 연관 코드

### 기존 모듈 (재사용)

1. **parsers.rs** (519 lines)
   - 경로: `src-tauri/src/mcp/builtin/content_store/parsers.rs`
   - 주요 기능: Document parsing (DOCX, XLSX, PDF, TXT, MD, CSV)
   - 인터페이스: `DocumentParser::parse_file(path, mime_type) -> ParseResult`
   - 상태: **변경 불필요** - 이미 잘 모듈화됨

2. **storage.rs** (443 lines)
   - 경로: `src-tauri/src/mcp/builtin/content_store/storage.rs`
   - 주요 기능: Content storage (InMemory/SQLite backends)
   - 주요 메서드:
     - `add_content()` - 콘텐츠 저장
     - `list_content()` - 콘텐츠 목록 조회
     - `read_content()` - 콘텐츠 읽기
     - `get_content_count()` - 개수 조회
     - `get_content_summary()` - 요약 정보
   - 상태: **변경 불필요** - 이미 잘 모듈화됨

3. **search.rs** (187 lines)
   - 경로: `src-tauri/src/mcp/builtin/content_store/search.rs`
   - 주요 기능: BM25-based content search
   - 주요 타입/메서드:
     - `TextChunk` - 검색 단위
     - `SearchResult` - 검색 결과
     - `ContentSearchEngine::new()` - 생성자
     - `add_chunks()` - 인덱싱
     - `search_bm25()` - BM25 검색
   - 상태: **변경 불필요** - 이미 잘 모듈화됨

4. **utils.rs** (30 lines)
   - 경로: `src-tauri/src/mcp/builtin/content_store/utils.rs`
   - 주요 기능: Response creation helpers
   - 주요 함수:
     - `generate_request_id()` - UUID 생성
     - `create_dual_response()` - MCP 성공 응답
     - `create_error_response()` - MCP 에러 응답
   - 상태: **변경 불필요** - 이미 잘 모듈화됨

### 의존하는 외부 크레이트

```toml
# Cargo.toml dependencies (relevant ones)
async-trait = "0.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1", features = ["sync", "fs"] }
log = "0.4"
chrono = "0.4"
```

### 관련 타입 및 트레이트

```rust
// src-tauri/src/mcp/mod.rs
pub trait BuiltinMCPServer: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn tools(&self) -> Vec<MCPTool>;
    fn get_service_context(&self, options: Option<&Value>) -> ServiceContext;
    async fn switch_context(&self, options: ServiceContextOptions) -> Result<(), String>;
    async fn call_tool(&self, tool_name: &str, args: Value) -> MCPResponse;
}

// src-tauri/src/mcp/types.rs
pub struct ServiceContext {
    pub context_prompt: String,
    pub structured_state: Option<Value>,
}

pub struct ServiceContextOptions {
    pub session_id: Option<String>,
}

// src-tauri/src/mcp/mod.rs
pub struct MCPResponse {
    pub jsonrpc: String,
    pub id: Option<Value>,
    pub result: Option<Value>,
    pub error: Option<MCPError>,
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 단위 테스트 추가 전략

#### 1. helpers.rs 테스트

```rust
// src-tauri/src/mcp/builtin/content_store/helpers.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_file_path_from_url_valid() {
        assert_eq!(
            extract_file_path_from_url("file:///home/user/doc.txt"),
            Ok("/home/user/doc.txt".to_string())
        );
    }

    #[test]
    fn test_extract_file_path_from_url_invalid() {
        assert!(extract_file_path_from_url("http://example.com/file.txt").is_err());
        assert!(extract_file_path_from_url("/home/user/file.txt").is_err());
    }

    #[test]
    fn test_mime_type_from_extension() {
        assert_eq!(
            mime_type_from_extension(Path::new("test.pdf")),
            "application/pdf"
        );
        assert_eq!(
            mime_type_from_extension(Path::new("test.docx")),
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        );
        assert_eq!(
            mime_type_from_extension(Path::new("test.unknown")),
            "text/plain"
        );
    }

    #[test]
    fn test_create_text_chunks() {
        let lines = vec!["line1", "line2", "line3", "line4", "line5"];
        let chunks = create_text_chunks(&lines, 2);
        assert_eq!(chunks.len(), 3);
        assert_eq!(chunks[0], "line1\nline2");
        assert_eq!(chunks[1], "line3\nline4");
        assert_eq!(chunks[2], "line5");
    }
}
```

#### 2. schemas.rs 테스트

```rust
// src-tauri/src/mcp/builtin/content_store/schemas.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tool_add_content_schema_has_required_fields() {
        let schema = tool_add_content_schema();
        // Verify schema structure
        assert!(schema.type_name == Some("object".to_string()));
        // Verify properties exist
        // (Add specific assertions based on JSONSchema structure)
    }

    #[test]
    fn test_tool_list_content_schema_pagination() {
        let schema = tool_list_content_schema();
        // Verify pagination properties
    }

    #[test]
    fn test_tool_read_content_schema_required_content_id() {
        let schema = tool_read_content_schema();
        // Verify content_id is required
    }

    #[test]
    fn test_tool_keyword_search_schema_query_required() {
        let schema = tool_keyword_search_schema();
        // Verify query is required, options is optional
    }
}
```

#### 3. handlers.rs 통합 테스트

```rust
// src-tauri/src/mcp/builtin/content_store/handlers.rs
#[cfg(test)]
mod tests {
    use super::*;
    use crate::session::SessionManager;
    use std::sync::Arc;
    use tempfile::TempDir;

    async fn setup_test_server() -> (ContentStoreServer, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let session_manager = Arc::new(SessionManager::new(temp_dir.path().to_path_buf()));
        let server = ContentStoreServer::new(session_manager);
        (server, temp_dir)
    }

    #[tokio::test]
    async fn test_handle_add_content_direct_content() {
        let (server, _temp) = setup_test_server().await;

        // Setup session context
        server.switch_context(ServiceContextOptions {
            session_id: Some("test-session".to_string()),
        }).await.unwrap();

        let params = serde_json::json!({
            "content": "Test content\nLine 2\nLine 3",
            "metadata": {
                "filename": "test.txt",
                "mime_type": "text/plain"
            }
        });

        let response = server.handle_add_content(params).await;

        // Verify response
        assert!(response.error.is_none());
        assert!(response.result.is_some());

        let result = response.result.unwrap();
        assert_eq!(result["filename"], "test.txt");
        assert_eq!(result["mimeType"], "text/plain");
    }

    #[tokio::test]
    async fn test_handle_add_content_missing_session() {
        let (server, _temp) = setup_test_server().await;

        // Don't setup session context
        let params = serde_json::json!({
            "content": "Test content"
        });

        let response = server.handle_add_content(params).await;

        // Should return error about missing session
        assert!(response.error.is_some());
        assert_eq!(response.error.unwrap().code, -32002);
    }

    #[tokio::test]
    async fn test_handle_add_content_both_content_and_url() {
        let (server, _temp) = setup_test_server().await;

        server.switch_context(ServiceContextOptions {
            session_id: Some("test-session".to_string()),
        }).await.unwrap();

        let params = serde_json::json!({
            "content": "Test content",
            "file_url": "file:///test.txt"
        });

        let response = server.handle_add_content(params).await;

        // Should return error about ambiguous input
        assert!(response.error.is_some());
        assert_eq!(response.error.unwrap().code, -32602);
    }

    #[tokio::test]
    async fn test_handle_list_content_empty() {
        let (server, _temp) = setup_test_server().await;

        server.switch_context(ServiceContextOptions {
            session_id: Some("test-session".to_string()),
        }).await.unwrap();

        let params = serde_json::json!({});
        let response = server.handle_list_content(params).await;

        assert!(response.error.is_none());
        let result = response.result.unwrap();
        assert_eq!(result["total"], 0);
        assert_eq!(result["contents"].as_array().unwrap().len(), 0);
    }

    #[tokio::test]
    async fn test_handle_keyword_search_no_results() {
        let (server, _temp) = setup_test_server().await;

        server.switch_context(ServiceContextOptions {
            session_id: Some("test-session".to_string()),
        }).await.unwrap();

        let params = serde_json::json!({
            "query": "nonexistent",
            "options": {
                "top_n": 5
            }
        });

        let response = server.handle_keyword_search(params).await;

        assert!(response.error.is_none());
        let result = response.result.unwrap();
        assert_eq!(result["results"].as_array().unwrap().len(), 0);
    }
}
```

#### 4. Integration Test (기존 MCP 테스트)

```rust
// src-tauri/tests/integration_test.rs (if exists)
// 또는 별도 integration test 파일 생성

#[tokio::test]
async fn test_content_store_full_workflow() {
    // 1. Create server
    // 2. Switch context to session
    // 3. Add content
    // 4. List content (verify it exists)
    // 5. Read content (verify content matches)
    // 6. Search content (verify search finds it)
    // 7. Add more content
    // 8. Search again (verify multiple results)
}

#[tokio::test]
async fn test_concurrent_add_and_search() {
    // Test for deadlocks
    // Spawn multiple tasks that add content and search simultaneously
}
```

### 테스트 실행 가이드

```bash
# 단위 테스트 실행
cd src-tauri
cargo test --lib content_store

# 특정 모듈 테스트
cargo test --lib content_store::helpers
cargo test --lib content_store::schemas
cargo test --lib content_store::handlers

# 통합 테스트 실행
cargo test --test '*'

# 전체 테스트 (모든 warnings도 체크)
cargo test --all -- --nocapture
cargo clippy --all-targets -- -D warnings
```

## 작업 수행 단계 (Step-by-Step Migration)

### Step 1: 준비 작업 (Preparation)

- [ ] Feature 브랜치 생성: `git checkout -b refactor/content-store-module-split`
- [ ] 현재 상태 빌드 확인: `cd src-tauri && cargo build && cargo test`
- [ ] Baseline 성능 측정 (선택사항): compilation time, runtime benchmarks

### Step 2: Types 분리 (Low Risk)

- [ ] `types.rs` 생성 및 6개 struct 이동
- [ ] `mod.rs`에서 `mod types;` 선언
- [ ] `mod.rs`에서 types 사용처에 `types::` prefix 추가
- [ ] 빌드 확인: `cargo build`
- [ ] Commit: "refactor(content_store): extract types to separate module"

### Step 3: Helpers 분리 (Low Risk)

- [ ] `helpers.rs` 생성
- [ ] `extract_file_path_from_url()` 이동
- [ ] MIME type detection 로직을 `mime_type_from_extension()` 함수로 추출
- [ ] Chunking 로직을 `create_text_chunks()` 함수로 추출 (선택사항)
- [ ] Unit tests 추가
- [ ] 빌드 및 테스트: `cargo build && cargo test`
- [ ] Commit: "refactor(content_store): extract helpers with tests"

### Step 4: Schemas 분리 (Low Risk)

- [ ] `schemas.rs` 생성
- [ ] 4개 schema 함수 이동 (`tool_*_schema`)
- [ ] EOF의 helper 함수들(`object_schema`, `string_prop`, `number_prop`) 처리
  - Option A: `schemas.rs`로 이동
  - Option B: `crate::mcp::utils::schema_builder`에서 직접 import
- [ ] `mod.rs`의 `tools()` 메서드에서 `schemas::` prefix로 호출
- [ ] Unit tests 추가 (schema validation)
- [ ] 빌드: `cargo build`
- [ ] Commit: "refactor(content_store): extract schemas to separate module"

### Step 5: Server 분리 (Medium Risk)

- [ ] `server.rs` 생성
- [ ] `ContentStoreServer` struct 정의 이동
- [ ] Constructor 메서드 이동 (`new`, `new_with_sqlite`)
- [ ] Utility 메서드 이동 (`generate_request_id`, `dual_response`, `error_response`)
- [ ] Session 관련 메서드 이동 (`require_active_session`, `ensure_session_store`)
- [ ] `mod.rs`에서 `pub use server::ContentStoreServer;` re-export
- [ ] 빌드: `cargo build`
- [ ] Commit: "refactor(content_store): extract server implementation"

### Step 6: Handlers 분리 (High Impact)

- [ ] `handlers.rs` 생성
- [ ] 4개 handler 메서드 이동
  - `handle_add_content` (가장 복잡 - 신중히 처리)
  - `handle_list_content`
  - `handle_read_content`
  - `handle_keyword_search`
- [ ] Handler 내부에서 `helpers::` 함수 사용
- [ ] Handler 내부에서 `self` 메서드 호출 확인 (`require_active_session`, etc.)
- [ ] 빌드: `cargo build`
- [ ] 전체 테스트: `cargo test`
- [ ] Commit: "refactor(content_store): extract handlers to separate module"

### Step 7: mod.rs 정리 (Final Cleanup)

- [ ] `mod.rs`를 최소화 (~120 lines 목표)
- [ ] Module declarations와 re-exports만 유지
- [ ] `BuiltinMCPServer` trait impl 유지
- [ ] 불필요한 imports 제거
- [ ] 빌드: `cargo build`
- [ ] Clippy 검사: `cargo clippy -- -D warnings`
- [ ] Commit: "refactor(content_store): finalize mod.rs cleanup"

### Step 8: 테스트 추가 (Test Enhancement)

- [ ] `helpers.rs`에 unit tests 추가
- [ ] `schemas.rs`에 validation tests 추가
- [ ] `handlers.rs`에 integration tests 추가
- [ ] Edge cases 테스트 (concurrent operations, error scenarios)
- [ ] 전체 테스트: `cargo test --all`
- [ ] Commit: "test(content_store): add comprehensive test coverage"

### Step 9: 문서화 및 검증 (Documentation & Verification)

- [ ] 각 모듈에 module-level documentation 추가
- [ ] Public API에 doc comments 추가
- [ ] README 업데이트 (필요시)
- [ ] 전체 품질 검사: `pnpm refactor:validate`
- [ ] 기능 검증 (manual testing or E2E test)
- [ ] Commit: "docs(content_store): add module documentation"

### Step 10: PR 및 리뷰 (Pull Request)

- [ ] PR 생성 with detailed description
- [ ] 변경사항 요약 (before/after structure)
- [ ] Breaking changes 없음 확인
- [ ] CI/CD 통과 확인
- [ ] Code review 반영
- [ ] Merge to main

## 추가 분석 과제 (Further Analysis Tasks)

리팩토링 작업자가 작업 중 추가 분석이 필요한 부분:

### 1. handle_add_content 복잡도 분석

**현황**: 220줄의 복잡한 로직 (파일 파싱, MIME 검증, chunking, 저장, 인덱싱)

**분석 필요 사항**:

- 이 함수를 더 작은 함수로 분해할 수 있는가?
- 예시 분해 후보:
  - `parse_content_from_args()` - Args에서 content 추출
  - `prepare_content_metadata()` - Metadata 준비
  - `store_and_index_content()` - 저장 및 인덱싱

**판단 기준**:

- 함수가 50줄 이하로 유지될 수 있는가?
- 각 sub-function이 독립적으로 테스트 가능한가?
- 가독성이 실제로 향상되는가?

**작업 방침**:

- Phase 6 (Handlers 분리) 이후에 별도 commit으로 진행
- Optional enhancement - 필수는 아님

### 2. Mutex vs RwLock 성능 분석

**현황**: `storage`와 `search_engine` 모두 `Mutex` 사용

**분석 필요 사항**:

- Read-heavy operations (list, read, search) vs Write operations (add) 비율
- `tokio::sync::RwLock`로 변경 시 성능 이득 측정
- Deadlock 가능성 분석

**측정 방법**:

```rust
// Benchmark example
#[tokio::test]
async fn benchmark_concurrent_reads() {
    // Spawn 100 concurrent read operations
    // Measure latency with Mutex vs RwLock
}
```

**작업 방침**:

- 리팩토링 완료 후 별도 성능 개선 PR로 진행
- Baseline 성능 측정 후 판단

### 3. Error Handling 개선 검토

**현황**: `Result<T, String>` 사용, 에러 코드가 handler에 하드코딩

**분석 필요 사항**:

- Custom error enum 도입 여부
- Error codes를 constants로 추출할지
- 예시 구조:

```rust
#[derive(Debug)]
pub enum ContentStoreError {
    NoActiveSession,
    InvalidFileUrl(String),
    ParseError(String),
    StorageError(String),
    SearchError(String),
}

impl ContentStoreError {
    fn to_mcp_response(&self, request_id: Value) -> MCPResponse {
        // Convert to standardized MCPResponse
    }
}
```

**작업 방침**:

- 리팩토링 완료 후 별도 개선 PR로 진행
- 현재 구조가 작동하므로 필수는 아님

### 4. Async 작업 최적화

**현황**: Search indexing이 `handle_add_content` 내부에서 동기적으로 실행

**분석 필요 사항**:

```rust
// Current: Blocking
{
    let mut search_engine = self.search_engine.lock().await;
    search_engine.add_chunks(text_chunks).await?;
}

// Proposed: Background task
tokio::spawn(async move {
    let mut search_engine = search_engine.lock().await;
    search_engine.add_chunks(text_chunks).await;
});
```

**Trade-offs**:

- Pros: `addContent` 응답 속도 향상
- Cons: Indexing 실패 시 error handling 복잡

**작업 방침**:

- 리팩토링 완료 후 성능 프로파일링 결과에 따라 결정
- Optional optimization

### 5. Session Isolation 검증

**현황**: Session별로 content store 분리되나, search index는 공유

**분석 필요 사항**:

- `keywordSimilaritySearch`가 다른 세션 결과를 필터링하는 방식 검증
- Multi-tenancy 안정성 확인
- 테스트 시나리오:
  - Session A와 B가 동시에 다른 content 추가
  - Session A의 search가 Session B 결과를 반환하지 않는지 확인

**작업 방침**:

- Step 8 (테스트 추가) 단계에서 통합 테스트로 검증
- 문제 발견 시 즉시 수정

## 리스크 및 완화 전략 (Risks & Mitigation)

### 높은 리스크 (High Risk)

**없음** - 외부 API가 변경되지 않으므로 breaking change 없음

### 중간 리스크 (Medium Risk)

#### 1. Handler 이동 시 self 메서드 참조

**리스크**: Handler 함수가 server의 private 메서드 호출

**완화**:

- `require_active_session`, `ensure_session_store` 등을 `pub(crate)`로 변경
- Server 필드(`storage`, `search_engine`)를 `pub(crate)`로 노출
- 또는 handler에 필요한 dependencies를 parameter로 전달

#### 2. 컴파일 시간 증가 가능성

**리스크**: 모듈 분리로 의존성 그래프 복잡해질 수 있음

**완화**:

- Incremental compilation 활용
- 불필요한 cross-module dependencies 최소화
- 빌드 시간 측정 (before/after)

### 낮은 리스크 (Low Risk)

#### 1. Import 경로 변경

**리스크**: 모듈 재구성으로 import path 변경

**완화**:

- Rust compiler가 명확한 에러 메시지 제공
- 단계적 commit으로 각 단계에서 컴파일 확인

#### 2. 테스트 누락

**리스크**: 기존 기능 검증 테스트 부족

**완화**:

- Step 8에서 충분한 테스트 추가
- 기존 integration test 활용
- Manual testing checklist 작성

## 성공 지표 (Success Metrics)

### 정량적 지표

- [ ] 모든 파일 500줄 이하 (현재: mod.rs 973줄)
- [ ] Test coverage 50% 이상 (현재: 측정 필요)
- [ ] 컴파일 시간 회귀 없음 (±5% 허용)
- [ ] Zero breaking changes (API compatibility 100%)

### 정성적 지표

- [ ] 코드 리뷰어가 구조 개선을 확인
- [ ] 각 모듈의 책임이 명확히 분리됨
- [ ] 새로운 handler 추가가 용이함
- [ ] 단위 테스트 작성이 쉬워짐

## 참고 자료 (References)

### 프로젝트 가이드라인

- [Project Coding Standards](../../.github/copilot-instructions.md)
- [Rust Style Guide](https://doc.rust-lang.org/1.0.0/style/)

### 관련 문서

- [MCP Integration Guide](../external-mcp-integration.md)
- [Built-in Tools Documentation](../builtin-tools.md)

### 기술 참고

- [Rust Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
- [Tokio Sync Primitives](https://docs.rs/tokio/latest/tokio/sync/index.html)
- [async-trait Documentation](https://docs.rs/async-trait/latest/async_trait/)

---

**작성일**: 2025-10-04  
**작성자**: AI Assistant (Verification & Analysis by Code Review)  
**상태**: Ready for Implementation  
**예상 소요 시간**: 4-6 hours (excluding optional enhancements)
