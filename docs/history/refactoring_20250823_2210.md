# Refactoring Plan: Browser Agent Deadlock Resolution

## 1. 작업의 목적 (Purpose of the Task)

The primary goal is to resolve the critical deadlock issue occurring in the Browser Agent feature. This issue arises when the Rust backend executes a script in a WebView and waits for a result, while the WebView simultaneously attempts to send that result back to the Rust backend using a new command. This refactoring will implement a non-blocking, polling-based architecture to ensure stable and reliable communication between the Tauri backend and the WebView frontend.

## 2. 현재의 상태 / 문제점 (Current State / Problem)

- **Deadlock:** The Rust command `execute_script` injects JavaScript into the WebView and blocks while waiting for a result on a `oneshot` channel.
- The JavaScript, upon completion, calls a separate Rust command (`browser_script_result`) to send the result back.
- Since the main Tauri command event loop is blocked by `execute_script`, the `browser_script_result` command is queued and never gets processed.
- This leads to `execute_script` timing out, dropping the communication channel, and causing the entire operation to fail.

## 3. 변경 이후의 상태 / 해결 판정 기준 (Future State / Success Criteria)

- **Non-Blocking Architecture:** The Rust backend will no longer block when waiting for a JavaScript result. Instead, it will use a polling mechanism.
- **Workflow:**
    1. A unique `request_id` is generated for each script execution request.
    2. The frontend calls `execute_script` and immediately receives the `request_id`.
    3. The frontend uses the `request_id` to poll a new `poll_script_result` command until the result is available.
    4. The JavaScript result is stored temporarily in the backend until it is retrieved via polling.
- **Success Criteria:** Browser agent tools (e.g., `get_page_content`, `click_element`) execute reliably without timeouts or deadlocks. The results from JavaScript execution are correctly received and processed by the requesting tool.

## 4. 수정이 필요한 코드 및 수정부분의 코드 스니핏 (Code to be Modified & Snippets)

### Phase 1: Modify Rust Backend for Polling

**File:** `src-tauri/src/services/interactive_browser_server.rs`

**Changes:**
- Remove the `oneshot` channel (`result_waiters`).
- Introduce a new `DashMap` to store results keyed by a unique `request_id`.
- Modify `execute_script` to be non-blocking and return a `request_id`.
- Add `poll_script_result` to retrieve results.

```rust
// Before
pub struct InteractiveBrowserServer {
    // ...
    result_waiters: Arc<DashMap<u32, oneshot::Sender<String>>>,
}

// After
pub struct InteractiveBrowserServer {
    // ...
    script_results: Arc<DashMap<String, String>>, // Key: request_id
}

// ---

// In InteractiveBrowserServer impl:

// Modified execute_script
pub async fn execute_script(&self, session_id: u32, script: &str) -> Result<String, String> {
    let request_id = Uuid::new_v4().to_string();
    let full_script = format!(
        "window.__TAURI__.core.invoke('browser_script_result', {{ session_id: {}, request_id: '{}', payload: (function() {{ try {{ return {}; }} catch(e) {{ return e.toString(); }} }})() }});",
        session_id, request_id, script
    );
    // ... find window and eval script ...
    Ok(request_id) // Return request_id immediately
}

// New poll_script_result
pub async fn poll_script_result(&self, request_id: &str) -> Result<Option<String>, String> {
    if let Some(result) = self.script_results.remove(request_id) {
        Ok(Some(result.1))
    } else {
        Ok(None)
    }
}

// Modified handle_script_result
pub fn handle_script_result(&self, session_id: u32, request_id: String, payload: String) {
    self.script_results.insert(request_id, payload);
}
```

**File:** `src-tauri/src/commands/browser_commands.rs`

**Changes:**
- Expose the new `poll_script_result` command.
- Update the `execute_script` command wrapper.

```rust
// New Command
#[tauri::command]
pub async fn poll_script_result(
    state: tauri::State<'_, AppState>,
    request_id: String,
) -> Result<Option<String>, String> {
    state.browser_server.poll_script_result(&request_id).await
}

// Modified browser_script_result command to include request_id
#[tauri::command]
pub fn browser_script_result(
    state: tauri::State<'_, AppState>,
    session_id: u32,
    request_id: String,
    payload: String,
) {
    state.browser_server.handle_script_result(session_id, request_id, payload);
}
```

### Phase 2: Create a Browser Invocation Hook in Frontend

**File:** `src/hooks/use-browser-invoker.ts` (New File)

**Changes:**
- Create a hook to encapsulate the `execute` -> `poll` logic.

```typescript
import { invoke } from '@tauri-apps/api/core';

const POLLING_INTERVAL = 100; // ms
const TIMEOUT = 10000; // ms

export function useBrowserInvoker() {
  const executeScript = async (sessionId: number, script: string): Promise<string> => {
    const requestId = await invoke<string>('execute_script', { sessionId, script });

    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      const poll = setInterval(async () => {
        if (Date.now() - startTime > TIMEOUT) {
          clearInterval(poll);
          reject(new Error(`Timeout waiting for script result for request: ${requestId}`));
        }

        const result = await invoke<string | null>('poll_script_result', { requestId });

        if (result !== null) {
          clearInterval(poll);
          resolve(result);
        }
      }, POLLING_INTERVAL);
    });
  };

  return { executeScript };
}
```

### Phase 3: Integrate the Hook as a Standard Tool

**File:** `src/context/BuiltInToolContext.tsx`

**Changes:**
- Modify the context to allow for the registration of frontend-based tools alongside backend-provided ones. This allows the new browser invoker to be used seamlessly throughout the app.

```typescript
// Before
const BuiltInToolContext = createContext<{
  tools: MCPTool[];
  // ...
}>({ tools: [] });

// After
interface BuiltInToolContextType {
  tools: MCPTool[];
  registerLocalTools: (tools: MCPTool[]) => void;
}

// In the provider component's state
const [localTools, setLocalTools] = useState<MCPTool[]>([]);

const registerLocalTools = (newTools: MCPTool[]) => {
    setLocalTools(prev => [...prev, ...newTools]);
};

const allTools = useMemo(() => [...backendTools, ...localTools], [backendTools, localTools]);

// The provider will expose `allTools` and `registerLocalTools`.
```

**File:** `src/features/tools/BrowserToolProvider.tsx` (New File)

**Changes:**
- A new component that uses the `useBrowserInvoker` hook and registers it as a standardized tool with the `BuiltInToolContext`. This makes the browser functionality available to any component that consumes the tool context.

```typescript
import { useContext, useEffect } from 'react';
import { BuiltInToolContext } from '@/context/BuiltInToolContext';
import { useBrowserInvoker } from '@/hooks/use-browser-invoker';
import { MCPTool } from '@/models/mcp';

export function BrowserToolProvider() {
  const { registerLocalTools } = useContext(BuiltInToolContext);
  const { executeScript } = useBrowserInvoker();

  useEffect(() => {
    const browserTools: MCPTool[] = [
      {
        name: 'browser_getPageContent',
        description: 'Gets the full HTML content of the current browser page.',
        parameters: {
          type: 'object',
          properties: {
            sessionId: { type: 'number', description: 'The ID of the browser session.' },
          },
          required: ['sessionId'],
        },
        execute: async ({ sessionId }) => {
          return executeScript(sessionId, 'document.documentElement.outerHTML');
        },
      },
      // ... other browser tools like clickElement, etc.
    ];

    registerLocalTools(browserTools);
  }, [registerLocalTools, executeScript]);

  return null; // This is a provider, does not render anything
}
```
