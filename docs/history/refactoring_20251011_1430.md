# Playbook Store ë¦¬íŒ©í† ë§ ê³„íš: list_playbooksì™€ show_playbooks ë¶„ë¦¬ + Pagination ì¶”ê°€

## ì‘ì—…ì˜ ëª©ì 

í˜„ì¬ `list_playbooks` íˆ´ì€ í…ìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ì™€ UI ë¦¬ì†ŒìŠ¤(HTML)ë¥¼ í•¨ê»˜ ë°˜í™˜í•˜ëŠ” multipart ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤. ì´ëŠ” ë‘ ê°€ì§€ ì„œë¡œ ë‹¤ë¥¸ ì±…ì„ì„ í•˜ë‚˜ì˜ íˆ´ì—ì„œ ì²˜ë¦¬í•˜ê³  ìˆì–´ ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤:

1. **ì±…ì„ì˜ í˜¼ì¬**: AI ì—ì´ì „íŠ¸ê°€ í…ìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ë§Œ í•„ìš”í•œ ê²½ìš°ì—ë„ UI ë¦¬ì†ŒìŠ¤ê°€ í•¨ê»˜ ìƒì„±ë¨
2. **ìœ ì—°ì„± ë¶€ì¡±**: í´ë¼ì´ì–¸íŠ¸ê°€ í…ìŠ¤íŠ¸ ì „ìš© ì‘ë‹µ ë˜ëŠ” UI ì „ìš© ì‘ë‹µì„ ì„ íƒí•  ìˆ˜ ì—†ìŒ
3. **ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ**: ë¶ˆí•„ìš”í•œ HTML ìƒì„± ë° UIResource ê°ì²´ ìƒì„± ë¹„ìš©
4. **ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¤‘ë‹¨**: UIResource í¬í•¨ ì‹œ ì—ì´ì „íŠ¸ ì‹¤í–‰ì´ ì¼ì‹œ ì¤‘ì§€ë˜ì–´, ììœ¨ì ì¸ playbook ì¡°íšŒ ë¶ˆê°€

ë³¸ ë¦¬íŒ©í† ë§ì˜ ëª©ì ì€:

- `list_playbooks`: í…ìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ ì „ìš© ì‘ë‹µìœ¼ë¡œ ë‹¨ìˆœí™” (AI ì—ì´ì „íŠ¸ê°€ ì‘ì—… ì¤‘ë‹¨ ì—†ì´ ì¡°íšŒ ê°€ëŠ¥)
- `show_playbooks`: UI ë¦¬ì†ŒìŠ¤ ìƒì„± ì „ìš© íˆ´ë¡œ ë¶„ë¦¬ (ì‚¬ìš©ì ì¸í„°ë™ì…˜ìš©, ì—ì´ì „íŠ¸ ì¼ì‹œ ì¤‘ì§€)
- `get_playbook_page`: í˜ì´ì§€ë„¤ì´ì…˜ ë‚´ë¹„ê²Œì´ì…˜ ì „ìš© íˆ´ ì¶”ê°€ (UI ë²„íŠ¼ í´ë¦­ìš©)
- **Agent Context ìµœì í™”**: ëª¨ë“  í…ìŠ¤íŠ¸ ì‘ë‹µì´ ëª…í™•í•œ ë§¥ë½ ì •ë³´ ì œê³µ (ë„êµ¬ëª…, ê²°ê³¼ ìš”ì•½, ë‹¤ìŒ ì•¡ì…˜ íŒíŠ¸)
- ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬(Separation of Concerns)ë¥¼ í†µí•œ ì½”ë“œ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ

## í˜„ì¬ ìƒíƒœ / ë¬¸ì œì 

### í˜„ì¬ ì½”ë“œ êµ¬ì¡° (Birdeye View)

`playbook-store.ts`ëŠ” WebMCP ì„œë²„ë¡œì„œ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:

```
playbookStore (WebMCPServer)
â”œâ”€â”€ tools: MCPTool[] (6ê°œ íˆ´ ì •ì˜)
â”‚   â”œâ”€â”€ create_playbook
â”‚   â”œâ”€â”€ list_playbooks  âš ï¸ (ë¦¬íŒ©í† ë§ ëŒ€ìƒ)
â”‚   â”œâ”€â”€ get_playbook
â”‚   â”œâ”€â”€ select_playbook
â”‚   â”œâ”€â”€ update_playbook
â”‚   â””â”€â”€ delete_playbook
â”œâ”€â”€ callTool(name, args) -> MCPResponse
â”‚   â””â”€â”€ switch-caseë¡œ ê° íˆ´ ì²˜ë¦¬
â””â”€â”€ switchContext(context) -> void
    â””â”€â”€ currentAssistantId ì„¤ì •
```

### Helper Functions (ì¬ì‚¬ìš© ê°€ëŠ¥ ì»´í¬ë„ŒíŠ¸)

```typescript
// í…ìŠ¤íŠ¸ í¬ë§·íŒ…
formatPlaybooksList(items: PlaybookRecord[]): string
  - ëª©ë¡ì„ ë²ˆí˜¸ê°€ ë§¤ê²¨ì§„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜

// UI ìƒì„±
buildListItemsHtml(items: PlaybookRecord[]): string
  - HTML ì¹´ë“œ ëª©ë¡ ìƒì„± (Select/Delete ë²„íŠ¼ í¬í•¨)

buildUiHtml(listItemsHtml: string): string
  - ì™„ì „í•œ HTML ë¬¸ì„œ ìƒì„± (ìŠ¤í¬ë¦½íŠ¸ í¬í•¨)

createUiResourceFromHtml(html: string): UIResource
  - HTMLì„ UIResourceë¡œ ë˜í•‘ (serviceInfo í¬í•¨)

makeListMultipartResponse(items, text, structured): MCPResponse
  - í…ìŠ¤íŠ¸ + UIResource multipart ì‘ë‹µ ìƒì„±
```

### í˜„ì¬ list_playbooksì˜ ë™ì‘ ë°©ì‹

#### ì…ë ¥

- `page?: number` (default: 1)
- `pageSize?: number` (default: -1, ëª¨ë“  í•­ëª©)
- ì•”ë¬µì : `currentAssistantId` (ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì„¤ì •)

#### ì²˜ë¦¬ ë¡œì§

1. `currentAssistantId` ê²€ì¦ (ì—†ìœ¼ë©´ ì—ëŸ¬ ë°˜í™˜)
2. DB/In-memory ë¶„ê¸° ì²˜ë¦¬
3. í˜ì´ì§• ì ìš© (`getPage` ë˜ëŠ” ë°°ì—´ ì „ì²´)
4. `agentId` í•„í„°ë§ (**ë¬¸ì œì : DBì—ì„œëŠ” í˜ì´ì§• í›„ í•„í„°ë§**)
5. ê²°ê³¼ê°€ ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ ì‘ë‹µ ë°˜í™˜
6. ê²°ê³¼ê°€ ìˆìœ¼ë©´:
   - `formatPlaybooksList(items)` -> í…ìŠ¤íŠ¸ ìƒì„±
   - `makeListMultipartResponse(...)` -> multipart ì‘ë‹µ ìƒì„±
     - í…ìŠ¤íŠ¸ íŒŒíŠ¸
     - UIResource íŒŒíŠ¸ (HTML + ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬)

#### ì¶œë ¥

- ì„±ê³µ (í•­ëª© ìˆìŒ): `MCPResponse<multipart>` with [text, UIResource]
- ì„±ê³µ (í•­ëª© ì—†ìŒ): `MCPResponse<structured>` with text only
- ì‹¤íŒ¨: `MCPResponse<text>` with error message

### ì‹ë³„ëœ ë¬¸ì œì 

#### 1. í˜ì´ì§•/í•„í„°ë§ ë²„ê·¸ (Critical)

```typescript
// DB ë¶„ê¸°ì˜ í˜„ì¬ ì½”ë“œ
const pageResult = await dbService.playbooks.getPage(page, pageSize);
let items = pageResult.items as PlaybookRecord[];
items = items.filter((p) => p.agentId === currentAssistantId);
```

**ë¬¸ì œ**:

- ì „ì²´ ë°ì´í„°ì—ì„œ í˜ì´ì§•í•œ í›„ í•„í„°ë§í•˜ë¯€ë¡œ ë¶€ì •í™•í•œ ê²°ê³¼
- ì˜ˆ: page=1ì— ë‹¤ë¥¸ agentì˜ playbookë§Œ ìˆìœ¼ë©´ í˜„ì¬ agentëŠ” ë¹ˆ í˜ì´ì§€ ë°›ìŒ
- `pageResult.totalItems` ë“±ì˜ ë©”íƒ€ë°ì´í„°ê°€ í•„í„°ë§ ì „ ê°’ì´ë¼ ë¶€ì •í™•

**ì˜í–¥ë„**: High - ë©€í‹° ì—ì´ì „íŠ¸ í™˜ê²½ì—ì„œ ë°ì´í„° ì†ì‹¤ ê°€ëŠ¥ì„±

#### 2. DBì™€ In-memory ë¶„ê¸° ë¶ˆì¼ì¹˜ (Medium)

```typescript
// In-memory ë¶„ê¸°
let items = [...inMemory];
items = items.filter((p) => p.agentId === currentAssistantId);
// í˜ì´ì§• ë¡œì§ ì—†ìŒ - ëª¨ë“  í•­ëª© ë°˜í™˜
```

**ë¬¸ì œ**:

- DB ëª¨ë“œëŠ” í˜ì´ì§• ì‹œë„, In-memoryëŠ” í˜ì´ì§• ë¬´ì‹œ
- ì‘ë‹µ êµ¬ì¡° ë¶ˆì¼ì¹˜: `{ page: {...} }` vs `{ playbooks: [...] }`

**ì˜í–¥ë„**: Medium - ê°œë°œ/í”„ë¡œë•ì…˜ í™˜ê²½ ê°„ ë™ì‘ ì°¨ì´

#### 3. ì±…ì„ì˜ í˜¼ì¬ + ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¤‘ë‹¨ (High)

```typescript
return makeListMultipartResponse(items, formatted, { ... });
```

**ë¬¸ì œ**:

- AI ì—ì´ì „íŠ¸ëŠ” í…ìŠ¤íŠ¸ë§Œ í•„ìš”í•œë° UI ìƒì„± ë¹„ìš© ë°œìƒ
- **UIResource í¬í•¨ ì‹œ ì—ì´ì „íŠ¸ ì‹¤í–‰ì´ ì¼ì‹œ ì¤‘ì§€ë¨**
- ì—ì´ì „íŠ¸ê°€ ììœ¨ì ìœ¼ë¡œ playbook ëª©ë¡ì„ ì¡°íšŒí•˜ê³  ë¶„ì„í•  ìˆ˜ ì—†ìŒ
- ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ìœ„ë°˜

**ì˜í–¥ë„**: High - ì—ì´ì „íŠ¸ ììœ¨ì„± ì €í•´ ë° ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ

#### 4. Agent Contextì— ë¶ˆëª…í™•í•œ ì •ë³´ ì „ë‹¬ (Critical - ì‹ ê·œ)

**ë¬¸ì œ**:

- í˜„ì¬ í…ìŠ¤íŠ¸ ì‘ë‹µì— ë„êµ¬ëª…, ë§¥ë½ ì •ë³´ ì—†ìŒ
- Agentê°€ "ì–´ë–¤ ë„êµ¬ì˜ ì‘ë‹µì¸ì§€", "ì™œ ì´ ë°ì´í„°ê°€ ì™”ëŠ”ì§€" íŒŒì•… ë¶ˆê°€
- í˜ì´ì§€ ì •ë³´, ì „ì²´ ê°œìˆ˜ ë“± ë©”íƒ€ë°ì´í„°ê°€ í…ìŠ¤íŠ¸ì— í¬í•¨ë˜ì§€ ì•ŠìŒ
- ë‹¤ìŒ ì•¡ì…˜ì— ëŒ€í•œ íŒíŠ¸ ì—†ìŒ

**ì˜ˆì‹œ (í˜„ì¬)**:

```
1. id:123 goal:"Deploy" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" steps:3 createdAt:2025-01-02
```

â†’ **ë§¥ë½ ì—†ìŒ, Agentê°€ ì´í•´í•˜ê¸° ì–´ë ¤ì›€**

**ì˜í–¥ë„**: Critical - Agentì˜ ì˜ì‚¬ê²°ì • ëŠ¥ë ¥ ì €í•˜

#### 5. í˜ì´ì§€ë„¤ì´ì…˜ UI ë¶€ì¬ (Medium)

**ë¬¸ì œ**:

- `show_playbooks`ê°€ UIë¥¼ ì œê³µí•˜ì§€ë§Œ í˜ì´ì§€ ì´ë™ ë°©ë²• ì—†ìŒ
- Previous/Next ë²„íŠ¼ ì—†ìŒ
- í˜ì´ì§€ ì •ë³´ í‘œì‹œ ì—†ìŒ

**ì˜í–¥ë„**: Medium - UX ë¶ˆì™„ì „

#### 6. ë³´ì•ˆ ì·¨ì•½ì  (Low)

```typescript
window.parent.postMessage({...}, '*');  // targetOrigin: '*'
```

**ë¬¸ì œ**: ëª¨ë“  originì— ë©”ì‹œì§€ ì „ì†¡ ê°€ëŠ¥

**ì˜í–¥ë„**: Low - ì œí•œëœ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‹¤í–‰ë˜ë¯€ë¡œ í˜„ì¬ëŠ” ìœ„í—˜ ë‚®ìŒ

## ë³€ê²½ ì´í›„ì˜ ìƒíƒœ / í•´ê²° íŒì • ê¸°ì¤€

### ëª©í‘œ ì•„í‚¤í…ì²˜

```
playbookStore (WebMCPServer)
â”œâ”€â”€ tools: MCPTool[] (8ê°œ íˆ´)
â”‚   â”œâ”€â”€ create_playbook
â”‚   â”œâ”€â”€ list_playbooks  âœ… (í…ìŠ¤íŠ¸ ì „ìš©, Agent ììœ¨ ì¡°íšŒ)
â”‚   â”œâ”€â”€ show_playbooks  âœ¨ (ì‹ ê·œ: ì´ˆê¸° UI í‘œì‹œ)
â”‚   â”œâ”€â”€ get_playbook_page âœ¨ (ì‹ ê·œ: í˜ì´ì§€ ë‚´ë¹„ê²Œì´ì…˜)
â”‚   â”œâ”€â”€ get_playbook
â”‚   â”œâ”€â”€ select_playbook
â”‚   â”œâ”€â”€ update_playbook
â”‚   â””â”€â”€ delete_playbook
â””â”€â”€ callTool(name, args) -> MCPResponse
    â”œâ”€â”€ case 'list_playbooks': -> structured response (text only)
    â”œâ”€â”€ case 'show_playbooks': -> multipart response (text + UI)
    â””â”€â”€ case 'get_playbook_page': -> multipart response (text + UI)
```

### ë„êµ¬ë³„ ì—­í•  ë¶„ë¦¬

| Tool                | Response Type     | Purpose         | Agent Behavior | Context Text         |
| ------------------- | ----------------- | --------------- | -------------- | -------------------- |
| `list_playbooks`    | Text + Structured | Agent ììœ¨ ì¿¼ë¦¬ | âœ… ê³„ì† ì‹¤í–‰   | ëª…í™•í•œ ë§¥ë½ + íŒíŠ¸   |
| `show_playbooks`    | Text + UIResource | ì´ˆê¸° UI í‘œì‹œ    | â¸ï¸ ì¼ì‹œ ì¤‘ì§€   | ë°ì´í„° + ìƒíƒœ í‘œì‹œ   |
| `get_playbook_page` | Text + UIResource | í˜ì´ì§€ ì´ë™     | â¸ï¸ ì¼ì‹œ ì¤‘ì§€   | í˜ì´ì§€ ì •ë³´ + ë°ì´í„° |

### list_playbooks (ë³€ê²½ í›„)

#### API ê³„ì•½

```typescript
// Input
interface ListPlaybooksInput {
  page?: number; // default: 1
  pageSize?: number; // default: -1 (all)
}

// Output (ì„±ê³µ)
interface ListPlaybooksOutput {
  content: [{ type: 'text'; text: string }];
  structured: {
    page: {
      page: number;
      pageSize: number;
      totalItems: number;
      totalPages: number;
      items: PlaybookRecord[];
    };
    formattedText: string;
  };
}
```

#### ë™ì‘

1. Context ê²€ì¦
2. DB/In-memory ë¶„ê¸°
   - **DB**: `getPageForAgent(assistantId, page, pageSize)` í˜¸ì¶œ (í•„í„°ë§ í›„ í˜ì´ì§•)
   - **In-memory**: í•„í„°ë§ í›„ `slice()`ë¡œ í˜ì´ì§• ì ìš©
3. ì¼ê´€ëœ í˜ì´ì§€ ë©”íƒ€ë°ì´í„° ìƒì„±
4. `formatPlaybooksList(items)` í…ìŠ¤íŠ¸ ìƒì„±
5. **Agent Context ì¹œí™”ì  í…ìŠ¤íŠ¸ ì‘ë‹µ ìƒì„±** (ë„êµ¬ëª…, ìš”ì•½, íŒíŠ¸ í¬í•¨)
6. `createMCPStructuredResponse(text, structured)` ë°˜í™˜

#### ì˜ˆì‹œ ì‘ë‹µ (Agent Contextì— ì¶”ê°€ë¨)

```
[list_playbooks] Found 25 playbook(s) for agent abc-123.
Showing page 1 of 3 (10 items on this page):

1. id:123 goal:"Deploy app" initial:"deploy production" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" initial:"fix auth issue" steps:3 createdAt:2025-01-02
...

Note: Use 'get_playbook' to view details or 'select_playbook' to execute a playbook.
```

### show_playbooks (ì‹ ê·œ)

#### API ê³„ì•½

```typescript
// Input
interface ShowPlaybooksInput {
  page?: number; // default: 1
  pageSize?: number; // default: -1 (all)
}

// Output (ì„±ê³µ)
interface ShowPlaybooksOutput {
  content: [
    { type: 'text'; text: string },
    { type: 'resource'; resource: UIResource },
  ];
  structured: {
    page: { page; pageSize; totalItems; totalPages; items };
    formattedText: string;
  };
}
```

#### ë™ì‘

1. `list_playbooks`ì™€ ë™ì¼í•œ í•„í„°ë§/í˜ì´ì§• ë¡œì§ ì¬ì‚¬ìš©
2. **Agent Context ì¹œí™”ì  í…ìŠ¤íŠ¸ ì‘ë‹µ ìƒì„±** (UI í‘œì‹œ ìƒíƒœ í¬í•¨)
3. **í˜ì´ì§€ë„¤ì´ì…˜ UI í¬í•¨í•œ HTML ìƒì„±**
4. `makeListMultipartResponse(items, text, structured, pageInfo)` í˜¸ì¶œ
5. UIResourceì— `serviceInfo.toolName = 'show_playbooks'` ì„¤ì •

#### ì˜ˆì‹œ ì‘ë‹µ (Agent Contextì— ì¶”ê°€ë¨)

```
[show_playbooks] Displaying 25 playbook(s) in interactive UI.
Current page: 1 of 3

Playbooks on this page:
1. id:123 goal:"Deploy app" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" steps:3 createdAt:2025-01-02
...

Status: Agent paused for user interaction (Select/Delete/Navigate buttons available).
```

### get_playbook_page (ì‹ ê·œ)

#### API ê³„ì•½

```typescript
// Input
interface GetPlaybookPageInput {
  page: number; // required: ì´ë™í•  í˜ì´ì§€ ë²ˆí˜¸ (1-based)
  pageSize?: number; // optional: í˜ì´ì§€ í¬ê¸° (ì´ì „ ê°’ ìœ ì§€)
}

// Output
interface GetPlaybookPageOutput {
  content: [
    { type: 'text'; text: string },
    { type: 'resource'; resource: UIResource },
  ];
  structured: {
    page: { page; pageSize; totalItems; totalPages; items };
    formattedText: string;
  };
}
```

#### ë™ì‘

1. `show_playbooks`ì™€ ë™ì¼í•œ ë¡œì§ (ì½”ë“œ ì¬ì‚¬ìš©: `getPlaybooksWithUI()`)
2. í˜ì´ì§€ ë‚´ë¹„ê²Œì´ì…˜ ì „ìš© (UI ë²„íŠ¼ í´ë¦­ìœ¼ë¡œ í˜¸ì¶œë¨)
3. AgentëŠ” ì¼ì‹œ ì¤‘ì§€ ìƒíƒœ ìœ ì§€

#### ì˜ˆì‹œ ì‘ë‹µ (Agent Contextì— ì¶”ê°€ë¨)

```
[get_playbook_page] Navigated to page 2 of 3.
Displaying 10 of 25 total playbook(s):

1. id:789 goal:"Update deps" steps:2 createdAt:2025-01-03
...

Status: Agent paused for user interaction.
```

### í˜ì´ì§€ë„¤ì´ì…˜ UI ì„¤ê³„

#### HTML êµ¬ì¡°

```html
<div class="pagination">
  <button data-page="1" class="nav-page-btn" [disabled]>â† Previous</button>
  <span class="page-info">Page 2 of 3 (25 total)</span>
  <button data-page="3" class="nav-page-btn">Next â†’</button>
</div>
```

#### ì´ë²¤íŠ¸ ì²˜ë¦¬

```javascript
if (btn.classList.contains('nav-page-btn') && !btn.disabled) {
  const page = parseInt(btn.getAttribute('data-page'));
  window.parent.postMessage(
    {
      type: 'tool',
      payload: { toolName: 'get_playbook_page', params: { page } },
    },
    '*',
  );
}
```

### Agent Context ìµœì í™” ì›ì¹™

**ëª¨ë“  í…ìŠ¤íŠ¸ ì‘ë‹µì€ ë‹¤ìŒì„ í¬í•¨:**

1. **ë„êµ¬ ì‹ë³„**: `[tool_name]` prefix
2. **ì•¡ì…˜ ê²°ê³¼**: "Found ...", "Successfully ...", "Displaying ..."
3. **í•µì‹¬ ë°ì´í„°**: ì‹¤ì œ ë‚´ìš© (í¬ë§·íŒ…ëœ ëª©ë¡/ìƒì„¸ì •ë³´)
4. **ë§¥ë½ ì •ë³´**: í˜ì´ì§€ ë²ˆí˜¸, ì´ ê°œìˆ˜, ì—ì´ì „íŠ¸ ID ë“±
5. **ë‹¤ìŒ ì•¡ì…˜ íŒíŠ¸**: "Use 'xxx' to ...", "You may now ..."
6. **ìƒíƒœ í‘œì‹œ** (UI ë„êµ¬): "Agent paused for user interaction"

### í•´ê²° íŒì • ê¸°ì¤€

#### í•„ìˆ˜ ê¸°ì¤€ (Must)

1. âœ… `Page<T>` ì¸í„°í˜ì´ìŠ¤ì— `totalPages` í•„ë“œ ì¶”ê°€
2. âœ… `list_playbooks`ëŠ” UI ë¦¬ì†ŒìŠ¤ ì—†ì´ í…ìŠ¤íŠ¸ë§Œ ë°˜í™˜
3. âœ… `show_playbooks`ëŠ” í…ìŠ¤íŠ¸ + UI ë¦¬ì†ŒìŠ¤ë¥¼ multipartë¡œ ë°˜í™˜
4. âœ… `get_playbook_page`ëŠ” í˜ì´ì§€ ë‚´ë¹„ê²Œì´ì…˜ ì œê³µ
5. âœ… DB ë¶„ê¸°ì—ì„œ í•„í„°ë§ í›„ í˜ì´ì§• ì ìš© (ì •í™•í•œ í˜ì´ì§€ ë©”íƒ€ë°ì´í„°)
6. âœ… In-memory ë¶„ê¸°ë„ í˜ì´ì§• ë¡œì§ ì ìš©
7. âœ… DBì™€ In-memoryì˜ ì‘ë‹µ êµ¬ì¡° ì¼ì¹˜ (`page` ê°ì²´)
8. âœ… **ëª¨ë“  í…ìŠ¤íŠ¸ ì‘ë‹µì— ëª…í™•í•œ ë§¥ë½ ì •ë³´ í¬í•¨** (ë„êµ¬ëª…, ìš”ì•½, íŒíŠ¸)
9. âœ… **í˜ì´ì§€ë„¤ì´ì…˜ UI êµ¬í˜„** (Previous/Next ë²„íŠ¼)
10. âœ… ê¸°ì¡´ í…ŒìŠ¤íŠ¸ í†µê³¼ ìœ ì§€

#### ê¶Œì¥ ê¸°ì¤€ (Should)

1. ğŸ¯ `show_playbooks`, `get_playbook_page`ì˜ `serviceInfo.toolName` ì •í™•íˆ ì„¤ì •
2. ğŸ¯ í˜ì´ì§€ ë©”íƒ€ë°ì´í„°ì— `totalPages` ê³„ì‚° í¬í•¨
3. ğŸ¯ postMessage targetOrigin ì£¼ì„ìœ¼ë¡œ ë³´ì•ˆ ë¦¬ìŠ¤í¬ ë¬¸ì„œí™”
4. ğŸ¯ ë²„ì „ ì¦ê°€: `playbookStore.version = '0.1.1'`
5. ğŸ¯ ê³µí†µ ë¡œì§ í•¨ìˆ˜ ì¶”ì¶œ: `getPlaybooksWithUI()`

#### í…ŒìŠ¤íŠ¸ ê¸°ì¤€

1. Context ì—†ì„ ë•Œ ì—ëŸ¬ ë°˜í™˜
2. ë¹ˆ ëª©ë¡ì¼ ë•Œ ì ì ˆí•œ ì‘ë‹µ
3. í˜ì´ì§• ë™ì‘ ê²€ì¦ (page=1, pageSize=5)
4. DB/In-memory ê²°ê³¼ ë™ë“±ì„±
5. `list_playbooks`ëŠ” UIResource ì—†ìŒ í™•ì¸
6. `show_playbooks`ëŠ” UIResource + í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ í¬í•¨ í™•ì¸
7. `get_playbook_page`ëŠ” í˜ì´ì§€ ì´ë™ ì •ìƒ ë™ì‘ í™•ì¸
8. HTML XSS ë°©ì–´ (escapeHtml) ê²€ì¦
9. **í…ìŠ¤íŠ¸ ì‘ë‹µì´ Agent Contextì—ì„œ ì´í•´ ê°€ëŠ¥í•œì§€ ê²€ì¦**
10. Previous ë²„íŠ¼ì´ ì²« í˜ì´ì§€ì—ì„œ disabled
11. Next ë²„íŠ¼ì´ ë§ˆì§€ë§‰ í˜ì´ì§€ì—ì„œ disabled

## ìˆ˜ì •ì´ í•„ìš”í•œ ì½”ë“œ ë° ìˆ˜ì • ë¶€ë¶„ì˜ ì½”ë“œ ìŠ¤ë‹ˆí•

### 0. DB Service í™•ì¥ (ìš°ì„  ì‘ì—…)

#### 0-1. DB ìŠ¤í‚¤ë§ˆì— agentId ì¸ë±ìŠ¤ ì¶”ê°€

**íŒŒì¼**: `src/lib/db/service.ts`
**ìœ„ì¹˜**: LocalDatabase ìƒì„±ì ë‚´ version ì •ì˜ ì„¹ì…˜

```typescript
// ê¸°ì¡´ version 6
this.version(6).stores({
  playbooks: '&id, createdAt, updatedAt, goal',
});

// ê¸°ì¡´ version 7 (ê·¸ëŒ€ë¡œ ìœ ì§€)
this.version(7)
  .stores({})
  .upgrade(async (tx) => {
    await tx
      .table('assistants')
      .toCollection()
      .modify((assistant) => {
        if (
          Array.isArray(assistant.allowedBuiltInServiceAliases) &&
          assistant.allowedBuiltInServiceAliases.length === 0
        ) {
          delete assistant.allowedBuiltInServiceAliases;
        }
      });
  });

// ìƒˆë¡œ ì¶”ê°€: version 8 (agentId ì¸ë±ìŠ¤ ì¶”ê°€)
this.version(8).stores({
  playbooks: '&id, agentId, createdAt, updatedAt, goal',
});
```

#### 0-2. Page<T> ì¸í„°í˜ì´ìŠ¤ì— totalPages ì¶”ê°€

**íŒŒì¼**: `src/lib/db/types.ts`
**ìœ„ì¹˜**: Page ì¸í„°í˜ì´ìŠ¤ ì •ì˜ (line ~90)

```typescript
export interface Page<T> {
  /** The array of items for the current page. */
  items: T[];
  /** The current page number. */
  page: number;
  /** The number of items per page. */
  pageSize: number;
  /** The total number of items across all pages. */
  totalItems: number;
  /** The total number of pages. */
  totalPages: number; // âœ¨ ì¶”ê°€
  /** A boolean indicating if there is a next page. */
  hasNextPage: boolean;
  /** A boolean indicating if there is a previous page. */
  hasPreviousPage: boolean;
}
```

#### 0-3. createPage í—¬í¼ í•¨ìˆ˜ ì—…ë°ì´íŠ¸

**íŒŒì¼**: `src/lib/db/crud.ts`
**ìœ„ì¹˜**: createPage í•¨ìˆ˜ (line ~23)

```typescript
export const createPage = <T>(
  items: T[],
  page: number,
  pageSize: number,
  totalItems: number,
): Page<T> => {
  if (pageSize === -1) {
    return {
      items,
      page: 1,
      pageSize: totalItems,
      totalItems,
      totalPages: 1, // âœ¨ ì¶”ê°€
      hasNextPage: false,
      hasPreviousPage: false,
    };
  }

  const totalPages = Math.ceil(totalItems / pageSize); // âœ¨ ê³„ì‚°

  return {
    items,
    page,
    pageSize,
    totalItems,
    totalPages, // âœ¨ ì¶”ê°€
    hasNextPage: page * pageSize < totalItems,
    hasPreviousPage: page > 1,
  };
};
```

#### 0-4. PlaybookCRUD ì¸í„°í˜ì´ìŠ¤ ì •ì˜

**íŒŒì¼**: `src/lib/db/types.ts`
**ìœ„ì¹˜**: íŒŒì¼ ëë¶€ë¶„ (DatabaseService ì¸í„°í˜ì´ìŠ¤ ì•)

```typescript
/**
 * Extends the basic CRUD interface with additional methods specific to `Playbook`.
 */
export interface PlaybookCRUD extends CRUD<Playbook & { id: string }> {
  /**
   * Retrieves a paginated list of playbooks filtered by agent ID.
   * This method uses an indexed query for optimal performance.
   *
   * @param agentId The ID of the agent/assistant to filter by.
   * @param page The page number to retrieve (1-based).
   * @param pageSize The number of items per page. Use -1 to retrieve all items.
   * @returns A promise that resolves to a `Page` of playbooks for the specified agent.
   */
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<Playbook & { id: string }>>;
}
```

ê·¸ë¦¬ê³  `DatabaseService` ì¸í„°í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸:

```typescript
export interface DatabaseService {
  /** CRUD operations for `Assistant` objects. */
  assistants: CRUD<Assistant>;
  /** Generic CRUD operations for `DatabaseObject`s. */
  objects: CRUD<DatabaseObject<unknown>, DatabaseObject<unknown>>;
  /** CRUD operations for `Session` objects. */
  sessions: CRUD<Session>;
  /** CRUD operations for `Message` objects. */
  messages: CRUD<Message>;
  /** Extended CRUD operations for persisted Playbook objects. */
  playbooks?: PlaybookCRUD; // CRUDì—ì„œ PlaybookCRUDë¡œ ë³€ê²½
}
```

#### 0-5. playbooksCRUDì— getPageForAgent ë©”ì„œë“œ êµ¬í˜„

**íŒŒì¼**: `src/lib/db/crud.ts`
**ìœ„ì¹˜**: playbooksCRUD ê°ì²´ ì •ì˜ (count ë©”ì„œë“œ ë‹¤ìŒ)

```typescript
/** CRUD for persisted Task records stored in the LocalDatabase.tasks table. */
export const playbooksCRUD: CRUD<PlaybookRecord> & {
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<PlaybookRecord>>;
} = {
  upsert: async (playbook) => {
    // ... ê¸°ì¡´ ì½”ë“œ ìœ ì§€ ...
  },
  upsertMany: async (playbooksArr) => {
    // ... ê¸°ì¡´ ì½”ë“œ ìœ ì§€ ...
  },
  read: async (id) => {
    // ... ê¸°ì¡´ ì½”ë“œ ìœ ì§€ ...
  },
  delete: async (id) => {
    // ... ê¸°ì¡´ ì½”ë“œ ìœ ì§€ ...
  },
  getPage: async (page, pageSize) => {
    // ... ê¸°ì¡´ ì½”ë“œ ìœ ì§€ ...
  },
  count: async () => {
    return LocalDatabase.getInstance().table('playbooks').count();
  },

  // ì‹ ê·œ ë©”ì„œë“œ: agentIdë¡œ í•„í„°ë§ëœ í˜ì´ì§•
  getPageForAgent: async (agentId, page, pageSize) => {
    const db = LocalDatabase.getInstance();
    const table = db.table('playbooks');

    // agentIdë¡œ í•„í„°ë§ëœ í•­ëª© ìˆ˜ ê³„ì‚°
    const totalItems = await table.where('agentId').equals(agentId).count();

    if (pageSize === -1) {
      // ëª¨ë“  í•­ëª© ë°˜í™˜
      const items = await table.where('agentId').equals(agentId).toArray();
      return createPage(items as PlaybookRecord[], page, pageSize, totalItems);
    }

    // í˜ì´ì§• ì ìš©
    const offset = (page - 1) * pageSize;
    const items = await table
      .where('agentId')
      .equals(agentId)
      .offset(offset)
      .limit(pageSize)
      .toArray();

    return createPage(items as PlaybookRecord[], page, pageSize, totalItems);
  },
};
```

### 1. tools ë°°ì—´ì— show_playbooks, get_playbook_page ì¶”ê°€

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: `tools` ë°°ì—´ (line ~220)

```typescript
const tools: MCPTool[] = [
  // ... ê¸°ì¡´ íˆ´ë“¤ ...
  {
    name: 'list_playbooks',
    description:
      'List playbooks with optional paging (text-only, non-interrupting for agent autonomous use)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to retrieve (1-based)',
        },
        pageSize: {
          type: 'number',
          description: 'Number of items per page; -1 for all',
        },
      },
    },
  },
  {
    name: 'show_playbooks',
    description:
      'Display playbooks with interactive UI (includes HTML UI resource for frontend, pauses agent)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to retrieve (1-based)',
        },
        pageSize: {
          type: 'number',
          description: 'Number of items per page; -1 for all',
        },
      },
    },
  },
  {
    name: 'get_playbook_page',
    description:
      'Navigate to a specific page of playbooks with interactive UI (for pagination buttons, pauses agent)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to navigate to (1-based)',
        },
        pageSize: {
          type: 'number',
          description:
            'Number of items per page (optional, keeps previous size)',
        },
      },
      required: ['page'],
    },
  },
  // ... ë‚˜ë¨¸ì§€ íˆ´ë“¤ ...
];
```

### 2. ê³µí†µ í˜ì´ì§• ë¡œì§ í—¬í¼ í•¨ìˆ˜ ì¶”ê°€

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: Helper functions ì„¹ì…˜ (formatPlaybook ì•„ë˜)

```typescript
// --- Helpers to reduce duplication between DB and in-memory branches ---

interface PageResult {
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  items: PlaybookRecord[];
}

/**
 * Apply pagination to filtered items (in-memory mode)
 */
function paginateItems(
  items: PlaybookRecord[],
  page: number,
  pageSize: number,
): PageResult {
  const totalItems = items.length;

  if (pageSize === -1) {
    // Return all items
    return {
      page: 1,
      pageSize: -1,
      totalItems,
      totalPages: 1,
      items,
    };
  }

  const totalPages = Math.ceil(totalItems / pageSize);
  const startIdx = (page - 1) * pageSize;
  const endIdx = startIdx + pageSize;
  const paginatedItems = items.slice(startIdx, endIdx);

  return {
    page,
    pageSize,
    totalItems,
    totalPages,
    items: paginatedItems,
  };
}

/**
 * Create consistent structured response for list operations
 */
function createListStructuredResponse(
  pageResult: PageResult,
  formattedText: string,
): unknown {
  return {
    page: pageResult,
    formattedText,
  };
}

/**
 * Create context-aware text response for list_playbooks
 */
function createListTextResponse(
  agentId: string,
  pageResult: PageResult,
  formattedList: string,
): string {
  if (pageResult.totalItems === 0) {
    return `[list_playbooks] No playbooks found for agent ${agentId}.`;
  }

  return `[list_playbooks] Found ${pageResult.totalItems} playbook(s) for agent ${agentId}.
Showing page ${pageResult.page} of ${pageResult.totalPages} (${pageResult.items.length} items on this page):

${formattedList}

Note: Use 'get_playbook' to view details or 'select_playbook' to execute a playbook.`;
}

/**
 * Create context-aware text response for UI-based tools (show_playbooks, get_playbook_page)
 */
function createUITextResponse(
  toolName: string,
  pageResult: PageResult,
  formattedList: string,
  isNavigation = false,
): string {
  const action = isNavigation
    ? `Navigated to page ${pageResult.page}`
    : `Displaying ${pageResult.totalItems} playbook(s) in interactive UI`;

  return `[${toolName}] ${action}.
Current page: ${pageResult.page} of ${pageResult.totalPages}

Playbooks on this page:
${formattedList}

Status: Agent paused for user interaction (Select/Delete/Navigate buttons available).`;
}
```

### 3. HTML UI ì—…ë°ì´íŠ¸ (í˜ì´ì§€ë„¤ì´ì…˜ ì¶”ê°€)

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: buildUiHtml í•¨ìˆ˜ (line ~76)

```typescript
function buildUiHtml(listItemsHtml: string, pageInfo: PageResult): string {
  const prevDisabled = pageInfo.page <= 1 ? 'disabled' : '';
  const nextDisabled = pageInfo.page >= pageInfo.totalPages ? 'disabled' : '';

  return `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 12px;
    }
    .pb-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pagination {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-top: 1px solid #eee;
    }
    button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #f5f5f5;
    }
    .delete-pb-btn {
      background-color: #dc3545;
      color: white;
      border: none;
    }
    .delete-pb-btn:hover:not(:disabled) {
      background-color: #c82333;
    }
    .page-info {
      padding: 6px 12px;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h3>Playbooks</h3>
  <div id="pb-list">${listItemsHtml}</div>

  <!-- Pagination UI -->
  <div class="pagination">
    <button data-page="${pageInfo.page - 1}" class="nav-page-btn" ${prevDisabled}>
      â† Previous
    </button>
    <span class="page-info">
      Page ${pageInfo.page} of ${pageInfo.totalPages} (${pageInfo.totalItems} total)
    </span>
    <button data-page="${pageInfo.page + 1}" class="nav-page-btn" ${nextDisabled}>
      Next â†’
    </button>
  </div>

  <script>
document.addEventListener('click', function(e) {
  const btn = e.target;
  if (btn && btn.classList) {
    const id = btn.getAttribute('data-pbid');
    const page = btn.getAttribute('data-page');

    if (btn.classList.contains('select-pb-btn')) {
      console.log('Select button clicked for id:', id);
      // Security note: Using '*' as targetOrigin for compatibility.
      // In production, consider restricting to specific origin if parent context is known.
      window.parent.postMessage({type:'tool', payload:{toolName:'select_playbook', params:{id}}}, '*');
    } else if (btn.classList.contains('delete-pb-btn')) {
      console.log('Delete button clicked for id:', id);
      window.parent.postMessage({type:'tool', payload:{toolName:'delete_playbook', params:{id}}}, '*');
    } else if (btn.classList.contains('nav-page-btn') && !btn.disabled) {
      console.log('Navigate to page:', page);
      window.parent.postMessage({type:'tool', payload:{toolName:'get_playbook_page', params:{page: parseInt(page)}}}, '*');
    }
  }
});
</script>
</body>
</html>`;
}
```

### 4. createUiResourceFromHtml ìˆ˜ì • (toolName ë™ì  ì„¤ì •)

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: createUiResourceFromHtml í•¨ìˆ˜ (line ~94)

```typescript
function createUiResourceFromHtml(html: string, toolName = 'show_playbooks') {
  const res = createUIResource({
    uri: `ui://playbooks/list/${Date.now()}`,
    content: { type: 'rawHtml', htmlString: html },
    encoding: 'text',
  }) as UIResource & { serviceInfo?: ServiceInfo };

  // Attach serviceInfo so the frontend can resolve tool names correctly
  // Use the canonical server name ('playbook') and mark this as a built-in web server
  res.serviceInfo = {
    serverName: 'playbook',
    toolName, // ë™ì ìœ¼ë¡œ ì„¤ì •
    backendType: 'BuiltInWeb',
  };

  return res;
}
```

### 5. makeListMultipartResponse ì‹œê·¸ë‹ˆì²˜ ì—…ë°ì´íŠ¸

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: makeListMultipartResponse í•¨ìˆ˜ (line ~112)

```typescript
function makeListMultipartResponse(
  items: PlaybookRecord[],
  formattedText: string,
  structured: unknown,
  pageInfo: PageResult, // âœ¨ ì¶”ê°€
  toolName = 'show_playbooks', // âœ¨ ì¶”ê°€
) {
  const textPart: MCPContent = {
    type: 'text',
    text: formattedText,
  } as unknown as MCPContent;

  const uiHtml = buildUiHtml(buildListItemsHtml(items), pageInfo); // âœ¨ pageInfo ì „ë‹¬
  const uiResource = {
    ...createUiResourceFromHtml(uiHtml, toolName), // âœ¨ toolName ì „ë‹¬
  };

  return createMCPStructuredMultipartResponse(
    [textPart, uiResource],
    structured,
  );
}
```

### 6. getPlaybooksWithUI ê³µí†µ í•¨ìˆ˜ ì¶”ê°€

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: Helper functions ì„¹ì…˜ (makeListMultipartResponse ì•„ë˜)

```typescript
/**
 * Common logic for UI-based playbook listing (show_playbooks, get_playbook_page)
 */
async function getPlaybooksWithUI(
  agentId: string,
  page: number,
  pageSize: number,
  hasDB: boolean,
  toolName: string,
  isNavigation = false,
): Promise<MCPResponse<unknown>> {
  if (hasDB && dbService.playbooks) {
    // DB branch: use indexed query
    const dbPageResult = await dbService.playbooks.getPageForAgent(
      agentId,
      page,
      pageSize,
    );

    // Convert Page<T> to PageResult
    const pageResult: PageResult = {
      page: dbPageResult.page,
      pageSize: dbPageResult.pageSize,
      totalItems: dbPageResult.totalItems,
      totalPages: dbPageResult.totalPages, // Now available from updated Page<T>
      items: dbPageResult.items as PlaybookRecord[],
    };

    if (pageResult.items.length === 0) {
      const emptyText = `[${toolName}] No playbooks found for agent ${agentId}.`;
      return createMCPStructuredResponse(emptyText, {
        page: pageResult,
      });
    }

    const formattedList = formatPlaybooksList(pageResult.items);
    const textResponse = createUITextResponse(
      toolName,
      pageResult,
      formattedList,
      isNavigation,
    );
    const structured = createListStructuredResponse(pageResult, formattedList);
    return makeListMultipartResponse(
      pageResult.items,
      textResponse,
      structured,
      pageResult,
      toolName,
    );
  }

  // In-memory branch
  const filtered = inMemory.filter((p) => p.agentId === agentId);
  const pageResult = paginateItems(filtered, page, pageSize);

  if (pageResult.items.length === 0) {
    const emptyText = `[${toolName}] No playbooks found (in-memory) for agent ${agentId}.`;
    return createMCPStructuredResponse(emptyText, {
      page: pageResult,
    });
  }

  const formattedList = formatPlaybooksList(pageResult.items);
  const textResponse = createUITextResponse(
    toolName,
    pageResult,
    formattedList,
    isNavigation,
  );
  const structured = createListStructuredResponse(pageResult, formattedList);
  return makeListMultipartResponse(
    pageResult.items,
    textResponse,
    structured,
    pageResult,
    toolName,
  );
}
```

### 7. list_playbooks case ìˆ˜ì • (í…ìŠ¤íŠ¸ ì „ìš©)

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: callTool switch-case ë‚´ 'list_playbooks' (line ~415)

```typescript
case 'list_playbooks': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[list_playbooks] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || -1);

  if (hasDB && dbService.playbooks) {
    // DB: Use indexed query for filtered pagination
    const dbPageResult = await dbService.playbooks.getPageForAgent(
      currentAssistantId,
      page,
      pageSize
    );

    // Convert Page<T> to PageResult
    const pageResult: PageResult = {
      page: dbPageResult.page,
      pageSize: dbPageResult.pageSize,
      totalItems: dbPageResult.totalItems,
      totalPages: dbPageResult.totalPages,
      items: dbPageResult.items as PlaybookRecord[],
    };

    const formattedList = formatPlaybooksList(pageResult.items);
    const textResponse = createListTextResponse(currentAssistantId, pageResult, formattedList);
    const structured = createListStructuredResponse(pageResult, formattedList);
    return createMCPStructuredResponse(textResponse, structured);
  }

  // In-memory branch
  const filtered = inMemory.filter((p) => p.agentId === currentAssistantId);
  const pageResult = paginateItems(filtered, page, pageSize);

  const formattedList = formatPlaybooksList(pageResult.items);
  const textResponse = createListTextResponse(currentAssistantId, pageResult, formattedList);
  const structured = createListStructuredResponse(pageResult, formattedList);
  return createMCPStructuredResponse(textResponse, structured);
}
```

### 8. show_playbooks case ì¶”ê°€ (UI í¬í•¨)

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: callTool switch-case ë‚´ (list_playbooks ë‹¤ìŒ)

```typescript
case 'show_playbooks': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[show_playbooks] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || -1);

  return getPlaybooksWithUI(currentAssistantId, page, pageSize, hasDB, 'show_playbooks', false);
}
```

### 9. get_playbook_page case ì¶”ê°€ (í˜ì´ì§€ ë‚´ë¹„ê²Œì´ì…˜)

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: callTool switch-case ë‚´ (show_playbooks ë‹¤ìŒ)

```typescript
case 'get_playbook_page': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[get_playbook_page] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || 10); // Default to 10 if not specified

  return getPlaybooksWithUI(currentAssistantId, page, pageSize, hasDB, 'get_playbook_page', true);
}
```

### 10. ë‹¤ë¥¸ ë„êµ¬ë“¤ì˜ í…ìŠ¤íŠ¸ ì‘ë‹µ ê°œì„ 

#### get_playbook

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: get_playbook case (line ~486)

```typescript
case 'get_playbook': {
  const id = String(a.id);
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id as string);
    if (!existing) {
      return createMCPTextResponse(`[get_playbook] Error: Playbook ${id} not found.`);
    }
    const rec = existing as PlaybookRecord;
    const formatted = formatPlaybookDetailed(rec);

    const textResponse = `[get_playbook] Retrieved playbook details for ID: ${id}

${formatted}

Note: Use 'select_playbook' to execute this playbook, or 'update_playbook' to modify it.`;

    return createMCPStructuredResponse(textResponse, {
      playbook: existing,
    });
  }

  const existing = inMemory.find((p) => p.id === String(a.id));
  if (!existing) {
    return createMCPTextResponse(`[get_playbook] Error: Playbook ${String(a.id)} not found (in-memory).`);
  }
  const formatted = formatPlaybookDetailed(existing);

  const textResponse = `[get_playbook] Retrieved playbook details for ID: ${String(a.id)} (in-memory)

${formatted}

Note: Use 'select_playbook' to execute this playbook, or 'update_playbook' to modify it.`;

  return createMCPStructuredResponse(textResponse, { playbook: existing });
}
```

#### select_playbook

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: select_playbook case (line ~562)

```typescript
case 'select_playbook': {
  const id = String(a.id);
  let existing: PlaybookRecord | undefined;
  if (hasDB && dbService.playbooks) {
    existing = (await dbService.playbooks.read(id)) as
      | PlaybookRecord
      | undefined;
  } else {
    existing = inMemory.find((p) => p.id === id);
  }

  if (!existing) {
    return createMCPTextResponse(`[select_playbook] Error: Playbook ${id} not found.`);
  }

  // Permission check
  if (currentAssistantId && existing.agentId !== currentAssistantId) {
    return createMCPTextResponse(
      `[select_playbook] Error: Playbook ${id} does not belong to the current assistant (${currentAssistantId}).`,
    );
  }

  // Build detailed text
  const formattedText = formatPlaybookDetailed(existing);

  const agentPrompt = `[select_playbook] Playbook "${existing.goal}" (ID: ${existing.id}) has been selected for execution.

Playbook Details:
---
${formattedText}
---

Instructions:
1. Review the workflow steps and success criteria above
2. Establish todos based on the workflow steps
3. Begin executing the tasks according to the defined steps
4. Track progress and verify against success criteria

You may now proceed with execution.`;

  return createMCPStructuredResponse(agentPrompt, {
    playbook: existing,
  });
}
```

#### create_playbook

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: create_playbook case (line ~365)

```typescript
case 'create_playbook': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[create_playbook] Error: Assistant ID not set. Please set context first.',
    );
  }

  const id = String(Date.now()) + '-' + String(nextId++);
  const playbook: PlaybookRecord = {
    id,
    agentId: currentAssistantId,
    goal: String(a.goal || ''),
    initialCommand: String(a.initialCommand || ''),
    workflow: ((a.workflow as Playbook['workflow']) || []).map(
      (s, i) => ({
        stepId: s?.stepId ?? `${id}-step-${i + 1}`,
        description: s?.description ?? '',
        action: s?.action ?? { toolName: '', purpose: '' },
        requiredData: s?.requiredData ?? [],
        outputVariable: s?.outputVariable ?? '',
      }),
    ),
    successCriteria:
      (a.successCriteria as Playbook['successCriteria']) || {
        description: '',
      },
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  if (hasDB && dbService.playbooks) {
    await dbService.playbooks.upsert(playbook as PlaybookRecord);
    const saved = await dbService.playbooks.read(id);
    const formatted = saved
      ? formatPlaybook(saved as PlaybookRecord)
      : `Playbook ${id} created`;

    const textResponse = `[create_playbook] Successfully created new playbook.
ID: ${id}
Goal: ${playbook.goal}
Steps: ${playbook.workflow.length}

${formatted}

The playbook is now available. Use 'list_playbooks' to see all playbooks, or 'select_playbook' with ID ${id} to execute it.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      playbook: saved,
    });
  }

  inMemory.push(playbook);
  const formattedInMemory = formatPlaybook(playbook);

  const textResponse = `[create_playbook] Successfully created new playbook (in-memory).
ID: ${id}
Goal: ${playbook.goal}
Steps: ${playbook.workflow.length}

${formattedInMemory}

The playbook is now available. Use 'list_playbooks' to see all playbooks, or 'select_playbook' with ID ${id} to execute it.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    playbook,
  });
}
```

#### update_playbook

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: update_playbook case (line ~505)

```typescript
case 'update_playbook': {
  const id = String(a.id);
  const patch = (a.playbook as Partial<Playbook>) || {};
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id as string);
    if (!existing) {
      return createMCPTextResponse(`[update_playbook] Error: Playbook ${id} not found.`);
    }
    const updatedWorkflow = (patch.workflow as Playbook['workflow'])
      ? (patch.workflow as Playbook['workflow']).map((s, i) => ({
          stepId: s?.stepId ?? `${id}-step-${i + 1}`,
          description: s?.description ?? '',
          action: s?.action ?? { toolName: '', purpose: '' },
          requiredData: s?.requiredData ?? [],
          outputVariable: s?.outputVariable ?? '',
        }))
      : existing.workflow;

    const updated: PlaybookRecord = {
      ...existing,
      ...patch,
      workflow: updatedWorkflow,
      updatedAt: new Date(),
    } as PlaybookRecord;
    await dbService.playbooks.upsert(updated);
    const saved = await dbService.playbooks.read(id);
    const formatted = saved
      ? formatPlaybook(saved as PlaybookRecord)
      : `Playbook ${id} updated`;

    const textResponse = `[update_playbook] Successfully updated playbook ID: ${id}

Updated Details:
${formatted}

The playbook has been modified. Changes are immediately available.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      playbook: saved
    });
  }

  const existing = inMemory.find((p) => p.id === id);
  if (!existing) {
    return createMCPTextResponse(`[update_playbook] Error: Playbook ${id} not found (in-memory).`);
  }
  if (patch.workflow) {
    existing.workflow = (patch.workflow as Playbook['workflow']).map(
      (s, i) => ({
        stepId: s?.stepId ?? `${id}-step-${i + 1}`,
        description: s?.description ?? '',
        action: s?.action ?? { toolName: '', purpose: '' },
        requiredData: s?.requiredData ?? [],
        outputVariable: s?.outputVariable ?? '',
      }),
    );
  }
  Object.assign(existing, patch);
  existing.updatedAt = new Date().toISOString();
  const formattedExisting = formatPlaybook(existing);

  const textResponse = `[update_playbook] Successfully updated playbook ID: ${id} (in-memory)

Updated Details:
${formattedExisting}

The playbook has been modified. Changes are immediately available.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    playbook: existing,
  });
}
```

#### delete_playbook

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: delete_playbook case (line ~463)

```typescript
case 'delete_playbook': {
  const id = String(a.id);
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id);
    if (!existing) {
      return createMCPTextResponse(`[delete_playbook] Error: Playbook ${id} not found.`);
    }
    await dbService.playbooks.delete(id);
    const formatted = formatPlaybook(existing as PlaybookRecord);

    const textResponse = `[delete_playbook] Successfully deleted playbook ID: ${id}

Deleted Playbook:
${formatted}

This playbook is no longer available. Use 'list_playbooks' to see remaining playbooks.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      id
    });
  }
  const idx = inMemory.findIndex((p) => p.id === id);
  if (idx === -1) {
    return createMCPTextResponse(`[delete_playbook] Error: Playbook ${id} not found (in-memory).`);
  }
  const removed = inMemory.splice(idx, 1)[0];
  const formattedRemoved = formatPlaybook(removed);

  const textResponse = `[delete_playbook] Successfully deleted playbook ID: ${id} (in-memory)

Deleted Playbook:
${formattedRemoved}

This playbook is no longer available. Use 'list_playbooks' to see remaining playbooks.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    id,
  });
}
```

### 11. ë²„ì „ ì—…ë°ì´íŠ¸

**íŒŒì¼**: `src/lib/web-mcp/modules/playbook-store.ts`
**ìœ„ì¹˜**: playbookStore ê°ì²´ ì •ì˜ (line ~352)

```typescript
const playbookStore: WebMCPServer = {
  name: 'playbook',
  version: '0.1.1', // 0.1.0 -> 0.1.1
  description:
    'Persisted playbook store for agent workflows (create/list/show/navigate/update/delete)',
  tools,
  // ...
};
```

## ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê´€ ì½”ë“œ

### DB Service Interface

**íŒŒì¼**: `src/lib/db/types.ts`

í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ì¸í„°í˜ì´ìŠ¤:

```typescript
interface CRUD<T, U = T> {
  upsert: (object: T) => Promise<void>;
  upsertMany: (objects: T[]) => Promise<void>;
  read: (key: string) => Promise<U | undefined>;
  delete: (key: string) => Promise<void>;
  getPage: (page: number, pageSize: number) => Promise<Page<U>>;
  count: () => Promise<number>;
}

interface Page<T> {
  items: T[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number; // âœ¨ ì¶”ê°€ë¨
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}
```

í™•ì¥ëœ PlaybookCRUD:

```typescript
interface PlaybookCRUD extends CRUD<Playbook & { id: string }> {
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<Playbook & { id: string }>>;
}
```

### Dexie ì‚¬ìš© íŒ¨í„´

**íŒŒì¼**: `src/lib/db/service.ts`, `src/lib/db/crud.ts`

```typescript
// Dexie í…Œì´ë¸” ì ‘ê·¼
const db = LocalDatabase.getInstance();
const table = db.table('playbooks');

// ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•œ í•„í„°ë§ + í˜ì´ì§•
const items = await table
  .where('agentId')
  .equals(targetAgentId)
  .offset((page - 1) * pageSize)
  .limit(pageSize)
  .toArray();

// ì¹´ìš´íŠ¸
const count = await table.where('agentId').equals(targetAgentId).count();
```

### MCP Response Utilities (ì¬ì‚¬ìš©)

**íŒŒì¼**: `src/lib/mcp-response-utils.ts`

```typescript
// ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ìœ í‹¸ë¦¬í‹°
export function createMCPTextResponse(text: string): MCPResponse<unknown>;
export function createMCPStructuredResponse(
  text: string,
  structured: unknown,
): MCPResponse<unknown>;
export function createMCPStructuredMultipartResponse(
  content: MCPContent[],
  structured: unknown,
): MCPResponse<unknown>;
```

### Type Definitions (ì¬ì‚¬ìš©)

**íŒŒì¼**: `src/types/playbook.ts`

```typescript
export interface Playbook {
  agentId: string;
  goal: string;
  initialCommand?: string;
  workflow: PlaybookStep[];
  successCriteria?: {
    description: string;
    requiredArtifacts?: string[];
  };
}

export interface PlaybookStep {
  stepId?: string;
  description: string;
  action: {
    toolName: string;
    purpose: string;
  };
  requiredData: string[];
  outputVariable: string;
}
```

## Test Code ì¶”ê°€ ë° ìˆ˜ì • í•„ìš” ë¶€ë¶„ì— ëŒ€í•œ ê°€ì´ë“œ

### í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±

**íŒŒì¼**: `src/lib/web-mcp/modules/__tests__/playbook-store.test.ts` (ì‹ ê·œ)

### í…ŒìŠ¤íŠ¸ ì¹´í…Œê³ ë¦¬

#### 0. DB Service í…ŒìŠ¤íŠ¸ (ì‹ ê·œ)

**íŒŒì¼**: `src/lib/db/__tests__/crud.test.ts` (ê¸°ì¡´ íŒŒì¼ì— ì¶”ê°€ ë˜ëŠ” ì‹ ê·œ)

```typescript
describe('playbooksCRUD.getPageForAgent', () => {
  beforeEach(async () => {
    // DB ì´ˆê¸°í™”
    const db = LocalDatabase.getInstance();
    await db.table('playbooks').clear();
  });

  it('should filter playbooks by agentId', async () => {
    // agent-1ì˜ playbooks 3ê°œ ìƒì„±
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 1',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 2',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 3',
      workflow: [],
    });

    // agent-2ì˜ playbooks 2ê°œ ìƒì„±
    await playbooksCRUD.upsert({
      agentId: 'agent-2',
      goal: 'Goal A',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-2',
      goal: 'Goal B',
      workflow: [],
    });

    // agent-1ì˜ playbooksë§Œ ì¡°íšŒ
    const result = await playbooksCRUD.getPageForAgent('agent-1', 1, -1);

    expect(result.totalItems).toBe(3);
    expect(result.items).toHaveLength(3);
    expect(result.items.every((p) => p.agentId === 'agent-1')).toBe(true);
  });

  it('should paginate correctly for specific agent', async () => {
    // agent-1ì˜ playbooks 5ê°œ ìƒì„±
    for (let i = 0; i < 5; i++) {
      await playbooksCRUD.upsert({
        agentId: 'agent-1',
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    // ì²« í˜ì´ì§€ (2ê°œ)
    const page1 = await playbooksCRUD.getPageForAgent('agent-1', 1, 2);
    expect(page1.items).toHaveLength(2);
    expect(page1.page).toBe(1);
    expect(page1.totalItems).toBe(5);
    expect(page1.totalPages).toBe(3);
    expect(page1.hasNextPage).toBe(true);
    expect(page1.hasPreviousPage).toBe(false);

    // ë‘ ë²ˆì§¸ í˜ì´ì§€ (2ê°œ)
    const page2 = await playbooksCRUD.getPageForAgent('agent-1', 2, 2);
    expect(page2.items).toHaveLength(2);
    expect(page2.page).toBe(2);
    expect(page2.hasNextPage).toBe(true);
    expect(page2.hasPreviousPage).toBe(true);

    // ë§ˆì§€ë§‰ í˜ì´ì§€ (1ê°œ)
    const page3 = await playbooksCRUD.getPageForAgent('agent-1', 3, 2);
    expect(page3.items).toHaveLength(1);
    expect(page3.hasNextPage).toBe(false);
  });

  it('should return all items when pageSize is -1', async () => {
    for (let i = 0; i < 10; i++) {
      await playbooksCRUD.upsert({
        agentId: 'test-agent',
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbooksCRUD.getPageForAgent('test-agent', 1, -1);

    expect(result.items).toHaveLength(10);
    expect(result.pageSize).toBe(-1);
    expect(result.totalPages).toBe(1);
    expect(result.hasNextPage).toBe(false);
  });

  it('should return empty page when no playbooks match agentId', async () => {
    await playbooksCRUD.upsert({
      agentId: 'other-agent',
      goal: 'Other goal',
      workflow: [],
    });

    const result = await playbooksCRUD.getPageForAgent('target-agent', 1, 10);

    expect(result.items).toHaveLength(0);
    expect(result.totalItems).toBe(0);
    expect(result.totalPages).toBe(0);
  });
});
```

#### 1. Context ê´€ë¦¬ í…ŒìŠ¤íŠ¸

```typescript
describe('Context Management', () => {
  it('should reject list_playbooks when assistantId is not set', async () => {
    // switchContext í˜¸ì¶œ ì—†ì´ list_playbooks í˜¸ì¶œ
    const result = await playbookStore.callTool('list_playbooks', {});
    expect(result.content[0].text).toContain(
      '[list_playbooks] Error: Assistant ID not set',
    );
  });

  it('should accept valid assistantId via switchContext', async () => {
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    // ì´í›„ í˜¸ì¶œë“¤ì´ ì •ìƒ ë™ì‘í•´ì•¼ í•¨
  });
});
```

#### 2. list_playbooks (í…ìŠ¤íŠ¸ ì „ìš©) í…ŒìŠ¤íŠ¸

```typescript
describe('list_playbooks (text-only)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('should return empty list with correct structure and context', async () => {
    const result = await playbookStore.callTool('list_playbooks', {});
    expect(result.content).toHaveLength(1); // í…ìŠ¤íŠ¸ë§Œ
    expect(result.content[0].type).toBe('text');
    expect(result.content[0].text).toContain('[list_playbooks]');
    expect(result.content[0].text).toContain('No playbooks found');
    expect(result.structured.page).toBeDefined();
    expect(result.structured.page.totalItems).toBe(0);
  });

  it('should return text-only response without UIResource', async () => {
    // Playbook ìƒì„±
    await playbookStore.callTool('create_playbook', {
      goal: 'Test goal',
      workflow: [
        {
          /* ... */
        },
      ],
    });

    const result = await playbookStore.callTool('list_playbooks', {});

    // UIResourceê°€ ì—†ì–´ì•¼ í•¨
    expect(result.content).toHaveLength(1);
    expect(result.content.every((c) => c.type !== 'resource')).toBe(true);

    // êµ¬ì¡°í™”ëœ ë°ì´í„° ê²€ì¦
    expect(result.structured.page.items).toHaveLength(1);
    expect(result.structured.formattedText).toContain('Test goal');

    // Agent context ì¹œí™”ì  í…ìŠ¤íŠ¸ ê²€ì¦
    expect(result.content[0].text).toContain('[list_playbooks]');
    expect(result.content[0].text).toContain('Found 1 playbook(s)');
    expect(result.content[0].text).toContain('Note: Use');
  });

  it('should apply pagination correctly (in-memory)', async () => {
    // 5ê°œ playbook ìƒì„±
    for (let i = 0; i < 5; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('list_playbooks', {
      page: 1,
      pageSize: 2,
    });

    expect(result.structured.page.items).toHaveLength(2);
    expect(result.structured.page.totalItems).toBe(5);
    expect(result.structured.page.totalPages).toBe(3);
    expect(result.structured.page.page).toBe(1);

    // Text includes pagination info
    expect(result.content[0].text).toContain('page 1 of 3');
  });

  it('should filter by assistantId correctly', async () => {
    // agent-1ì˜ playbook
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    await playbookStore.callTool('create_playbook', {
      goal: 'Agent 1 goal',
      workflow: [],
    });

    // agent-2ì˜ playbook
    await playbookStore.switchContext({ assistantId: 'agent-2' });
    await playbookStore.callTool('create_playbook', {
      goal: 'Agent 2 goal',
      workflow: [],
    });

    // agent-1ë¡œ ì „í™˜í•˜ì—¬ ì¡°íšŒ
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    const result = await playbookStore.callTool('list_playbooks', {});

    expect(result.structured.page.totalItems).toBe(1);
    expect(result.structured.formattedText).toContain('Agent 1 goal');
    expect(result.structured.formattedText).not.toContain('Agent 2 goal');
  });
});
```

#### 3. show_playbooks (UI í¬í•¨) í…ŒìŠ¤íŠ¸

```typescript
describe('show_playbooks (with UI and pagination)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('should return multipart response with text and UIResource', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: 'Test UI goal',
      workflow: [],
    });

    const result = await playbookStore.callTool('show_playbooks', {});

    // Multipart ê²€ì¦
    expect(result.content).toHaveLength(2);
    expect(result.content[0].type).toBe('text');
    expect(result.content[1].type).toBe('resource');

    // Text includes context info
    expect(result.content[0].text).toContain('[show_playbooks]');
    expect(result.content[0].text).toContain('Agent paused');

    // UIResource ê²€ì¦
    const uiResource = result.content[1].resource;
    expect(uiResource.uri).toMatch(/^ui:\/\/playbooks\/list\//);
    expect(uiResource.serviceInfo?.serverName).toBe('playbook');
    expect(uiResource.serviceInfo?.toolName).toBe('show_playbooks');
    expect(uiResource.serviceInfo?.backendType).toBe('BuiltInWeb');
  });

  it('should generate HTML with Select, Delete, and Navigation buttons', async () => {
    // Multiple playbooks for pagination
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Button test ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const uiResource = result.content[1].resource;
    const htmlContent = uiResource.content.htmlString;

    expect(htmlContent).toContain('class="select-pb-btn"');
    expect(htmlContent).toContain('class="delete-pb-btn"');
    expect(htmlContent).toContain('class="nav-page-btn"');
    expect(htmlContent).toContain('data-pbid=');
    expect(htmlContent).toContain('data-page=');
    expect(htmlContent).toContain('window.parent.postMessage');
    expect(htmlContent).toContain('Page 1 of 2');
  });

  it('should disable Previous button on first page', async () => {
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).toMatch(
      /<button[^>]*data-page="0"[^>]*disabled[^>]*>â† Previous/,
    );
  });

  it('should disable Next button on last page', async () => {
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 2,
      pageSize: 2,
    });
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).toMatch(
      /<button[^>]*data-page="3"[^>]*disabled[^>]*>Next â†’/,
    );
  });

  it('should escape HTML in playbook goal', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: '<script>alert("xss")</script>',
      workflow: [],
    });

    const result = await playbookStore.callTool('show_playbooks', {});
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).not.toContain('<script>alert("xss")</script>');
    expect(htmlContent).toContain('&lt;script&gt;');
  });
});
```

#### 4. get_playbook_page (í˜ì´ì§€ë„¤ì´ì…˜) í…ŒìŠ¤íŠ¸

```typescript
describe('get_playbook_page (pagination)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    // Create test data
    for (let i = 0; i < 5; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Page test ${i}`,
        workflow: [],
      });
    }
  });

  it('should navigate to specified page', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 2,
      pageSize: 2,
    });

    expect(result.content).toHaveLength(2); // text + UI
    expect(result.content[0].text).toContain('[get_playbook_page]');
    expect(result.content[0].text).toContain('Navigated to page 2');
    expect(result.structured.page.page).toBe(2);
  });

  it('should generate UI with correct page buttons', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 2,
      pageSize: 2,
    });

    const htmlContent = result.content[1].resource.content.htmlString;
    expect(htmlContent).toContain('Page 2 of 3');
    expect(htmlContent).toContain('data-page="1"'); // Previous
    expect(htmlContent).toContain('data-page="3"'); // Next
  });

  it('should set serviceInfo.toolName to get_playbook_page', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 1,
    });

    const uiResource = result.content[1].resource;
    expect(uiResource.serviceInfo?.toolName).toBe('get_playbook_page');
  });
});
```

#### 5. í˜ì´ì§• ì¼ê´€ì„± í…ŒìŠ¤íŠ¸

```typescript
describe('Pagination Consistency', () => {
  it('should have identical page structure between list and show', async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const listResult = await playbookStore.callTool('list_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const showResult = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });

    // í˜ì´ì§€ êµ¬ì¡° ë™ì¼ì„± ê²€ì¦
    expect(listResult.structured.page.page).toBe(
      showResult.structured.page.page,
    );
    expect(listResult.structured.page.totalItems).toBe(
      showResult.structured.page.totalItems,
    );
    expect(listResult.structured.page.totalPages).toBe(
      showResult.structured.page.totalPages,
    );
  });

  it('should handle pageSize=-1 (all items) correctly', async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    for (let i = 0; i < 10; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('list_playbooks', {
      pageSize: -1,
    });

    expect(result.structured.page.items).toHaveLength(10);
    expect(result.structured.page.pageSize).toBe(-1);
    expect(result.structured.page.totalPages).toBe(1);
  });
});
```

#### 6. Agent Context í…ìŠ¤íŠ¸ ì‘ë‹µ í…ŒìŠ¤íŠ¸

```typescript
describe('Agent Context-Aware Text Responses', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('list_playbooks should include tool name and context', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: 'Test',
      workflow: [],
    });

    const result = await playbookStore.callTool('list_playbooks', {});
    const text = result.content[0].text;

    expect(text).toContain('[list_playbooks]');
    expect(text).toContain('Found 1 playbook(s)');
    expect(text).toContain('page 1 of 1');
    expect(text).toContain('Note: Use');
  });

  it('get_playbook should include tool name and action hints', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Test',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('get_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[get_playbook]');
    expect(text).toContain(`Retrieved playbook details for ID: ${id}`);
    expect(text).toContain('Note: Use');
  });

  it('select_playbook should include execution instructions', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Test Execution',
      workflow: [
        {
          description: 'Step 1',
          action: { toolName: 'test', purpose: 'test' },
          requiredData: [],
          outputVariable: 'out',
        },
      ],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('select_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[select_playbook]');
    expect(text).toContain('has been selected for execution');
    expect(text).toContain('Instructions:');
    expect(text).toContain('You may now proceed');
  });

  it('create_playbook should include success confirmation and next steps', async () => {
    const result = await playbookStore.callTool('create_playbook', {
      goal: 'New Playbook',
      workflow: [],
    });
    const text = result.content[0].text;

    expect(text).toContain('[create_playbook]');
    expect(text).toContain('Successfully created');
    expect(text).toContain('ID:');
    expect(text).toContain("Use 'list_playbooks'");
  });

  it('update_playbook should confirm changes', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Original',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('update_playbook', {
      id,
      playbook: { goal: 'Updated' },
    });
    const text = result.content[0].text;

    expect(text).toContain('[update_playbook]');
    expect(text).toContain('Successfully updated');
    expect(text).toContain('Changes are immediately available');
  });

  it('delete_playbook should confirm deletion', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'To Delete',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('delete_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[delete_playbook]');
    expect(text).toContain('Successfully deleted');
    expect(text).toContain('no longer available');
  });
});
```

#### 7. Helper Functions ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```typescript
describe('Helper Functions', () => {
  describe('paginateItems', () => {
    const mockItems = Array.from({ length: 10 }, (_, i) => ({
      id: `${i}`,
      agentId: 'test',
      goal: `Goal ${i}`,
      workflow: [],
    }));

    it('should paginate correctly', () => {
      const result = paginateItems(mockItems, 2, 3);
      expect(result.items).toHaveLength(3);
      expect(result.items[0].id).toBe('3'); // ë‘ ë²ˆì§¸ í˜ì´ì§€ ì‹œì‘
      expect(result.page).toBe(2);
      expect(result.totalPages).toBe(4);
    });

    it('should return all items when pageSize=-1', () => {
      const result = paginateItems(mockItems, 1, -1);
      expect(result.items).toHaveLength(10);
      expect(result.totalPages).toBe(1);
    });

    it('should handle empty array', () => {
      const result = paginateItems([], 1, 10);
      expect(result.items).toHaveLength(0);
      expect(result.totalItems).toBe(0);
      expect(result.totalPages).toBe(0);
    });
  });

  describe('formatPlaybooksList', () => {
    it('should format items with numbering', () => {
      const items = [
        { id: '1', goal: 'Goal 1', workflow: [], createdAt: '2025-01-01' },
        { id: '2', goal: 'Goal 2', workflow: [], createdAt: '2025-01-02' },
      ];
      const result = formatPlaybooksList(items);

      expect(result).toContain('1. id:1 goal:"Goal 1"');
      expect(result).toContain('2. id:2 goal:"Goal 2"');
    });
  });

  describe('escapeHtml', () => {
    it('should escape HTML entities', () => {
      expect(escapeHtml('<script>')).toBe('&lt;script&gt;');
      expect(escapeHtml('a & b')).toBe('a &amp; b');
      expect(escapeHtml('"quote"')).toBe('&quot;quote&quot;');
    });
  });
});
```

### í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ê°€ì´ë“œ

```bash
# ë‹¨ì¼ í…ŒìŠ¤íŠ¸ íŒŒì¼ ì‹¤í–‰
pnpm test src/lib/web-mcp/modules/__tests__/playbook-store.test.ts

# Watch ëª¨ë“œë¡œ ê°œë°œ
pnpm test:watch playbook-store

# Coverage í™•ì¸
pnpm test:coverage
```

### Mock ì„¤ì • ê°€ì´ë“œ

```typescript
// DB service mock (í•„ìš” ì‹œ)
jest.mock('@/lib/db', () => ({
  dbService: {
    playbooks: {
      read: jest.fn(),
      upsert: jest.fn(),
      delete: jest.fn(),
      getPage: jest.fn(),
      getPageForAgent: jest.fn(), // âœ¨ ì¶”ê°€
      count: jest.fn(),
    },
  },
}));
```

## êµ¬í˜„ ë‹¨ê³„ (ê¶Œì¥ ìˆœì„œ)

### Phase 0: DB Service í™•ì¥ (ìµœìš°ì„ )

1. **Page<T> ì¸í„°í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸**
   - `src/lib/db/types.ts`ì— `totalPages` í•„ë“œ ì¶”ê°€
   - ë¡œì»¬ í…ŒìŠ¤íŠ¸ë¡œ íƒ€ì… ì²´í¬ í™•ì¸

2. **createPage í—¬í¼ ì—…ë°ì´íŠ¸**
   - `src/lib/db/crud.ts`ì—ì„œ `totalPages` ê³„ì‚° ë¡œì§ ì¶”ê°€
   - ê¸°ì¡´ ì‚¬ìš©ì²˜ ì˜í–¥ ì—†ëŠ”ì§€ í™•ì¸

3. **DB ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸**
   - `src/lib/db/service.ts`ì— version 8 ì¶”ê°€
   - `playbooks` í…Œì´ë¸”ì— `agentId` ì¸ë±ìŠ¤ ì¶”ê°€
   - ë¡œì»¬ í…ŒìŠ¤íŠ¸ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë™ì‘ í™•ì¸

4. **íƒ€ì… ì •ì˜ í™•ì¥**
   - `src/lib/db/types.ts`ì— `PlaybookCRUD` ì¸í„°í˜ì´ìŠ¤ ì¶”ê°€
   - `DatabaseService.playbooks` íƒ€ì… ë³€ê²½

5. **playbooksCRUD í™•ì¥**
   - `src/lib/db/crud.ts`ì— `getPageForAgent` ë©”ì„œë“œ êµ¬í˜„
   - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± (agentId í•„í„°ë§ + í˜ì´ì§• ê²€ì¦)

### Phase 1: ê¸°ë°˜ ì‘ì—… + show_playbooks + get_playbook_page (Breaking Change ì—†ìŒ)

1. Helper functions ì¶”ê°€
   - `paginateItems()`: In-memory í˜ì´ì§•
   - `createListStructuredResponse()`: ì¼ê´€ëœ êµ¬ì¡° ìƒì„±
   - `createListTextResponse()`: Agent context ì¹œí™”ì  í…ìŠ¤íŠ¸ (list_playbooksìš©)
   - `createUITextResponse()`: Agent context ì¹œí™”ì  í…ìŠ¤íŠ¸ (UI ë„êµ¬ìš©)
   - `getPlaybooksWithUI()`: ê³µí†µ UI ìƒì„± ë¡œì§

2. HTML UI ì—…ë°ì´íŠ¸
   - `buildUiHtml()` ì‹œê·¸ë‹ˆì²˜ ë³€ê²½ (pageInfo ì¶”ê°€)
   - í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì¶”ê°€ (Previous/Next)
   - CSS ìŠ¤íƒ€ì¼ ì¶”ê°€
   - ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì—…ë°ì´íŠ¸ (get_playbook_page í˜¸ì¶œ)

3. `show_playbooks` íˆ´ ì¶”ê°€
   - tools ë°°ì—´ì— ì •ì˜ ì¶”ê°€
   - case êµ¬í˜„ (`getPlaybooksWithUI()` í˜¸ì¶œ)

4. `get_playbook_page` íˆ´ ì¶”ê°€
   - tools ë°°ì—´ì— ì •ì˜ ì¶”ê°€
   - case êµ¬í˜„ (`getPlaybooksWithUI()` í˜¸ì¶œ)

5. Helper functions ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì‹¤í–‰

6. `show_playbooks`, `get_playbook_page` í†µí•© í…ŒìŠ¤íŠ¸

### Phase 2: list_playbooks ìˆ˜ì • + ëª¨ë“  ë„êµ¬ í…ìŠ¤íŠ¸ ê°œì„  (Potentially Breaking)

1. `list_playbooks` case ìˆ˜ì •
   - Text-only ì‘ë‹µìœ¼ë¡œ ë³€ê²½ (UIResource ì œê±°)
   - `getPageForAgent()` ì‚¬ìš© (DB ë¶„ê¸°)
   - `paginateItems()` ì‚¬ìš© (in-memory ë¶„ê¸°)
   - Agent context ì¹œí™”ì  í…ìŠ¤íŠ¸ ìƒì„±
   - In-memory ë¹ˆ ì‘ë‹µ êµ¬ì¡° í†µì¼

2. ë‹¤ë¥¸ ë„êµ¬ë“¤ì˜ í…ìŠ¤íŠ¸ ì‘ë‹µ ê°œì„ 
   - `get_playbook`: ë„êµ¬ëª… + ì•¡ì…˜ íŒíŠ¸ ì¶”ê°€
   - `select_playbook`: ì‹¤í–‰ ì§€ì¹¨ ëª…í™•í™”
   - `create_playbook`: ìƒì„± í™•ì¸ + ë‹¤ìŒ ì•¡ì…˜
   - `update_playbook`: ì—…ë°ì´íŠ¸ í™•ì¸
   - `delete_playbook`: ì‚­ì œ í™•ì¸ + ê²°ê³¼

3. ê¸°ì¡´ `list_playbooks` í…ŒìŠ¤íŠ¸ ì—…ë°ì´íŠ¸

4. Agent context í…ìŠ¤íŠ¸ ì‘ë‹µ í…ŒìŠ¤íŠ¸ ì¶”ê°€

### Phase 3: í†µí•© ë° ë¬¸ì„œí™”

1. ë²„ì „ ì—…ë°ì´íŠ¸ (`0.1.1`)

2. `pnpm refactor:validate` ì‹¤í–‰
   - Lint ì²´í¬
   - Format ì²´í¬
   - TypeScript ì»´íŒŒì¼
   - Build ê²€ì¦

3. ìˆ˜ë™ í…ŒìŠ¤íŠ¸
   - í˜ì´ì§€ë„¤ì´ì…˜ UI ë™ì‘ í™•ì¸
   - Previous/Next ë²„íŠ¼ disabled ìƒíƒœ í™•ì¸
   - Select/Delete ë²„íŠ¼ ì •ìƒ ë™ì‘ í™•ì¸
   - Agent contextì— ì¶”ê°€ë˜ëŠ” í…ìŠ¤íŠ¸ í™•ì¸

4. CHANGELOG ì‘ì„± (ê°„ë‹¨íˆ)

### Phase 4: ë¦´ë¦¬ì¦ˆ (ìƒëµ ê°€ëŠ¥ - ë¹„í”„ë¡œë•ì…˜)

1. Feature branch merge (ì„ íƒ ì‚¬í•­)
2. ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ë°œí–‰ (ì„ íƒ ì‚¬í•­)

## ë¡¤ë°± ê³„íš (ê°„ì†Œí™” - ë¹„í”„ë¡œë•ì…˜)

### ë¡¤ë°± íŠ¸ë¦¬ê±°

- ì¹˜ëª…ì  ë²„ê·¸ ë°œê²¬
- ë¹Œë“œ ì‹¤íŒ¨
- í…ŒìŠ¤íŠ¸ ëŒ€ëŸ‰ ì‹¤íŒ¨

### ë¡¤ë°± ì ˆì°¨

1. Git revertë¡œ ì´ì „ ì»¤ë°‹ìœ¼ë¡œ ë³µê·€
2. `pnpm refactor:validate` ì¬ì‹¤í–‰
3. ë¬¸ì œ ë¶„ì„ ë° ì¬ì‹œë„

## ì°¸ê³  ë¬¸ì„œ

- [MCP Protocol Specification](https://modelcontextprotocol.io/docs)
- [Playbook Type Definition](./src/types/playbook.ts)
- [Web MCP Server Architecture](./docs/architecture/web-mcp-architecture.md) (ì¡´ì¬ ì‹œ)
- [Frontend MCP Integration Guide](./docs/guides/mcp-integration.md) (ì¡´ì¬ ì‹œ)

---

**ì‘ì„±ì**: Claude (Anthropic)
**ì‘ì„±ì¼**: 2025-01-11 (updated)
**ìµœì¢… ìˆ˜ì •ì¼**: 2025-01-11 23:45
**ë²„ì „**: 2.0
**ë¦¬ë·° í•„ìš” í•­ëª©**: Agent Context í…ìŠ¤íŠ¸ ì‘ë‹µ ê°€ë…ì„±, í˜ì´ì§€ë„¤ì´ì…˜ UI UX

**ì£¼ìš” ë³€ê²½ì‚¬í•­ (v2.0)**:

- âœ… `Page<T>` ì¸í„°í˜ì´ìŠ¤ì— `totalPages` í•„ë“œ ì¶”ê°€
- âœ… `get_playbook_page` ë„êµ¬ ì¶”ê°€ (í˜ì´ì§€ë„¤ì´ì…˜ ë‚´ë¹„ê²Œì´ì…˜)
- âœ… **Agent Context ìµœì í™”**: ëª¨ë“  í…ìŠ¤íŠ¸ ì‘ë‹µì— ëª…í™•í•œ ë§¥ë½ ì •ë³´ ì¶”ê°€ (ë„êµ¬ëª…, ìš”ì•½, íŒíŠ¸)
- âœ… í˜ì´ì§€ë„¤ì´ì…˜ UI êµ¬í˜„ (Previous/Next ë²„íŠ¼, í˜ì´ì§€ ì •ë³´ í‘œì‹œ)
- âœ… ê³µí†µ ë¡œì§ í•¨ìˆ˜ ì¶”ê°€ (`getPlaybooksWithUI()`, `createListTextResponse()`, `createUITextResponse()`)
- âœ… `buildUiHtml()` ì‹œê·¸ë‹ˆì²˜ ë³€ê²½ (í˜ì´ì§€ ì •ë³´ ì „ë‹¬)
- âœ… ëª¨ë“  ë„êµ¬ì˜ í…ìŠ¤íŠ¸ ì‘ë‹µ ê°œì„  (create, update, delete, get, select)
- âœ… Agent Context í…ìŠ¤íŠ¸ ì‘ë‹µ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¶”ê°€
- âœ… í˜ì´ì§€ë„¤ì´ì…˜ UI í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¶”ê°€
