# Playbook Store 리팩토링 계획: list_playbooks와 show_playbooks 분리 + Pagination 추가

## 작업의 목적

현재 `list_playbooks` 툴은 텍스트 프롬프트와 UI 리소스(HTML)를 함께 반환하는 multipart 응답을 생성합니다. 이는 두 가지 서로 다른 책임을 하나의 툴에서 처리하고 있어 다음과 같은 문제가 있습니다:

1. **책임의 혼재**: AI 에이전트가 텍스트 프롬프트만 필요한 경우에도 UI 리소스가 함께 생성됨
2. **유연성 부족**: 클라이언트가 텍스트 전용 응답 또는 UI 전용 응답을 선택할 수 없음
3. **성능 오버헤드**: 불필요한 HTML 생성 및 UIResource 객체 생성 비용
4. **에이전트 실행 중단**: UIResource 포함 시 에이전트 실행이 일시 중지되어, 자율적인 playbook 조회 불가

본 리팩토링의 목적은:

- `list_playbooks`: 텍스트 프롬프트 전용 응답으로 단순화 (AI 에이전트가 작업 중단 없이 조회 가능)
- `show_playbooks`: UI 리소스 생성 전용 툴로 분리 (사용자 인터랙션용, 에이전트 일시 중지)
- `get_playbook_page`: 페이지네이션 내비게이션 전용 툴 추가 (UI 버튼 클릭용)
- **Agent Context 최적화**: 모든 텍스트 응답이 명확한 맥락 정보 제공 (도구명, 결과 요약, 다음 액션 힌트)
- 관심사의 분리(Separation of Concerns)를 통한 코드 유지보수성 향상

## 현재 상태 / 문제점

### 현재 코드 구조 (Birdeye View)

`playbook-store.ts`는 WebMCP 서버로서 다음과 같은 구조를 가지고 있습니다:

```
playbookStore (WebMCPServer)
├── tools: MCPTool[] (6개 툴 정의)
│   ├── create_playbook
│   ├── list_playbooks  ⚠️ (리팩토링 대상)
│   ├── get_playbook
│   ├── select_playbook
│   ├── update_playbook
│   └── delete_playbook
├── callTool(name, args) -> MCPResponse
│   └── switch-case로 각 툴 처리
└── switchContext(context) -> void
    └── currentAssistantId 설정
```

### Helper Functions (재사용 가능 컴포넌트)

```typescript
// 텍스트 포맷팅
formatPlaybooksList(items: PlaybookRecord[]): string
  - 목록을 번호가 매겨진 텍스트로 변환

// UI 생성
buildListItemsHtml(items: PlaybookRecord[]): string
  - HTML 카드 목록 생성 (Select/Delete 버튼 포함)

buildUiHtml(listItemsHtml: string): string
  - 완전한 HTML 문서 생성 (스크립트 포함)

createUiResourceFromHtml(html: string): UIResource
  - HTML을 UIResource로 래핑 (serviceInfo 포함)

makeListMultipartResponse(items, text, structured): MCPResponse
  - 텍스트 + UIResource multipart 응답 생성
```

### 현재 list_playbooks의 동작 방식

#### 입력

- `page?: number` (default: 1)
- `pageSize?: number` (default: -1, 모든 항목)
- 암묵적: `currentAssistantId` (컨텍스트에서 설정)

#### 처리 로직

1. `currentAssistantId` 검증 (없으면 에러 반환)
2. DB/In-memory 분기 처리
3. 페이징 적용 (`getPage` 또는 배열 전체)
4. `agentId` 필터링 (**문제점: DB에서는 페이징 후 필터링**)
5. 결과가 없으면 텍스트 응답 반환
6. 결과가 있으면:
   - `formatPlaybooksList(items)` -> 텍스트 생성
   - `makeListMultipartResponse(...)` -> multipart 응답 생성
     - 텍스트 파트
     - UIResource 파트 (HTML + 이벤트 핸들러)

#### 출력

- 성공 (항목 있음): `MCPResponse<multipart>` with [text, UIResource]
- 성공 (항목 없음): `MCPResponse<structured>` with text only
- 실패: `MCPResponse<text>` with error message

### 식별된 문제점

#### 1. 페이징/필터링 버그 (Critical)

```typescript
// DB 분기의 현재 코드
const pageResult = await dbService.playbooks.getPage(page, pageSize);
let items = pageResult.items as PlaybookRecord[];
items = items.filter((p) => p.agentId === currentAssistantId);
```

**문제**:

- 전체 데이터에서 페이징한 후 필터링하므로 부정확한 결과
- 예: page=1에 다른 agent의 playbook만 있으면 현재 agent는 빈 페이지 받음
- `pageResult.totalItems` 등의 메타데이터가 필터링 전 값이라 부정확

**영향도**: High - 멀티 에이전트 환경에서 데이터 손실 가능성

#### 2. DB와 In-memory 분기 불일치 (Medium)

```typescript
// In-memory 분기
let items = [...inMemory];
items = items.filter((p) => p.agentId === currentAssistantId);
// 페이징 로직 없음 - 모든 항목 반환
```

**문제**:

- DB 모드는 페이징 시도, In-memory는 페이징 무시
- 응답 구조 불일치: `{ page: {...} }` vs `{ playbooks: [...] }`

**영향도**: Medium - 개발/프로덕션 환경 간 동작 차이

#### 3. 책임의 혼재 + 에이전트 실행 중단 (High)

```typescript
return makeListMultipartResponse(items, formatted, { ... });
```

**문제**:

- AI 에이전트는 텍스트만 필요한데 UI 생성 비용 발생
- **UIResource 포함 시 에이전트 실행이 일시 중지됨**
- 에이전트가 자율적으로 playbook 목록을 조회하고 분석할 수 없음
- 단일 책임 원칙(SRP) 위반

**영향도**: High - 에이전트 자율성 저해 및 성능 오버헤드

#### 4. Agent Context에 불명확한 정보 전달 (Critical - 신규)

**문제**:

- 현재 텍스트 응답에 도구명, 맥락 정보 없음
- Agent가 "어떤 도구의 응답인지", "왜 이 데이터가 왔는지" 파악 불가
- 페이지 정보, 전체 개수 등 메타데이터가 텍스트에 포함되지 않음
- 다음 액션에 대한 힌트 없음

**예시 (현재)**:

```
1. id:123 goal:"Deploy" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" steps:3 createdAt:2025-01-02
```

→ **맥락 없음, Agent가 이해하기 어려움**

**영향도**: Critical - Agent의 의사결정 능력 저하

#### 5. 페이지네이션 UI 부재 (Medium)

**문제**:

- `show_playbooks`가 UI를 제공하지만 페이지 이동 방법 없음
- Previous/Next 버튼 없음
- 페이지 정보 표시 없음

**영향도**: Medium - UX 불완전

#### 6. 보안 취약점 (Low)

```typescript
window.parent.postMessage({...}, '*');  // targetOrigin: '*'
```

**문제**: 모든 origin에 메시지 전송 가능

**영향도**: Low - 제한된 컨텍스트에서 실행되므로 현재는 위험 낮음

## 변경 이후의 상태 / 해결 판정 기준

### 목표 아키텍처

```
playbookStore (WebMCPServer)
├── tools: MCPTool[] (8개 툴)
│   ├── create_playbook
│   ├── list_playbooks  ✅ (텍스트 전용, Agent 자율 조회)
│   ├── show_playbooks  ✨ (신규: 초기 UI 표시)
│   ├── get_playbook_page ✨ (신규: 페이지 내비게이션)
│   ├── get_playbook
│   ├── select_playbook
│   ├── update_playbook
│   └── delete_playbook
└── callTool(name, args) -> MCPResponse
    ├── case 'list_playbooks': -> structured response (text only)
    ├── case 'show_playbooks': -> multipart response (text + UI)
    └── case 'get_playbook_page': -> multipart response (text + UI)
```

### 도구별 역할 분리

| Tool                | Response Type     | Purpose         | Agent Behavior | Context Text         |
| ------------------- | ----------------- | --------------- | -------------- | -------------------- |
| `list_playbooks`    | Text + Structured | Agent 자율 쿼리 | ✅ 계속 실행   | 명확한 맥락 + 힌트   |
| `show_playbooks`    | Text + UIResource | 초기 UI 표시    | ⏸️ 일시 중지   | 데이터 + 상태 표시   |
| `get_playbook_page` | Text + UIResource | 페이지 이동     | ⏸️ 일시 중지   | 페이지 정보 + 데이터 |

### list_playbooks (변경 후)

#### API 계약

```typescript
// Input
interface ListPlaybooksInput {
  page?: number; // default: 1
  pageSize?: number; // default: -1 (all)
}

// Output (성공)
interface ListPlaybooksOutput {
  content: [{ type: 'text'; text: string }];
  structured: {
    page: {
      page: number;
      pageSize: number;
      totalItems: number;
      totalPages: number;
      items: PlaybookRecord[];
    };
    formattedText: string;
  };
}
```

#### 동작

1. Context 검증
2. DB/In-memory 분기
   - **DB**: `getPageForAgent(assistantId, page, pageSize)` 호출 (필터링 후 페이징)
   - **In-memory**: 필터링 후 `slice()`로 페이징 적용
3. 일관된 페이지 메타데이터 생성
4. `formatPlaybooksList(items)` 텍스트 생성
5. **Agent Context 친화적 텍스트 응답 생성** (도구명, 요약, 힌트 포함)
6. `createMCPStructuredResponse(text, structured)` 반환

#### 예시 응답 (Agent Context에 추가됨)

```
[list_playbooks] Found 25 playbook(s) for agent abc-123.
Showing page 1 of 3 (10 items on this page):

1. id:123 goal:"Deploy app" initial:"deploy production" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" initial:"fix auth issue" steps:3 createdAt:2025-01-02
...

Note: Use 'get_playbook' to view details or 'select_playbook' to execute a playbook.
```

### show_playbooks (신규)

#### API 계약

```typescript
// Input
interface ShowPlaybooksInput {
  page?: number; // default: 1
  pageSize?: number; // default: -1 (all)
}

// Output (성공)
interface ShowPlaybooksOutput {
  content: [
    { type: 'text'; text: string },
    { type: 'resource'; resource: UIResource },
  ];
  structured: {
    page: { page; pageSize; totalItems; totalPages; items };
    formattedText: string;
  };
}
```

#### 동작

1. `list_playbooks`와 동일한 필터링/페이징 로직 재사용
2. **Agent Context 친화적 텍스트 응답 생성** (UI 표시 상태 포함)
3. **페이지네이션 UI 포함한 HTML 생성**
4. `makeListMultipartResponse(items, text, structured, pageInfo)` 호출
5. UIResource에 `serviceInfo.toolName = 'show_playbooks'` 설정

#### 예시 응답 (Agent Context에 추가됨)

```
[show_playbooks] Displaying 25 playbook(s) in interactive UI.
Current page: 1 of 3

Playbooks on this page:
1. id:123 goal:"Deploy app" steps:5 createdAt:2025-01-01
2. id:456 goal:"Fix bug" steps:3 createdAt:2025-01-02
...

Status: Agent paused for user interaction (Select/Delete/Navigate buttons available).
```

### get_playbook_page (신규)

#### API 계약

```typescript
// Input
interface GetPlaybookPageInput {
  page: number; // required: 이동할 페이지 번호 (1-based)
  pageSize?: number; // optional: 페이지 크기 (이전 값 유지)
}

// Output
interface GetPlaybookPageOutput {
  content: [
    { type: 'text'; text: string },
    { type: 'resource'; resource: UIResource },
  ];
  structured: {
    page: { page; pageSize; totalItems; totalPages; items };
    formattedText: string;
  };
}
```

#### 동작

1. `show_playbooks`와 동일한 로직 (코드 재사용: `getPlaybooksWithUI()`)
2. 페이지 내비게이션 전용 (UI 버튼 클릭으로 호출됨)
3. Agent는 일시 중지 상태 유지

#### 예시 응답 (Agent Context에 추가됨)

```
[get_playbook_page] Navigated to page 2 of 3.
Displaying 10 of 25 total playbook(s):

1. id:789 goal:"Update deps" steps:2 createdAt:2025-01-03
...

Status: Agent paused for user interaction.
```

### 페이지네이션 UI 설계

#### HTML 구조

```html
<div class="pagination">
  <button data-page="1" class="nav-page-btn" [disabled]>← Previous</button>
  <span class="page-info">Page 2 of 3 (25 total)</span>
  <button data-page="3" class="nav-page-btn">Next →</button>
</div>
```

#### 이벤트 처리

```javascript
if (btn.classList.contains('nav-page-btn') && !btn.disabled) {
  const page = parseInt(btn.getAttribute('data-page'));
  window.parent.postMessage(
    {
      type: 'tool',
      payload: { toolName: 'get_playbook_page', params: { page } },
    },
    '*',
  );
}
```

### Agent Context 최적화 원칙

**모든 텍스트 응답은 다음을 포함:**

1. **도구 식별**: `[tool_name]` prefix
2. **액션 결과**: "Found ...", "Successfully ...", "Displaying ..."
3. **핵심 데이터**: 실제 내용 (포맷팅된 목록/상세정보)
4. **맥락 정보**: 페이지 번호, 총 개수, 에이전트 ID 등
5. **다음 액션 힌트**: "Use 'xxx' to ...", "You may now ..."
6. **상태 표시** (UI 도구): "Agent paused for user interaction"

### 해결 판정 기준

#### 필수 기준 (Must)

1. ✅ `Page<T>` 인터페이스에 `totalPages` 필드 추가
2. ✅ `list_playbooks`는 UI 리소스 없이 텍스트만 반환
3. ✅ `show_playbooks`는 텍스트 + UI 리소스를 multipart로 반환
4. ✅ `get_playbook_page`는 페이지 내비게이션 제공
5. ✅ DB 분기에서 필터링 후 페이징 적용 (정확한 페이지 메타데이터)
6. ✅ In-memory 분기도 페이징 로직 적용
7. ✅ DB와 In-memory의 응답 구조 일치 (`page` 객체)
8. ✅ **모든 텍스트 응답에 명확한 맥락 정보 포함** (도구명, 요약, 힌트)
9. ✅ **페이지네이션 UI 구현** (Previous/Next 버튼)
10. ✅ 기존 테스트 통과 유지

#### 권장 기준 (Should)

1. 🎯 `show_playbooks`, `get_playbook_page`의 `serviceInfo.toolName` 정확히 설정
2. 🎯 페이지 메타데이터에 `totalPages` 계산 포함
3. 🎯 postMessage targetOrigin 주석으로 보안 리스크 문서화
4. 🎯 버전 증가: `playbookStore.version = '0.1.1'`
5. 🎯 공통 로직 함수 추출: `getPlaybooksWithUI()`

#### 테스트 기준

1. Context 없을 때 에러 반환
2. 빈 목록일 때 적절한 응답
3. 페이징 동작 검증 (page=1, pageSize=5)
4. DB/In-memory 결과 동등성
5. `list_playbooks`는 UIResource 없음 확인
6. `show_playbooks`는 UIResource + 페이지네이션 버튼 포함 확인
7. `get_playbook_page`는 페이지 이동 정상 동작 확인
8. HTML XSS 방어 (escapeHtml) 검증
9. **텍스트 응답이 Agent Context에서 이해 가능한지 검증**
10. Previous 버튼이 첫 페이지에서 disabled
11. Next 버튼이 마지막 페이지에서 disabled

## 수정이 필요한 코드 및 수정 부분의 코드 스니핏

### 0. DB Service 확장 (우선 작업)

#### 0-1. DB 스키마에 agentId 인덱스 추가

**파일**: `src/lib/db/service.ts`
**위치**: LocalDatabase 생성자 내 version 정의 섹션

```typescript
// 기존 version 6
this.version(6).stores({
  playbooks: '&id, createdAt, updatedAt, goal',
});

// 기존 version 7 (그대로 유지)
this.version(7)
  .stores({})
  .upgrade(async (tx) => {
    await tx
      .table('assistants')
      .toCollection()
      .modify((assistant) => {
        if (
          Array.isArray(assistant.allowedBuiltInServiceAliases) &&
          assistant.allowedBuiltInServiceAliases.length === 0
        ) {
          delete assistant.allowedBuiltInServiceAliases;
        }
      });
  });

// 새로 추가: version 8 (agentId 인덱스 추가)
this.version(8).stores({
  playbooks: '&id, agentId, createdAt, updatedAt, goal',
});
```

#### 0-2. Page<T> 인터페이스에 totalPages 추가

**파일**: `src/lib/db/types.ts`
**위치**: Page 인터페이스 정의 (line ~90)

```typescript
export interface Page<T> {
  /** The array of items for the current page. */
  items: T[];
  /** The current page number. */
  page: number;
  /** The number of items per page. */
  pageSize: number;
  /** The total number of items across all pages. */
  totalItems: number;
  /** The total number of pages. */
  totalPages: number; // ✨ 추가
  /** A boolean indicating if there is a next page. */
  hasNextPage: boolean;
  /** A boolean indicating if there is a previous page. */
  hasPreviousPage: boolean;
}
```

#### 0-3. createPage 헬퍼 함수 업데이트

**파일**: `src/lib/db/crud.ts`
**위치**: createPage 함수 (line ~23)

```typescript
export const createPage = <T>(
  items: T[],
  page: number,
  pageSize: number,
  totalItems: number,
): Page<T> => {
  if (pageSize === -1) {
    return {
      items,
      page: 1,
      pageSize: totalItems,
      totalItems,
      totalPages: 1, // ✨ 추가
      hasNextPage: false,
      hasPreviousPage: false,
    };
  }

  const totalPages = Math.ceil(totalItems / pageSize); // ✨ 계산

  return {
    items,
    page,
    pageSize,
    totalItems,
    totalPages, // ✨ 추가
    hasNextPage: page * pageSize < totalItems,
    hasPreviousPage: page > 1,
  };
};
```

#### 0-4. PlaybookCRUD 인터페이스 정의

**파일**: `src/lib/db/types.ts`
**위치**: 파일 끝부분 (DatabaseService 인터페이스 앞)

```typescript
/**
 * Extends the basic CRUD interface with additional methods specific to `Playbook`.
 */
export interface PlaybookCRUD extends CRUD<Playbook & { id: string }> {
  /**
   * Retrieves a paginated list of playbooks filtered by agent ID.
   * This method uses an indexed query for optimal performance.
   *
   * @param agentId The ID of the agent/assistant to filter by.
   * @param page The page number to retrieve (1-based).
   * @param pageSize The number of items per page. Use -1 to retrieve all items.
   * @returns A promise that resolves to a `Page` of playbooks for the specified agent.
   */
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<Playbook & { id: string }>>;
}
```

그리고 `DatabaseService` 인터페이스 업데이트:

```typescript
export interface DatabaseService {
  /** CRUD operations for `Assistant` objects. */
  assistants: CRUD<Assistant>;
  /** Generic CRUD operations for `DatabaseObject`s. */
  objects: CRUD<DatabaseObject<unknown>, DatabaseObject<unknown>>;
  /** CRUD operations for `Session` objects. */
  sessions: CRUD<Session>;
  /** CRUD operations for `Message` objects. */
  messages: CRUD<Message>;
  /** Extended CRUD operations for persisted Playbook objects. */
  playbooks?: PlaybookCRUD; // CRUD에서 PlaybookCRUD로 변경
}
```

#### 0-5. playbooksCRUD에 getPageForAgent 메서드 구현

**파일**: `src/lib/db/crud.ts`
**위치**: playbooksCRUD 객체 정의 (count 메서드 다음)

```typescript
/** CRUD for persisted Task records stored in the LocalDatabase.tasks table. */
export const playbooksCRUD: CRUD<PlaybookRecord> & {
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<PlaybookRecord>>;
} = {
  upsert: async (playbook) => {
    // ... 기존 코드 유지 ...
  },
  upsertMany: async (playbooksArr) => {
    // ... 기존 코드 유지 ...
  },
  read: async (id) => {
    // ... 기존 코드 유지 ...
  },
  delete: async (id) => {
    // ... 기존 코드 유지 ...
  },
  getPage: async (page, pageSize) => {
    // ... 기존 코드 유지 ...
  },
  count: async () => {
    return LocalDatabase.getInstance().table('playbooks').count();
  },

  // 신규 메서드: agentId로 필터링된 페이징
  getPageForAgent: async (agentId, page, pageSize) => {
    const db = LocalDatabase.getInstance();
    const table = db.table('playbooks');

    // agentId로 필터링된 항목 수 계산
    const totalItems = await table.where('agentId').equals(agentId).count();

    if (pageSize === -1) {
      // 모든 항목 반환
      const items = await table.where('agentId').equals(agentId).toArray();
      return createPage(items as PlaybookRecord[], page, pageSize, totalItems);
    }

    // 페이징 적용
    const offset = (page - 1) * pageSize;
    const items = await table
      .where('agentId')
      .equals(agentId)
      .offset(offset)
      .limit(pageSize)
      .toArray();

    return createPage(items as PlaybookRecord[], page, pageSize, totalItems);
  },
};
```

### 1. tools 배열에 show_playbooks, get_playbook_page 추가

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: `tools` 배열 (line ~220)

```typescript
const tools: MCPTool[] = [
  // ... 기존 툴들 ...
  {
    name: 'list_playbooks',
    description:
      'List playbooks with optional paging (text-only, non-interrupting for agent autonomous use)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to retrieve (1-based)',
        },
        pageSize: {
          type: 'number',
          description: 'Number of items per page; -1 for all',
        },
      },
    },
  },
  {
    name: 'show_playbooks',
    description:
      'Display playbooks with interactive UI (includes HTML UI resource for frontend, pauses agent)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to retrieve (1-based)',
        },
        pageSize: {
          type: 'number',
          description: 'Number of items per page; -1 for all',
        },
      },
    },
  },
  {
    name: 'get_playbook_page',
    description:
      'Navigate to a specific page of playbooks with interactive UI (for pagination buttons, pauses agent)',
    inputSchema: {
      type: 'object',
      properties: {
        page: {
          type: 'number',
          description: 'Page number to navigate to (1-based)',
        },
        pageSize: {
          type: 'number',
          description:
            'Number of items per page (optional, keeps previous size)',
        },
      },
      required: ['page'],
    },
  },
  // ... 나머지 툴들 ...
];
```

### 2. 공통 페이징 로직 헬퍼 함수 추가

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: Helper functions 섹션 (formatPlaybook 아래)

```typescript
// --- Helpers to reduce duplication between DB and in-memory branches ---

interface PageResult {
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  items: PlaybookRecord[];
}

/**
 * Apply pagination to filtered items (in-memory mode)
 */
function paginateItems(
  items: PlaybookRecord[],
  page: number,
  pageSize: number,
): PageResult {
  const totalItems = items.length;

  if (pageSize === -1) {
    // Return all items
    return {
      page: 1,
      pageSize: -1,
      totalItems,
      totalPages: 1,
      items,
    };
  }

  const totalPages = Math.ceil(totalItems / pageSize);
  const startIdx = (page - 1) * pageSize;
  const endIdx = startIdx + pageSize;
  const paginatedItems = items.slice(startIdx, endIdx);

  return {
    page,
    pageSize,
    totalItems,
    totalPages,
    items: paginatedItems,
  };
}

/**
 * Create consistent structured response for list operations
 */
function createListStructuredResponse(
  pageResult: PageResult,
  formattedText: string,
): unknown {
  return {
    page: pageResult,
    formattedText,
  };
}

/**
 * Create context-aware text response for list_playbooks
 */
function createListTextResponse(
  agentId: string,
  pageResult: PageResult,
  formattedList: string,
): string {
  if (pageResult.totalItems === 0) {
    return `[list_playbooks] No playbooks found for agent ${agentId}.`;
  }

  return `[list_playbooks] Found ${pageResult.totalItems} playbook(s) for agent ${agentId}.
Showing page ${pageResult.page} of ${pageResult.totalPages} (${pageResult.items.length} items on this page):

${formattedList}

Note: Use 'get_playbook' to view details or 'select_playbook' to execute a playbook.`;
}

/**
 * Create context-aware text response for UI-based tools (show_playbooks, get_playbook_page)
 */
function createUITextResponse(
  toolName: string,
  pageResult: PageResult,
  formattedList: string,
  isNavigation = false,
): string {
  const action = isNavigation
    ? `Navigated to page ${pageResult.page}`
    : `Displaying ${pageResult.totalItems} playbook(s) in interactive UI`;

  return `[${toolName}] ${action}.
Current page: ${pageResult.page} of ${pageResult.totalPages}

Playbooks on this page:
${formattedList}

Status: Agent paused for user interaction (Select/Delete/Navigate buttons available).`;
}
```

### 3. HTML UI 업데이트 (페이지네이션 추가)

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: buildUiHtml 함수 (line ~76)

```typescript
function buildUiHtml(listItemsHtml: string, pageInfo: PageResult): string {
  const prevDisabled = pageInfo.page <= 1 ? 'disabled' : '';
  const nextDisabled = pageInfo.page >= pageInfo.totalPages ? 'disabled' : '';

  return `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 12px;
    }
    .pb-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pagination {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-top: 1px solid #eee;
    }
    button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #f5f5f5;
    }
    .delete-pb-btn {
      background-color: #dc3545;
      color: white;
      border: none;
    }
    .delete-pb-btn:hover:not(:disabled) {
      background-color: #c82333;
    }
    .page-info {
      padding: 6px 12px;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h3>Playbooks</h3>
  <div id="pb-list">${listItemsHtml}</div>

  <!-- Pagination UI -->
  <div class="pagination">
    <button data-page="${pageInfo.page - 1}" class="nav-page-btn" ${prevDisabled}>
      ← Previous
    </button>
    <span class="page-info">
      Page ${pageInfo.page} of ${pageInfo.totalPages} (${pageInfo.totalItems} total)
    </span>
    <button data-page="${pageInfo.page + 1}" class="nav-page-btn" ${nextDisabled}>
      Next →
    </button>
  </div>

  <script>
document.addEventListener('click', function(e) {
  const btn = e.target;
  if (btn && btn.classList) {
    const id = btn.getAttribute('data-pbid');
    const page = btn.getAttribute('data-page');

    if (btn.classList.contains('select-pb-btn')) {
      console.log('Select button clicked for id:', id);
      // Security note: Using '*' as targetOrigin for compatibility.
      // In production, consider restricting to specific origin if parent context is known.
      window.parent.postMessage({type:'tool', payload:{toolName:'select_playbook', params:{id}}}, '*');
    } else if (btn.classList.contains('delete-pb-btn')) {
      console.log('Delete button clicked for id:', id);
      window.parent.postMessage({type:'tool', payload:{toolName:'delete_playbook', params:{id}}}, '*');
    } else if (btn.classList.contains('nav-page-btn') && !btn.disabled) {
      console.log('Navigate to page:', page);
      window.parent.postMessage({type:'tool', payload:{toolName:'get_playbook_page', params:{page: parseInt(page)}}}, '*');
    }
  }
});
</script>
</body>
</html>`;
}
```

### 4. createUiResourceFromHtml 수정 (toolName 동적 설정)

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: createUiResourceFromHtml 함수 (line ~94)

```typescript
function createUiResourceFromHtml(html: string, toolName = 'show_playbooks') {
  const res = createUIResource({
    uri: `ui://playbooks/list/${Date.now()}`,
    content: { type: 'rawHtml', htmlString: html },
    encoding: 'text',
  }) as UIResource & { serviceInfo?: ServiceInfo };

  // Attach serviceInfo so the frontend can resolve tool names correctly
  // Use the canonical server name ('playbook') and mark this as a built-in web server
  res.serviceInfo = {
    serverName: 'playbook',
    toolName, // 동적으로 설정
    backendType: 'BuiltInWeb',
  };

  return res;
}
```

### 5. makeListMultipartResponse 시그니처 업데이트

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: makeListMultipartResponse 함수 (line ~112)

```typescript
function makeListMultipartResponse(
  items: PlaybookRecord[],
  formattedText: string,
  structured: unknown,
  pageInfo: PageResult, // ✨ 추가
  toolName = 'show_playbooks', // ✨ 추가
) {
  const textPart: MCPContent = {
    type: 'text',
    text: formattedText,
  } as unknown as MCPContent;

  const uiHtml = buildUiHtml(buildListItemsHtml(items), pageInfo); // ✨ pageInfo 전달
  const uiResource = {
    ...createUiResourceFromHtml(uiHtml, toolName), // ✨ toolName 전달
  };

  return createMCPStructuredMultipartResponse(
    [textPart, uiResource],
    structured,
  );
}
```

### 6. getPlaybooksWithUI 공통 함수 추가

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: Helper functions 섹션 (makeListMultipartResponse 아래)

```typescript
/**
 * Common logic for UI-based playbook listing (show_playbooks, get_playbook_page)
 */
async function getPlaybooksWithUI(
  agentId: string,
  page: number,
  pageSize: number,
  hasDB: boolean,
  toolName: string,
  isNavigation = false,
): Promise<MCPResponse<unknown>> {
  if (hasDB && dbService.playbooks) {
    // DB branch: use indexed query
    const dbPageResult = await dbService.playbooks.getPageForAgent(
      agentId,
      page,
      pageSize,
    );

    // Convert Page<T> to PageResult
    const pageResult: PageResult = {
      page: dbPageResult.page,
      pageSize: dbPageResult.pageSize,
      totalItems: dbPageResult.totalItems,
      totalPages: dbPageResult.totalPages, // Now available from updated Page<T>
      items: dbPageResult.items as PlaybookRecord[],
    };

    if (pageResult.items.length === 0) {
      const emptyText = `[${toolName}] No playbooks found for agent ${agentId}.`;
      return createMCPStructuredResponse(emptyText, {
        page: pageResult,
      });
    }

    const formattedList = formatPlaybooksList(pageResult.items);
    const textResponse = createUITextResponse(
      toolName,
      pageResult,
      formattedList,
      isNavigation,
    );
    const structured = createListStructuredResponse(pageResult, formattedList);
    return makeListMultipartResponse(
      pageResult.items,
      textResponse,
      structured,
      pageResult,
      toolName,
    );
  }

  // In-memory branch
  const filtered = inMemory.filter((p) => p.agentId === agentId);
  const pageResult = paginateItems(filtered, page, pageSize);

  if (pageResult.items.length === 0) {
    const emptyText = `[${toolName}] No playbooks found (in-memory) for agent ${agentId}.`;
    return createMCPStructuredResponse(emptyText, {
      page: pageResult,
    });
  }

  const formattedList = formatPlaybooksList(pageResult.items);
  const textResponse = createUITextResponse(
    toolName,
    pageResult,
    formattedList,
    isNavigation,
  );
  const structured = createListStructuredResponse(pageResult, formattedList);
  return makeListMultipartResponse(
    pageResult.items,
    textResponse,
    structured,
    pageResult,
    toolName,
  );
}
```

### 7. list_playbooks case 수정 (텍스트 전용)

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: callTool switch-case 내 'list_playbooks' (line ~415)

```typescript
case 'list_playbooks': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[list_playbooks] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || -1);

  if (hasDB && dbService.playbooks) {
    // DB: Use indexed query for filtered pagination
    const dbPageResult = await dbService.playbooks.getPageForAgent(
      currentAssistantId,
      page,
      pageSize
    );

    // Convert Page<T> to PageResult
    const pageResult: PageResult = {
      page: dbPageResult.page,
      pageSize: dbPageResult.pageSize,
      totalItems: dbPageResult.totalItems,
      totalPages: dbPageResult.totalPages,
      items: dbPageResult.items as PlaybookRecord[],
    };

    const formattedList = formatPlaybooksList(pageResult.items);
    const textResponse = createListTextResponse(currentAssistantId, pageResult, formattedList);
    const structured = createListStructuredResponse(pageResult, formattedList);
    return createMCPStructuredResponse(textResponse, structured);
  }

  // In-memory branch
  const filtered = inMemory.filter((p) => p.agentId === currentAssistantId);
  const pageResult = paginateItems(filtered, page, pageSize);

  const formattedList = formatPlaybooksList(pageResult.items);
  const textResponse = createListTextResponse(currentAssistantId, pageResult, formattedList);
  const structured = createListStructuredResponse(pageResult, formattedList);
  return createMCPStructuredResponse(textResponse, structured);
}
```

### 8. show_playbooks case 추가 (UI 포함)

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: callTool switch-case 내 (list_playbooks 다음)

```typescript
case 'show_playbooks': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[show_playbooks] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || -1);

  return getPlaybooksWithUI(currentAssistantId, page, pageSize, hasDB, 'show_playbooks', false);
}
```

### 9. get_playbook_page case 추가 (페이지 내비게이션)

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: callTool switch-case 내 (show_playbooks 다음)

```typescript
case 'get_playbook_page': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[get_playbook_page] Error: Assistant ID not set. Please set context first.',
    );
  }

  const page = Number(a.page || 1);
  const pageSize = Number(a.pageSize || 10); // Default to 10 if not specified

  return getPlaybooksWithUI(currentAssistantId, page, pageSize, hasDB, 'get_playbook_page', true);
}
```

### 10. 다른 도구들의 텍스트 응답 개선

#### get_playbook

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: get_playbook case (line ~486)

```typescript
case 'get_playbook': {
  const id = String(a.id);
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id as string);
    if (!existing) {
      return createMCPTextResponse(`[get_playbook] Error: Playbook ${id} not found.`);
    }
    const rec = existing as PlaybookRecord;
    const formatted = formatPlaybookDetailed(rec);

    const textResponse = `[get_playbook] Retrieved playbook details for ID: ${id}

${formatted}

Note: Use 'select_playbook' to execute this playbook, or 'update_playbook' to modify it.`;

    return createMCPStructuredResponse(textResponse, {
      playbook: existing,
    });
  }

  const existing = inMemory.find((p) => p.id === String(a.id));
  if (!existing) {
    return createMCPTextResponse(`[get_playbook] Error: Playbook ${String(a.id)} not found (in-memory).`);
  }
  const formatted = formatPlaybookDetailed(existing);

  const textResponse = `[get_playbook] Retrieved playbook details for ID: ${String(a.id)} (in-memory)

${formatted}

Note: Use 'select_playbook' to execute this playbook, or 'update_playbook' to modify it.`;

  return createMCPStructuredResponse(textResponse, { playbook: existing });
}
```

#### select_playbook

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: select_playbook case (line ~562)

```typescript
case 'select_playbook': {
  const id = String(a.id);
  let existing: PlaybookRecord | undefined;
  if (hasDB && dbService.playbooks) {
    existing = (await dbService.playbooks.read(id)) as
      | PlaybookRecord
      | undefined;
  } else {
    existing = inMemory.find((p) => p.id === id);
  }

  if (!existing) {
    return createMCPTextResponse(`[select_playbook] Error: Playbook ${id} not found.`);
  }

  // Permission check
  if (currentAssistantId && existing.agentId !== currentAssistantId) {
    return createMCPTextResponse(
      `[select_playbook] Error: Playbook ${id} does not belong to the current assistant (${currentAssistantId}).`,
    );
  }

  // Build detailed text
  const formattedText = formatPlaybookDetailed(existing);

  const agentPrompt = `[select_playbook] Playbook "${existing.goal}" (ID: ${existing.id}) has been selected for execution.

Playbook Details:
---
${formattedText}
---

Instructions:
1. Review the workflow steps and success criteria above
2. Establish todos based on the workflow steps
3. Begin executing the tasks according to the defined steps
4. Track progress and verify against success criteria

You may now proceed with execution.`;

  return createMCPStructuredResponse(agentPrompt, {
    playbook: existing,
  });
}
```

#### create_playbook

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: create_playbook case (line ~365)

```typescript
case 'create_playbook': {
  if (!currentAssistantId) {
    return createMCPTextResponse(
      '[create_playbook] Error: Assistant ID not set. Please set context first.',
    );
  }

  const id = String(Date.now()) + '-' + String(nextId++);
  const playbook: PlaybookRecord = {
    id,
    agentId: currentAssistantId,
    goal: String(a.goal || ''),
    initialCommand: String(a.initialCommand || ''),
    workflow: ((a.workflow as Playbook['workflow']) || []).map(
      (s, i) => ({
        stepId: s?.stepId ?? `${id}-step-${i + 1}`,
        description: s?.description ?? '',
        action: s?.action ?? { toolName: '', purpose: '' },
        requiredData: s?.requiredData ?? [],
        outputVariable: s?.outputVariable ?? '',
      }),
    ),
    successCriteria:
      (a.successCriteria as Playbook['successCriteria']) || {
        description: '',
      },
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  if (hasDB && dbService.playbooks) {
    await dbService.playbooks.upsert(playbook as PlaybookRecord);
    const saved = await dbService.playbooks.read(id);
    const formatted = saved
      ? formatPlaybook(saved as PlaybookRecord)
      : `Playbook ${id} created`;

    const textResponse = `[create_playbook] Successfully created new playbook.
ID: ${id}
Goal: ${playbook.goal}
Steps: ${playbook.workflow.length}

${formatted}

The playbook is now available. Use 'list_playbooks' to see all playbooks, or 'select_playbook' with ID ${id} to execute it.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      playbook: saved,
    });
  }

  inMemory.push(playbook);
  const formattedInMemory = formatPlaybook(playbook);

  const textResponse = `[create_playbook] Successfully created new playbook (in-memory).
ID: ${id}
Goal: ${playbook.goal}
Steps: ${playbook.workflow.length}

${formattedInMemory}

The playbook is now available. Use 'list_playbooks' to see all playbooks, or 'select_playbook' with ID ${id} to execute it.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    playbook,
  });
}
```

#### update_playbook

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: update_playbook case (line ~505)

```typescript
case 'update_playbook': {
  const id = String(a.id);
  const patch = (a.playbook as Partial<Playbook>) || {};
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id as string);
    if (!existing) {
      return createMCPTextResponse(`[update_playbook] Error: Playbook ${id} not found.`);
    }
    const updatedWorkflow = (patch.workflow as Playbook['workflow'])
      ? (patch.workflow as Playbook['workflow']).map((s, i) => ({
          stepId: s?.stepId ?? `${id}-step-${i + 1}`,
          description: s?.description ?? '',
          action: s?.action ?? { toolName: '', purpose: '' },
          requiredData: s?.requiredData ?? [],
          outputVariable: s?.outputVariable ?? '',
        }))
      : existing.workflow;

    const updated: PlaybookRecord = {
      ...existing,
      ...patch,
      workflow: updatedWorkflow,
      updatedAt: new Date(),
    } as PlaybookRecord;
    await dbService.playbooks.upsert(updated);
    const saved = await dbService.playbooks.read(id);
    const formatted = saved
      ? formatPlaybook(saved as PlaybookRecord)
      : `Playbook ${id} updated`;

    const textResponse = `[update_playbook] Successfully updated playbook ID: ${id}

Updated Details:
${formatted}

The playbook has been modified. Changes are immediately available.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      playbook: saved
    });
  }

  const existing = inMemory.find((p) => p.id === id);
  if (!existing) {
    return createMCPTextResponse(`[update_playbook] Error: Playbook ${id} not found (in-memory).`);
  }
  if (patch.workflow) {
    existing.workflow = (patch.workflow as Playbook['workflow']).map(
      (s, i) => ({
        stepId: s?.stepId ?? `${id}-step-${i + 1}`,
        description: s?.description ?? '',
        action: s?.action ?? { toolName: '', purpose: '' },
        requiredData: s?.requiredData ?? [],
        outputVariable: s?.outputVariable ?? '',
      }),
    );
  }
  Object.assign(existing, patch);
  existing.updatedAt = new Date().toISOString();
  const formattedExisting = formatPlaybook(existing);

  const textResponse = `[update_playbook] Successfully updated playbook ID: ${id} (in-memory)

Updated Details:
${formattedExisting}

The playbook has been modified. Changes are immediately available.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    playbook: existing,
  });
}
```

#### delete_playbook

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: delete_playbook case (line ~463)

```typescript
case 'delete_playbook': {
  const id = String(a.id);
  if (hasDB && dbService.playbooks) {
    const existing = await dbService.playbooks.read(id);
    if (!existing) {
      return createMCPTextResponse(`[delete_playbook] Error: Playbook ${id} not found.`);
    }
    await dbService.playbooks.delete(id);
    const formatted = formatPlaybook(existing as PlaybookRecord);

    const textResponse = `[delete_playbook] Successfully deleted playbook ID: ${id}

Deleted Playbook:
${formatted}

This playbook is no longer available. Use 'list_playbooks' to see remaining playbooks.`;

    return createMCPStructuredResponse(textResponse, {
      success: true,
      id
    });
  }
  const idx = inMemory.findIndex((p) => p.id === id);
  if (idx === -1) {
    return createMCPTextResponse(`[delete_playbook] Error: Playbook ${id} not found (in-memory).`);
  }
  const removed = inMemory.splice(idx, 1)[0];
  const formattedRemoved = formatPlaybook(removed);

  const textResponse = `[delete_playbook] Successfully deleted playbook ID: ${id} (in-memory)

Deleted Playbook:
${formattedRemoved}

This playbook is no longer available. Use 'list_playbooks' to see remaining playbooks.`;

  return createMCPStructuredResponse(textResponse, {
    success: true,
    id,
  });
}
```

### 11. 버전 업데이트

**파일**: `src/lib/web-mcp/modules/playbook-store.ts`
**위치**: playbookStore 객체 정의 (line ~352)

```typescript
const playbookStore: WebMCPServer = {
  name: 'playbook',
  version: '0.1.1', // 0.1.0 -> 0.1.1
  description:
    'Persisted playbook store for agent workflows (create/list/show/navigate/update/delete)',
  tools,
  // ...
};
```

## 재사용 가능한 연관 코드

### DB Service Interface

**파일**: `src/lib/db/types.ts`

현재 사용 중인 인터페이스:

```typescript
interface CRUD<T, U = T> {
  upsert: (object: T) => Promise<void>;
  upsertMany: (objects: T[]) => Promise<void>;
  read: (key: string) => Promise<U | undefined>;
  delete: (key: string) => Promise<void>;
  getPage: (page: number, pageSize: number) => Promise<Page<U>>;
  count: () => Promise<number>;
}

interface Page<T> {
  items: T[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number; // ✨ 추가됨
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}
```

확장된 PlaybookCRUD:

```typescript
interface PlaybookCRUD extends CRUD<Playbook & { id: string }> {
  getPageForAgent: (
    agentId: string,
    page: number,
    pageSize: number,
  ) => Promise<Page<Playbook & { id: string }>>;
}
```

### Dexie 사용 패턴

**파일**: `src/lib/db/service.ts`, `src/lib/db/crud.ts`

```typescript
// Dexie 테이블 접근
const db = LocalDatabase.getInstance();
const table = db.table('playbooks');

// 인덱스를 사용한 필터링 + 페이징
const items = await table
  .where('agentId')
  .equals(targetAgentId)
  .offset((page - 1) * pageSize)
  .limit(pageSize)
  .toArray();

// 카운트
const count = await table.where('agentId').equals(targetAgentId).count();
```

### MCP Response Utilities (재사용)

**파일**: `src/lib/mcp-response-utils.ts`

```typescript
// 이미 사용 중인 유틸리티
export function createMCPTextResponse(text: string): MCPResponse<unknown>;
export function createMCPStructuredResponse(
  text: string,
  structured: unknown,
): MCPResponse<unknown>;
export function createMCPStructuredMultipartResponse(
  content: MCPContent[],
  structured: unknown,
): MCPResponse<unknown>;
```

### Type Definitions (재사용)

**파일**: `src/types/playbook.ts`

```typescript
export interface Playbook {
  agentId: string;
  goal: string;
  initialCommand?: string;
  workflow: PlaybookStep[];
  successCriteria?: {
    description: string;
    requiredArtifacts?: string[];
  };
}

export interface PlaybookStep {
  stepId?: string;
  description: string;
  action: {
    toolName: string;
    purpose: string;
  };
  requiredData: string[];
  outputVariable: string;
}
```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 테스트 파일 생성

**파일**: `src/lib/web-mcp/modules/__tests__/playbook-store.test.ts` (신규)

### 테스트 카테고리

#### 0. DB Service 테스트 (신규)

**파일**: `src/lib/db/__tests__/crud.test.ts` (기존 파일에 추가 또는 신규)

```typescript
describe('playbooksCRUD.getPageForAgent', () => {
  beforeEach(async () => {
    // DB 초기화
    const db = LocalDatabase.getInstance();
    await db.table('playbooks').clear();
  });

  it('should filter playbooks by agentId', async () => {
    // agent-1의 playbooks 3개 생성
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 1',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 2',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-1',
      goal: 'Goal 3',
      workflow: [],
    });

    // agent-2의 playbooks 2개 생성
    await playbooksCRUD.upsert({
      agentId: 'agent-2',
      goal: 'Goal A',
      workflow: [],
    });
    await playbooksCRUD.upsert({
      agentId: 'agent-2',
      goal: 'Goal B',
      workflow: [],
    });

    // agent-1의 playbooks만 조회
    const result = await playbooksCRUD.getPageForAgent('agent-1', 1, -1);

    expect(result.totalItems).toBe(3);
    expect(result.items).toHaveLength(3);
    expect(result.items.every((p) => p.agentId === 'agent-1')).toBe(true);
  });

  it('should paginate correctly for specific agent', async () => {
    // agent-1의 playbooks 5개 생성
    for (let i = 0; i < 5; i++) {
      await playbooksCRUD.upsert({
        agentId: 'agent-1',
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    // 첫 페이지 (2개)
    const page1 = await playbooksCRUD.getPageForAgent('agent-1', 1, 2);
    expect(page1.items).toHaveLength(2);
    expect(page1.page).toBe(1);
    expect(page1.totalItems).toBe(5);
    expect(page1.totalPages).toBe(3);
    expect(page1.hasNextPage).toBe(true);
    expect(page1.hasPreviousPage).toBe(false);

    // 두 번째 페이지 (2개)
    const page2 = await playbooksCRUD.getPageForAgent('agent-1', 2, 2);
    expect(page2.items).toHaveLength(2);
    expect(page2.page).toBe(2);
    expect(page2.hasNextPage).toBe(true);
    expect(page2.hasPreviousPage).toBe(true);

    // 마지막 페이지 (1개)
    const page3 = await playbooksCRUD.getPageForAgent('agent-1', 3, 2);
    expect(page3.items).toHaveLength(1);
    expect(page3.hasNextPage).toBe(false);
  });

  it('should return all items when pageSize is -1', async () => {
    for (let i = 0; i < 10; i++) {
      await playbooksCRUD.upsert({
        agentId: 'test-agent',
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbooksCRUD.getPageForAgent('test-agent', 1, -1);

    expect(result.items).toHaveLength(10);
    expect(result.pageSize).toBe(-1);
    expect(result.totalPages).toBe(1);
    expect(result.hasNextPage).toBe(false);
  });

  it('should return empty page when no playbooks match agentId', async () => {
    await playbooksCRUD.upsert({
      agentId: 'other-agent',
      goal: 'Other goal',
      workflow: [],
    });

    const result = await playbooksCRUD.getPageForAgent('target-agent', 1, 10);

    expect(result.items).toHaveLength(0);
    expect(result.totalItems).toBe(0);
    expect(result.totalPages).toBe(0);
  });
});
```

#### 1. Context 관리 테스트

```typescript
describe('Context Management', () => {
  it('should reject list_playbooks when assistantId is not set', async () => {
    // switchContext 호출 없이 list_playbooks 호출
    const result = await playbookStore.callTool('list_playbooks', {});
    expect(result.content[0].text).toContain(
      '[list_playbooks] Error: Assistant ID not set',
    );
  });

  it('should accept valid assistantId via switchContext', async () => {
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    // 이후 호출들이 정상 동작해야 함
  });
});
```

#### 2. list_playbooks (텍스트 전용) 테스트

```typescript
describe('list_playbooks (text-only)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('should return empty list with correct structure and context', async () => {
    const result = await playbookStore.callTool('list_playbooks', {});
    expect(result.content).toHaveLength(1); // 텍스트만
    expect(result.content[0].type).toBe('text');
    expect(result.content[0].text).toContain('[list_playbooks]');
    expect(result.content[0].text).toContain('No playbooks found');
    expect(result.structured.page).toBeDefined();
    expect(result.structured.page.totalItems).toBe(0);
  });

  it('should return text-only response without UIResource', async () => {
    // Playbook 생성
    await playbookStore.callTool('create_playbook', {
      goal: 'Test goal',
      workflow: [
        {
          /* ... */
        },
      ],
    });

    const result = await playbookStore.callTool('list_playbooks', {});

    // UIResource가 없어야 함
    expect(result.content).toHaveLength(1);
    expect(result.content.every((c) => c.type !== 'resource')).toBe(true);

    // 구조화된 데이터 검증
    expect(result.structured.page.items).toHaveLength(1);
    expect(result.structured.formattedText).toContain('Test goal');

    // Agent context 친화적 텍스트 검증
    expect(result.content[0].text).toContain('[list_playbooks]');
    expect(result.content[0].text).toContain('Found 1 playbook(s)');
    expect(result.content[0].text).toContain('Note: Use');
  });

  it('should apply pagination correctly (in-memory)', async () => {
    // 5개 playbook 생성
    for (let i = 0; i < 5; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('list_playbooks', {
      page: 1,
      pageSize: 2,
    });

    expect(result.structured.page.items).toHaveLength(2);
    expect(result.structured.page.totalItems).toBe(5);
    expect(result.structured.page.totalPages).toBe(3);
    expect(result.structured.page.page).toBe(1);

    // Text includes pagination info
    expect(result.content[0].text).toContain('page 1 of 3');
  });

  it('should filter by assistantId correctly', async () => {
    // agent-1의 playbook
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    await playbookStore.callTool('create_playbook', {
      goal: 'Agent 1 goal',
      workflow: [],
    });

    // agent-2의 playbook
    await playbookStore.switchContext({ assistantId: 'agent-2' });
    await playbookStore.callTool('create_playbook', {
      goal: 'Agent 2 goal',
      workflow: [],
    });

    // agent-1로 전환하여 조회
    await playbookStore.switchContext({ assistantId: 'agent-1' });
    const result = await playbookStore.callTool('list_playbooks', {});

    expect(result.structured.page.totalItems).toBe(1);
    expect(result.structured.formattedText).toContain('Agent 1 goal');
    expect(result.structured.formattedText).not.toContain('Agent 2 goal');
  });
});
```

#### 3. show_playbooks (UI 포함) 테스트

```typescript
describe('show_playbooks (with UI and pagination)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('should return multipart response with text and UIResource', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: 'Test UI goal',
      workflow: [],
    });

    const result = await playbookStore.callTool('show_playbooks', {});

    // Multipart 검증
    expect(result.content).toHaveLength(2);
    expect(result.content[0].type).toBe('text');
    expect(result.content[1].type).toBe('resource');

    // Text includes context info
    expect(result.content[0].text).toContain('[show_playbooks]');
    expect(result.content[0].text).toContain('Agent paused');

    // UIResource 검증
    const uiResource = result.content[1].resource;
    expect(uiResource.uri).toMatch(/^ui:\/\/playbooks\/list\//);
    expect(uiResource.serviceInfo?.serverName).toBe('playbook');
    expect(uiResource.serviceInfo?.toolName).toBe('show_playbooks');
    expect(uiResource.serviceInfo?.backendType).toBe('BuiltInWeb');
  });

  it('should generate HTML with Select, Delete, and Navigation buttons', async () => {
    // Multiple playbooks for pagination
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Button test ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const uiResource = result.content[1].resource;
    const htmlContent = uiResource.content.htmlString;

    expect(htmlContent).toContain('class="select-pb-btn"');
    expect(htmlContent).toContain('class="delete-pb-btn"');
    expect(htmlContent).toContain('class="nav-page-btn"');
    expect(htmlContent).toContain('data-pbid=');
    expect(htmlContent).toContain('data-page=');
    expect(htmlContent).toContain('window.parent.postMessage');
    expect(htmlContent).toContain('Page 1 of 2');
  });

  it('should disable Previous button on first page', async () => {
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).toMatch(
      /<button[^>]*data-page="0"[^>]*disabled[^>]*>← Previous/,
    );
  });

  it('should disable Next button on last page', async () => {
    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('show_playbooks', {
      page: 2,
      pageSize: 2,
    });
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).toMatch(
      /<button[^>]*data-page="3"[^>]*disabled[^>]*>Next →/,
    );
  });

  it('should escape HTML in playbook goal', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: '<script>alert("xss")</script>',
      workflow: [],
    });

    const result = await playbookStore.callTool('show_playbooks', {});
    const htmlContent = result.content[1].resource.content.htmlString;

    expect(htmlContent).not.toContain('<script>alert("xss")</script>');
    expect(htmlContent).toContain('&lt;script&gt;');
  });
});
```

#### 4. get_playbook_page (페이지네이션) 테스트

```typescript
describe('get_playbook_page (pagination)', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    // Create test data
    for (let i = 0; i < 5; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Page test ${i}`,
        workflow: [],
      });
    }
  });

  it('should navigate to specified page', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 2,
      pageSize: 2,
    });

    expect(result.content).toHaveLength(2); // text + UI
    expect(result.content[0].text).toContain('[get_playbook_page]');
    expect(result.content[0].text).toContain('Navigated to page 2');
    expect(result.structured.page.page).toBe(2);
  });

  it('should generate UI with correct page buttons', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 2,
      pageSize: 2,
    });

    const htmlContent = result.content[1].resource.content.htmlString;
    expect(htmlContent).toContain('Page 2 of 3');
    expect(htmlContent).toContain('data-page="1"'); // Previous
    expect(htmlContent).toContain('data-page="3"'); // Next
  });

  it('should set serviceInfo.toolName to get_playbook_page', async () => {
    const result = await playbookStore.callTool('get_playbook_page', {
      page: 1,
    });

    const uiResource = result.content[1].resource;
    expect(uiResource.serviceInfo?.toolName).toBe('get_playbook_page');
  });
});
```

#### 5. 페이징 일관성 테스트

```typescript
describe('Pagination Consistency', () => {
  it('should have identical page structure between list and show', async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    for (let i = 0; i < 3; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const listResult = await playbookStore.callTool('list_playbooks', {
      page: 1,
      pageSize: 2,
    });
    const showResult = await playbookStore.callTool('show_playbooks', {
      page: 1,
      pageSize: 2,
    });

    // 페이지 구조 동일성 검증
    expect(listResult.structured.page.page).toBe(
      showResult.structured.page.page,
    );
    expect(listResult.structured.page.totalItems).toBe(
      showResult.structured.page.totalItems,
    );
    expect(listResult.structured.page.totalPages).toBe(
      showResult.structured.page.totalPages,
    );
  });

  it('should handle pageSize=-1 (all items) correctly', async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });

    for (let i = 0; i < 10; i++) {
      await playbookStore.callTool('create_playbook', {
        goal: `Goal ${i}`,
        workflow: [],
      });
    }

    const result = await playbookStore.callTool('list_playbooks', {
      pageSize: -1,
    });

    expect(result.structured.page.items).toHaveLength(10);
    expect(result.structured.page.pageSize).toBe(-1);
    expect(result.structured.page.totalPages).toBe(1);
  });
});
```

#### 6. Agent Context 텍스트 응답 테스트

```typescript
describe('Agent Context-Aware Text Responses', () => {
  beforeEach(async () => {
    await playbookStore.switchContext({ assistantId: 'test-agent' });
  });

  it('list_playbooks should include tool name and context', async () => {
    await playbookStore.callTool('create_playbook', {
      goal: 'Test',
      workflow: [],
    });

    const result = await playbookStore.callTool('list_playbooks', {});
    const text = result.content[0].text;

    expect(text).toContain('[list_playbooks]');
    expect(text).toContain('Found 1 playbook(s)');
    expect(text).toContain('page 1 of 1');
    expect(text).toContain('Note: Use');
  });

  it('get_playbook should include tool name and action hints', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Test',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('get_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[get_playbook]');
    expect(text).toContain(`Retrieved playbook details for ID: ${id}`);
    expect(text).toContain('Note: Use');
  });

  it('select_playbook should include execution instructions', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Test Execution',
      workflow: [
        {
          description: 'Step 1',
          action: { toolName: 'test', purpose: 'test' },
          requiredData: [],
          outputVariable: 'out',
        },
      ],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('select_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[select_playbook]');
    expect(text).toContain('has been selected for execution');
    expect(text).toContain('Instructions:');
    expect(text).toContain('You may now proceed');
  });

  it('create_playbook should include success confirmation and next steps', async () => {
    const result = await playbookStore.callTool('create_playbook', {
      goal: 'New Playbook',
      workflow: [],
    });
    const text = result.content[0].text;

    expect(text).toContain('[create_playbook]');
    expect(text).toContain('Successfully created');
    expect(text).toContain('ID:');
    expect(text).toContain("Use 'list_playbooks'");
  });

  it('update_playbook should confirm changes', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'Original',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('update_playbook', {
      id,
      playbook: { goal: 'Updated' },
    });
    const text = result.content[0].text;

    expect(text).toContain('[update_playbook]');
    expect(text).toContain('Successfully updated');
    expect(text).toContain('Changes are immediately available');
  });

  it('delete_playbook should confirm deletion', async () => {
    const createResult = await playbookStore.callTool('create_playbook', {
      goal: 'To Delete',
      workflow: [],
    });
    const id = createResult.structured.playbook.id;

    const result = await playbookStore.callTool('delete_playbook', { id });
    const text = result.content[0].text;

    expect(text).toContain('[delete_playbook]');
    expect(text).toContain('Successfully deleted');
    expect(text).toContain('no longer available');
  });
});
```

#### 7. Helper Functions 단위 테스트

```typescript
describe('Helper Functions', () => {
  describe('paginateItems', () => {
    const mockItems = Array.from({ length: 10 }, (_, i) => ({
      id: `${i}`,
      agentId: 'test',
      goal: `Goal ${i}`,
      workflow: [],
    }));

    it('should paginate correctly', () => {
      const result = paginateItems(mockItems, 2, 3);
      expect(result.items).toHaveLength(3);
      expect(result.items[0].id).toBe('3'); // 두 번째 페이지 시작
      expect(result.page).toBe(2);
      expect(result.totalPages).toBe(4);
    });

    it('should return all items when pageSize=-1', () => {
      const result = paginateItems(mockItems, 1, -1);
      expect(result.items).toHaveLength(10);
      expect(result.totalPages).toBe(1);
    });

    it('should handle empty array', () => {
      const result = paginateItems([], 1, 10);
      expect(result.items).toHaveLength(0);
      expect(result.totalItems).toBe(0);
      expect(result.totalPages).toBe(0);
    });
  });

  describe('formatPlaybooksList', () => {
    it('should format items with numbering', () => {
      const items = [
        { id: '1', goal: 'Goal 1', workflow: [], createdAt: '2025-01-01' },
        { id: '2', goal: 'Goal 2', workflow: [], createdAt: '2025-01-02' },
      ];
      const result = formatPlaybooksList(items);

      expect(result).toContain('1. id:1 goal:"Goal 1"');
      expect(result).toContain('2. id:2 goal:"Goal 2"');
    });
  });

  describe('escapeHtml', () => {
    it('should escape HTML entities', () => {
      expect(escapeHtml('<script>')).toBe('&lt;script&gt;');
      expect(escapeHtml('a & b')).toBe('a &amp; b');
      expect(escapeHtml('"quote"')).toBe('&quot;quote&quot;');
    });
  });
});
```

### 테스트 실행 가이드

```bash
# 단일 테스트 파일 실행
pnpm test src/lib/web-mcp/modules/__tests__/playbook-store.test.ts

# Watch 모드로 개발
pnpm test:watch playbook-store

# Coverage 확인
pnpm test:coverage
```

### Mock 설정 가이드

```typescript
// DB service mock (필요 시)
jest.mock('@/lib/db', () => ({
  dbService: {
    playbooks: {
      read: jest.fn(),
      upsert: jest.fn(),
      delete: jest.fn(),
      getPage: jest.fn(),
      getPageForAgent: jest.fn(), // ✨ 추가
      count: jest.fn(),
    },
  },
}));
```

## 구현 단계 (권장 순서)

### Phase 0: DB Service 확장 (최우선)

1. **Page<T> 인터페이스 업데이트**
   - `src/lib/db/types.ts`에 `totalPages` 필드 추가
   - 로컬 테스트로 타입 체크 확인

2. **createPage 헬퍼 업데이트**
   - `src/lib/db/crud.ts`에서 `totalPages` 계산 로직 추가
   - 기존 사용처 영향 없는지 확인

3. **DB 스키마 업데이트**
   - `src/lib/db/service.ts`에 version 8 추가
   - `playbooks` 테이블에 `agentId` 인덱스 추가
   - 로컬 테스트로 마이그레이션 동작 확인

4. **타입 정의 확장**
   - `src/lib/db/types.ts`에 `PlaybookCRUD` 인터페이스 추가
   - `DatabaseService.playbooks` 타입 변경

5. **playbooksCRUD 확장**
   - `src/lib/db/crud.ts`에 `getPageForAgent` 메서드 구현
   - 단위 테스트 작성 (agentId 필터링 + 페이징 검증)

### Phase 1: 기반 작업 + show_playbooks + get_playbook_page (Breaking Change 없음)

1. Helper functions 추가
   - `paginateItems()`: In-memory 페이징
   - `createListStructuredResponse()`: 일관된 구조 생성
   - `createListTextResponse()`: Agent context 친화적 텍스트 (list_playbooks용)
   - `createUITextResponse()`: Agent context 친화적 텍스트 (UI 도구용)
   - `getPlaybooksWithUI()`: 공통 UI 생성 로직

2. HTML UI 업데이트
   - `buildUiHtml()` 시그니처 변경 (pageInfo 추가)
   - 페이지네이션 버튼 추가 (Previous/Next)
   - CSS 스타일 추가
   - 이벤트 핸들러 업데이트 (get_playbook_page 호출)

3. `show_playbooks` 툴 추가
   - tools 배열에 정의 추가
   - case 구현 (`getPlaybooksWithUI()` 호출)

4. `get_playbook_page` 툴 추가
   - tools 배열에 정의 추가
   - case 구현 (`getPlaybooksWithUI()` 호출)

5. Helper functions 단위 테스트 작성 및 실행

6. `show_playbooks`, `get_playbook_page` 통합 테스트

### Phase 2: list_playbooks 수정 + 모든 도구 텍스트 개선 (Potentially Breaking)

1. `list_playbooks` case 수정
   - Text-only 응답으로 변경 (UIResource 제거)
   - `getPageForAgent()` 사용 (DB 분기)
   - `paginateItems()` 사용 (in-memory 분기)
   - Agent context 친화적 텍스트 생성
   - In-memory 빈 응답 구조 통일

2. 다른 도구들의 텍스트 응답 개선
   - `get_playbook`: 도구명 + 액션 힌트 추가
   - `select_playbook`: 실행 지침 명확화
   - `create_playbook`: 생성 확인 + 다음 액션
   - `update_playbook`: 업데이트 확인
   - `delete_playbook`: 삭제 확인 + 결과

3. 기존 `list_playbooks` 테스트 업데이트

4. Agent context 텍스트 응답 테스트 추가

### Phase 3: 통합 및 문서화

1. 버전 업데이트 (`0.1.1`)

2. `pnpm refactor:validate` 실행
   - Lint 체크
   - Format 체크
   - TypeScript 컴파일
   - Build 검증

3. 수동 테스트
   - 페이지네이션 UI 동작 확인
   - Previous/Next 버튼 disabled 상태 확인
   - Select/Delete 버튼 정상 동작 확인
   - Agent context에 추가되는 텍스트 확인

4. CHANGELOG 작성 (간단히)

### Phase 4: 릴리즈 (생략 가능 - 비프로덕션)

1. Feature branch merge (선택 사항)
2. 릴리즈 노트 발행 (선택 사항)

## 롤백 계획 (간소화 - 비프로덕션)

### 롤백 트리거

- 치명적 버그 발견
- 빌드 실패
- 테스트 대량 실패

### 롤백 절차

1. Git revert로 이전 커밋으로 복귀
2. `pnpm refactor:validate` 재실행
3. 문제 분석 및 재시도

## 참고 문서

- [MCP Protocol Specification](https://modelcontextprotocol.io/docs)
- [Playbook Type Definition](./src/types/playbook.ts)
- [Web MCP Server Architecture](./docs/architecture/web-mcp-architecture.md) (존재 시)
- [Frontend MCP Integration Guide](./docs/guides/mcp-integration.md) (존재 시)

---

**작성자**: Claude (Anthropic)
**작성일**: 2025-01-11 (updated)
**최종 수정일**: 2025-01-11 23:45
**버전**: 2.0
**리뷰 필요 항목**: Agent Context 텍스트 응답 가독성, 페이지네이션 UI UX

**주요 변경사항 (v2.0)**:

- ✅ `Page<T>` 인터페이스에 `totalPages` 필드 추가
- ✅ `get_playbook_page` 도구 추가 (페이지네이션 내비게이션)
- ✅ **Agent Context 최적화**: 모든 텍스트 응답에 명확한 맥락 정보 추가 (도구명, 요약, 힌트)
- ✅ 페이지네이션 UI 구현 (Previous/Next 버튼, 페이지 정보 표시)
- ✅ 공통 로직 함수 추가 (`getPlaybooksWithUI()`, `createListTextResponse()`, `createUITextResponse()`)
- ✅ `buildUiHtml()` 시그니처 변경 (페이지 정보 전달)
- ✅ 모든 도구의 텍스트 응답 개선 (create, update, delete, get, select)
- ✅ Agent Context 텍스트 응답 테스트 케이스 추가
- ✅ 페이지네이션 UI 테스트 케이스 추가
