# Refactoring Plan: Process Polling State Management Enhancement

**작성일**: 2025-10-11  
**작업자**: Development Team  
**관련 이슈**: Excessive polling detection and user guidance

---

## 작업의 목적

Async process 실행 시 AI 에이전트가 `poll_process` 도구를 과도하게 자주 호출하는 문제를 해결하기 위해, 연속적인 polling 패턴을 감지하고 적절한 가이드를 제공하는 메커니즘을 구축한다. 이를 통해:

1. **불필요한 시스템 부하 감소**: 과도한 polling으로 인한 I/O 및 CPU 오버헤드 최소화
2. **에이전트 행동 개선**: AI 에이전트에게 더 효율적인 polling 전략 유도
3. **사용자 경험 향상**: 명확한 피드백을 통해 프로세스 모니터링 방식 개선

---

## 현재의 상태 / 문제점

### 현재 구조

- **ProcessEntry**: 프로세스 메타데이터만 저장 (상태, PID, 시작/종료 시간, 출력 파일 경로 등)
- **handle_poll_process**: 단순한 읽기 전용 조회 기능만 제공
- **상태 관리**: 백그라운드 모니터링 태스크에서만 프로세스 상태 업데이트
- **Poll 추적 부재**: Poll 호출 자체를 기록하거나 분석하는 메커니즘 없음

### 핵심 문제점

1. **과도한 Polling 미감지**: 에이전트가 1-2초 간격으로 수십 번 polling해도 시스템이 인지하지 못함
2. **피드백 부재**: 비효율적인 polling 패턴에 대한 경고나 가이드 없음
3. **학습 기회 상실**: 에이전트가 더 나은 polling 전략을 학습할 수 없음
4. **리소스 낭비**: 불필요한 파일 I/O 및 락 경합 발생

### 관찰된 패턴

```text
[시간: 10:00:00] poll_process(process_id: "abc123") -> status: "running"
[시간: 10:00:02] poll_process(process_id: "abc123") -> status: "running"
[시간: 10:00:04] poll_process(process_id: "abc123") -> status: "running"
[시간: 10:00:06] poll_process(process_id: "abc123") -> status: "running"
[시간: 10:00:08] poll_process(process_id: "abc123") -> status: "running"
...
(30초 동안 15회 이상 반복)
```

---

## 관련 코드의 구조 및 동작 방식 Summary

### 1. Process Registry Architecture

```
WorkspaceServer
    └── process_registry: Arc<RwLock<ProcessRegistryData>>
            ├── entries: HashMap<String, ProcessEntry>
            └── cancellation_tokens: HashMap<String, CancellationToken>
```

**ProcessEntry (terminal_manager.rs)**

```rust
pub struct ProcessEntry {
    pub id: String,
    pub session_id: String,
    pub command: String,
    pub status: ProcessStatus,
    pub pid: Option<u32>,
    pub exit_code: Option<i32>,
    pub started_at: DateTime<Utc>,
    pub finished_at: Option<DateTime<Utc>>,
    pub stdout_path: String,
    pub stderr_path: String,
    pub stdout_size: u64,
    pub stderr_size: u64,
}
```

### 2. Async Process Execution Flow

```
execute_shell(run_mode: "async")
    ↓
1. 동시 실행 제한 확인 (최대 20개/세션)
    ↓
2. 프로세스 ID 생성 및 임시 디렉토리 생성
    ↓
3. ProcessEntry 등록 (status: Starting)
    ↓
4. 백그라운드 모니터링 태스크 시작
    ├── spawn_and_stream_to_files() 실행
    ├── stdout/stderr를 파일로 스트리밍
    └── 완료 시 status 업데이트 (Finished/Failed)
    ↓
5. 즉시 응답 반환 (process_id 포함)
```

### 3. Poll Process Flow

```
poll_process(process_id)
    ↓
1. 파라미터 검증 (process_id 필수)
    ↓
2. 세션 권한 확인
    ↓
3. Registry에서 ProcessEntry 조회 (읽기 전용)
    ↓
4. 선택적 tail 처리 (stdout/stderr 마지막 N줄)
    ↓
5. JSON 응답 구성 및 반환
```

**Key Insight**: Poll은 현재 **완전한 읽기 전용**으로 설계되어 있으며, 호출 자체를 추적하지 않음.

### 4. State Management Pattern

- **Write**: 백그라운드 태스크만 프로세스 상태 변경 가능
- **Read**: Poll은 관측(observation)만 수행
- **Lock Strategy**: RwLock 사용으로 다중 읽기 동시 지원
- **Session Isolation**: 세션별로 프로세스 격리

---

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **Poll 추적 메커니즘 활성화**
   - 각 프로세스에 대한 poll 호출 횟수, 시간, 패턴 기록
   - Running 상태에서의 연속 poll 특별 추적

2. **적응형 가이드 시스템**
   - 임계값 초과 시 자동으로 일반적인 가이드 메시지 추가
   - 구체적인 도구명 없이 행동 패턴 권장

3. **성능 저하 최소화**
   - Poll 추적으로 인한 락 경합 최소화
   - 메모리 오버헤드 최소화 (프로세스당 ~100 bytes 추가)

### 해결 판정 기준

#### 기능적 기준

- [ ] 연속 5회 이상 running 상태 poll 시 가이드 메시지 자동 추가
- [ ] 가이드 메시지에 구체적 도구명 미포함 (일반적 권장사항만)
- [ ] 세션 격리 유지 (다른 세션의 poll에 영향 없음)
- [ ] 프로세스 상태 변경 시 poll 카운터 자동 리셋

#### 성능 기준

- [ ] Poll 응답 시간 증가 < 5ms
- [ ] 메모리 오버헤드 < 200 bytes per process
- [ ] 기존 동기/비동기 실행 로직 정상 작동

#### 코드 품질 기준

- [ ] Rust 컴파일러 경고 없음
- [ ] `pnpm refactor:validate` 통과
- [ ] 기존 테스트 코드 모두 통과

---

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ProcessEntry 구조체 확장 (terminal_manager.rs)

**파일 경로**: `src-tauri/src/mcp/builtin/workspace/terminal_manager.rs`

**수정 위치**: 19-33행

**Before**:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessEntry {
    pub id: String,
    pub session_id: String,
    pub command: String,
    pub status: ProcessStatus,
    pub pid: Option<u32>,
    pub exit_code: Option<i32>,
    pub started_at: DateTime<Utc>,
    pub finished_at: Option<DateTime<Utc>>,
    pub stdout_path: String,
    pub stderr_path: String,
    pub stdout_size: u64,
    pub stderr_size: u64,
}
```

**After**:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessEntry {
    pub id: String,
    pub session_id: String,
    pub command: String,
    pub status: ProcessStatus,
    pub pid: Option<u32>,
    pub exit_code: Option<i32>,
    pub started_at: DateTime<Utc>,
    pub finished_at: Option<DateTime<Utc>>,
    pub stdout_path: String,
    pub stderr_path: String,
    pub stdout_size: u64,
    pub stderr_size: u64,

    // Poll tracking fields
    pub last_poll_at: Option<DateTime<Utc>>,
    pub poll_count: u32,
    pub consecutive_running_polls: u32,
    pub first_running_poll_at: Option<DateTime<Utc>>,
}
```

**변경 이유**: Poll 추적을 위한 메타데이터 필드 추가. 총 poll 횟수, 연속 running poll, 타임스탬프를 기록하여 패턴 분석 가능하게 함.

---

### 2. ProcessEntry 초기화 로직 업데이트 (code_execution.rs)

**파일 경로**: `src-tauri/src/mcp/builtin/workspace/code_execution.rs`

**수정 위치**: 다음 두 곳에서 ProcessEntry 생성 시

- 275-289행 (sync 모드)
- 609-623행 (async 모드)

**수정 내용**:

```rust
let entry = terminal_manager::ProcessEntry {
    id: process_id.clone(),
    session_id: session_id.clone(),
    command: command.to_string(),
    status: terminal_manager::ProcessStatus::Starting,
    pid: None,
    exit_code: None,
    started_at: chrono::Utc::now(),
    finished_at: None,
    stdout_path: stdout_path.to_string_lossy().to_string(),
    stderr_path: stderr_path.to_string_lossy().to_string(),
    stdout_size: 0,
    stderr_size: 0,

    // Initialize poll tracking fields
    last_poll_at: None,
    poll_count: 0,
    consecutive_running_polls: 0,
    first_running_poll_at: None,
};
```

---

### 3. handle_poll_process 로직 확장 (mod.rs)

**파일 경로**: `src-tauri/src/mcp/builtin/workspace/mod.rs`

**수정 위치**: 160-245행

**추가할 로직**:

```rust
pub async fn handle_poll_process(&self, args: Value) -> MCPResponse {
    let request_id = Self::generate_request_id();

    // ... 기존 파라미터 검증 및 권한 확인 로직 ...

    // === 추가: Poll 추적 및 Detect 로직 ===
    const MAX_CONSECUTIVE_RUNNING_POLLS: u32 = 5;

    let (should_show_guidance, entry_for_response) = {
        let mut registry = self.process_registry.write().await;
        if let Some(entry) = registry.entries.get_mut(process_id) {
            let now = chrono::Utc::now();

            // Update poll metadata
            entry.last_poll_at = Some(now);
            entry.poll_count += 1;

            // Track consecutive running polls
            let is_running = matches!(entry.status, terminal_manager::ProcessStatus::Running);
            if is_running {
                if entry.first_running_poll_at.is_none() {
                    entry.first_running_poll_at = Some(now);
                }
                entry.consecutive_running_polls += 1;
            } else {
                // Reset counters when status changes
                entry.consecutive_running_polls = 0;
                entry.first_running_poll_at = None;
            }

            let should_guide = is_running && entry.consecutive_running_polls >= MAX_CONSECUTIVE_RUNNING_POLLS;
            (should_guide, entry.clone())
        } else {
            return Self::error_response(
                request_id,
                -32603,
                "Process not found or access denied",
            );
        }
    };

    // Verify session access
    if entry_for_response.session_id != session_id {
        return Self::error_response(request_id, -32603, "Process not found or access denied");
    }

    // Build response
    let mut response = serde_json::json!({
        "process_id": entry_for_response.id,
        "status": format!("{:?}", entry_for_response.status).to_lowercase(),
        "command": entry_for_response.command,
        "pid": entry_for_response.pid,
        "exit_code": entry_for_response.exit_code,
        "started_at": entry_for_response.started_at.to_rfc3339(),
        "finished_at": entry_for_response.finished_at.map(|t| t.to_rfc3339()),
        "stdout_size": entry_for_response.stdout_size,
        "stderr_size": entry_for_response.stderr_size,
    });

    // Optional tail (기존 로직 유지)
    if let Some(tail_obj) = args.get("tail").and_then(|v| v.as_object()) {
        // ... 기존 tail 처리 로직 ...
    }

    // === 추가: 가이드 메시지 생성 ===
    let response_text = if should_show_guidance {
        let guidance = format!(
            "\n\n⚠️  Polling Efficiency Notice\n\
            This process has been polled {} times while running.\n\n\
            Consider more efficient monitoring strategies:\n\
            • Increase polling intervals (e.g., wait 10-30 seconds between checks)\n\
            • Wait longer before checking status again\n\
            • Use longer intervals for long-running processes\n\n\
            Frequent polling may impact system performance without providing additional value.",
            entry_for_response.consecutive_running_polls
        );

        format!(
            "{}\n{}",
            serde_json::to_string_pretty(&response).unwrap_or_default(),
            guidance
        )
    } else {
        serde_json::to_string_pretty(&response).unwrap_or_default()
    };

    Self::success_response(request_id, &response_text)
}
```

---

## 재사용 가능한 연관 코드

### 1. 상수 정의 (config.rs 또는 mod.rs)

```rust
// Polling behavior constants
pub const MAX_CONSECUTIVE_RUNNING_POLLS: u32 = 5;
pub const POLL_GUIDANCE_COOLDOWN_SECS: u64 = 60; // 가이드 재표시 간격
```

### 2. Tail 처리 로직 (terminal_manager.rs)

**파일 경로**: `src-tauri/src/mcp/builtin/workspace/terminal_manager.rs:54-149`

**기능**: 큰 파일 최적화 처리

- 1MB 미만: 전체 파일 읽기
- 1MB 이상: 청크 단위 역방향 탐색

**재사용 가능**: 변경 없이 그대로 사용

### 3. Session 격리 검증 (mod.rs)

```rust
// Get current session
let session_id = self
    .session_manager
    .get_current_session()
    .unwrap_or_else(|| "default".to_string());

// Verify session access
if entry.session_id != session_id {
    return Self::error_response(request_id, -32603, "Process not found or access denied");
}
```

**재사용 가능**: 세션 검증 패턴은 모든 poll 관련 핸들러에서 동일

### 4. 응답 생성 유틸리티 (utils.rs)

**파일 경로**: `src-tauri/src/mcp/builtin/workspace/utils.rs:10-20`

```rust
pub fn create_success_response(request_id: Value, message: &str) -> MCPResponse {
    MCPResponse::success(
        request_id,
        json!({
            "content": [{
                "type": "text",
                "text": message
            }]
        }),
    )
}
```

**재사용 가능**: 가이드 메시지 포함 응답 생성 시 사용

---

## Test Code 추가 및 수정 필요 부분 가이드

### 1. Unit Tests (terminal_manager.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_process_entry_initialization() {
        let entry = ProcessEntry {
            id: "test-123".to_string(),
            session_id: "session-1".to_string(),
            command: "test command".to_string(),
            status: ProcessStatus::Starting,
            pid: None,
            exit_code: None,
            started_at: Utc::now(),
            finished_at: None,
            stdout_path: "/tmp/stdout".to_string(),
            stderr_path: "/tmp/stderr".to_string(),
            stdout_size: 0,
            stderr_size: 0,
            last_poll_at: None,
            poll_count: 0,
            consecutive_running_polls: 0,
            first_running_poll_at: None,
        };

        assert_eq!(entry.poll_count, 0);
        assert_eq!(entry.consecutive_running_polls, 0);
        assert!(entry.last_poll_at.is_none());
    }

    #[test]
    fn test_poll_counter_increment() {
        // Poll 카운터 증가 로직 테스트
    }

    #[test]
    fn test_consecutive_running_poll_reset() {
        // 상태 변경 시 카운터 리셋 검증
    }
}
```

### 2. Integration Tests (mod.rs)

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_excessive_polling_guidance() {
        // 1. Async 프로세스 시작
        // 2. 5회 이상 poll 호출
        // 3. 가이드 메시지 포함 여부 확인
    }

    #[tokio::test]
    async fn test_poll_tracking_across_status_changes() {
        // 1. Running 상태에서 5회 poll
        // 2. 프로세스 완료 (Finished)
        // 3. 다시 poll 시 카운터 리셋 확인
    }

    #[tokio::test]
    async fn test_session_isolation_in_poll_tracking() {
        // 1. 두 개의 서로 다른 세션 생성
        // 2. 각 세션에서 독립적인 poll 추적 확인
    }

    #[tokio::test]
    async fn test_poll_performance_impact() {
        // 1. Poll 추적 활성화 전후 응답 시간 측정
        // 2. 5ms 이내 증가 확인
    }
}
```

### 3. Serialization Tests

```rust
#[test]
fn test_process_entry_serialization() {
    let entry = ProcessEntry { /* ... */ };

    // JSON serialization
    let json = serde_json::to_string(&entry).unwrap();
    let deserialized: ProcessEntry = serde_json::from_str(&json).unwrap();

    assert_eq!(entry.id, deserialized.id);
    assert_eq!(entry.poll_count, deserialized.poll_count);
}
```

### 4. Mock 테스트를 위한 헬퍼

```rust
#[cfg(test)]
pub fn create_test_process_entry(id: &str, status: ProcessStatus) -> ProcessEntry {
    ProcessEntry {
        id: id.to_string(),
        session_id: "test-session".to_string(),
        command: "test command".to_string(),
        status,
        pid: Some(12345),
        exit_code: None,
        started_at: Utc::now(),
        finished_at: None,
        stdout_path: format!("/tmp/{}/stdout", id),
        stderr_path: format!("/tmp/{}/stderr", id),
        stdout_size: 0,
        stderr_size: 0,
        last_poll_at: None,
        poll_count: 0,
        consecutive_running_polls: 0,
        first_running_poll_at: None,
    }
}
```

---

## 추가 분석 과제

### 1. 가이드 메시지 최적화

- **현재 상태**: 영어 메시지만 제공
- **분석 필요**:
  - 다국어 지원 필요성 검토
  - 메시지 길이가 응답 크기에 미치는 영향 측정
  - 에이전트의 가이드 메시지 해석 능력 평가

### 2. 임계값 동적 조정

- **현재 상태**: 하드코딩된 임계값 (5회)
- **분석 필요**:
  - 프로세스 실행 시간에 따른 적정 임계값 연구
  - 세션별 또는 사용자별 설정 가능성 검토
  - 환경 변수를 통한 설정 가능성

### 3. Poll 패턴 분석 고도화

- **현재 상태**: 연속 횟수만 추적
- **분석 필요**:
  - Poll 간격(time delta) 추적 및 분석
  - 비정상적으로 짧은 간격(< 1초) 특별 처리
  - 통계 데이터 수집 (평균 간격, 표준편차 등)

### 4. 메모리 오버헤드 측정

- **현재 추정**: ProcessEntry당 ~100 bytes 추가
- **측정 필요**:
  - 실제 메모리 사용량 프로파일링
  - 대량 프로세스(100+) 시나리오 테스트
  - 메모리 누수 가능성 검증

### 5. 가이드 효과성 검증

- **현재 상태**: 가이드 제공 후 행동 변화 미추적
- **분석 필요**:
  - 가이드 표시 후 실제 polling 간격 변화 측정
  - A/B 테스트 (가이드 있음/없음)
  - 에이전트 학습 효과 장기 추적

---

## 구현 순서 권장사항

### Phase 1: 기본 인프라 구축 (1-2일)

1. ProcessEntry 구조체 확장
2. 초기화 로직 업데이트
3. 기본 테스트 작성 및 컴파일 확인

### Phase 2: Poll 추적 로직 구현 (2-3일)

1. handle_poll_process 수정
2. 카운터 증가/리셋 로직 구현
3. 세션 격리 검증

### Phase 3: 가이드 시스템 구현 (1-2일)

1. 가이드 메시지 생성 로직
2. 임계값 기반 트리거
3. 응답 형식 통합

### Phase 4: 테스트 및 검증 (2-3일)

1. Unit/Integration 테스트 작성
2. 성능 측정 및 최적화
3. `pnpm refactor:validate` 통과 확인

### Phase 5: 문서화 및 배포 (1일)

1. 코드 주석 보완
2. 사용자 문서 업데이트
3. 변경 사항 로깅

**총 예상 기간**: 7-11일

---

## 위험 요소 및 완화 전략

### 위험 1: 락 경합 증가

- **위험도**: 중간
- **완화**:
  - Write 락을 최소 시간만 보유
  - 필요한 데이터만 clone하여 락 외부에서 처리
  - 성능 테스트로 검증

### 위험 2: 기존 기능 회귀

- **위험도**: 낮음
- **완화**:
  - 필드 추가만으로 기존 로직 변경 최소화
  - 광범위한 테스트 커버리지
  - 단계적 배포 (feature flag 고려)

### 위험 3: 가이드 메시지 무시

- **위험도**: 높음
- **완화**:
  - 명확하고 실행 가능한 권장사항 제공
  - 에이전트 프롬프트에 가이드 준수 강조
  - 효과성 모니터링 및 개선

### 위험 4: 메모리 누수

- **위험도**: 낮음
- **완화**:
  - 24시간 자동 cleanup 메커니즘 활용
  - 메모리 프로파일링
  - 오래된 프로세스 정기 정리

---

## 성공 지표

1. **기술적 지표**
   - Poll 추적 정확도 99.9%
   - 응답 시간 증가 < 5ms
   - 메모리 오버헤드 < 200 bytes/process

2. **사용성 지표**
   - 가이드 표시 후 평균 polling 간격 증가율 > 50%
   - 과도한 polling (>10회) 발생 빈도 감소 > 70%

3. **시스템 안정성**
   - 기존 테스트 100% 통과
   - 새로운 크래시 또는 메모리 누수 0건
   - `refactor:validate` 통과

---

## 참고 자료

- **관련 파일**:
  - `src-tauri/src/mcp/builtin/workspace/terminal_manager.rs`
  - `src-tauri/src/mcp/builtin/workspace/mod.rs`
  - `src-tauri/src/mcp/builtin/workspace/code_execution.rs`
  - `src-tauri/src/mcp/builtin/workspace/utils.rs`

- **관련 문서**:
  - Async Process Execution Design
  - Session Isolation Architecture
  - MCP Tool Response Format Specification

- **참고 구현**:
  - Cleanup task (mod.rs:44-85)
  - Tail optimization (terminal_manager.rs:54-149)
  - Session-based isolation pattern

---

**작성 완료일**: 2025-10-11  
**최종 검토자**: [작업자명]  
**승인 상태**: 검토 대기
