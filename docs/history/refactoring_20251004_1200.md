# Refactoring Plan: Modularize html-parser.ts (Internal Repository)

## 작업의 목적

- 현재 하나의 거대한 `src/lib/html-parser.ts` 파일이 지나치게 크고 복잡하여 유지보수·리뷰·테스트가 어렵습니다.
- 책임 분리(타입·상수·유틸·파이프라인·인터랙터블)를 통해 가독성, 단위 테스트 작성 용이성, 향후 패키지 분리(옵션 A)로의 이전을 쉽게 합니다.
- 레거시 코드를 사용하는 다른 모듈의 import 경로를 깨지 않도록 호환성을 유지합니다.

## 현재의 상태 / 문제점

- 단일 대형 파일(약 1300+ 라인)로 유지보수 부담이 큼.
- 내부 유틸/상수/타입/클래스가 한 파일에 섞여 있어 재사용/테스트가 어려움.
- 여러 기능(구조적 파싱, DOM map, interactables 추출)이 동일 네임스페이스에 있어 변경 영향 범위 파악이 어려움.
- 다수의 테스트와 도구(`src/test/html-parser/...`, `src/features/tools/...`)가 `@/lib/html-parser`를 직접 import 하고 있음 — 경로 변경 시 호환성 필요.

## 관련 코드의 구조 및 동작 방식 Summary (Birdseye View)

- Public API (현재): export된 함수/타입들
  - `parseHTMLToStructured(htmlString, options) -> StructuredContent`
  - `parseHTMLToDOMMap(htmlString, options) -> DOMMapResult`
  - `parseHtmlToInteractables(htmlString, scopeSelector, options) -> InteractableResult`
  - `extractHTMLMetadata(htmlString) -> PageMetadata`
  - 여러 인터페이스/타입: `ParsedElement, DOMMapNode, InteractableElement, ...`
- 내부 구성(현재 한 파일)
  - 상수(기본옵션, 제외태그, selectors)
  - 타입/인터페이스
  - validator/utility 함수 (validateHtmlInput, createCompactText 사용)
  - 파이프라인 구현(StructuredParsePipeline, DOMMapParsePipeline)
  - interactable extraction 로직
  - 에러 타입 및 에러 핸들링
- 외부 의존
  - `@/lib/logger`, `@/lib/text-utils`, `@/lib/dom/selector`
  - Tests use `jsdom` and import current public functions.

## 변경 이후의 상태 / 해결 판정 기준 (Success Criteria)

- 파일이 기능 단위로 분리되어 각 파일이 명확한 책임(타입, 상수, 유틸, 파이프라인, interactable)을 가짐.
- 기존 import 구문(예: `import { parseHtmlToInteractables } from '@/lib/html-parser'`) 그대로 작동 — 즉시 호환성 유지.
- 기존 테스트(특히 `src/test/html-parser/*`)가 변경 없이 통과.
- 타입스크립트 빌드(`pnpm build`) 및 단위 테스트(`pnpm test`) 성공.
- 변경 후 코드 품질(ESLint, Prettier) 준수.
- 리팩터링 PR 크기 설명 및 변경 파일 목록이 기록됨.

검증 체크리스트 (머지 전)

- [ ] TypeScript 컴파일 통과
- [ ] 관련 vitest 테스트 통과(특히 selector/visibility tests)
- [ ] ESLint (필요 시 lint:fix) 적용
- [ ] 변경된 파일들에 대해 `pnpm refactor:validate` 실행(권장)

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

(목표: 최소한의 API 변경 — 내부 파일로 분해 후 `src/lib/html-parser.ts`는 re-export 어댑터로 유지)

1. 새 디렉터리 및 파일 구조 제안

- `src/lib/html-parser/`
  - `index.ts` // public exports (re-export)
  - `types.ts` // 모든 인터페이스/타입
  - `constants.ts` // DEFAULT\_\* 상수, EXCLUDE_TAGS 등
  - `utils.ts` // validateHtmlInput, extractTextContent, parseHTMLDocument, metadata 생성, 에러유틸
  - `attribute-extractors.ts` // AttributeExtractor classes (Basic, Link, Interactive)
  - `pipelines.ts` // StructuredParsePipeline, DOMMapParsePipeline, 공통 파이프라인
  - `interactable.ts` // parseElementToInteractable, parseHtmlToInteractables
  - `structured.ts` // parseHTMLToStructured / helpers
  - `dommap.ts` // parseHTMLToDOMMap / helpers

2. 예시 — 호환성 어댑터(`src/lib/html-parser.ts`) (작업 후 대체/덮어쓰기)

```ts
// src/lib/html-parser.ts  <--- 기존 긴 파일을 대체하는 적은 코드의 어댑터
export * from './html-parser/index';
```

3. 예시 — 새 `index.ts` (public re-exports)

```ts
// src/lib/html-parser/index.ts
export * from './types';
export * from './constants';
export * from './utils';
export * from './interactable';
export * from './structured';
export * from './dommap';
```

4. 예시 — `types.ts` (일부)

```ts
// src/lib/html-parser/types.ts
export interface ParsedElement {
  /* ... same as before ... */
}
export interface DOMMapNode {
  /* ... */
}
export interface PageMetadata {
  /* ... */
}
export interface ParseOptions {
  /* ... */
}
export interface DOMMapOptions {
  /* ... */
}
export interface InteractableElement {
  /* ... */
}
export interface InteractableOptions {
  /* ... */
}
export interface InteractableResult {
  /* ... */
}
export interface StructuredContent {
  /* ... */
}
export interface DOMMapResult {
  /* ... */
}
```

5. 예시 — `utils.ts` (일부)

```ts
// src/lib/html-parser/utils.ts
import { createCompactText } from '@/lib/text-utils';
import { getLogger } from '@/lib/logger';

const logger = getLogger('HTMLParser:utils');

export function validateHtmlInput(html: string): string | null {
  /* same as before */
}
export function parseHTMLDocument(htmlString: string): Document {
  /* same as before */
}
export function createMetadata(doc: Document): PageMetadata {
  /* same as before */
}
export function extractTextContent(
  element: Element,
  maxLength: number,
): string {
  /* same as before */
}
// plus error types HTMLParseError, DOMParserError and helper factories
```

(실제 코드 스니펫은 리팩터 시 그대로 옮기되, 파일 경계에 맞춘다 — 위는 예시)

## 재사용 가능한 연관 코드 (파일 경로, 주요 기능, 인터페이스)

- `src/lib/logger.ts` — 중앙 로거 사용 (모든 새 파일에서 import)
- `src/lib/text-utils.ts` — `createCompactText` 사용; 유지 필요
- `src/lib/dom/selector.ts` — `buildUniqueSelector`, `isValidCSSIdentifier` 사용; 유지 필요
- Tests referencing parser:
  - `src/test/html-parser/selector-builder.test.ts`
  - `src/test/html-parser/visibility-fix.test.ts`
  - `src/test/html-parser/selector-debug.test.ts`
- Browser tools calling parse functions:
  - `src/features/tools/browser-tools/ExtractInteractableTool.ts` imports `parseHtmlToInteractables` and types from `@/lib/html-parser` — 어댑터 유지로 변경 불필요.

## Test Code 추가 및 수정 필요 부분에 대한 가이드

목표: 기능 분리 후에도 기존 테스트가 변경 없이 통과해야 함.

1. 유닛 테스트 유지/보강

- 이동한 각 모듈(`interactable.ts`, `pipelines.ts`, `utils.ts`)에 대해 소규모 단위 테스트 추가:
  - `utils.validateHtmlInput` 유닛 테스트(잘못된/빈 HTML 케이스)
  - `utils.extractTextContent` 유닛 테스트(직접 텍스트 vs 자식 포함 텍스트 등)
  - `attribute-extractors`의 각 클래스(unit tests for extraction)
  - `pipelines`의 핵심 흐름: 간단한 DOM으로 StructuredParsePipeline의 postValidate/children 처리
  - `interactable.parseElementToInteractable`의 visible/enabled/attributes 확인
- 기존 통합 테스트(현재 존재하는 jsdom 기반 테스트)는 그대로 유지. (경로 변하지 않으면 수정을 요구하지 않음)

2. 테스트 위치

- 기존 스타일과 동일하게 `src/test/html-parser/` 아래에 모듈별 테스트 추가(예: `utils.test.ts`, `pipelines.test.ts`, `interactable.test.ts`).

3. Minimal smoke test

- PR에 포함될 빠른 smoke test 스크립트(간단한 DOM input으로 `parseHtmlToInteractables` 및 `parseHTMLToStructured` 호출하고 결과에 error 없는지 확인).

## 변경 절차(세부 단계, 안전 우선)

(각 단계 완료 후 빌드/테스트 확인 — 실패 시 롤백 또는 수정을 수행)

1. 준비(로컬 브랜치에서)
   - 새 브랜치 생성: `git checkout -b refactor/html-parser-modularize`
2. 디렉터리 및 파일 생성
   - `src/lib/html-parser/` 생성
   - 위에서 제안한 파일들 (`types.ts`, `constants.ts`, `utils.ts`, `attribute-extractors.ts`, `pipelines.ts`, `interactable.ts`, `structured.ts`, `dommap.ts`, `index.ts`)을 생성하고 원본 코드를 책임별로 옮기기
   - 기존 `src/lib/html-parser.ts`를 호환용 어댑터(또는 단일 한 줄 re-export)로 바꿈
3. 내부 참조 정리
   - 새 파일들 간의 상대 import 정리
   - 외부 의존(`@/lib/logger`, `@/lib/text-utils`, `@/lib/dom/selector`) 그대로 사용
4. 타입스크립트 빌드 & 테스트
   - `pnpm build` 또는 `pnpm test`
   - 실패 시 원인 분석(주로 경로/타입 누락) 후 수정
5. ESLint/Prettier 적용
   - `pnpm lint` / `pnpm format`
6. 테스트 보강
   - 새 파일에 맞춘 단위 테스트 추가(위 가이드에 따라)
   - 전체 테스트 재실행 — 통과 확인
7. PR 준비
   - 변경사항 요약, risk, migration notes(어댑터로 경로 변경 불필요), test 결과 스크린샷/요약
   - `docs/history/refactoring_{yyyyMMdd_hhmm}.md` 생성(필수)
8. 코드 리뷰 수정(리뷰어 피드백 반영)
9. 병합 후(옵션)
   - 모듈 단위로 추가 리팩터(더 작은 유틸 공용화 등)
   - 향후 패키지화(A 옵션) 검토

## Rollback / 안전장치

- 단계별 커밋(파일 추가/이동은 별도 커밋)으로 rollback 간편화.
- 모든 변경 전 `git status`/`git diff`로 확인.
- `src/lib/html-parser.ts` 어댑터는 기존 API를 보존하므로 레거시 호출은 안전.

## 예상 소요 시간 (대략)

- 파일 분해 및 코드 이동(초안): 30–60분
- import/타입 문제 해결 + 빌드/테스트 통과: 20–40분
- 테스트 추가/보강 + lint 수정: 30–60분
- 총합(완전한 PR 준비): 1.5–3 시간 (테스트/예상되는 조정에 따라 달라짐)

## 위험/엣지케이스

- 엣지케이스
  - 내부 의존(예: `createCompactText` 또는 `buildUniqueSelector`)가 모듈 경계 문제를 일으킬 수 있음 — 경로 변경 없이 동일 import를 그대로 사용하면 위험 낮음
  - 테스트가 JSDOM 환경에 의존 — 새로운 모듈에서의 DOM 관련 코드가 Node 환경 차이에 민감할 수 있음
  - public 타입/인터페이스 실수로 변경되면 호출부에서 타입 에러 발생
- 대응
  - 단계별로 빌드/테스트를 수행하여 변경 영향 최소화
  - 변경 시 public API가 정확히 동일한지(이름/시그니처) 확인

## Quality gates (PR 제출 전 체크)

- Build: pnpm build -> PASS
- Unit tests: pnpm test -> PASS
- Lint: pnpm lint -> PASS (or lint:fix applied)
- Format: pnpm format -> applied
- Dead code check (선택): pnpm dead-code -> optional

권장 명령(로컬에서 실행):

```bash
pnpm install
pnpm build
pnpm test
pnpm lint
pnpm format
pnpm refactor:validate   # (전체 파이프라인, 시간이 걸릴 수 있음)
```

## 파일 규칙 및 기록

- 생성된/수정된 리팩터링 기록은 반드시:
  - `./docs/history/refactoring_{YYYYMMDD_HHMM}.md` 파일로 작성
  - 내용: 작업 목적, 변경 파일 목록, 주의사항, 테스트 결과 스냅샷, 롤백 방법
- PR 제목 예시: `[refactor] modularize html-parser (internal)`
- PR 본문에 `refactoring_plan_submission_guide.md`의 필수 요소를 요약하여 붙임

## 요구사항 맵핑 (refactoring_plan_submission_guide.md의 필수요소 대비)

- 작업의 목적: Done (위의 목적 섹션)
- 현재의 상태 / 문제점: Done
- 관련 코드의 구조 및 동작 방식 Summary: Done (Birdseye View)
- 변경 이후의 상태 / 해결 판정 기준: Done (Success Criteria + 체크리스트)
- 수정이 필요한 코드 및 수정부분의 코드 스니핏: Done (어댑터 예시, index 및 types 예시)
- 재사용 가능한 연관 코드: Done (경로 및 파일 목록)
- Test Code 추가 및 수정 필요 가이드: Done (무엇을 추가/검증할지)
- file 규칙: Done (`docs/history/refactoring_{yyyyMMdd_hhmm}.md` 지시 포함)
