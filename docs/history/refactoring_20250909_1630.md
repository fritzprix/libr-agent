# Refactoring Plan: Malformed JSON Prevention in AI Service

## 작업의 목적

API 호출 시 malformed JSON으로 인한 "Incomplete JSON segment" 오류를 방지하기 위해, 메시지 데이터를 API에 전달하기 전에 JSON 구조를 검증하고 안전하게 escape 처리하는 보호 로직을 구현한다.

## 현재의 상태 / 문제점

### 문제 상황

- `error.txt`에서 "Incomplete JSON segment at the end" 오류 발생
- API 호출 시 malformed JSON이 포함된 메시지로 인해 요청 실패
- 특히 `tool_calls.function.arguments` 및 `MCPContent.text` 필드에서 불완전한 JSON 구조 전달

### 현재 코드 분석

- `use-ai-service.ts`의 `submit` 함수에서 API 호출 전 검증 로직 부재
- Line 67-72: `serviceInstance.streamChat()` 호출 시 메시지 데이터 직접 전달
- JSON 파싱 실패 시 단순히 텍스트로 처리하는 defensive 로직만 존재 (Line 79-86)

### 영향 범위

- AI 서비스 응답 실패로 인한 사용자 경험 저하
- 불완전한 응답으로 인한 세션 중단
- API 호출 오류로 인한 비용 낭비

## 추가 분석 과제

1. **에러 로그 상세 분석**: `analyze_errors.py` 스크립트를 활용하여 malformed JSON 패턴의 빈도와 유형 파악
2. **MCP 컨텐츠 타입별 검증**: `MCPContent` 각 타입(`text`, `image`, `audio`, `resource_link`)별 escape 필요성 검토
3. **API Provider별 차이**: 다양한 AI 서비스 제공자(OpenAI, Anthropic, Google 등)의 JSON 처리 방식 차이 분석

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **API 호출 성공률 100%**: malformed JSON으로 인한 요청 실패 제거
2. **데이터 무결성 보장**: escape 처리 후에도 원본 컨텍스트와 의미 보존
3. **에러 로그 정상화**: "Incomplete JSON segment" 오류 발생 빈도 0건
4. **성능 영향 최소화**: 검증 로직 추가로 인한 응답 지연 5% 이내

### 검증 방법

- 기존 malformed JSON 케이스로 테스트 수행
- 다양한 메시지 타입(텍스트, tool_calls, thinking)에 대한 검증
- API 응답 품질 및 컨텍스트 보존 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 주요 수정 파일: `src/hooks/use-ai-service.ts`

**수정 위치**: Line 67 직전 (API 호출 전)

```typescript
// 현재 코드 (Line 67-72)
const stream = serviceInstance.streamChat(safeMessages, {
  modelName: model,
  systemPrompt: resolvedSystemPrompt,
  availableTools: config?.tools || [],
  config: config,
});

// 수정 후 코드
const sanitizedMessages = safeMessages.map(sanitizeMessage);
const stream = serviceInstance.streamChat(sanitizedMessages, {
  modelName: model,
  systemPrompt: resolvedSystemPrompt,
  availableTools: config?.tools || [],
  config: config,
});
```

### 2. 추가 구현 함수

```typescript
// JSON 필드 안전성 검증 및 escape 처리
const sanitizeJsonField = (value: string): string => {
  try {
    JSON.parse(value);
    return value; // 유효한 JSON이면 그대로 반환
  } catch {
    return JSON.stringify(value); // malformed면 escape된 문자열로 변환
  }
};

// MCPContent 안전성 처리
const sanitizeContent = (content: MCPContent): MCPContent => {
  if (content.type === 'text') {
    return {
      ...content,
      text: sanitizeJsonField(content.text),
    };
  }
  return content; // 다른 타입은 그대로 유지
};

// ToolCall 안전성 처리
const sanitizeToolCall = (toolCall: ToolCall): ToolCall => {
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      arguments: sanitizeJsonField(toolCall.function.arguments),
    },
  };
};

// Message 전체 안전성 처리
const sanitizeMessage = (message: Message): Message => {
  const sanitized = { ...message };

  // content 배열 처리
  if (sanitized.content) {
    sanitized.content = sanitized.content.map(sanitizeContent);
  }

  // tool_calls 처리
  if (sanitized.tool_calls) {
    sanitized.tool_calls = sanitized.tool_calls.map(sanitizeToolCall);
  }

  // thinking 내용 처리
  if (sanitized.thinking) {
    sanitized.thinking = sanitizeJsonField(sanitized.thinking);
  }

  return sanitized;
};
```

## 재사용 가능한 연관 코드

### 관련 파일 및 인터페이스

1. **타입 정의**
   - `src/models/chat.ts`: `Message`, `ToolCall`, `MCPContent` 인터페이스
   - `src/lib/mcp-types.ts`: `MCPTextContent`, `MCPImageContent` 등 상세 타입

2. **유틸리티 함수**
   - `src/lib/message-preprocessor.ts`: 메시지 전처리 로직 (연관성 검토)
   - `src/lib/token-utils.ts`: 컨텍스트 관리 유틸리티
   - `src/lib/logger.ts`: 로깅 시스템

3. **AI 서비스 관련**
   - `src/lib/ai-service/`: AI 서비스 팩토리 및 구현체들
   - API 호출 로직에서 동일한 sanitization 패턴 적용 가능

### 재사용 가능성

- `sanitizeJsonField` 함수: 전역 유틸리티로 추출하여 다른 JSON 처리 로직에서 재사용
- 메시지 검증 패턴: MCP 서버와의 통신, 파일 첨부 처리 등에서 유사한 패턴 적용 가능
- 에러 처리 로직: 다른 API 통신 모듈에서 동일한 defensive programming 패턴 적용

### 확장 고려사항

- 향후 새로운 `MCPContent` 타입 추가 시 `sanitizeContent` 함수 확장
- AI 모델별 특화된 sanitization 로직 필요시 provider별 처리 추가
- 성능 최적화를 위한 캐싱 메커니즘 도입 검토
