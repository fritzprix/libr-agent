# Refactoring Plan: Planning Server 간소화 및 이벤트 처리 개선

## 작업의 목적

- `planning-server.ts` 파일의 코드 중복을 제거하고 `@mcp-ui/server` 패키지를 활용하여 UI 리소스 생성을 표준화
- 이벤트 처리 로직을 보안 강화 및 MCP-UI 표준 준수로 개선하여 사용자 입력 처리의 안정성과 신뢰성 향상
- 전체 코드베이스의 유지보수성과 가독성을 높여 장기적인 개발 효율성 증대

## 현재의 상태 / 문제점

- `generatePromptHTML` 함수와 `createPromptUIResource` 함수가 분리되어 코드 중복 발생
- 이벤트 처리에서 `window.parent.postMessage`의 출처 제한이 부족하여 보안 취약성 존재
- `@mcp-ui/server` 패키지의 `createUIResource`를 충분히 활용하지 못해 표준화 부족
- HTML 템플릿이 인라인으로 복잡하게 작성되어 가독성 저하
- 타입 안전성이 일부 부족하여 런타임 에러 가능성 존재

## 추가 분석 과제 (선택적)

- 호스트 측 이벤트 리스너(`window.addEventListener`)의 출처 검증 로직 검토 및 강화
- MCP-UI 호환성을 위한 크로스-브라우저 테스트 수행
- 대용량 데이터 시 `EphemeralState`의 성능 최적화 분석

## 변경 이후의 상태 / 해결 판정 기준

- 코드 라인 수가 20-30% 감소하고, 중복 제거로 가독성 향상
- `@mcp-ui/server` 패키지를 통한 UI 리소스 생성 표준화 완료
- TypeScript 타입 가드 추가로 런타임 에러 방지
- 단위 테스트 및 통합 테스트에서 100% 통과
- 호스트 측 UI 렌더러와의 이벤트 통합 정상 작동 확인

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 대상 파일: `src/lib/web-mcp/modules/planning-server.ts`

#### 기존 코드 (문제점: 중복 및 복잡한 HTML 생성)

```typescript
/**
 * Generate HTML content for promptUser tool
 */
function generatePromptHTML(params: {
  question: string;
  type: string;
  options?: string[];
}): string {
  const { question, type, options } = params;

  let inputSection = '';
  switch (type) {
    case 'yesno':
    case 'options':
    case 'text':
  }

  return `
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 500px; margin: 0; padding: 20px; line-height: 1.5;">
      <div style="margin-bottom: 16px; padding: 16px; background: #f8fafc; border-left: 4px solid #2563eb; border-radius: 6px;">
        <h3 style="margin: 0 0 8px 0; color: #1e40af;">❓ User Input Required</h3>
        <div style="color: #1f2937; font-size: 16px;">${question}</div>
      </div>
      ${inputSection}
    </div>
  `;
}
```

#### 개선된 코드 (간소화 및 표준화)

```typescript
// UIResource 생성 헬퍼 (promptUser)
function createPromptUIResource(params: {
  question: string;
  type: string;
  options?: string[];
}) {
  const { question, type, options } = params;
  let inputSection = '';
  switch (type) {
    case 'yesno':
      inputSection = `
        <button onclick="window.parent.postMessage({type:'ui_action',action:{type:'prompt',payload:{prompt:'yes'}}},'*')">Yes</button>
        <button onclick="window.parent.postMessage({type:'ui_action',action:{type:'prompt',payload:{prompt:'no'}}},'*')">No</button>
      `;
      break;
    case 'options':
      inputSection = (options || [])
        .map(
          (opt) =>
            `<button onclick="window.parent.postMessage({type:'ui_action',action:{type:'prompt',payload:{prompt:'${opt}'}}},'*')">${opt}</button>`,
        )
        .join('');
      break;
    case 'text':
      inputSection = `
        <input id="textInput" type="text" placeholder="Type your response..."/>
        <button onclick="const v=document.getElementById('textInput').value; if(v) window.parent.postMessage({type:'ui_action',action:{type:'prompt',payload:{prompt:v}}},'*')">Submit</button>
      `;
      break;
  }
  const htmlContent = `<div><div>${question}</div>${inputSection}</div>`;
  return createUIResource({
    uri: `ui://prompt/${Date.now()}`,
    content: { type: 'rawHtml', htmlString: htmlContent },
    encoding: 'text',
  });
}
```

#### 기존 코드 (문제점: 불완전한 switch 문)

```typescript
async callTool(name: string, args: unknown): Promise<MCPResponse> {
  const typedArgs = args as Record<string, unknown>;
  switch (name) {
    default:
  }
}
```

#### 개선된 코드 (완전한 도구 호출 로직)

```typescript
async callTool(name: string, args: unknown): Promise<MCPResponse> {
  const typedArgs = args as Record<string, unknown>;
  switch (name) {
    case 'create_goal':
      return normalizeToolResult(`Goal created: "${state.createGoal(typedArgs.goal as string)}"`, 'create_goal');
    case 'clear_goal':
      return normalizeToolResult(state.clearGoal().success ? 'Goal cleared successfully' : 'Failed to clear goal', 'clear_goal');
    case 'add_todo':
      return normalizeToolResult(
        state.addTodo(typedArgs.name as string).success
          ? `Todo added: "${typedArgs.name}"`
          : 'Failed to add todo',
        'add_todo',
      );
    case 'toggle_todo': {
      const result = state.toggleTodo(typedArgs.index as number);
      return normalizeToolResult(
        result.todo
          ? `Todo "${result.todo.name}" marked as ${result.todo.status}`
          : `Todo at index ${typedArgs.index} not found`,
        'toggle_todo',
      );
    }
    case 'clear_todos':
      return normalizeToolResult(state.clearTodos().success ? 'All todos cleared' : 'Failed to clear todos', 'clear_todos');
    case 'clear_session':
      state.clear();
      return normalizeToolResult('Session state cleared', 'clear_session');
    case 'promptUser': {
      const params = typedArgs as { question: string; type: string; options?: string[] };
      const uiResource = createPromptUIResource(params);
      const baseResponse = normalizeToolResult(
        { success: true, question: params.question, type: params.type, options: params.options },
        'promptUser',
      );
      if (baseResponse.result?.content) {
        baseResponse.result.content.unshift({
          type: 'resource',
          resource: uiResource,
        });
      }
      return baseResponse;
    }
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}
```

## 재사용 가능한 연관 코드

- **파일 경로**: `src/components/ui/UIResourceRenderer.tsx`
  - **주요 기능**: UI 리소스 렌더링 및 이벤트 처리
  - **인터페이스**: `UIResourceRenderer` 컴포넌트, 이벤트 리스너(`window.addEventListener`)
- **파일 경로**: `src/lib/mcp-types.ts`
  - **주요 기능**: MCP 타입 정의 및 `normalizeToolResult` 유틸리티
  - **인터페이스**: `MCPTool`, `WebMCPServer`, `MCPResponse`
- **파일 경로**: `src/lib/web-mcp/modules/planning-server.ts` (본 파일)
  - **주요 기능**: 계획 및 목표 관리 서버 구현
  - **인터페이스**: `EphemeralState` 클래스, `planningServer` 객체

## 추가 참고 사항

- 작업 진행 시 호스트 측 코드와의 통합 테스트를 우선 수행
- 보안 강화 후 프로덕션 배포 전 크로스-브라우저 호환성 테스트 필수
- 코드 변경 후 `pnpm lint` 및 `pnpm format` 실행으로 품질 검증
