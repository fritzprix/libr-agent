# MessageRenderer Tauri Command 처리 구조 개선 리팩토링

## 작업의 목적

MessageRenderer 컴포넌트의 Tauri 명령어 처리를 동적이고 확장 가능한 구조로 개선하여 유지보수성과 AI 서비스 호환성을 향상시킨다.

### 주요 목표

- 하드코딩된 Tauri 명령어 switch문을 동적 처리로 대체
- AI 서비스별 tool chain 제약사항 준수 (Anthropic, Gemini 등)
- 코드 중복 제거 및 단일 책임 원칙 적용
- 보안 강화 (화이트리스트 기반 명령어 검증)

## 현재의 상태 / 문제점

### 1. 하드코딩된 Tauri 명령어 처리

```typescript
// src/components/MessageRenderer.tsx (현재 문제)
switch (strippedCommand) {
  case 'downloadWorkspaceFile': {
    result = await tauriCommands.downloadWorkspaceFile(
      params.filePath as string,
    );
    break;
  }
  case 'exportAndDownloadZip': {
    result = await tauriCommands.exportAndDownloadZip(
      params.files as string[],
      params.packageName as string,
    );
    break;
  }
  // 새 명령어마다 케이스 추가 필요 - 백엔드와 강한 결합
}
```

### 2. 과도한 함수 복잡성

- `handleUIAction` 함수가 5개 이상의 액션 타입 처리
- 단일 책임 원칙 위반 (SRP violation)
- 테스트 및 유지보수 어려움

### 3. 중복 코드 패턴

- 에러 처리 패턴 중복
- `useRustBackend()` 중복 호출
- Tool call message 생성 로직 반복

## 추가 분석 과제

### 1. Rust 백엔드 시그니처 호환성 분석

- 현재 Tauri 명령어들이 단일 객체 인자를 받는지 확인
- 동적 호출을 위한 파라미터 표준화 필요성 평가
- `useRustBackend` 훅의 타입 정의 검토

### 2. AI 서비스별 제약사항 상세 분석

- Rust 백엔드 파라미터 표준화 검토 (단일 객체 인자 vs 개별 인자)
- 동적 호출 시 타입 안전성 확보 방안
- 화이트리스트 기반 보안 정책 수립

## 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. **확장성**: 새 Tauri 명령어 추가 시 프론트엔드 코드 수정 불필요
2. **코드 품질**: 함수별 단일 책임 원칙 준수, 중복 코드 80% 이상 제거
3. **보안**: 화이트리스트 기반 명령어 검증으로 무단 접근 방지
4. **유지보수성**: 동적 처리로 백엔드-프론트엔드 결합도 감소

### 검증 방법

- 새 Tauri 명령어 추가 시 화이트리스트만 업데이트하면 동작
- ESLint 규칙 통과 및 코드 복잡도 개선
- 하드코딩된 switch문 완전 제거

## 수정이 필요한 코드 및 수정부분

### 1. MessageRenderer.tsx 핵심 수정

```typescript
// 현재 (문제있는 코드)
if (toolName.startsWith('tauri:')) {
  const [, strippedCommand] = toolName.split('tauri:');
  // 하드코딩된 switch문 - 백엔드 의존성
  switch (strippedCommand) {
    case 'downloadWorkspaceFile':
      /* ... */ break;
    case 'exportAndDownloadZip':
      /* ... */ break;
  }
}

// 개선 후 (동적 처리)
if (toolName.startsWith('tauri:')) {
  await handleTauriAction(toolName, params, sessionId, assistantId);
}
```

### 2. 동적 Tauri 명령어 실행 구조

```typescript
// 새로운 handleTauriAction 함수
const commandFn = safeTauriCommand(tauriCommands, strippedCommand);
if (commandFn) {
  const result = await commandFn(params); // 동적 실행
  // plan.md 제안 구현: 객체 인자로 통일된 호출
}
```

### 3. Handler 분리를 통한 복잡도 감소

```typescript
// 기존 (복잡한 단일 함수)
const handleUIAction = useCallback(async (result: UIActionResult) => {
  // 300+ 줄의 복잡한 로직
  switch (result.type) {
    case 'tool': {
      if (toolName.startsWith('tauri:')) {
        // 하드코딩된 Tauri 처리
        switch (strippedCommand /* ... */) {
        }
      } else {
        // MCP 처리
      }
    }
    // 다른 케이스들...
  }
});

// 개선 후 (분리된 핸들러)
const handleUIAction = useCallback(async (result: UIActionResult) => {
  switch (result.type) {
    case 'tool':
      if (toolName.startsWith('tauri:')) {
        await handleTauriAction(toolName, params, sessionId, assistantId);
      } else {
        await handleMCPAction(toolName, params, sessionId, assistantId);
      }
      break;
    // 다른 케이스들도 분리된 핸들러로...
  }
});
```

## 재사용 가능한 연관 코드

### 생성할 유틸리티 파일

#### 1. `src/lib/tauri-utils.ts`

```typescript
// 주요 기능: 안전한 Tauri 명령어 검증 및 실행
export function safeTauriCommand(commands, commandName): Function | null;
export const ALLOWED_TAURI_COMMANDS: Set<string>;
export function isAllowedTauriCommand(commandName: string): boolean;
```

#### 2. `src/lib/chat-utils.ts` (확장)

```typescript
// 주요 기능: Tool message 쌍 생성 (이미 구현됨)
export const createToolMessagePair: (
  toolName,
  params,
  result,
  toolCallId,
  sessionId,
  assistantId,
  isError?,
) => [Message, Message];
```

### 연관 인터페이스

```typescript
// src/models/chat.ts
interface Message {
  tool_calls?: ToolCall[]; // assistant 메시지용
  tool_call_id?: string; // tool 메시지용 (필수)
}

// src/lib/mcp-types.ts
interface UIActionResult {
  type: 'tool' | 'intent' | 'prompt' | 'link' | 'notify';
  payload: { toolName: string; params: Record<string, unknown> };
}
```

### 기존 활용 코드

- `src/hooks/use-rust-backend.ts`: tauriCommands 객체 제공
- `src/hooks/use-unified-mcp.ts`: executeToolCall 함수
- `src/lib/chat-utils.ts`: Tool message 쌍 생성 헬퍼 (이미 구현됨)
- `src/lib/tauri-utils.ts`: 안전한 Tauri 명령어 처리 유틸리티 (이미 구현됨)

## 구현 단계

### Phase 1: 기반 유틸리티 구축 (완료)

1. ✅ `tauri-utils.ts` 생성 및 safeTauriCommand 구현
2. ✅ `chat-utils.ts`에 createToolMessagePair 추가
3. ✅ 화이트리스트 기반 보안 검증 로직

### Phase 2: 동적 Tauri 처리 구현 (진행 중)

1. 🔧 handleTauriAction 함수 구현 및 적용
2. 🔧 하드코딩된 switch문을 동적 처리로 교체
3. 🔧 Rust 백엔드 파라미터 호환성 검증

### Phase 3: Handler 분리 및 리팩토링

1. 🔧 handleMCPAction, handleIntentAction 등 분리
2. 🔧 handleUIAction을 간소화된 라우터로 변경
3. 🔧 중복 코드 제거 및 의존성 배열 수정

### Phase 4: 검증 및 최적화

1. 🔧 새 Tauri 명령어 추가 시나리오 테스트
2. 🔧 성능 최적화 및 에러 처리 강화
3. 🔧 코드 복잡도 및 유지보수성 검증

이 리팩토링을 통해 MessageRenderer는 확장 가능하고 유지보수하기 쉬운 견고한 구조로 개선될 것이다.
