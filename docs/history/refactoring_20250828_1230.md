# Refactoring Plan: System Prompt Management Modularization

## 작업의 목적

시스템 프롬프트 관리를 ChatContext에서 분리하여 독립적인 SystemPromptProvider로 모듈화하고, 각 서비스(Built-in, MCP)가 자신의 컨텍스트를 독립적으로 제공할 수 있도록 하여 코드의 유연성과 유지보수성을 향상시킵니다.

## 현재의 상태 / 문제점

- 시스템 프롬프트 관리가 ChatContext에 집중되어 있어 관심사 분리가 부족
- registerSystemPrompt, unregisterSystemPrompt, buildSystemPrompt 등의 기능이 ChatContext에 혼재
- 프롬프트 컴포넌트들(BuiltInToolsSystemPrompt, TimeLocationSystemPrompt, JailbreakSystemPrompt)이 ChatContext에 직접 의존
- 도구 관련 프롬프트가 별도 컴포넌트로 분리되어 있어 각 서비스가 자신의 컨텍스트를 유연하게 제공하기 어려움
- MCP 서버들이 서비스별 컨텍스트를 제공하는 표준화된 방법이 없음

## 변경 이후의 상태 / 해결 판정 기준

- SystemPromptProvider가 시스템 프롬프트를 독립적으로 관리
- ChatContext에서 시스템 프롬프트 관련 기능이 완전히 제거되고 SystemPromptProvider를 사용
- 모든 프롬프트 컴포넌트들이 SystemPromptProvider로 마이그레이션 완료
- 각 서비스(Built-in, WebMCP, RustMCP)가 getServiceContext() 메서드를 통해 자신의 컨텍스트를 제공
- 시스템 프롬프트가 모듈화되어 새로운 프롬프트 타입 추가가 용이
- 해결 판정 기준:
  - pnpm lint, pnpm format, pnpm build가 성공적으로 실행됨
  - 모든 프롬프트 컴포넌트가 SystemPromptProvider를 사용하도록 변경됨
  - 각 MCP 서버와 Built-in 서비스에 getServiceContext()가 구현됨
  - AI 모델이 시스템 프롬프트를 정상적으로 받아서 올바른 응답을 생성함

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. SystemPromptProvider 생성 (src/context/SystemPromptContext.tsx)

```typescript
import React, {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
} from 'react';
import { createId } from '@paralleldrive/cuid2';
import { getLogger } from '@/lib/logger';

const logger = getLogger('SystemPromptProvider');

type SystemPrompt = string | (() => string) | (() => Promise<string>);

interface SystemPromptExtension {
  id: string;
  key: string;
  content: SystemPrompt;
  priority: number;
}

interface SystemPromptContextType {
  // register returns a generated id; unregister removes by that id (Option A)
  register(key: string, prompt: SystemPrompt, priority?: number): string;
  unregister(id: string): void;
  getSystemPrompt(): Promise<string>;
}

const SystemPromptContext = createContext<SystemPromptContextType | null>(null);

interface SystemPromptProviderProps {
  children: React.ReactNode;
}

export function SystemPromptProvider({ children }: SystemPromptProviderProps) {
  const [extensions, setExtensions] = useState<SystemPromptExtension[]>([]);

  const register = useCallback(
    (key: string, prompt: SystemPrompt, priority: number = 0): string => {
      const id = createId();
      const extension: SystemPromptExtension = {
        id,
        key,
        content: prompt,
        priority,
      };

      setExtensions((prev) => {
        // Remove existing extension with same key
        const filtered = prev.filter((ext) => ext.key !== key);
        const updated = [...filtered, extension];
        // Sort by priority (higher priority first)
        return updated.sort((a, b) => b.priority - a.priority);
      });

      logger.debug('Registered system prompt extension', {
        id,
        key,
        priority,
      });
      return id;
    },
    [],
  );

  const unregister = useCallback((id: string) => {
    setExtensions((prev) => prev.filter((ext) => ext.id !== id));
    logger.debug('Unregistered system prompt extension', { id });
  }, []);

  const getSystemPrompt = useCallback(async (): Promise<string> => {
    const prompts: string[] = [];

    for (const extension of extensions) {
      try {
        let content: string;
        if (typeof extension.content === 'function') {
          content = await extension.content();
        } else {
          content = extension.content;
        }

        if (content && content.trim()) {
          prompts.push(content);
        }
      } catch (error) {
        logger.error('Failed to resolve system prompt extension', {
          key: extension.key,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    return prompts.join('\n\n');
  }, [extensions]);

  const contextValue = useMemo(
    () => ({
      register,
      unregister,
      getSystemPrompt,
    }),
    [register, unregister, getSystemPrompt],
  );

  return (
    <SystemPromptContext.Provider value={contextValue}>
      {children}
    </SystemPromptContext.Provider>
  );
}

export function useSystemPrompt() {
  const context = useContext(SystemPromptContext);
  if (!context) {
    throw new Error('useSystemPrompt must be used within SystemPromptProvider');
  }
  return context;
}
```

### 2. ChatContext.tsx 수정 - 시스템 프롬프트 기능 제거

```typescript
// ...existing code...

// 제거할 인터페이스와 함수들:
interface SystemPromptExtension {
  id: string;
  content: string | (() => Promise<string>);
  priority: number; // Higher number = higher priority
}

// 제거할 상태:
const [systemPromptExtensions, setSystemPromptExtensions] = useState<SystemPromptExtension[]>([]);

// 제거할 함수들:
const registerSystemPrompt = useCallback(...)
const unregisterSystemPrompt = useCallback(...)
const buildSystemPrompt = useCallback(async (): Promise<string> => ...)

// ChatContextValue에서 제거:
interface ChatContextValue {
  // registerSystemPrompt 제거
  // unregisterSystemPrompt 제거
}

// submit 함수 수정 - SystemPromptProvider 사용
const submit = useCallback(async (messageToAdd?: Message[], agentKey?: string): Promise<Message> => {
  // ...existing code...

  // 시스템 프롬프트 가져오기
  const { getSystemPrompt } = useSystemPrompt();  // 추가
  const systemPrompt = await getSystemPrompt();  // 변경

  // ...existing code...
}, [/* dependencies에 getSystemPrompt 추가 */]);

// ...existing code...
```

### 3. BuiltInService 인터페이스 확장 (src/features/tools/index.tsx)

```typescript
export interface BuiltInService {
  listTools: () => MCPTool[];
  executeTool: (toolCall: ToolCall) => Promise<MCPResponse>;
  loadService?: () => Promise<void>;
  unloadService?: () => Promise<void>;
  getServiceContext?: () => Promise<string>;  // 추가
}
```

### 4. BuiltInToolProvider 수정 (src/features/tools/index.tsx)

```typescript
// ...existing code...

interface BuiltInToolContextType {
  register: (serviceId: string, service: BuiltInService) => void;
  unregister: (serviceId: string) => void;
  availableTools: MCPTool[];
  executeTool: (toolCall: ToolCall) => Promise<MCPResponse>;
  buildToolPrompt: () => Promise<string>;  // 이름 변경 고려
  status: Record<string, ServiceStatus>;
}

// ...existing code...

export function BuiltInToolProvider({ children }: BuiltInToolProviderProps) {
  // ...existing code...

  // buildToolPrompt → buildServiceContext로 이름 변경 고려
  const buildToolPrompt = useCallback(async (): Promise<string> => {
    const prompts: string[] = [];
    for (const [serviceId, entry] of serviceEntries.entries()) {
      if (entry.status === 'ready' && entry.service.getServiceContext) {
        try {
          const prompt = await entry.service.getServiceContext();
          if (prompt) {
            prompts.push(prompt);
          }
        } catch (err) {
          logger.error('Failed to get service context from service', { serviceId, err });
        }
      }
    }
    return prompts.join('\n\n');
  }, [serviceEntries]);

  // ...existing code...
}
```

### 5. 프롬프트 컴포넌트들 마이그레이션 예시 (src/features/prompts/BuiltInToolsSystemPrompt.tsx)

```typescript
// ...existing code...

export function BuiltInToolsSystemPrompt() {
  const { register, unregister } = useSystemPrompt();  // 변경: register returns id, unregister expects id
  const { server } = useWebMCPServer<ContentStoreServer>('content-store');
  const { getCurrentSession } = useSessionContext();
  const { availableTools } = useBuiltInTool();

  // ...existing code...

  useEffect(() => {
    const id = register('builtin-tools', buildPrompt, 1);  // register returns id
    return () => {
      unregister(id); // unregister by id
    };
  }, [buildPrompt, register, unregister]);

  // ...existing code...
}
```

### 6. WebMCPProxy 확장 (src/lib/web-mcp/mcp-proxy.ts)

```typescript
export class WebMCPProxy {
  // ...existing code...

  async getServiceContext(): Promise<string> {
    // 각 MCP 서버의 컨텍스트 정보 반환
    // 예: 사용 가능한 도구 목록, 서버 상태 등
    return `# MCP Server Context
Server: ${this.config.serverName || 'Unknown'}
Status: Connected
Available Tools: ${this.tools?.length || 0} tools
`;
  }
}
```

### 7. ContentStoreServer 확장 (src/lib/web-mcp/modules/content-store.ts)

```typescript
export class ContentStoreServer implements WebMCPServer {
  // ...existing code...

  async getServiceContext(): Promise<string> {
    // 첨부 파일 관련 컨텍스트 정보 반환
    const currentSession = getCurrentSession();
    if (!currentSession?.storeId) {
      return '# Attached Files\nNo files currently attached.';
    }

    try {
      const result = await this.listContent({ storeId: currentSession.storeId });
      if (!result?.contents || result.contents.length === 0) {
        return '# Attached Files\nNo files currently attached.';
      }

      const attachedResources = result.contents
        .map((c) => JSON.stringify({
          storeId: c.storeId,
          contentId: c.contentId,
          preview: c.preview,
          filename: c.filename,
          type: c.mimeType,
          size: c.size,
        }))
        .join('\n');

      return `# Attached Files\n${attachedResources}`;
    } catch (error) {
      logger.error('Failed to build attached files context', { error });
      return '# Attached Files\nError loading attached files.';
    }
  }
}
```

### 8. Rust 백엔드 확장 (src-tauri/src/mcp/)

```rust
// Rust 코드 예시
#[tauri::command]
pub async fn get_service_context(server_id: String) -> Result<String, String> {
    // MCP 서버의 컨텍스트 정보 반환
    // 각 서버 타입에 따라 적절한 컨텍스트 제공
    Ok(format!("# MCP Server Context\nServer ID: {}\nStatus: Active", server_id))
}
```

## 추가 고려사항

- **호환성**: 기존 API를 완전히 제거하므로 모든 사용처를 동시에 마이그레이션
- **에러 처리**: 각 서비스의 getServiceContext 실패 시 적절한 폴백 제공
- **성능**: 컨텍스트 생성이 빈번하지 않도록 캐싱 고려
- **테스트**: 변경 후 AI 응답 품질 검증 및 모든 컴포넌트 정상 동작 확인
