# Chat UI/UX 개선: Width Overflow 및 Rich Display 리팩토링 계획

## 📅 작성 일시

2025년 11월 1일 13:25

## 🎯 작업의 목적

Chat UI의 사용자 경험을 개선하기 위해 다음을 달성:

1. Agent 응답에서 width overflow 발생 시 적절한 스크롤 제공
2. Agent 메시지를 Rich하게 표시 (ChatGPT 스타일의 전체 너비 활용)
3. 코드 블록에 Syntax Highlighting 추가
4. Streaming 중 더 나은 Loading UI 제공
5. User 메시지는 간결한 버블, Agent는 Embedded 형태로 차별화

**핵심 목표**: idea.md의 요구사항을 충족하면서 overflow 문제를 해결하고 가독성을 향상

## 🔍 현재의 상태 / 문제점

### 1. Width Overflow 문제

- **ReactMarkdown 컴포넌트**: `pre`, `code` 태그에 overflow 처리 스타일이 없음
  - 긴 코드 라인이 버블 밖으로 넘침
  - 수평 스크롤 없음
  - `MessageRenderer.tsx` lines 402-418
- **전역 CSS**: `globals.css`에 markdown 관련 스타일 정의 없음

### 2. 메시지 레이아웃 제약

- **모든 메시지 역할에 동일한 너비 제한** (`MessageBubble.tsx` line 74)

  ```tsx
  max-w-[85%] lg:max-w-4xl
  ```

  - User 메시지도, Agent 메시지도 동일한 제약
  - idea.md 요구사항: Agent는 전체 너비 활용 필요

### 3. Syntax Highlighting 부재

- 현재 ReactMarkdown만 사용, syntax highlighting 없음
- 코드 블록이 단순 텍스트로 표시되어 가독성 저하

### 4. 단조로운 Loading UI

- `ChatMessages.tsx` lines 86-95: 단순 "thinking..." 텍스트
- 애니메이션이나 동적 효과 없음

## 🏗️ 관련 코드 구조 및 동작 방식 (Bird's Eye View)

### 컴포넌트 계층 구조

```text
Chat (Provider)
└─ ChatMessages (스크롤 컨테이너: overflow-y-auto)
    └─ MessageBubble (max-w-[85%] 제약)
        ├─ Header (아바타, 역할, 타임스탬프)
        ├─ Attachments (파일 목록)
        ├─ Thinking (스트리밍 상태)
        └─ MessageBubbleRouter
            ├─ ContentBubble → MessageRenderer
            │   └─ ReactMarkdown (텍스트)
            │       ├─ p, code, pre (스타일 없음)
            │       └─ ...
            │   └─ UIResourceRenderer (리소스)
            ├─ ToolCallBubble (BaseBubble)
            └─ ToolOutputBubble (BaseBubble)
```

### 데이터 플로우

1. `ChatContext` → `ChatMessages` → messages 배열
2. 각 message → `MessageBubble` (역할별 스타일 결정)
3. message.content (MCPContent[]) → `MessageRenderer`
4. Text content → `ReactMarkdown` 렌더링
5. Resource content → `UIResourceRenderer`

### Width 제한 지점

1. **MessageBubble**: `max-w-[85%] lg:max-w-4xl` (모든 역할 공통)
2. **BaseBubble**: `max-h-96 overflow-auto` (수직 스크롤만)
3. **ReactMarkdown**: 스타일 없음 (overflow 처리 안됨)

## ✨ 변경 이후의 상태 / 해결 판정 기준

### 성공 기준

1. ✅ 긴 코드 블록이 수평 스크롤로 처리됨 (버블 밖으로 나가지 않음)
2. ✅ Agent 메시지가 전체 너비 활용 (User는 기존 버블 유지)
3. ✅ 코드 블록에 syntax highlighting 적용
4. ✅ Loading UI가 애니메이션 효과와 함께 표시
5. ✅ 긴 텍스트 라인이 자동 줄바꿈됨
6. ✅ 기존 UI Resource (remoteDom, rawHtml) 정상 작동

### 테스트 시나리오

- [ ] 100자 이상의 긴 코드 라인 입력 시 수평 스크롤 확인
- [ ] Agent 메시지가 채팅 창 전체 너비 사용 확인
- [ ] User 메시지가 여전히 버블 형태 유지 확인
- [ ] Python, JavaScript, TypeScript 코드 블록 syntax highlighting 확인
- [ ] Streaming 중 로딩 애니메이션 표시 확인
- [ ] Tool Output의 UI Resource 정상 표시 확인

## 🔧 수정이 필요한 코드 및 코드 스니핏

### 1. MessageRenderer.tsx - Code Block Overflow 처리

**파일**: `src/components/MessageRenderer.tsx`
**위치**: lines 402-418

**현재 코드**:

```tsx
<ReactMarkdown
  skipHtml={false}
  remarkPlugins={[]}
  rehypePlugins={[]}
  components={{
    p: ({ children, ...props }) => <p {...props}>{children}</p>,
    code: ({ children, className }) => (
      <code className={className}>{children}</code>
    ),
    pre: ({ children, ...props }) => <pre {...props}>{children}</pre>,
  }}
>
  {textItem.text}
</ReactMarkdown>
```

**수정 후 코드**:

```tsx
<ReactMarkdown
  skipHtml={false}
  remarkPlugins={[]}
  rehypePlugins={[]}
  components={{
    p: ({ children, ...props }) => (
      <p className="mb-2 last:mb-0" {...props}>
        {children}
      </p>
    ),
    code: ({ inline, children, className, ...props }) => {
      // inline code vs block code 구분
      if (inline) {
        return (
          <code
            className="px-1.5 py-0.5 bg-muted rounded text-sm font-mono border border-border"
            {...props}
          >
            {children}
          </code>
        );
      }
      // block code (pre > code 구조에서 사용됨)
      return (
        <code className={`${className} block font-mono text-sm`} {...props}>
          {children}
        </code>
      );
    },
    pre: ({ children, ...props }) => (
      <pre
        className="overflow-x-auto bg-muted rounded-lg p-4 my-3 border border-border max-w-full"
        {...props}
      >
        {children}
      </pre>
    ),
    // 추가: 기타 마크다운 요소
    h1: ({ children, ...props }) => (
      <h1 className="text-2xl font-bold mb-3 mt-4" {...props}>
        {children}
      </h1>
    ),
    h2: ({ children, ...props }) => (
      <h2 className="text-xl font-bold mb-2 mt-3" {...props}>
        {children}
      </h2>
    ),
    h3: ({ children, ...props }) => (
      <h3 className="text-lg font-semibold mb-2 mt-2" {...props}>
        {children}
      </h3>
    ),
    ul: ({ children, ...props }) => (
      <ul className="list-disc list-inside mb-2 space-y-1" {...props}>
        {children}
      </ul>
    ),
    ol: ({ children, ...props }) => (
      <ol className="list-decimal list-inside mb-2 space-y-1" {...props}>
        {children}
      </ol>
    ),
    li: ({ children, ...props }) => (
      <li className="ml-2" {...props}>
        {children}
      </li>
    ),
    blockquote: ({ children, ...props }) => (
      <blockquote
        className="border-l-4 border-primary pl-4 italic my-2 text-muted-foreground"
        {...props}
      >
        {children}
      </blockquote>
    ),
    a: ({ children, href, ...props }) => (
      <a
        href={href}
        className="text-primary hover:underline"
        target="_blank"
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    ),
  }}
>
  {textItem.text}
</ReactMarkdown>
```

**외부 컨테이너에도 overflow 보호 추가** (line 385):

```tsx
<div key={key} className="group relative text-sm leading-relaxed overflow-x-hidden break-words">
```

### 2. MessageBubble.tsx - 역할별 차별화된 레이아웃

**파일**: `src/features/chat/MessageBubble.tsx`
**위치**: lines 24-73

**수정 전략**:

- User 메시지: 기존 버블 스타일 유지 (`max-w-[85%]`)
- Agent/Tool 메시지: 전체 너비 활용, 버블 스타일 최소화

**현재 코드** (line 74):

```tsx
<div
  className={`flex ${styles.container} mb-8 mt-3 animate-in fade-in slide-in-from-bottom-4 duration-500`}
>
  <div
    className={`max-w-[85%] lg:max-w-4xl ${styles.bubble} rounded-2xl px-5 py-4 backdrop-blur-sm transition-all duration-200 hover:shadow-xl`}
  >
```

**수정 후 코드**:

```tsx
<div
  className={`flex ${styles.container} mb-8 mt-3 animate-in fade-in slide-in-from-bottom-4 duration-500`}
>
  <div
    className={`${getBubbleContainerStyles()} ${styles.bubble} ${getBubblePaddingStyles()} backdrop-blur-sm transition-all duration-200 hover:shadow-xl`}
  >
```

**추가 함수**:

```tsx
const getBubbleContainerStyles = () => {
  if (isUser) {
    // User: 간결한 버블
    return 'max-w-[85%] lg:max-w-4xl rounded-2xl';
  } else if (isAssistant) {
    // Agent: 전체 너비, 최소 버블 스타일
    return 'w-full max-w-full rounded-lg border-l-4';
  } else {
    // Tool: 중간 크기
    return 'max-w-[90%] lg:max-w-5xl rounded-lg';
  }
};

const getBubblePaddingStyles = () => {
  if (isUser) {
    return 'px-5 py-4';
  } else if (isAssistant) {
    return 'px-6 py-5'; // Agent는 더 넓은 패딩
  } else {
    return 'px-4 py-3';
  }
};
```

### 3. ChatMessages.tsx - Loading UI 개선

**파일**: `src/features/chat/components/ChatMessages.tsx`
**위치**: lines 86-95

**현재 코드**:

```tsx
{
  isLoading && (
    <div className="flex justify-start">
      <div className="rounded px-3 py-2">
        <div className="text-xs mb-1">
          Agent ({currentSession?.assistants[0]?.name})
        </div>
        <div className="text-sm">thinking...</div>
      </div>
    </div>
  );
}
```

**수정 후 코드**:

```tsx
{
  isLoading && (
    <div className="flex justify-start mb-8 mt-3">
      <div className="w-full max-w-full bg-secondary/30 border-l-4 border-primary rounded-lg px-6 py-5">
        <div className="flex items-center gap-3 mb-2">
          <div className="w-7 h-7 bg-primary rounded-full flex items-center justify-center animate-pulse">
            <Bot size={16} className="text-primary-foreground" />
          </div>
          <span className="text-xs font-medium">
            Agent ({currentSession?.assistants[0]?.name})
          </span>
        </div>
        <div className="flex items-center gap-2 text-sm text-muted-foreground">
          <div className="flex gap-1">
            <span className="animate-bounce" style={{ animationDelay: '0ms' }}>
              ●
            </span>
            <span
              className="animate-bounce"
              style={{ animationDelay: '150ms' }}
            >
              ●
            </span>
            <span
              className="animate-bounce"
              style={{ animationDelay: '300ms' }}
            >
              ●
            </span>
          </div>
          <span className="animate-pulse">Thinking and analyzing...</span>
        </div>
      </div>
    </div>
  );
}
```

### 4. Syntax Highlighting 추가 (Optional Enhancement)

**새 의존성 추가**:

```bash
pnpm add react-syntax-highlighter @types/react-syntax-highlighter
```

**MessageRenderer.tsx에 통합**:

```tsx
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark, oneLight } from 'react-syntax-highlighter/dist/esm/styles/prism';

// 테마 감지
const isDark = typeof window !== 'undefined' &&
  window.matchMedia('(prefers-color-scheme: dark)').matches;

// ReactMarkdown components 수정
code: ({ inline, children, className, ...props }) => {
  if (inline) {
    return (
      <code className="px-1.5 py-0.5 bg-muted rounded text-sm font-mono border border-border">
        {children}
      </code>
    );
  }

  // language 추출 (예: language-python)
  const match = /language-(\w+)/.exec(className || '');
  const language = match ? match[1] : 'text';

  return (
    <SyntaxHighlighter
      style={isDark ? oneDark : oneLight}
      language={language}
      PreTag="div"
      className="rounded-lg my-3 text-sm"
      customStyle={{
        margin: 0,
        borderRadius: '0.5rem',
        maxWidth: '100%',
      }}
      codeTagProps={{
        className: 'text-sm',
      }}
    >
      {String(children).replace(/\n$/, '')}
    </SyntaxHighlighter>
  );
},
pre: ({ children }) => <>{children}</>, // SyntaxHighlighter가 wrapper 제공
```

## 🔗 재사용 가능한 연관 코드

### 1. BaseBubble 컴포넌트

**파일**: `src/components/ui/BaseBubble.tsx`

- **주요 기능**: Collapsible 버블 UI (Tool Call/Output에 사용)
- **인터페이스**:
  ```tsx
  interface BaseBubbleProps {
    title: string;
    icon?: React.ReactNode;
    badge?: React.ReactNode;
    defaultExpanded?: boolean;
    copyData?: string;
    collapsedSummary?: React.ReactNode;
    children: React.ReactNode;
    className?: string;
  }
  ```
- **재사용 가능**: Tool 관련 메시지에 이미 적용됨, 변경 불필요

### 2. UIResourceRenderer

**파일**: `@mcp-ui/client` (외부 라이브러리)

- **주요 기능**: MCP UI Resource 렌더링 (remoteDom, rawHtml, externalUrl)
- **사용 위치**: `MessageRenderer.tsx` lines 436-467
- **주의사항**: 이 부분은 수정하지 않고 유지

### 3. useClipboard Hook

**파일**: `src/hooks/useClipboard.ts`

- **주요 기능**: 클립보드 복사 기능
- **재사용**: Copy 버튼 구현에 이미 사용 중

### 4. 테마 감지 로직

**현재 위치**: `MessageBubble.tsx` lines 20-22

```tsx
const isDark =
  typeof window !== 'undefined' &&
  window.matchMedia('(prefers-color-scheme: dark)').matches;
```

- **재사용 가능**: Syntax highlighting 테마 선택에 활용

## 🧪 Test Code 추가 및 수정 가이드

### 단위 테스트

#### 1. MessageRenderer 테스트

**파일**: `src/components/__tests__/MessageRenderer.test.tsx` (신규 생성)

````tsx
import { render, screen } from '@testing-library/react';
import { MessageRenderer } from '../MessageRenderer';
import type { MCPContent } from '@/lib/mcp-types';

describe('MessageRenderer', () => {
  it('renders code blocks with overflow scroll', () => {
    const content: MCPContent[] = [
      {
        type: 'text',
        text: '```python\nprint("very long line that should trigger horizontal scroll" * 10)\n```',
      },
    ];

    const { container } = render(<MessageRenderer content={content} />);
    const preElement = container.querySelector('pre');

    expect(preElement).toHaveClass('overflow-x-auto');
    expect(preElement).toHaveClass('max-w-full');
  });

  it('renders inline code with proper styling', () => {
    const content: MCPContent[] = [
      { type: 'text', text: 'This is `inline code` test' },
    ];

    render(<MessageRenderer content={content} />);
    const codeElement = screen.getByText('inline code');

    expect(codeElement.tagName).toBe('CODE');
    expect(codeElement).toHaveClass('bg-muted');
  });

  it('renders long text with word break', () => {
    const longText = 'verylongtextwithoutspaces'.repeat(20);
    const content: MCPContent[] = [{ type: 'text', text: longText }];

    const { container } = render(<MessageRenderer content={content} />);
    const wrapper = container.firstChild as HTMLElement;

    expect(wrapper).toHaveClass('break-words');
  });
});
````

#### 2. MessageBubble 레이아웃 테스트

**파일**: `src/features/chat/__tests__/MessageBubble.test.tsx` (신규 생성)

```tsx
import { render } from '@testing-library/react';
import MessageBubble from '../MessageBubble';
import type { Message } from '@/models/chat';

describe('MessageBubble Layout', () => {
  it('applies compact bubble style for user messages', () => {
    const userMessage: Message = {
      id: '1',
      role: 'user',
      content: [{ type: 'text', text: 'Hello' }],
      createdAt: new Date(),
    };

    const { container } = render(<MessageBubble message={userMessage} />);

    const bubble = container.querySelector('[class*="max-w-[85%]"]');
    expect(bubble).toBeInTheDocument();
    expect(bubble).toHaveClass('rounded-2xl');
  });

  it('applies full-width style for assistant messages', () => {
    const assistantMessage: Message = {
      id: '2',
      role: 'assistant',
      content: [{ type: 'text', text: 'Response' }],
      createdAt: new Date(),
    };

    const { container } = render(<MessageBubble message={assistantMessage} />);

    const bubble = container.querySelector('[class*="w-full"]');
    expect(bubble).toBeInTheDocument();
    expect(bubble).toHaveClass('border-l-4');
  });
});
```

### 통합 테스트

#### ChatMessages 통합 테스트

**파일**: `src/features/chat/__tests__/ChatMessages.integration.test.tsx`

```tsx
describe('ChatMessages Integration', () => {
  it('renders loading state with animation', () => {
    // Mock isLoading = true
    render(<ChatMessages />);

    const loadingElement = screen.getByText(/Thinking and analyzing/i);
    expect(loadingElement).toBeInTheDocument();
    expect(loadingElement).toHaveClass('animate-pulse');

    const dots = screen.getAllByText('●');
    expect(dots).toHaveLength(3);
  });

  it('scrolls to bottom on new message', async () => {
    const { rerender } = render(<ChatMessages />);

    // Add new message and verify scroll behavior
    // (구현 세부사항은 실제 테스트 환경에 맞게 조정)
  });
});
```

### E2E 테스트 시나리오 (Manual Testing Checklist)

```markdown
## Chat UI Overflow & Layout Testing

### Code Block Overflow

- [ ] 긴 Python 코드 입력 시 수평 스크롤 생성 확인
- [ ] 긴 JavaScript 코드 입력 시 수평 스크롤 생성 확인
- [ ] Inline code가 줄바꿈 없이 표시되는지 확인
- [ ] 코드 블록이 버블 밖으로 넘치지 않는지 확인

### Layout Differentiation

- [ ] User 메시지가 오른쪽 정렬, 최대 85% 너비 확인
- [ ] Agent 메시지가 왼쪽 정렬, 전체 너비 사용 확인
- [ ] Tool Output이 중간 크기 버블로 표시되는지 확인

### Loading State

- [ ] Streaming 시작 시 애니메이션 로딩 표시 확인
- [ ] "●●●" 점 애니메이션 작동 확인
- [ ] Avatar 아이콘 pulse 효과 확인

### Markdown Rendering

- [ ] 헤딩(h1, h2, h3) 스타일 적용 확인
- [ ] 리스트(ul, ol) 들여쓰기 확인
- [ ] 인용구(blockquote) 왼쪽 테두리 확인
- [ ] 링크가 새 탭에서 열리는지 확인

### Syntax Highlighting (Optional)

- [ ] Python 코드 syntax highlighting 확인
- [ ] JavaScript/TypeScript 코드 컬러링 확인
- [ ] 다크/라이트 모드에서 테마 전환 확인
```

## 📋 작업 순서 제안

### Phase 1: Critical Overflow 수정 (우선순위: 높음)

1. MessageRenderer.tsx의 ReactMarkdown components 스타일 추가
2. 외부 컨테이너에 `overflow-x-hidden`, `break-words` 추가
3. 수동 테스트: 긴 코드 입력 후 overflow 확인

### Phase 2: 레이아웃 차별화 (우선순위: 높음)

4. MessageBubble.tsx에 역할별 스타일 함수 추가
5. User/Agent/Tool 메시지 렌더링 후 레이아웃 확인
6. 반응형 동작 테스트 (모바일, 태블릿, 데스크톱)

### Phase 3: Loading UI 개선 (우선순위: 중간)

7. ChatMessages.tsx의 loading 상태 UI 교체
8. 애니메이션 효과 확인
9. 여러 에이전트 이름으로 테스트

### Phase 4: Syntax Highlighting (우선순위: 낮음, Optional)

10. react-syntax-highlighter 의존성 추가
11. MessageRenderer에 SyntaxHighlighter 통합
12. 주요 언어(Python, JS, TS, Java, Rust) 테스트
13. 다크/라이트 모드 테마 전환 확인

### Phase 5: 테스트 및 검증

14. 단위 테스트 작성 및 실행
15. 통합 테스트 작성
16. E2E 수동 테스트 체크리스트 완료
17. `pnpm refactor:validate` 실행

## ⚠️ 주의 사항

### Breaking Changes 방지

- `MessageRenderer`의 기존 props interface 유지
- `MessageBubble`의 외부 API 변경 없음
- `BaseBubble`, `UIResourceRenderer` 등 재사용 컴포넌트는 수정하지 않음

### 성능 고려사항

- ReactMarkdown components를 함수 컴포넌트로 정의하되, 가능한 React.memo 사용
- Syntax Highlighting은 Optional로 두고, 성능 저하 시 토글 기능 추가 고려
- 긴 메시지 렌더링 시 virtual scrolling 고려 (추후 개선)

### 접근성 (Accessibility)

- 코드 블록에 적절한 `aria-label` 추가
- 스크롤 가능한 영역에 키보드 네비게이션 지원
- 로딩 상태 애니메이션이 `prefers-reduced-motion` 존중

### 호환성

- Tauri 환경에서 window.matchMedia 사용 확인
- 외부 라이브러리(react-syntax-highlighter)의 번들 크기 확인
- 다크/라이트 모드 전환 시 깜빡임 없는지 확인

## 📊 추가 분석 과제

작업자가 구현 중 추가로 확인해야 할 사항들:

### 1. Markdown 렌더링 최적화

- **질문**: 매우 긴 메시지(수천 줄 코드)에서 ReactMarkdown 성능은?
- **분석 방향**:
  - 필요시 lazy loading이나 virtualization 고려
  - `react-window`나 `react-virtualized` 사용 검토

### 2. 스트리밍 중 레이아웃 Shift

- **질문**: Agent 메시지가 streaming되는 동안 레이아웃이 튀지 않는가?
- **분석 방향**:
  - `message.isStreaming` 상태에서 스타일 일관성 확인
  - 필요시 최소 높이(min-height) 설정

### 3. 모바일 반응형 동작

- **질문**: 작은 화면에서 전체 너비 Agent 메시지가 적절한가?
- **분석 방향**:
  - 768px 이하에서 패딩 조정 필요성 검토
  - 모바일에서 수평 스크롤 제스처 테스트

### 4. Tool Output의 UI Resource

- **질문**: ToolOutputBubble에서 `expandResources={true}` 전달 시 문제 없는가?
- **분석 방향**:
  - `ToolOutputBubble.tsx` line 26의 `expandResources` prop 동작 확인
  - Resource가 매우 클 때 스크롤 동작 검증

### 5. Copy 버튼 위치 조정

- **질문**: 전체 너비 Agent 메시지에서 Copy 버튼이 적절한 위치에 있는가?
- **분석 방향**:
  - `MessageRenderer.tsx` line 389의 Copy 버튼이 잘 보이는지 확인
  - 필요시 sticky position 고려

## 🎯 Clarification Q-list

구현 전 사용자의 의사 결정이 필요한 사항들:

### Q1: Syntax Highlighting 라이브러리 선택

**질문**: `react-syntax-highlighter`를 사용할 것인가, 아니면 더 가벼운 대안을 사용할 것인가?

- **옵션 A**: `react-syntax-highlighter` (풍부한 기능, 번들 크기 큼)
- **옵션 B**: `prism-react-renderer` (가벼움, 제한적 언어 지원)
- **옵션 C**: Syntax highlighting 제외하고 단순 스타일만 (Phase 4 생략)

**권장**: 옵션 A (react-syntax-highlighter) - 가장 많이 사용되고 안정적

### Q2: Agent 메시지 레이아웃 스타일

**질문**: Agent 메시지에 버블 스타일을 완전히 제거할 것인가, 최소한으로 유지할 것인가?

- **옵션 A**: 완전 제거 (ChatGPT 스타일, 평평한 레이아웃)
- **옵션 B**: 최소 유지 (border-l-4, 약간의 배경색)
- **옵션 C**: 현재처럼 버블 유지, 너비만 확장

**권장**: 옵션 B - 구분을 위한 최소한의 시각적 요소 유지

### Q3: Loading UI 애니메이션 강도

**질문**: "Thinking..." 로딩 애니메이션을 얼마나 동적으로 만들 것인가?

- **옵션 A**: 단순 점 애니메이션 (제안된 코드)
- **옵션 B**: 단계별 메시지 변경 ("Thinking..." → "Analyzing..." → "Generating...")
- **옵션 C**: Progress bar 추가

**권장**: 옵션 A로 시작, 사용자 피드백 후 옵션 B 고려

### Q4: 모바일에서 Agent 메시지 너비

**질문**: 모바일 화면(< 768px)에서도 Agent 메시지가 전체 너비를 사용해야 하는가?

- **옵션 A**: 모든 화면 크기에서 전체 너비
- **옵션 B**: 모바일에서는 User처럼 제한된 너비 (max-w-[95%])

**권장**: 옵션 A - 일관성 유지, 단 패딩 조정

### Q5: 테스트 범위

**질문**: 어느 수준까지 테스트를 작성할 것인가?

- **옵션 A**: 단위 테스트만 (Phase 5의 일부)
- **옵션 B**: 단위 + 통합 테스트
- **옵션 C**: 단위 + 통합 + E2E 자동화

**권장**: 옵션 B - 핵심 기능에 대한 단위/통합 테스트, E2E는 수동

---

**다음 단계**: 위 Clarification Q-list에 대한 결정 후 Phase 1부터 순차 진행
