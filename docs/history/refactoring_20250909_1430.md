# ExtractContentTool 경량화 리팩토링 계획

## 작업의 목적

AI Agent가 브라우저 자동화 도구(ClickElementTool, InputTextTool 등)를 효과적으로 사용할 수 있도록 CSS selector 탐색에 필요한 최소한의 DOM 구조 정보만 추출하는 경량화된 모드를 추가한다. 기존의 전체 HTML 추출 방식은 크기가 커서 AI Agent의 컨텍스트 처리에 부담을 주므로, selector 식별에 필요한 핵심 정보만 포함하는 DOM 맵을 제공한다.

## 현재의 상태 / 문제점

### 현재 ExtractContentTool의 동작

- **Markdown 모드**: TurndownService로 HTML→Markdown 변환, 텍스트 중심 콘텐츠 추출
- **JSON 모드**: DOM 구조를 재귀적으로 탐색하여 구조화된 데이터 생성
- **Raw HTML 저장**: 전체 HTML을 파일로 저장하는 옵션 제공

### 문제점

1. **AI Agent의 selector 사용 어려움**: Markdown은 HTML 구조를 제거하여 CSS selector 탐색 불가
2. **전체 HTML의 크기 부담**: Raw HTML은 스크립트, 스타일, 광고 등 불필요한 요소로 인해 크기가 커짐 (수십KB~수MB)
3. **컨텍스트 오버헤드**: AI Agent가 처리하기에는 너무 많은 정보가 포함되어 효율성 저하
4. **selector 타겟팅 정확도 저하**: 복잡한 DOM에서 핵심 요소를 찾기 어려움

### 사용 시나리오 분석

- AI Agent가 페이지를 분석한 후 → ClickElementTool로 버튼 클릭
- AI Agent가 폼을 이해한 후 → InputTextTool로 텍스트 입력
- 이때 필요한 정보: 태그명, ID, 클래스, 기본 텍스트, 계층 구조

## 추가 분석 과제

1. **최적 정보 밀도 분석**: selector 식별에 필요한 최소 정보 세트 정의
   - 어떤 속성들이 selector 작성에 필수적인가? (id, class, tagName, text?)
   - 몇 단계의 DOM 깊이가 적절한가?
2. **크기 최적화 효과 측정**: 기존 대비 크기 감소율 및 정확도 유지 여부
   - 실제 웹사이트에서 크기 감소 효과 측정
   - selector 탐색 정확도 유지 확인

3. **광고/노이즈 필터링 패턴 조사**: 일반적인 광고/불필요 요소 식별 패턴
   - 클래스명 패턴 (ad*, banner*, popup\* 등)
   - 태그 조합 패턴
   - visibility/display 상태 확인

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **새로운 'dom-map' 모드 추가**: 경량화된 DOM 구조 정보 제공
2. **크기 최적화**: 기존 HTML 대비 70-90% 크기 감소
3. **selector 호환성**: ClickElementTool, InputTextTool과 완벽 연동
4. **AI Agent 친화성**: 구조적이고 읽기 쉬운 출력 형식

### 해결 판정 기준

- [ ] dom-map 모드에서 selector 정보가 정확히 추출됨
- [ ] 크기가 기존 HTML 대비 최소 70% 감소
- [ ] 기존 markdown/json 모드 동작에 영향 없음
- [ ] AI Agent가 추출된 정보로 정확한 selector 작성 가능
- [ ] 테스트 페이지(복잡한 DOM)에서 핵심 요소 누락 없음

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. ExtractContentTool.ts - inputSchema 수정

```typescript
// 현재
format: {
  type: 'string',
  enum: ['markdown', 'json'],
  description: 'Output format (default: markdown)',
},

// 수정 후
format: {
  type: 'string',
  enum: ['markdown', 'json', 'dom-map'],
  description: 'Output format (default: markdown). dom-map provides minimal selector info.',
},
```

### 2. ExtractContentTool.ts - execute 함수 타입 정의 수정

```typescript
// 현재
format?: 'markdown' | 'json';

// 수정 후
format?: 'markdown' | 'json' | 'dom-map';
```

### 3. ExtractContentTool.ts - dom-map 모드 실행 로직 추가

```typescript
// 새로 추가할 코드 (기존 JSON 모드 후)
} else if (format === 'dom-map') {
  // DOM 맵 추출 스크립트 실행
  const domMapScript = `
(function() {
  function createDOMMap(element, depth = 0, maxDepth = 3) {
    if (depth > maxDepth || !element) return null;

    // 불필요한 요소 필터링
    const excludeTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK'];
    const excludeClasses = ['ad', 'banner', 'popup', 'sidebar'];

    if (excludeTags.includes(element.tagName) ||
        excludeClasses.some(cls => element.classList.contains(cls))) {
      return null;
    }

    // 가시성 확인
    const style = window.getComputedStyle(element);
    if (style.display === 'none' || style.visibility === 'hidden') {
      return null;
    }

    const map = {
      tag: element.tagName.toLowerCase(),
      selector: '',
      children: []
    };

    // selector 생성에 필요한 핵심 정보만 포함
    if (element.id) {
      map.id = element.id;
      map.selector = '#' + element.id;
    } else if (element.className) {
      const classes = element.className.trim().split(/\s+/);
      map.class = classes[0]; // 첫 번째 클래스만
      map.selector = '.' + classes[0];
    } else {
      map.selector = element.tagName.toLowerCase();
    }

    // 텍스트 내용 (최대 50자)
    const textContent = element.textContent?.trim().substring(0, 50);
    if (textContent) map.text = textContent;

    // 중요한 속성만 포함
    if (element.type) map.type = element.type;
    if (element.href) map.href = element.href;
    if (element.placeholder) map.placeholder = element.placeholder;

    // 자식 요소 처리 (중요한 것만)
    const importantChildren = Array.from(element.children).filter(child => {
      return ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FORM'].includes(child.tagName) ||
             child.id || child.className;
    });

    for (let child of importantChildren.slice(0, 10)) { // 최대 10개
      const childMap = createDOMMap(child, depth + 1, maxDepth);
      if (childMap) map.children.push(childMap);
    }

    return map;
  }

  const targetElement = document.querySelector('${selector.replace(/'/g, "\\'")}');
  if (!targetElement) return { error: 'Element not found' };

  return {
    url: window.location.href,
    title: document.title,
    domMap: createDOMMap(targetElement)
  };
})()`;

  const domMapResult = await executeScript(sessionId, domMapScript);
  try {
    result = JSON.parse(domMapResult);
    result.format = 'dom-map';
  } catch {
    result = { content: domMapResult, format: 'dom-map' };
  }
} else {
  // 기존 JSON 로직...
```

## 재사용 가능한 연관 코드

### 관련 파일 및 기능

1. **`/src/features/tools/browser-tools/helpers.ts`**
   - `checkElementState()`: 요소 상태 확인 로직
   - `BROWSER_TOOL_SCHEMAS`: 공통 스키마 정의
   - 재사용 가능: DOM 필터링 로직을 helpers로 분리

2. **`/src/features/tools/browser-tools/ClickElementTool.ts`**
   - selector 기반 요소 클릭 로직
   - dom-map과 연동하여 selector 정확성 향상

3. **`/src/features/tools/browser-tools/InputTextTool.ts`**
   - selector 기반 텍스트 입력 로직
   - dom-map의 폼 요소 정보 활용

4. **`/src/lib/mcp-response-utils.ts`**
   - `createMCPStructuredResponse()`: 구조화된 응답 생성
   - dom-map 결과 포맷팅에 재사용

### 재사용 가능한 헬퍼 함수 제안

```typescript
// helpers.ts에 추가할 함수
export const DOM_FILTER_CONFIG = {
  excludeTags: ['SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK'],
  excludeClasses: ['ad', 'banner', 'popup', 'sidebar', 'advertisement'],
  maxTextLength: 50,
  maxChildren: 10,
  maxDepth: 3,
};

export function createElementSelector(element: Element): string {
  if (element.id) return `#${element.id}`;
  if (element.className) {
    const classes = element.className.trim().split(/\s+/);
    return `.${classes[0]}`;
  }
  return element.tagName.toLowerCase();
}

export function isElementVisible(element: Element): boolean {
  const style = window.getComputedStyle(element);
  return style.display !== 'none' && style.visibility !== 'hidden';
}
```

### 인터페이스 정의

```typescript
// types.ts에 추가할 타입
export interface DOMMapNode {
  tag: string;
  selector: string;
  id?: string;
  class?: string;
  text?: string;
  type?: string;
  href?: string;
  placeholder?: string;
  children: DOMMapNode[];
}

export interface DOMMapResult {
  url: string;
  title: string;
  domMap: DOMMapNode;
  format: 'dom-map';
}
```

## 구현 우선순위

1. **Phase 1**: 기본 dom-map 모드 구현 및 테스트
2. **Phase 2**: 필터링 로직 최적화 및 헬퍼 함수 분리
3. **Phase 3**: ClickElementTool, InputTextTool과의 연동 테스트
4. **Phase 4**: 실제 웹사이트에서 성능 및 정확도 검증
