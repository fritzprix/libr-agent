# Refactoring Plan — Message-Triggered Update Hook 통합

## 작업의 목적

- ChatPlanningPanel과 WorkspaceFilesPanel에서 중복되는 메시지 기반 업데이트 로직을 재사용 가능한 Custom Hook으로 추출하여 코드 중복을 제거하고 일관된 업데이트 메커니즘을 제공한다.
- 메시지 필터링, 디바운싱 등의 옵션을 통해 유연하고 성능 최적화된 업데이트 시스템을 구축한다.

## 현재의 상태 / 문제점

- `ChatPlanningPanel.tsx`에서 메시지 변경 감지 및 상태 업데이트 로직이 구현되어 있음
- `WorkspaceFilesPanel.tsx`에서도 파일 목록 자동 업데이트를 위해 동일한 패턴의 로직이 필요함
- 메시지 감지, 중복 처리 방지(`lastHandledMessageRef`), 업데이트 트리거 로직이 각 컴포넌트에서 반복 구현될 예정
- 현재 `ChatPlanningPanel`의 구현:

  ```typescript
  const lastHandledMessageRef = useRef<{ id?: string }>({});

  useEffect(() => {
    if (!server?.get_current_state || messages.length === 0) return;
    const lastMessage = messages[messages.length - 1];
    if (lastHandledMessageRef.current.id === lastMessage.id) return;
    lastHandledMessageRef.current.id = lastMessage.id;
    refreshState();
  }, [messages, refreshState]);
  ```

## 추가 분석 과제

- 다른 패널 컴포넌트(Browser, Files 등)에서도 메시지 기반 업데이트가 필요한지 조사
- 메시지 타입별 필터링 전략 정의 (assistant 응답, user 입력, tool 결과 등)
- 디바운싱 시간 최적값 분석 (연속 메시지 처리 성능 vs 반응성)
- 메모리 누수 방지를 위한 cleanup 로직 검증

## 변경 이후의 상태 / 해결 판정 기준

- `useMessageTrigger` Custom Hook이 생성되어 메시지 기반 업데이트 로직을 캡슐화
- `ChatPlanningPanel`과 `WorkspaceFilesPanel`에서 중복 코드가 제거되고 Hook을 통해 일관된 업데이트 수행
- 필터링 옵션을 통해 특정 메시지 타입에만 반응하도록 최적화
- 디바운싱 옵션으로 연속 메시지에 대한 성능 최적화 구현
- 해결 판정:
  - 두 컴포넌트에서 메시지 감지 로직이 Hook으로 대체됨
  - 코드 중복 제거 확인 (DRY 원칙 준수)
  - 새로운 메시지 도착 시 자동 업데이트 동작 검증

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. 새로운 Custom Hook 생성

**파일:** `src/hooks/use-message-trigger.ts`

```typescript
import { useEffect, useRef } from 'react';
import { useChatContext } from '@/context/ChatContext';
import type { Message } from '@/models/chat';

interface UseMessageTriggerOptions {
  enabled?: boolean;
  debounceMs?: number;
  messageFilter?: (message: Message) => boolean;
}

export function useMessageTrigger(
  callback: () => void | Promise<void>,
  options: UseMessageTriggerOptions = {},
) {
  const { messages } = useChatContext();
  const lastHandledRef = useRef<{ id?: string }>({});
  const timeoutRef = useRef<NodeJS.Timeout>();

  useEffect(() => {
    const { enabled = true, debounceMs = 0, messageFilter } = options;

    if (!enabled || messages.length === 0) return;

    const lastMessage = messages[messages.length - 1];

    // 메시지 필터링
    if (messageFilter && !messageFilter(lastMessage)) {
      return;
    }

    // 중복 처리 방지
    if (lastHandledRef.current.id === lastMessage.id) {
      return;
    }

    lastHandledRef.current.id = lastMessage.id;

    // 기존 타이머 정리
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // 디바운싱 적용
    timeoutRef.current = setTimeout(() => {
      callback();
    }, debounceMs);

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [messages, callback, options]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
}
```

### 2. ChatPlanningPanel 리팩토링

**파일:** `src/features/chat/components/ChatPlanningPanel.tsx`

**제거할 코드:**

```typescript
// 제거 - 기존 메시지 감지 로직
const lastHandledMessageRef = useRef<{ id?: string }>({});

useEffect(() => {
  if (!server?.get_current_state || messages.length === 0) {
    return;
  }
  const lastMessage = messages[messages.length - 1];
  if (lastHandledMessageRef.current.id === lastMessage.id) {
    return;
  }
  lastHandledMessageRef.current.id = lastMessage.id;
  refreshState();
}, [messages, refreshState]);
```

**추가할 코드:**

```typescript
import { useMessageTrigger } from '@/hooks/use-message-trigger';

// Hook 사용으로 대체
useMessageTrigger(refreshState, {
  enabled: !!server?.get_current_state,
  messageFilter: (message) => message.role === 'assistant', // AI 응답에만 반응
});
```

### 3. WorkspaceFilesPanel 업데이트

**파일:** `src/features/chat/components/WorkspaceFilesPanel.tsx`

**추가할 import:**

```typescript
import { useMessageTrigger } from '@/hooks/use-message-trigger';
```

**추가할 Hook 사용:**

```typescript
// 메시지 기반 자동 파일 목록 업데이트
useMessageTrigger(
  () => {
    if (rootPath) {
      loadDirectory(rootPath);
    }
  },
  {
    debounceMs: 500, // 500ms 디바운싱
    messageFilter: (message) => {
      // 파일 관련 키워드가 포함된 메시지에만 반응
      const fileKeywords = [
        'file',
        'directory',
        'folder',
        'create',
        'delete',
        'move',
        'copy',
      ];
      return fileKeywords.some((keyword) =>
        message.content.toLowerCase().includes(keyword),
      );
    },
  },
);
```

## 재사용 가능한 연관 코드

### 주요 파일 및 인터페이스

1. **기존 관련 파일:**
   - `src/context/ChatContext.tsx` - useChatContext Hook 제공
   - `src/models/chat.ts` - Message 타입 정의
   - `src/features/chat/components/ChatPlanningPanel.tsx` - 기존 메시지 감지 로직
   - `src/features/chat/components/WorkspaceFilesPanel.tsx` - 적용 대상 컴포넌트

2. **타입 정의:**

   ```typescript
   // src/models/chat.ts
   export interface Message {
     id: string;
     role: 'user' | 'assistant' | 'system';
     content: string;
     timestamp: number;
     // ... 기타 필드
   }
   ```

3. **확장 가능한 필터 함수들:**
   ```typescript
   // src/hooks/message-filters.ts
   export const MessageFilters = {
     assistantOnly: (message: Message) => message.role === 'assistant',
     userOnly: (message: Message) => message.role === 'user',
     containsKeywords: (keywords: string[]) => (message: Message) =>
       keywords.some((keyword) =>
         message.content.toLowerCase().includes(keyword.toLowerCase()),
       ),
     toolResults: (message: Message) => message.content.includes('tool_result'),
   };
   ```

## Test Code 추가 및 수정 필요 부분에 대한 가이드

### 1. useMessageTrigger Hook 테스트

**파일:** `src/hooks/__tests__/use-message-trigger.test.tsx`

```typescript
import { renderHook, act } from '@testing-library/react';
import { useMessageTrigger } from '../use-message-trigger';

describe('useMessageTrigger', () => {
  it('should call callback when new message arrives', () => {
    const callback = jest.fn();
    // Mock ChatContext with messages
    // Test callback execution
  });

  it('should not call callback for duplicate messages', () => {
    // Test duplicate message filtering
  });

  it('should apply debouncing correctly', () => {
    // Test debouncing functionality
  });

  it('should apply message filtering', () => {
    // Test messageFilter option
  });
});
```

### 2. 통합 테스트

**파일:** `src/features/chat/components/__tests__/ChatPlanningPanel.test.tsx`

```typescript
describe('ChatPlanningPanel with useMessageTrigger', () => {
  it('should update planning state when assistant message arrives', () => {
    // Test integration with useMessageTrigger
  });
});
```

### 3. E2E 테스트 시나리오

- 새 메시지 도착 시 패널 자동 업데이트 확인
- 연속 메시지에 대한 디바운싱 동작 검증
- 필터링된 메시지에 대한 선택적 업데이트 확인
- 메모리 누수 없이 컴포넌트 언마운트 처리 검증

### 4. 성능 테스트

- 대량 메시지 처리 시 Hook 성능 측정
- 디바운싱 시간별 반응성 vs 성능 트레이드오프 분석
- 메모리 사용량 모니터링 (ref cleanup 검증)
