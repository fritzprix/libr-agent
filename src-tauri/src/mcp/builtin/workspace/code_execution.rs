use serde_json::Value;
use std::time::Duration;
use tokio::time::timeout;
use tracing::info;
use uuid::Uuid;

use super::{utils, WorkspaceServer};
use crate::mcp::MCPResponse;

// A unique sentinel to mark the end of a synchronous command execution.
const SYNC_EXEC_SENTINEL: &str = "SYNAPTIC_FLOW_EXEC_DONE";

impl WorkspaceServer {
    /// Helper to read from a terminal until a sentinel is found or it times out.
    async fn read_terminal_until_sentinel(
        &self,
        terminal_id: &str,
        sentinel: &str,
        timeout_duration: Duration,
    ) -> Result<String, String> {
        let mut output_lines = Vec::new();
        let mut current_index = 0;

        let res = timeout(timeout_duration, async {
            loop {
                // Read new output since the last poll.
                let read_result = self
                    .terminal_manager
                    .read_terminal_output(terminal_id, Some(current_index))
                    .await?;

                current_index = read_result.next_index;

                for output in read_result.output {
                    if output.line.contains(sentinel) {
                        // Sentinel found, command is done.
                        return Ok(output_lines.join("\n"));
                    }
                    output_lines.push(output.line);
                }

                if read_result.closed {
                    return Err("Terminal closed unexpectedly during execution.".to_string());
                }

                // Small delay to prevent busy-waiting.
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        })
        .await;

        match res {
            Ok(Ok(output)) => Ok(output),
            Ok(Err(e)) => Err(e),
            Err(_) => Err(format!(
                "Command execution timed out after {} seconds.",
                timeout_duration.as_secs()
            )),
        }
    }

    /// Automatically corrects quoting issues in shell commands generated by LLMs.
    fn normalize_shell_command(raw_command: &str) -> String {
        let mut normalized = raw_command.to_string();

        // 1. Detect and correct incomplete quote pairs.
        let double_quote_count = normalized.chars().filter(|&c| c == '"').count();
        let single_quote_count = normalized.chars().filter(|&c| c == '\'').count();

        // 2. If there's an odd number of quotes, append one to the end.
        if double_quote_count % 2 != 0 {
            normalized.push('"');
            info!("Shell command: Added missing double quote");
        }
        if single_quote_count % 2 != 0 {
            normalized.push('\'');
            info!("Shell command: Added missing single quote");
        }

        normalized
    }

    /// Corrects string issues in Python/TypeScript code.
    fn normalize_code_string(raw_code: &str, language: &str) -> String {
        let mut normalized = raw_code.to_string();

        // 1. Detect and correct incomplete quote pairs.
        let double_quote_count = normalized.chars().filter(|&c| c == '"').count();
        let single_quote_count = normalized.chars().filter(|&c| c == '\'').count();

        // 2. Language-specific handling
        match language {
            "python" | "typescript" => {
                if double_quote_count % 2 != 0 {
                    normalized.push('"');
                    info!("{language} code: Added missing double quote");
                }
                if single_quote_count % 2 != 0 {
                    normalized.push('\'');
                    info!("{language} code: Added missing single quote");
                }
            }
            _ => {
                // Generic quote balancing
                if double_quote_count % 2 != 0 {
                    normalized.push('"');
                    info!("Code: Added missing double quote");
                }
                if single_quote_count % 2 != 0 {
                    normalized.push('\'');
                    info!("Code: Added missing single quote");
                }
            }
        }

        normalized
    }

    pub async fn handle_execute_python(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let terminal_id = match args.get("terminal_id").and_then(|v| v.as_str()) {
            Some(id) => id,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: terminal_id",
                )
            }
        };

        let raw_code = match args.get("code").and_then(|v| v.as_str()) {
            Some(code) => code,
            None => {
                return Self::error_response(request_id, -32602, "Missing required parameter: code")
            }
        };

        let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);
        let timeout_secs = utils::validate_timeout(args.get("timeout").and_then(|v| v.as_u64()));
        let normalized_code = Self::normalize_code_string(raw_code, "python");

        // Write code to a temporary script file in the session's workspace
        let workspace_dir = self.get_workspace_dir();
        let script_name = format!("script_{}.py", Uuid::new_v4());
        let script_path = workspace_dir.join(&script_name);

        if let Err(e) = tokio::fs::write(&script_path, &normalized_code).await {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to write Python script: {e}"),
            );
        }

        let script_path_str = script_path.to_string_lossy();
        let command = format!("python3 {script_path_str}");

        if async_flag {
            match self
                .terminal_manager
                .write_to_terminal(terminal_id, &command)
                .await
            {
                Ok(_) => Self::success_response(
                    request_id,
                    &format!("Asynchronous command sent to terminal {terminal_id}"),
                ),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        } else {
            // For synchronous execution, we append a sentinel echo command.
            let sentinel = format!("{}_{}", SYNC_EXEC_SENTINEL, Uuid::new_v4());
            let full_command = format!("{command}; echo '{sentinel}'");

            if let Err(e) = self
                .terminal_manager
                .write_to_terminal(terminal_id, &full_command)
                .await
            {
                return Self::error_response(request_id, -32603, &e);
            }

            // Wait for the sentinel or timeout.
            let timeout_duration = Duration::from_secs(timeout_secs);
            match self
                .read_terminal_until_sentinel(terminal_id, &sentinel, timeout_duration)
                .await
            {
                Ok(output) => Self::success_response(request_id, &output),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        }
    }

    pub async fn handle_execute_typescript(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let terminal_id = match args.get("terminal_id").and_then(|v| v.as_str()) {
            Some(id) => id,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: terminal_id",
                )
            }
        };

        let raw_code = match args.get("code").and_then(|v| v.as_str()) {
            Some(code) => code,
            None => {
                return Self::error_response(request_id, -32602, "Missing required parameter: code")
            }
        };

        let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);
        let timeout_secs = utils::validate_timeout(args.get("timeout").and_then(|v| v.as_u64()));
        let normalized_code = Self::normalize_code_string(raw_code, "typescript");

        // Write code to a temporary script file
        let workspace_dir = self.get_workspace_dir();
        let script_name = format!("script_{}.ts", Uuid::new_v4());
        let script_path = workspace_dir.join(&script_name);

        if let Err(e) = tokio::fs::write(&script_path, &normalized_code).await {
            return Self::error_response(
                request_id,
                -32603,
                &format!("Failed to write TypeScript script: {e}"),
            );
        }

        let script_path_str = script_path.to_string_lossy();
        let command = format!("deno run --allow-all {script_path_str}");

        if async_flag {
            match self
                .terminal_manager
                .write_to_terminal(terminal_id, &command)
                .await
            {
                Ok(_) => Self::success_response(
                    request_id,
                    &format!("Asynchronous command sent to terminal {terminal_id}"),
                ),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        } else {
            let sentinel = format!("{}_{}", SYNC_EXEC_SENTINEL, Uuid::new_v4());
            let full_command = format!("{command}; echo '{sentinel}'");

            if let Err(e) = self
                .terminal_manager
                .write_to_terminal(terminal_id, &full_command)
                .await
            {
                return Self::error_response(request_id, -32603, &e);
            }

            let timeout_duration = Duration::from_secs(timeout_secs);
            match self
                .read_terminal_until_sentinel(terminal_id, &sentinel, timeout_duration)
                .await
            {
                Ok(output) => Self::success_response(request_id, &output),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        }
    }

    pub async fn handle_execute_shell(&self, args: Value) -> MCPResponse {
        let request_id = Self::generate_request_id();

        let terminal_id = match args.get("terminal_id").and_then(|v| v.as_str()) {
            Some(id) => id,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: terminal_id",
                )
            }
        };

        let raw_command = match args.get("command").and_then(|v| v.as_str()) {
            Some(cmd) => cmd,
            None => {
                return Self::error_response(
                    request_id,
                    -32602,
                    "Missing required parameter: command",
                )
            }
        };

        let async_flag = args.get("async").and_then(|v| v.as_bool()).unwrap_or(false);
        let timeout_secs = utils::validate_timeout(args.get("timeout").and_then(|v| v.as_u64()));
        let normalized_command = Self::normalize_shell_command(raw_command);

        if async_flag {
            match self
                .terminal_manager
                .write_to_terminal(terminal_id, &normalized_command)
                .await
            {
                Ok(_) => Self::success_response(
                    request_id,
                    &format!("Asynchronous command sent to terminal {terminal_id}"),
                ),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        } else {
            let sentinel = format!("{}_{}", SYNC_EXEC_SENTINEL, Uuid::new_v4());
            let full_command = format!("{normalized_command}; echo '{sentinel}'");

            if let Err(e) = self
                .terminal_manager
                .write_to_terminal(terminal_id, &full_command)
                .await
            {
                return Self::error_response(request_id, -32603, &e);
            }

            let timeout_duration = Duration::from_secs(timeout_secs);
            match self
                .read_terminal_until_sentinel(terminal_id, &sentinel, timeout_duration)
                .await
            {
                Ok(output) => Self::success_response(request_id, &output),
                Err(e) => Self::error_response(request_id, -32603, &e),
            }
        }
    }
}
